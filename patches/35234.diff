commit 371ab925eaef2b872efc2c68442a02588ccaee04
Author: Alex Deymo <deymo@google.com>
Date:   Fri Jul 9 17:16:53 2021 +0200

    Relax x0 % kPaddingXRound requirement in FilterPipeline (#303)
    
    The FilterPipeline required that the x0 in all three input, output and
    image rects be a multiple of kPaddingXRound. This has the issue that it
    is 4 in ARM but 8 in x86, however Sigma is always an 8x8 downsampled
    image.
    
    This patch relaxes the requirement so that input, output and image rect
    all have the same alignment % kPaddingXRound but it doesn't need to be
    0, removing the logic that extends the filters ranges from
    dec_reconstruct.
    
    The EPF functions were receiving a image_x_mod_8 value as
    image_rect.x0() % 8, which was always 0 in x86, but may be 4 in ARM.
    This value now can be anything between 0 and 7 in both architectures
    since it depends on the value of x0.
    
    This patch overall reduces a tiny bit the total range of [x0, x1) where
    we run intermediate filters since the FilterPipeline now handles the
    values of image_rect.x0() that are not a multiple of kPaddingXRound.
    
    This removes the rect parameter from ApplyFiltersRow() since it is
    already passed on initialization and it must be the same every time.

diff --git a/lib/jxl/dec_reconstruct.cc b/lib/jxl/dec_reconstruct.cc
index c2db7cb9..266c2496 100644
--- a/lib/jxl/dec_reconstruct.cc
+++ b/lib/jxl/dec_reconstruct.cc
@@ -559,532 +559,514 @@ void EnsurePaddingInPlace(Image3F* img, const Rect& rect,
 Status FinalizeImageRect(
     Image3F* input_image, const Rect& input_rect,
     const std::vector<std::pair<ImageF*, Rect>>& extra_channels,
     PassesDecoderState* dec_state, size_t thread,
     ImageBundle* JXL_RESTRICT output_image, const Rect& frame_rect) {
   const ImageFeatures& image_features = dec_state->shared->image_features;
   const FrameHeader& frame_header = dec_state->shared->frame_header;
   const ImageMetadata& metadata = frame_header.nonserialized_metadata->m;
   const LoopFilter& lf = frame_header.loop_filter;
   const FrameDimensions& frame_dim = dec_state->shared->frame_dim;
   JXL_DASSERT(frame_rect.xsize() <= kApplyImageFeaturesTileDim);
   JXL_DASSERT(frame_rect.ysize() <= kApplyImageFeaturesTileDim);
   JXL_DASSERT(input_rect.xsize() == frame_rect.xsize());
   JXL_DASSERT(input_rect.ysize() == frame_rect.ysize());
   JXL_DASSERT(frame_rect.x0() % GroupBorderAssigner::kPaddingXRound == 0);
   JXL_DASSERT(frame_rect.xsize() % GroupBorderAssigner::kPaddingXRound == 0 ||
               frame_rect.xsize() + frame_rect.x0() == frame_dim.xsize ||
               frame_rect.xsize() + frame_rect.x0() == frame_dim.xsize_padded);
 
   // +----------------------------- STEP 1 ------------------------------+
   // | Compute the rects on which patches and splines will be applied.   |
   // | In case we are applying upsampling, we need to apply patches on a |
   // | slightly larger image.                                            |
   // +-------------------------------------------------------------------+
 
   // If we are applying upsampling, we need 2 more pixels around the actual rect
   // for border. Thus, we also need to apply patches and splines to those
   // pixels. We compute here
   // - The portion of image that corresponds to the area we are applying IF.
   //   (rect_for_if)
   // - The rect where that pixel data is stored in upsampling_input_storage.
   //   (rect_for_if_storage)
   // - The rect where the pixel data that we need to upsample is stored.
   //   (rect_for_upsampling)
   // - The source rect for the pixel data in `input_image`. It is assumed that,
   //   if `frame_rect` is not on an image border, `input_image:input_rect` has
   //   enough border available. (rect_for_if_input)
 
   Image3F* output_color =
       dec_state->rgb_output == nullptr && dec_state->pixel_callback == nullptr
           ? output_image->color()
           : nullptr;
 
   Image3F* storage_for_if = output_color;
   Rect rect_for_if = frame_rect;
   Rect rect_for_if_storage = frame_rect;
   Rect rect_for_upsampling = frame_rect;
   Rect rect_for_if_input = input_rect;
   size_t extra_rows_t = 0;
   size_t extra_rows_b = 0;
   if (frame_header.upsampling != 1) {
     size_t ifbx0 = 0;
     size_t ifbx1 = 0;
     size_t ifby0 = 0;
     size_t ifby1 = 0;
     if (frame_rect.x0() >= 2) {
       JXL_DASSERT(input_rect.x0() >= 2);
       ifbx0 = 2;
     }
     if (frame_rect.y0() >= 2) {
       JXL_DASSERT(input_rect.y0() >= 2);
       extra_rows_t = ifby0 = 2;
     }
     for (size_t extra : {1, 2}) {
       if (frame_rect.x0() + frame_rect.xsize() + extra <=
           dec_state->shared->frame_dim.xsize_padded) {
         JXL_DASSERT(input_rect.x0() + input_rect.xsize() + extra <=
                     input_image->xsize());
         ifbx1 = extra;
       }
       if (frame_rect.y0() + frame_rect.ysize() + extra <=
           dec_state->shared->frame_dim.ysize_padded) {
         JXL_DASSERT(input_rect.y0() + input_rect.ysize() + extra <=
                     input_image->ysize());
         extra_rows_b = ifby1 = extra;
       }
     }
     rect_for_if = Rect(frame_rect.x0() - ifbx0, frame_rect.y0() - ifby0,
                        frame_rect.xsize() + ifbx0 + ifbx1,
                        frame_rect.ysize() + ifby0 + ifby1);
     // Storage for pixel data does not necessarily start at (0, 0) as we need to
     // have the left border of upsampling_rect aligned to a multiple of
     // GroupBorderAssigner::kPaddingXRound.
     rect_for_if_storage =
         Rect(kBlockDim + RoundUpTo(ifbx0, GroupBorderAssigner::kPaddingXRound) -
                  ifbx0,
              kBlockDim, rect_for_if.xsize(), rect_for_if.ysize());
     rect_for_upsampling =
         Rect(kBlockDim + RoundUpTo(ifbx0, GroupBorderAssigner::kPaddingXRound),
              kBlockDim + ifby0, frame_rect.xsize(), frame_rect.ysize());
     rect_for_if_input =
         Rect(input_rect.x0() - ifbx0, input_rect.y0() - ifby0,
              rect_for_if_storage.xsize(), rect_for_if_storage.ysize());
     storage_for_if = &dec_state->upsampling_input_storage[thread];
   }
 
   // +--------------------------- STEP 1.5 ------------------------------+
   // | Perform YCbCr upsampling if needed.                               |
   // +-------------------------------------------------------------------+
 
   Image3F* input = input_image;
   if (!frame_header.chroma_subsampling.Is444()) {
     for (size_t c = 0; c < 3; c++) {
       size_t vs = frame_header.chroma_subsampling.VShift(c);
       size_t hs = frame_header.chroma_subsampling.HShift(c);
       // The per-thread output is used for the first time here. Poison the temp
       // image on this thread to prevent leaking initialized data from a
       // previous run in this thread in msan builds.
       msan::PoisonImage(dec_state->ycbcr_out_images[thread].Plane(c));
       HWY_DYNAMIC_DISPATCH(DoYCbCrUpsampling)
       (hs, vs, &input_image->Plane(c), rect_for_if_input, frame_rect, frame_dim,
        &dec_state->ycbcr_out_images[thread].Plane(c), lf,
        &dec_state->ycbcr_temp_images[thread]);
     }
     input = &dec_state->ycbcr_out_images[thread];
   }
 
   // Variables for upsampling and filtering.
   Rect upsampled_frame_rect(frame_rect.x0() * frame_header.upsampling,
                             frame_rect.y0() * frame_header.upsampling,
                             frame_rect.xsize() * frame_header.upsampling,
                             frame_rect.ysize() * frame_header.upsampling);
   Rect full_frame_rect(0, 0, frame_dim.xsize_upsampled,
                        frame_dim.ysize_upsampled);
   upsampled_frame_rect = upsampled_frame_rect.Crop(full_frame_rect);
   EnsurePaddingInPlaceRowByRow ensure_padding_upsampling;
   ssize_t ensure_padding_upsampling_y0 = 0;
   ssize_t ensure_padding_upsampling_y1 = 0;
 
   EnsurePaddingInPlaceRowByRow ensure_padding_filter;
   FilterPipeline* fp = nullptr;
   ssize_t ensure_padding_filter_y0 = 0;
   ssize_t ensure_padding_filter_y1 = 0;
-  Rect image_padded_rect;
   if (lf.epf_iters != 0 || lf.gab) {
     fp = &dec_state->filter_pipelines[thread];
-    size_t xextra =
-        rect_for_if_input.x0() % GroupBorderAssigner::kPaddingXRound;
-    image_padded_rect = Rect(rect_for_if.x0() - xextra, rect_for_if.y0(),
-                             rect_for_if.xsize() + xextra, rect_for_if.ysize());
   }
 
   // +----------------------------- STEP 2 ------------------------------+
   // | Change rects and buffer to not use `output_image` if direct       |
   // | output to rgb8 is requested.                                      |
   // +-------------------------------------------------------------------+
   Image3F* output_pixel_data_storage = output_color;
   Rect upsampled_frame_rect_for_storage = upsampled_frame_rect;
   if (dec_state->rgb_output || dec_state->pixel_callback) {
     size_t log2_upsampling = CeilLog2Nonzero(frame_header.upsampling);
     if (storage_for_if == output_color) {
       storage_for_if =
           &dec_state->output_pixel_data_storage[log2_upsampling][thread];
       rect_for_if_storage =
           Rect(0, 0, rect_for_if_storage.xsize(), rect_for_if_storage.ysize());
     }
     output_pixel_data_storage =
         &dec_state->output_pixel_data_storage[log2_upsampling][thread];
     upsampled_frame_rect_for_storage =
         Rect(0, 0, upsampled_frame_rect.xsize(), upsampled_frame_rect.ysize());
     if (frame_header.upsampling == 1 && fp == nullptr) {
       upsampled_frame_rect_for_storage = rect_for_if_storage =
           rect_for_if_input;
       output_pixel_data_storage = storage_for_if = input;
     }
   }
   // Set up alpha channel.
   const size_t ec =
       metadata.Find(ExtraChannel::kAlpha) - metadata.extra_channel_info.data();
   const ImageF* alpha = nullptr;
   Rect alpha_rect = upsampled_frame_rect;
   if (ec < metadata.extra_channel_info.size()) {
     JXL_ASSERT(ec < extra_channels.size());
     if (frame_header.extra_channel_upsampling[ec] == 1) {
       alpha = extra_channels[ec].first;
       alpha_rect = extra_channels[ec].second;
     } else {
       alpha = &output_image->extra_channels()[ec];
       alpha_rect = upsampled_frame_rect;
     }
   }
 
   // +----------------------------- STEP 3 ------------------------------+
   // | Set up upsampling and upsample extra channels.                    |
   // +-------------------------------------------------------------------+
   Upsampler* color_upsampler = nullptr;
   if (frame_header.upsampling != 1) {
     color_upsampler =
         &dec_state->upsamplers[CeilLog2Nonzero(frame_header.upsampling) - 1];
     ensure_padding_upsampling.Init(
         storage_for_if, rect_for_upsampling, frame_rect, frame_dim.xsize_padded,
         frame_dim.ysize_padded, 2, 2, &ensure_padding_upsampling_y0,
         &ensure_padding_upsampling_y1);
   }
 
   std::vector<std::pair<ImageF*, Rect>> extra_channels_for_patches;
   std::vector<EnsurePaddingInPlaceRowByRow> ec_padding;
 
   bool late_ec_upsample = frame_header.upsampling != 1;
   for (auto ecups : frame_header.extra_channel_upsampling) {
     if (ecups != frame_header.upsampling) {
       // If patches are applied, either frame_header.upsampling == 1 or
       // late_ec_upsample is true.
       late_ec_upsample = false;
     }
   }
 
   ssize_t ensure_padding_upsampling_ec_y0 = 0;
   ssize_t ensure_padding_upsampling_ec_y1 = 0;
 
   // TODO(veluca) do not upsample extra channels to a full-image-sized buffer if
   // we are not outputting to an ImageBundle.
   if (!late_ec_upsample) {
     // Upsample extra channels first if not all channels have the same
     // upsampling factor.
     for (size_t ec = 0; ec < extra_channels.size(); ec++) {
       size_t ecups = frame_header.extra_channel_upsampling[ec];
       if (ecups == 1) {
         extra_channels_for_patches.push_back(extra_channels[ec]);
         continue;
       }
       ssize_t ensure_padding_y0, ensure_padding_y1;
       EnsurePaddingInPlaceRowByRow ensure_padding;
       Rect ec_image_rect = ScaleRectForEC(frame_rect, frame_header, ec);
       size_t ecxs = DivCeil(frame_dim.xsize_upsampled,
                             frame_header.extra_channel_upsampling[ec]);
       size_t ecys = DivCeil(frame_dim.ysize_upsampled,
                             frame_header.extra_channel_upsampling[ec]);
       ensure_padding.Init(extra_channels[ec].first, extra_channels[ec].second,
                           ec_image_rect, ecxs, ecys, 2, 2, &ensure_padding_y0,
                           &ensure_padding_y1);
       for (ssize_t y = ensure_padding_y0; y < ensure_padding_y1; y++) {
         ensure_padding.Process(y);
       }
       Upsampler& upsampler =
           dec_state->upsamplers[CeilLog2Nonzero(
                                     frame_header.extra_channel_upsampling[ec]) -
                                 1];
       upsampler.UpsampleRect(
           *extra_channels[ec].first, extra_channels[ec].second,
           &output_image->extra_channels()[ec], upsampled_frame_rect,
           static_cast<ssize_t>(ec_image_rect.y0()) -
               static_cast<ssize_t>(extra_channels[ec].second.y0()),
           ecys, dec_state->upsampler_storage[thread].get());
       extra_channels_for_patches.emplace_back(
           &output_image->extra_channels()[ec], upsampled_frame_rect);
     }
   } else {
     // Upsample extra channels last if color channels are upsampled and all the
     // extra channels have the same upsampling as them.
     ec_padding.resize(extra_channels.size());
     for (size_t ec = 0; ec < extra_channels.size(); ec++) {
       // Add a border to the extra channel rect for when patches are applied.
       // This ensures that the correct row is accessed (y values for patches are
       // relative to rect_for_if, not to input_rect).
       // As the rect is extended by 0 or 2 pixels, and the patches input has,
       // accordingly, the same padding, this is safe.
       Rect r(extra_channels[ec].second.x0() + rect_for_upsampling.x0() -
                  rect_for_if_storage.x0(),
              extra_channels[ec].second.y0() + rect_for_upsampling.y0() -
                  rect_for_if_storage.y0(),
              extra_channels[ec].second.xsize() + rect_for_if_storage.xsize() -
                  rect_for_upsampling.xsize(),
              extra_channels[ec].second.ysize() + rect_for_if_storage.ysize() -
                  rect_for_upsampling.ysize());
       extra_channels_for_patches.emplace_back(extra_channels[ec].first, r);
       ec_padding[ec].Init(extra_channels[ec].first, extra_channels[ec].second,
                           frame_rect, frame_dim.xsize, frame_dim.ysize, 2, 2,
                           &ensure_padding_upsampling_ec_y0,
                           &ensure_padding_upsampling_ec_y1);
     }
   }
 
   // Initialized to a valid non-null ptr to avoid UB if arithmetic is done with
   // the pointer value (which would then not be used).
   std::vector<float*> ec_ptrs_for_patches(extra_channels.size(),
                                           input->PlaneRow(0, 0));
 
   // +----------------------------- STEP 4 ------------------------------+
   // | Set up the filter pipeline.                                       |
   // +-------------------------------------------------------------------+
   if (fp) {
-    // If `rect_for_if_input` does not start at a multiple of
-    // GroupBorderAssigner::kPaddingXRound, we extend the rect we run EPF on by
-    // one full padding length to ensure sigma is handled correctly. We also
-    // extend the output and image rects accordingly. To do this, we need 2x the
-    // border.
-    size_t xextra =
-        rect_for_if_input.x0() % GroupBorderAssigner::kPaddingXRound;
-    Rect filter_input_padded_rect(
-        rect_for_if_input.x0() - xextra, rect_for_if_input.y0(),
-        rect_for_if_input.xsize() + xextra, rect_for_if_input.ysize());
     ensure_padding_filter.Init(
         input, rect_for_if_input, rect_for_if, frame_dim.xsize_padded,
         frame_dim.ysize_padded, lf.Padding(), lf.Padding(),
         &ensure_padding_filter_y0, &ensure_padding_filter_y1);
-    Rect filter_output_padded_rect(
-        rect_for_if_storage.x0() - xextra, rect_for_if_storage.y0(),
-        rect_for_if_storage.xsize() + xextra, rect_for_if_storage.ysize());
-    fp = PrepareFilterPipeline(dec_state, image_padded_rect, *input,
-                               filter_input_padded_rect, frame_dim.ysize_padded,
-                               thread, storage_for_if,
-                               filter_output_padded_rect);
+
+    fp = PrepareFilterPipeline(dec_state, rect_for_if, *input,
+                               rect_for_if_input, frame_dim.ysize_padded,
+                               thread, storage_for_if, rect_for_if_storage);
   }
 
   // +----------------------------- STEP 5 ------------------------------+
   // | Run the prepared pipeline of operations.                          |
   // +-------------------------------------------------------------------+
 
   // y values are relative to rect_for_if.
   // Automatic mirroring in fp->ApplyFiltersRow() implies that we should ensure
   // that padding for the first lines of the image is already present before
   // calling ApplyFiltersRow() with "virtual" rows.
   // Here we rely on the fact that virtual rows at the beginning of the image
   // are only present if input_rect.y0() == 0.
   ssize_t first_ensure_padding_y = ensure_padding_filter_y0;
   if (frame_rect.y0() == 0) {
     JXL_DASSERT(ensure_padding_filter_y0 == 0);
     first_ensure_padding_y =
         std::min<ssize_t>(lf.Padding(), ensure_padding_filter_y1);
     for (ssize_t y = 0; y < first_ensure_padding_y; y++) {
       ensure_padding_filter.Process3(y);
     }
   }
 
   for (ssize_t y = -lf.Padding();
        y < static_cast<ssize_t>(lf.Padding() + rect_for_if.ysize()); y++) {
     if (fp) {
       if (y >= first_ensure_padding_y && y < ensure_padding_filter_y1) {
         ensure_padding_filter.Process3(y);
       }
-      fp->ApplyFiltersRow(lf, dec_state->filter_weights, image_padded_rect, y);
+      fp->ApplyFiltersRow(lf, dec_state->filter_weights, y);
     } else if (output_pixel_data_storage != input) {
       for (size_t c = 0; c < 3; c++) {
         memcpy(rect_for_if_storage.PlaneRow(storage_for_if, c, y),
                rect_for_if_input.ConstPlaneRow(*input, c, y),
                rect_for_if_input.xsize() * sizeof(float));
       }
     }
     if (y < static_cast<ssize_t>(lf.Padding())) continue;
     // At this point, row `y - lf.Padding()` of `rect_for_if` has been produced
     // by the filters.
     ssize_t available_y = y - lf.Padding();
     if (frame_header.upsampling == 1) {
       for (size_t i = 0; i < extra_channels.size(); i++) {
         ec_ptrs_for_patches[i] = extra_channels_for_patches[i].second.Row(
             extra_channels_for_patches[i].first, available_y);
       }
     }
     JXL_RETURN_IF_ERROR(image_features.patches.AddTo(
         storage_for_if, rect_for_if_storage.Line(available_y),
         ec_ptrs_for_patches.data(), rect_for_if.Line(available_y)));
     JXL_RETURN_IF_ERROR(image_features.splines.AddTo(
         storage_for_if, rect_for_if_storage.Line(available_y),
         rect_for_if.Line(available_y), dec_state->shared->cmap));
     size_t num_ys = 1;
     if (frame_header.upsampling != 1) {
       // Upsampling `y` values are relative to `rect_for_upsampling`, not to
       // `rect_for_if`.
       ssize_t shifted_y = available_y - extra_rows_t;
       if (shifted_y >= ensure_padding_upsampling_y0 &&
           shifted_y < ensure_padding_upsampling_y1) {
         ensure_padding_upsampling.Process3(shifted_y);
       }
       if (late_ec_upsample && shifted_y >= ensure_padding_upsampling_ec_y0 &&
           shifted_y < ensure_padding_upsampling_ec_y1) {
         for (size_t ec = 0; ec < extra_channels.size(); ec++) {
           ec_padding[ec].Process(shifted_y);
         }
       }
       // Upsampling will access two rows of border, so the first upsampling
       // output will be available after shifted_y is at least 2, *unless* image
       // height is <= 2.
       if (shifted_y < 2 &&
           shifted_y + 1 != static_cast<ssize_t>(frame_rect.ysize())) {
         continue;
       }
       // Value relative to upsampled_frame_rect.
       size_t input_y = std::max<ssize_t>(shifted_y - 2, 0);
       size_t upsampled_available_y = frame_header.upsampling * input_y;
       size_t num_input_rows = 1;
       // If we are going to mirror the last output rows, then we already have 3
       // input lines ready. This happens iff we did not extend rect_for_if on
       // the bottom *and* we are at the last `y` value.
       if (extra_rows_b != 2 &&
           static_cast<size_t>(y) + 1 == lf.Padding() + rect_for_if.ysize()) {
         num_input_rows = 3;
       }
       num_input_rows = std::min(num_input_rows, frame_dim.ysize_padded);
       num_ys = num_input_rows * frame_header.upsampling;
 
       if (static_cast<size_t>(upsampled_available_y) >=
           upsampled_frame_rect.ysize()) {
         continue;
       }
 
       if (upsampled_available_y + num_ys >= upsampled_frame_rect.ysize()) {
         num_ys = upsampled_frame_rect.ysize() - upsampled_available_y;
       }
 
       // Upsampler takes care of mirroring, and checks "physical" boundaries.
       Rect upsample_input_rect = rect_for_upsampling.Lines(input_y, 1);
       color_upsampler->UpsampleRect(
           *storage_for_if, upsample_input_rect, output_pixel_data_storage,
           upsampled_frame_rect_for_storage.Lines(upsampled_available_y, num_ys),
           static_cast<ssize_t>(frame_rect.y0()) -
               static_cast<ssize_t>(rect_for_upsampling.y0()),
           frame_dim.ysize_padded, dec_state->upsampler_storage[thread].get());
       if (late_ec_upsample) {
         for (size_t ec = 0; ec < extra_channels.size(); ec++) {
           // Upsampler takes care of mirroring, and checks "physical"
           // boundaries.
           Rect upsample_ec_input_rect =
               extra_channels[ec].second.Lines(input_y, 1);
           color_upsampler->UpsampleRect(
               *extra_channels[ec].first, upsample_ec_input_rect,
               &output_image->extra_channels()[ec],
               upsampled_frame_rect.Lines(upsampled_available_y, num_ys),
               static_cast<ssize_t>(frame_rect.y0()) -
                   static_cast<ssize_t>(extra_channels[ec].second.y0()),
               frame_dim.ysize, dec_state->upsampler_storage[thread].get());
         }
       }
       available_y = upsampled_available_y;
     }
 
     if (static_cast<size_t>(available_y) >= upsampled_frame_rect.ysize()) {
       continue;
     }
 
     // The image data is now unconditionally in
     // `output_image_storage:upsampled_frame_rect_for_storage`.
     if (frame_header.flags & FrameHeader::kNoise) {
       PROFILER_ZONE("AddNoise");
       AddNoise(image_features.noise_params,
                upsampled_frame_rect.Lines(available_y, num_ys),
                dec_state->noise,
                upsampled_frame_rect_for_storage.Lines(available_y, num_ys),
                dec_state->shared_storage.cmap, output_pixel_data_storage);
     }
 
     if (dec_state->pre_color_transform_frame.xsize() != 0) {
       for (size_t c = 0; c < 3; c++) {
         for (size_t y = available_y; y < available_y + num_ys; y++) {
           float* JXL_RESTRICT row_out = upsampled_frame_rect.PlaneRow(
               &dec_state->pre_color_transform_frame, c, y);
           const float* JXL_RESTRICT row_in =
               upsampled_frame_rect_for_storage.ConstPlaneRow(
                   *output_pixel_data_storage, c, y);
           memcpy(row_out, row_in,
                  upsampled_frame_rect.xsize() * sizeof(*row_in));
         }
       }
     }
 
     // We skip the color transform entirely if save_before_color_transform and
     // the frame is not supposed to be displayed.
 
     if (dec_state->fast_xyb_srgb8_conversion) {
       FastXYBTosRGB8(
           *output_pixel_data_storage,
           upsampled_frame_rect_for_storage.Lines(available_y, num_ys),
           upsampled_frame_rect.Lines(available_y, num_ys)
               .Crop(Rect(0, 0, frame_dim.xsize, frame_dim.ysize)),
           alpha, alpha_rect.Lines(available_y, num_ys),
           dec_state->rgb_output_is_rgba, dec_state->rgb_output, frame_dim.xsize,
           dec_state->rgb_stride);
     } else {
       if (frame_header.needs_color_transform()) {
         if (frame_header.color_transform == ColorTransform::kXYB) {
           JXL_RETURN_IF_ERROR(HWY_DYNAMIC_DISPATCH(UndoXYBInPlace)(
               output_pixel_data_storage,
               upsampled_frame_rect_for_storage.Lines(available_y, num_ys),
               dec_state->output_encoding_info));
         } else if (frame_header.color_transform == ColorTransform::kYCbCr) {
           YcbcrToRgb(
               *output_pixel_data_storage, output_pixel_data_storage,
               upsampled_frame_rect_for_storage.Lines(available_y, num_ys));
         }
       }
 
       // TODO(veluca): all blending should happen here.
 
       if (dec_state->rgb_output != nullptr) {
         HWY_DYNAMIC_DISPATCH(FloatToRGBA8)
         (*output_pixel_data_storage,
          upsampled_frame_rect_for_storage.Lines(available_y, num_ys),
          dec_state->rgb_output_is_rgba, alpha,
          alpha_rect.Lines(available_y, num_ys),
          upsampled_frame_rect.Lines(available_y, num_ys)
              .Crop(Rect(0, 0, frame_dim.xsize, frame_dim.ysize)),
          dec_state->rgb_output, dec_state->rgb_stride);
       }
       if (dec_state->pixel_callback != nullptr) {
         Rect alpha_line_rect = alpha_rect.Lines(available_y, num_ys);
         Rect color_input_line_rect =
             upsampled_frame_rect_for_storage.Lines(available_y, num_ys);
         Rect image_line_rect =
             upsampled_frame_rect.Lines(available_y, num_ys)
                 .Crop(Rect(0, 0, frame_dim.xsize, frame_dim.ysize));
         const float* line_buffers[4];
         for (size_t iy = 0; iy < image_line_rect.ysize(); iy++) {
           for (size_t c = 0; c < 3; c++) {
             line_buffers[c] = color_input_line_rect.ConstPlaneRow(
                 *output_pixel_data_storage, c, iy);
           }
           if (alpha) {
             line_buffers[3] = alpha_line_rect.ConstRow(*alpha, iy);
           } else {
             line_buffers[3] = dec_state->opaque_alpha.data();
           }
           std::vector<float>& interleaved =
               dec_state->pixel_callback_rows[thread];
           size_t j = 0;
           for (size_t i = 0; i < image_line_rect.xsize(); i++) {
             interleaved[j++] = line_buffers[0][i];
             interleaved[j++] = line_buffers[1][i];
             interleaved[j++] = line_buffers[2][i];
             if (dec_state->rgb_output_is_rgba) {
               interleaved[j++] = line_buffers[3][i];
             }
           }
           dec_state->pixel_callback(interleaved.data(), image_line_rect.x0(),
                                     image_line_rect.y0() + iy,
                                     image_line_rect.xsize());
         }
       }
     }
   }
 
   return true;
 }
diff --git a/lib/jxl/epf.cc b/lib/jxl/epf.cc
index 43de31f7..1701203d 100644
--- a/lib/jxl/epf.cc
+++ b/lib/jxl/epf.cc
@@ -141,327 +141,327 @@ void GaborishVector(const D df, const float* JXL_RESTRICT row_t,
 
 void GaborishRow(const FilterRows& rows, const LoopFilter& /* lf */,
                  const FilterWeights& filter_weights, size_t x0, size_t x1,
-                 size_t /*image_x_mod_8*/, size_t /* image_y_mod_8 */) {
+                 size_t /*sigma_x_offset*/, size_t /* image_y_mod_8 */) {
   JXL_DASSERT(x0 % Lanes(df) == 0);
 
   const float* JXL_RESTRICT gab_weights = filter_weights.gab_weights;
   for (size_t c = 0; c < 3; c++) {
     const float* JXL_RESTRICT row_t = rows.GetInputRow(-1, c);
     const float* JXL_RESTRICT row_m = rows.GetInputRow(0, c);
     const float* JXL_RESTRICT row_b = rows.GetInputRow(1, c);
     float* JXL_RESTRICT row_out = rows.GetOutputRow(c);
 
     size_t ix = x0;
 
 #if HWY_CAP_GE512
     const HWY_FULL(float) dfull;  // Gaborish is not block-dependent.
 
     // For AVX3, x0 might only be aligned to 8, not 16; if so, do a capped
     // vector first to ensure full (Store-only!) alignment, then full vectors.
     const uintptr_t addr = reinterpret_cast<uintptr_t>(row_out + ix);
     if ((addr % 64) != 0 && ix < x1) {
       const auto w0 = Set(df, gab_weights[3 * c + 0]);
       const auto w1 = Set(df, gab_weights[3 * c + 1]);
       const auto w2 = Set(df, gab_weights[3 * c + 2]);
       GaborishVector(df, row_t + ix, row_m + ix, row_b + ix, w0, w1, w2,
                      row_out + ix);
       ix += Lanes(df);
     }
 
     const auto wfull0 = Set(dfull, gab_weights[3 * c + 0]);
     const auto wfull1 = Set(dfull, gab_weights[3 * c + 1]);
     const auto wfull2 = Set(dfull, gab_weights[3 * c + 2]);
     for (; ix + Lanes(dfull) <= x1; ix += Lanes(dfull)) {
       GaborishVector(dfull, row_t + ix, row_m + ix, row_b + ix, wfull0, wfull1,
                      wfull2, row_out + ix);
     }
 #endif
 
     // Non-AVX3 loop, or last capped vector for AVX3, if necessary
     const auto w0 = Set(df, gab_weights[3 * c + 0]);
     const auto w1 = Set(df, gab_weights[3 * c + 1]);
     const auto w2 = Set(df, gab_weights[3 * c + 2]);
     for (; ix < x1; ix += Lanes(df)) {
       GaborishVector(df, row_t + ix, row_m + ix, row_b + ix, w0, w1, w2,
                      row_out + ix);
     }
   }
 }
 
 // Step 0: 5x5 plus-shaped kernel with 5 SADs per pixel (3x3
 // plus-shaped). So this makes this filter a 7x7 filter.
 void Epf0Row(const FilterRows& rows, const LoopFilter& lf,
              const FilterWeights& filter_weights, size_t x0, size_t x1,
-             size_t image_x_mod_8, size_t image_y_mod_8) {
+             size_t sigma_x_offset, size_t image_y_mod_8) {
   JXL_DASSERT(x0 % Lanes(df) == 0);
   const float* JXL_RESTRICT row_sigma = rows.GetSigmaRow();
 
   float sm = lf.epf_pass0_sigma_scale;
   float bsm = sm * lf.epf_border_sad_mul;
 
   HWY_ALIGN float sad_mul[kBlockDim] = {bsm, sm, sm, sm, sm, sm, sm, bsm};
 
   if (image_y_mod_8 == 0 || image_y_mod_8 == kBlockDim - 1) {
     for (size_t i = 0; i < kBlockDim; i += Lanes(df)) {
       Store(Set(df, bsm), df, sad_mul + i);
     }
   }
 
   for (size_t x = x0; x < x1; x += Lanes(df)) {
-    size_t bx = (x + image_x_mod_8) / kBlockDim;
-    size_t ix = (x + image_x_mod_8) % kBlockDim;
+    size_t bx = (x + sigma_x_offset) / kBlockDim;
+    size_t ix = (x + sigma_x_offset) % kBlockDim;
     if (row_sigma[bx] < kMinSigma) {
       for (size_t c = 0; c < 3; c++) {
         auto px = Load(df, rows.GetInputRow(0, c) + x);
         Store(px, df, rows.GetOutputRow(c) + x);
       }
       continue;
     }
 
     const auto sm = Load(df, sad_mul + ix);
     const auto inv_sigma = Set(DF(), row_sigma[bx]) * sm;
 
     decltype(Zero(df)) sads[12];
     for (size_t i = 0; i < 12; i++) sads[i] = Zero(df);
     constexpr std::array<int, 2> sads_off[12] = {
         {-2, 0}, {-1, -1}, {-1, 0}, {-1, 1}, {0, -2}, {0, -1},
         {0, 1},  {0, 2},   {1, -1}, {1, 0},  {1, 1},  {2, 0},
     };
 
     // compute sads
     // TODO(veluca): consider unrolling and optimizing this.
     for (size_t c = 0; c < 3; c++) {
       auto scale = Set(df, lf.epf_channel_scale[c]);
       for (size_t i = 0; i < 12; i++) {
         auto sad = Zero(df);
         constexpr std::array<int, 2> plus_off[] = {
             {0, 0}, {-1, 0}, {0, -1}, {1, 0}, {0, 1}};
         for (size_t j = 0; j < 5; j++) {
           const auto r11 = LoadU(
               df, rows.GetInputRow(plus_off[j][0], c) + x + plus_off[j][1]);
           const auto c11 =
               LoadU(df, rows.GetInputRow(sads_off[i][0] + plus_off[j][0], c) +
                             x + sads_off[i][1] + plus_off[j][1]);
           sad += AbsDiff(r11, c11);
         }
         sads[i] = MulAdd(sad, scale, sads[i]);
       }
     }
     const auto x_cc = LoadU(df, rows.GetInputRow(0, 0) + x);
     const auto y_cc = LoadU(df, rows.GetInputRow(0, 1) + x);
     const auto b_cc = LoadU(df, rows.GetInputRow(0, 2) + x);
 
     auto w = Set(df, 1);
     auto X = x_cc;
     auto Y = y_cc;
     auto B = b_cc;
 
     for (size_t i = 0; i < 12; i++) {
       AddPixelStep1</*aligned=*/false>(/*row=*/sads_off[i][0], rows,
                                        x + sads_off[i][1], sads[i], inv_sigma,
                                        lf, &X, &Y, &B, &w);
     }
 
 #if JXL_HIGH_PRECISION
     auto inv_w = Set(df, 1.0f) / w;
 #else
     auto inv_w = ApproximateReciprocal(w);
 #endif
     Store(X * inv_w, df, rows.GetOutputRow(0) + x);
     Store(Y * inv_w, df, rows.GetOutputRow(1) + x);
     Store(B * inv_w, df, rows.GetOutputRow(2) + x);
   }
 }
 
 // Step 1: 3x3 plus-shaped kernel with 5 SADs per pixel (also 3x3
 // plus-shaped). So this makes this filter a 5x5 filter.
 void Epf1Row(const FilterRows& rows, const LoopFilter& lf,
              const FilterWeights& filter_weights, size_t x0, size_t x1,
-             size_t image_x_mod_8, size_t image_y_mod_8) {
+             size_t sigma_x_offset, size_t image_y_mod_8) {
   JXL_DASSERT(x0 % Lanes(df) == 0);
   const float* JXL_RESTRICT row_sigma = rows.GetSigmaRow();
 
   float sm = 1.0f;
   float bsm = sm * lf.epf_border_sad_mul;
 
   HWY_ALIGN float sad_mul[kBlockDim] = {bsm, sm, sm, sm, sm, sm, sm, bsm};
 
   if (image_y_mod_8 == 0 || image_y_mod_8 == kBlockDim - 1) {
     for (size_t i = 0; i < kBlockDim; i += Lanes(df)) {
       Store(Set(df, bsm), df, sad_mul + i);
     }
   }
 
   for (size_t x = x0; x < x1; x += Lanes(df)) {
-    size_t bx = (x + image_x_mod_8) / kBlockDim;
-    size_t ix = (x + image_x_mod_8) % kBlockDim;
+    size_t bx = (x + sigma_x_offset) / kBlockDim;
+    size_t ix = (x + sigma_x_offset) % kBlockDim;
     if (row_sigma[bx] < kMinSigma) {
       for (size_t c = 0; c < 3; c++) {
         auto px = Load(df, rows.GetInputRow(0, c) + x);
         Store(px, df, rows.GetOutputRow(c) + x);
       }
       continue;
     }
 
     const auto sm = Load(df, sad_mul + ix);
     const auto inv_sigma = Set(DF(), row_sigma[bx]) * sm;
     auto sad0 = Zero(df);
     auto sad1 = Zero(df);
     auto sad2 = Zero(df);
     auto sad3 = Zero(df);
 
     // compute sads
     for (size_t c = 0; c < 3; c++) {
       // center px = 22, px above = 21
       auto t = Undefined(df);
 
       const auto p20 = Load(df, rows.GetInputRow(-2, c) + x);
       const auto p21 = Load(df, rows.GetInputRow(-1, c) + x);
       auto sad0c = AbsDiff(p20, p21);  // SAD 2, 1
 
       const auto p11 = LoadU(df, rows.GetInputRow(-1, c) + x - 1);
       auto sad1c = AbsDiff(p11, p21);  // SAD 1, 2
 
       const auto p31 = LoadU(df, rows.GetInputRow(-1, c) + x + 1);
       auto sad2c = AbsDiff(p31, p21);  // SAD 3, 2
 
       const auto p02 = LoadU(df, rows.GetInputRow(0, c) + x - 2);
       const auto p12 = LoadU(df, rows.GetInputRow(0, c) + x - 1);
       sad1c += AbsDiff(p02, p12);  // SAD 1, 2
       sad0c += AbsDiff(p11, p12);  // SAD 2, 1
 
       const auto p22 = LoadU(df, rows.GetInputRow(0, c) + x);
       t = AbsDiff(p12, p22);
       sad1c += t;  // SAD 1, 2
       sad2c += t;  // SAD 3, 2
       t = AbsDiff(p22, p21);
       auto sad3c = t;  // SAD 2, 3
       sad0c += t;      // SAD 2, 1
 
       const auto p32 = LoadU(df, rows.GetInputRow(0, c) + x + 1);
       sad0c += AbsDiff(p31, p32);  // SAD 2, 1
       t = AbsDiff(p22, p32);
       sad1c += t;  // SAD 1, 2
       sad2c += t;  // SAD 3, 2
 
       const auto p42 = LoadU(df, rows.GetInputRow(0, c) + x + 2);
       sad2c += AbsDiff(p42, p32);  // SAD 3, 2
 
       const auto p13 = LoadU(df, rows.GetInputRow(1, c) + x - 1);
       sad3c += AbsDiff(p13, p12);  // SAD 2, 3
 
       const auto p23 = Load(df, rows.GetInputRow(1, c) + x);
       t = AbsDiff(p22, p23);
       sad0c += t;                  // SAD 2, 1
       sad3c += t;                  // SAD 2, 3
       sad1c += AbsDiff(p13, p23);  // SAD 1, 2
 
       const auto p33 = LoadU(df, rows.GetInputRow(1, c) + x + 1);
       sad2c += AbsDiff(p33, p23);  // SAD 3, 2
       sad3c += AbsDiff(p33, p32);  // SAD 2, 3
 
       const auto p24 = Load(df, rows.GetInputRow(2, c) + x);
       sad3c += AbsDiff(p24, p23);  // SAD 2, 3
 
       auto scale = Set(df, lf.epf_channel_scale[c]);
       sad0 = MulAdd(sad0c, scale, sad0);
       sad1 = MulAdd(sad1c, scale, sad1);
       sad2 = MulAdd(sad2c, scale, sad2);
       sad3 = MulAdd(sad3c, scale, sad3);
     }
     const auto x_cc = Load(df, rows.GetInputRow(0, 0) + x);
     const auto y_cc = Load(df, rows.GetInputRow(0, 1) + x);
     const auto b_cc = Load(df, rows.GetInputRow(0, 2) + x);
 
     auto w = Set(df, 1);
     auto X = x_cc;
     auto Y = y_cc;
     auto B = b_cc;
 
     // Top row
     AddPixelStep1</*aligned=*/true>(/*row=*/-1, rows, x, sad0, inv_sigma, lf,
                                     &X, &Y, &B, &w);
     // Center
     AddPixelStep1</*aligned=*/false>(/*row=*/0, rows, x - 1, sad1, inv_sigma,
                                      lf, &X, &Y, &B, &w);
     AddPixelStep1</*aligned=*/false>(/*row=*/0, rows, x + 1, sad2, inv_sigma,
                                      lf, &X, &Y, &B, &w);
     // Bottom
     AddPixelStep1</*aligned=*/true>(/*row=*/1, rows, x, sad3, inv_sigma, lf, &X,
                                     &Y, &B, &w);
 #if JXL_HIGH_PRECISION
     auto inv_w = Set(df, 1.0f) / w;
 #else
     auto inv_w = ApproximateReciprocal(w);
 #endif
     Store(X * inv_w, df, rows.GetOutputRow(0) + x);
     Store(Y * inv_w, df, rows.GetOutputRow(1) + x);
     Store(B * inv_w, df, rows.GetOutputRow(2) + x);
   }
 }
 
 // Step 2: 3x3 plus-shaped kernel with a single reference pixel, ran on
 // the output of the previous step.
 void Epf2Row(const FilterRows& rows, const LoopFilter& lf,
              const FilterWeights& filter_weights, size_t x0, size_t x1,
-             size_t image_x_mod_8, size_t image_y_mod_8) {
+             size_t sigma_x_offset, size_t image_y_mod_8) {
   JXL_DASSERT(x0 % Lanes(df) == 0);
   const float* JXL_RESTRICT row_sigma = rows.GetSigmaRow();
 
   float sm = lf.epf_pass2_sigma_scale;
   float bsm = sm * lf.epf_border_sad_mul;
 
   HWY_ALIGN float sad_mul[kBlockDim] = {bsm, sm, sm, sm, sm, sm, sm, bsm};
 
   if (image_y_mod_8 == 0 || image_y_mod_8 == kBlockDim - 1) {
     for (size_t i = 0; i < kBlockDim; i += Lanes(df)) {
       Store(Set(df, bsm), df, sad_mul + i);
     }
   }
 
   for (size_t x = x0; x < x1; x += Lanes(df)) {
-    size_t bx = (x + image_x_mod_8) / kBlockDim;
-    size_t ix = (x + image_x_mod_8) % kBlockDim;
+    size_t bx = (x + sigma_x_offset) / kBlockDim;
+    size_t ix = (x + sigma_x_offset) % kBlockDim;
 
     if (row_sigma[bx] < kMinSigma) {
       for (size_t c = 0; c < 3; c++) {
         auto px = Load(df, rows.GetInputRow(0, c) + x);
         Store(px, df, rows.GetOutputRow(c) + x);
       }
       continue;
     }
 
     const auto sm = Load(df, sad_mul + ix);
     const auto inv_sigma = Set(DF(), row_sigma[bx]) * sm;
 
     const auto x_cc = Load(df, rows.GetInputRow(0, 0) + x);
     const auto y_cc = Load(df, rows.GetInputRow(0, 1) + x);
     const auto b_cc = Load(df, rows.GetInputRow(0, 2) + x);
 
     auto w = Set(df, 1);
     auto X = x_cc;
     auto Y = y_cc;
     auto B = b_cc;
 
     // Top row
     AddPixelStep2</*aligned=*/true>(/*row=*/-1, rows, x, x_cc, y_cc, b_cc,
                                     inv_sigma, lf, &X, &Y, &B, &w);
     // Center
     AddPixelStep2</*aligned=*/false>(/*row=*/0, rows, x - 1, x_cc, y_cc, b_cc,
                                      inv_sigma, lf, &X, &Y, &B, &w);
     AddPixelStep2</*aligned=*/false>(/*row=*/0, rows, x + 1, x_cc, y_cc, b_cc,
                                      inv_sigma, lf, &X, &Y, &B, &w);
     // Bottom
     AddPixelStep2</*aligned=*/true>(/*row=*/1, rows, x, x_cc, y_cc, b_cc,
                                     inv_sigma, lf, &X, &Y, &B, &w);
 
 #if JXL_HIGH_PRECISION
     auto inv_w = Set(df, 1.0f) / w;
 #else
     auto inv_w = ApproximateReciprocal(w);
 #endif
     Store(X * inv_w, df, rows.GetOutputRow(0) + x);
     Store(Y * inv_w, df, rows.GetOutputRow(1) + x);
     Store(B * inv_w, df, rows.GetOutputRow(2) + x);
   }
 }
@@ -474,55 +474,64 @@ constexpr FilterDefinition kEpf2Filter{&Epf2Row, 1};
 void FilterPipelineInit(FilterPipeline* fp, const LoopFilter& lf,
                         const Image3F& in, const Rect& in_rect,
                         const Rect& image_rect, size_t image_ysize,
                         Image3F* out, const Rect& out_rect) {
   JXL_DASSERT(lf.gab || lf.epf_iters > 0);
   // All EPF filters use sigma so we need to compute it.
   fp->compute_sigma = lf.epf_iters > 0;
 
   fp->num_filters = 0;
   fp->storage_rows_used = 0;
   // First filter always uses the input image.
   fp->filters[0].SetInput(&in, in_rect, image_rect, image_ysize);
 
   if (lf.gab) {
     fp->AddStep<kGaborishFilter.border>(kGaborishFilter);
   }
 
   if (lf.epf_iters == 1) {
     fp->AddStep<kEpf1Filter.border>(kEpf1Filter);
   } else if (lf.epf_iters == 2) {
     fp->AddStep<kEpf1Filter.border>(kEpf1Filter);
     fp->AddStep<kEpf2Filter.border>(kEpf2Filter);
   } else if (lf.epf_iters == 3) {
     fp->AddStep<kEpf0Filter.border>(kEpf0Filter);
     fp->AddStep<kEpf1Filter.border>(kEpf1Filter);
     fp->AddStep<kEpf2Filter.border>(kEpf2Filter);
   }
 
   // At least one of the filters was enabled so "num_filters" must be non-zero.
   JXL_DASSERT(fp->num_filters > 0);
 
   // Set the output of the last filter as the output image.
   fp->filters[fp->num_filters - 1].SetOutput(out, out_rect);
 
   // Walk the list of filters backwards to compute how many rows are needed.
   size_t col_border = 0;
   for (int i = fp->num_filters - 1; i >= 0; i--) {
-    // The extra border needed for future filtering should be a multiple of
-    // Lanes(df). Rounding up in each step but not storing the rounded up
-    // value in col_border means that in a 3-step filter the first two filters
-    // may have the same output_col_border value but the second one would use
-    // uninitialized values from the previous one. It is fine to have this
-    // situation for pixels outside the col_border but inside the rounded up
-    // col_border.
-    fp->filters[i].output_col_border = RoundUpTo(col_border, Lanes(df));
+    // Compute the region where we need to apply this filter. Depending on the
+    // step we might need to compute a larger portion than the original rect
+    // because of the border needed by other stages. This is the range of valid
+    // output values we produce, however we run the filter over a larger region
+    // to make those values multiple of Lanes(df).
+    const size_t x0 =
+        FilterPipeline::FilterStep::MaxLeftPadding(image_rect.x0()) -
+        col_border;
+    const size_t x1 =
+        FilterPipeline::FilterStep::MaxLeftPadding(image_rect.x0()) +
+        image_rect.xsize() + col_border;
+
+    fp->filters[i].filter_x0 = x0 - x0 % Lanes(df);
+    fp->filters[i].filter_x1 = RoundUpTo(x1, Lanes(df));
+
+    // The extra border needed for future filtering.
+    fp->filters[i].output_col_border = col_border;
     col_border += fp->filters[i].filter_def.border;
   }
   fp->total_border = col_border;
   JXL_ASSERT(fp->total_border == lf.Padding());
   JXL_ASSERT(fp->total_border <= kMaxFilterBorder);
 }
 
 // NOLINTNEXTLINE(google-readability-namespace-comments)
 }  // namespace HWY_NAMESPACE
 }  // namespace jxl
@@ -646,19 +655,30 @@ void ComputeSigma(const Rect& block_rect, PassesDecoderState* state) {
 FilterPipeline* PrepareFilterPipeline(
     PassesDecoderState* dec_state, const Rect& image_rect, const Image3F& input,
     const Rect& input_rect, size_t image_ysize, size_t thread,
     Image3F* JXL_RESTRICT out, const Rect& output_rect) {
   const LoopFilter& lf = dec_state->shared->frame_header.loop_filter;
-  JXL_DASSERT(image_rect.x0() % GroupBorderAssigner::kPaddingXRound == 0);
-  JXL_DASSERT(input_rect.x0() % GroupBorderAssigner::kPaddingXRound == 0);
-  JXL_DASSERT(output_rect.x0() % GroupBorderAssigner::kPaddingXRound == 0);
-  JXL_DASSERT(input_rect.x0() >= lf.Padding());
+  // image_rect, input and output must all have the same kPaddingXRound
+  // alignment for SIMD, but it doesn't need to be 0.
+  JXL_DASSERT(image_rect.x0() % GroupBorderAssigner::kPaddingXRound ==
+              input_rect.x0() % GroupBorderAssigner::kPaddingXRound);
+  JXL_DASSERT(image_rect.x0() % GroupBorderAssigner::kPaddingXRound ==
+              output_rect.x0() % GroupBorderAssigner::kPaddingXRound);
+
+  // We need enough pixels to access the padding and the rounding to
+  // GroupBorderAssigner::kPaddingXRound to the left of the image.
+  JXL_DASSERT(input_rect.x0() >=
+              input_rect.x0() % GroupBorderAssigner::kPaddingXRound +
+                  lf.Padding());
+
   JXL_DASSERT(image_rect.xsize() == input_rect.xsize());
   JXL_DASSERT(image_rect.xsize() == output_rect.xsize());
   FilterPipeline* fp = &(dec_state->filter_pipelines[thread]);
+  fp->image_rect = image_rect;
+
   HWY_DYNAMIC_DISPATCH(FilterPipelineInit)
   (fp, lf, input, input_rect, image_rect, image_ysize, out, output_rect);
   return fp;
 }
 
 }  // namespace jxl
 #endif  // HWY_ONCE
diff --git a/lib/jxl/epf.h b/lib/jxl/epf.h
index 6a2a8f72..a2fd9d16 100644
--- a/lib/jxl/epf.h
+++ b/lib/jxl/epf.h
@@ -24,11 +24,27 @@ static constexpr float kInvSigmaNum = -1.1715728752538099024f;
 // Fills the `state->filter_weights.sigma` image with the precomputed sigma
 // values in the area inside `block_rect`. Accesses the AC strategy, quant field
 // and epf_sharpness fields in the corresponding positions.
 void ComputeSigma(const Rect& block_rect, PassesDecoderState* state);
 
-// Same as ApplyFilters, but only prepares the pipeline (which is returned and
-// must be run by the caller on -lf.Padding() to image_rect.ysize() +
-// lf.Padding()).
+// Applies Gaborish + EPF to the given `image_rect` part of the image (used to
+// select the sigma values). Input pixels are taken from `input:input_rect`, and
+// the filtering result is written to `out:output_rect`. `dec_state->sigma` must
+// be padded with `kMaxFilterPadding/kBlockDim` values along the x axis.
+// All rects must have the same alignment module
+// GroupBorderAssigner::kPaddingXRound pixels.
+// `input_rect`, `output_rect` and `image_rect` must all have the same size.
+// At least `lf.Padding()` pixels must be accessible and contain valid values
+// outside of `image_rect` in `input`. Also, depending on the implementation,
+// more pixels in the input up to a vector size boundary should be accessible
+// but may contain uninitialized data.
+//
+// This function only prepares and returns the pipeline, to perform the
+// filtering process it must be called on all row from -lf.Padding() to
+// image_rect.ysize() + lf.Padding() .
+//
+// Note: if the output_rect x0 or x1 are not a multiple of kPaddingXRound more
+// pixels with potentially uninitialized data will be written to the output left
+// and right of the requested rect up to a multiple of kPaddingXRound pixels.
 FilterPipeline* PrepareFilterPipeline(
     PassesDecoderState* dec_state, const Rect& image_rect, const Image3F& input,
     const Rect& input_rect, size_t image_ysize, size_t thread,
diff --git a/lib/jxl/filters.cc b/lib/jxl/filters.cc
index 195df1ce..064670d7 100644
--- a/lib/jxl/filters.cc
+++ b/lib/jxl/filters.cc
@@ -43,48 +43,61 @@ void FilterWeights::GaborishWeights(const LoopFilter& lf) {
 
 void FilterPipeline::ApplyFiltersRow(const LoopFilter& lf,
                                      const FilterWeights& filter_weights,
-                                     const Rect& rect, ssize_t y) {
+                                     ssize_t y) {
   PROFILER_ZONE("Gaborish+EPF");
   JXL_DASSERT(num_filters != 0);  // Must be initialized.
 
-  JXL_ASSERT(y < static_cast<ssize_t>(rect.ysize() + lf.Padding()));
+  JXL_ASSERT(y < static_cast<ssize_t>(image_rect.ysize() + lf.Padding()));
 
   // The minimum value of the center row "y" needed to process the current
   // filter.
   ssize_t rows_needed = -static_cast<ssize_t>(lf.Padding());
 
+  // We pass `image_rect.x0() - image_rect.x0() % kBlockDim` as the x0 for
+  // the row_sigma, so to go from an `x` value in the filter to the
+  // corresponding value in row_sigma we use the fact that we mapped
+  // image_rect.x0() in the original image to MaxLeftPadding(image_rect.x0()) in
+  // the input/output rows seen by the filters:
+  // x_in_sigma_row =
+  //    ((x - (image_rect.x0() % kPaddingXRound) + image_rect.x0()) -
+  //     (image_rect.x0() - image_rect.x0() % kBlockDim))) / kBlockDim
+  // x_in_sigma_row =
+  //   x - image_rect.x0() % kPaddingXRound + image_rect.x0() % kBlockDim
+  const size_t sigma_x_offset =
+      image_rect.x0() % kBlockDim -
+      image_rect.x0() % GroupBorderAssigner::kPaddingXRound;
+
   for (size_t i = 0; i < num_filters; i++) {
     const FilterStep& filter = filters[i];
 
     rows_needed += filter.filter_def.border;
 
     // After this "y" points to the rect row for the center of the filter.
     y -= filter.filter_def.border;
     if (y < rows_needed) return;
 
-    // Compute the region where we need to apply this filter. Depending on the
-    // step we might need to compute a larger portion than the original rect.
-    const size_t filter_x0 = kMaxFilterPadding - filter.output_col_border;
-    const size_t filter_x1 =
-        filter_x0 + rect.xsize() + 2 * filter.output_col_border;
-
     // Apply filter to the given region.
     FilterRows rows(filter.filter_def.border);
     filter.set_input_rows(filter, &rows, y);
     filter.set_output_rows(filter, &rows, y);
 
     // The "y" coordinate used for the sigma image in EPF1. Sigma is padded
     // with kMaxFilterPadding (or kMaxFilterPadding/kBlockDim rows in sigma)
     // above and below.
-    const size_t sigma_y = kMaxFilterPadding + rect.y0() + y;
+    const size_t sigma_y = kMaxFilterPadding + image_rect.y0() + y;
+    // The offset to subtract to a "x" value in the filter to obtain the
+    // corresponding x in the sigma row.
     if (compute_sigma) {
-      rows.SetSigma(filter_weights.sigma, sigma_y, rect.x0());
+      rows.SetSigma(filter_weights.sigma, sigma_y,
+                    image_rect.x0() - image_rect.x0() % kBlockDim);
     }
 
-    filter.filter_def.apply(rows, lf, filter_weights, filter_x0, filter_x1,
-                            rect.x0() % kBlockDim, sigma_y % kBlockDim);
+    filter.filter_def.apply(rows, lf, filter_weights, filter.filter_x0,
+                            filter.filter_x1, sigma_x_offset,
+                            sigma_y % kBlockDim);
   }
+
   JXL_DASSERT(rows_needed == 0);
 }
 
 }  // namespace jxl
diff --git a/lib/jxl/filters.h b/lib/jxl/filters.h
index f0223ef4..4b3745c7 100644
--- a/lib/jxl/filters.h
+++ b/lib/jxl/filters.h
@@ -65,257 +65,283 @@ constexpr size_t kMaxBorderSize = 3;
 struct FilterRows {
   explicit FilterRows(int border_size) : border_size_(border_size) {
     JXL_DASSERT(border_size <= static_cast<int>(kMaxBorderSize));
   }
 
   JXL_INLINE const float* GetInputRow(int row, size_t c) const {
     // Check that row is within range.
     JXL_DASSERT(-border_size_ <= row && row <= border_size_);
     return rows_in_[c] + offsets_in_[kMaxBorderSize + row];
   }
 
   float* GetOutputRow(size_t c) const { return rows_out_[c]; }
 
   const float* GetSigmaRow() const {
     JXL_DASSERT(row_sigma_ != nullptr);
     return row_sigma_;
   }
 
   template <typename RowMap>
   void SetInput(const Image3F& in, size_t y_offset, ssize_t y0, ssize_t x0,
                 ssize_t full_image_y_offset = 0, ssize_t image_ysize = 0) {
     RowMap row_map(full_image_y_offset, image_ysize);
     for (size_t c = 0; c < 3; c++) {
       rows_in_[c] = in.ConstPlaneRow(c, 0);
     }
     for (int32_t i = -border_size_; i <= border_size_; i++) {
       size_t y = row_map(y0 + i);
       offsets_in_[i + kMaxBorderSize] =
           static_cast<ssize_t>((y + y_offset) * in.PixelsPerRow()) + x0;
     }
   }
 
   template <typename RowMap>
   void SetOutput(Image3F* out, size_t y_offset, ssize_t y0, ssize_t x0) {
     size_t y = RowMap()(y0);
     for (size_t c = 0; c < 3; c++) {
       rows_out_[c] = out->PlaneRow(c, y + y_offset) + x0;
     }
   }
 
   // Sets the sigma row for the given y0, x0 input image position. Sigma images
   // have one pixel per input image block, although they are padded with two
   // blocks (pixels in sigma) on each one of the four sides. The (x0, y0) values
   // should include this padding.
   void SetSigma(const ImageF& sigma, size_t y0, size_t x0) {
-    JXL_DASSERT(x0 % GroupBorderAssigner::kPaddingXRound == 0);
+    JXL_DASSERT(x0 % kBlockDim == 0);
     row_sigma_ = sigma.ConstRow(y0 / kBlockDim) + x0 / kBlockDim;
   }
 
  private:
   // Base pointer to each one of the planes.
   const float* JXL_RESTRICT rows_in_[3];
 
   // Offset to the pixel x0 at the different rows. offsets_in_[kMaxBorderSize]
   // references the center row, regardless of the border_size_. Only the center
   // row, border_size_ before and border_size_ after are initialized. The offset
   // is relative to the base pointer in rows_in_.
   ssize_t offsets_in_[2 * kMaxBorderSize + 1];
 
   float* JXL_RESTRICT rows_out_[3];
 
   const float* JXL_RESTRICT row_sigma_{nullptr};
 
   const int border_size_;
 };
 
 // Definition of a filter. This specifies the function to be used to apply the
 // filter and its row and column padding requirements.
 struct FilterDefinition {
   // Function to apply the filter to a given row. The filter constant parameters
-  // are passed in LoopFilter lf and filter_weights. `xoff` is needed to offset
-  // the `x0` value so that it will cause correct accesses to
+  // are passed in LoopFilter lf and filter_weights. `sigma_x_offset` is needed
+  // to offset the `x0` value so that it will cause correct accesses to
   // rows.GetSigmaRow(): there is just one sigma value per 8 pixels, and if the
   // image rectangle is not aligned to multiples of 8 pixels, we need to
   // compensate for the difference between x0 and the image position modulo 8.
   void (*apply)(const FilterRows& rows, const LoopFilter& lf,
                 const FilterWeights& filter_weights, size_t x0, size_t x1,
-                size_t image_y_mod_8, size_t image_x_mod_8);
+                size_t sigma_x_offset, size_t image_y_mod_8);
 
   // Number of source image rows and cols before and after an input pixel needed
   // to compute the output of the filter. For a 3x3 convolution this border will
   // be only 1.
   size_t border;
 };
 
 // A chain of filters to be applied to a source image. This instance must be
 // initialized by the FilterPipelineInit() function before it can be used.
 class FilterPipeline {
  public:
   FilterPipeline() : FilterPipeline(kApplyImageFeaturesTileDim) {}
   explicit FilterPipeline(size_t max_rect_xsize)
-      : storage{max_rect_xsize + 2 * kMaxFilterPadding, kTotalStorageRows} {
+      : storage{max_rect_xsize + 2 * kMaxFilterPadding +
+                    GroupBorderAssigner::kPaddingXRound,
+                kTotalStorageRows} {
 #if MEMORY_SANITIZER
     // The padding of the storage may be used uninitialized since we process
     // multiple SIMD lanes at a time, aligned to a multiple of lanes.
     // For example, in a hypothetical 3-step filter process where all filters
     // use 1 pixel border the first filter needs to process 2 pixels more on
     // each side than the requested rect.x0(), rect.xsize(), while the second
     // filter needs to process 1 more pixel on each side, however for
     // performance reasons both will process Lanes(df) more pixels on each
     // side assuming this Lanes(df) value is more than one. In that case the
     // second filter will be using one pixel of uninitialized data to generate
     // an output pixel that won't affect the final output but may cause msan
     // failures. For this reason we initialize the padding region.
     for (size_t c = 0; c < 3; c++) {
       for (size_t y = 0; y < storage.ysize(); y++) {
         float* row = storage.PlaneRow(c, y);
         std::fill(row, row + kMaxFilterPadding, msan::kSanitizerSentinel);
         std::fill(row + storage.xsize() - kMaxFilterPadding,
                   row + storage.xsize(), msan::kSanitizerSentinel);
       }
     }
 #endif  // MEMORY_SANITIZER
   }
 
   FilterPipeline(const FilterPipeline&) = delete;
   FilterPipeline(FilterPipeline&&) = default;
 
   // Apply the filter chain to a given row. To apply the filter chain to a whole
-  // image this must be called for `rect.ysize() + 2 * total_border`
+  // image this must be called for `image_rect.ysize() + 2 * total_border`
   // values of `y`, in increasing order, starting from `y = -total_border`.
+  // `image_rect` is the value passed to FilterPipelineInit().
   void ApplyFiltersRow(const LoopFilter& lf,
-                       const FilterWeights& filter_weights, const Rect& rect,
-                       ssize_t y);
+                       const FilterWeights& filter_weights, ssize_t y);
 
   struct FilterStep {
+    // We don't map self.input_rect.x0() directly to kMaxFilterPadding in
+    // input/output row since they might have a different alignment, instead we
+    // keep the alignment modulo kPaddingXRound.
+    static size_t MaxLeftPadding(size_t image_rect_x0) {
+      return kMaxFilterPadding +
+             image_rect_x0 % GroupBorderAssigner::kPaddingXRound;
+    }
+
     // Sets the input of the filter step as an image region.
     void SetInput(const Image3F* im_input, const Rect& input_rect,
                   const Rect& image_rect, size_t image_ysize) {
       input = im_input;
       this->input_rect = input_rect;
       this->image_rect = image_rect;
       this->image_ysize = image_ysize;
       JXL_DASSERT(SameSize(input_rect, image_rect));
       set_input_rows = [](const FilterStep& self, FilterRows* rows,
                           ssize_t y0) {
         ssize_t full_image_y_offset =
             static_cast<ssize_t>(self.image_rect.y0()) -
             static_cast<ssize_t>(self.input_rect.y0());
         rows->SetInput<RowMapMirror>(*(self.input), 0,
                                      self.input_rect.y0() + y0,
                                      self.input_rect.x0() - kMaxFilterPadding,
                                      full_image_y_offset, self.image_ysize);
+        rows->SetInput<RowMapMirror>(
+            *(self.input), 0, self.input_rect.y0() + y0,
+            self.input_rect.x0() - MaxLeftPadding(self.input_rect.x0()),
+            full_image_y_offset, self.image_ysize);
       };
     }
 
     // Sets the input of the filter step as the temporary cyclic storage with
-    // num_rows rows. The value rect.x0() during application will be mapped to
-    // kMaxFilterPadding regardless of the rect being processed.
+    // num_rows rows. The value image_rect.x0() during application will be
+    // mapped to "kMaxFilterPadding + alignment" regardless of the rect being
+    // processed.
     template <size_t num_rows>
     void SetInputCyclicStorage(const Image3F* storage, size_t offset_rows) {
       input = storage;
       input_y_offset = offset_rows;
       set_input_rows = [](const FilterStep& self, FilterRows* rows,
                           ssize_t y0) {
         rows->SetInput<RowMapMod<num_rows>>(*(self.input), self.input_y_offset,
                                             y0, 0);
       };
     }
 
     // Sets the output of the filter step as the temporary cyclic storage with
-    // num_rows rows. The value rect.x0() during application will be mapped to
-    // kMaxFilterPadding regardless of the rect being processed.
+    // num_rows rows. The value image_rect.x0() during application will be
+    // mapped to "kMaxFilterPadding + alignment" regardless of the rect being
+    // processed.
     template <size_t num_rows>
     void SetOutputCyclicStorage(Image3F* storage, size_t offset_rows) {
       output = storage;
       output_y_offset = offset_rows;
       set_output_rows = [](const FilterStep& self, FilterRows* rows,
                            ssize_t y0) {
         rows->SetOutput<RowMapMod<num_rows>>(self.output, self.output_y_offset,
                                              y0, 0);
       };
     }
 
     // Set the output of the filter step as the output image. The value
     // rect.x0() will be mapped to the same value in the output image.
     void SetOutput(Image3F* im_output, const Rect& output_rect) {
       output = im_output;
       this->output_rect = output_rect;
       set_output_rows = [](const FilterStep& self, FilterRows* rows,
                            ssize_t y0) {
-        rows->SetOutput<RowMapId>(
-            self.output, 0, self.output_rect.y0() + y0,
-            static_cast<ssize_t>(self.output_rect.x0()) - kMaxFilterPadding);
+        rows->SetOutput<RowMapId>(self.output, 0, self.output_rect.y0() + y0,
+                                  static_cast<ssize_t>(self.output_rect.x0()) -
+                                      MaxLeftPadding(self.output_rect.x0()));
       };
     }
 
     // The input and output image buffers for the current filter step. Note that
     // the rows used from these images depends on the module used in
     // set_input_rows and set_output_rows functions.
     const Image3F* input;
     size_t input_y_offset = 0;
     Image3F* output;
     size_t output_y_offset = 0;
 
     // Input/output rect for the first/last steps of the filter.
     Rect input_rect;
     Rect output_rect;
 
     // Information to properly do RowMapMirror().
     Rect image_rect;
     size_t image_ysize;
 
     // Functions that compute the list of rows needed to process a region for
     // the given row and starting column.
     void (*set_input_rows)(const FilterStep&, FilterRows* rows, ssize_t y0);
     void (*set_output_rows)(const FilterStep&, FilterRows* rows, ssize_t y0);
 
     // Actual filter descriptor.
     FilterDefinition filter_def;
 
+    // Range of output pixels of the step. The filter [x0, x1) range is always
+    // a multiple of Lanes(df) and is large enough to contain the input and
+    // border needed by the next stages, but values outside that range may be
+    // undefined values. Coordinates are relative to the FilterRows pointers.
+    size_t filter_x0, filter_x1;
+
     // Number of extra horizontal pixels needed on each side of the output of
     // this filter to produce the requested rect at the end of the chain. This
     // value is always 0 for the last filter of the chain but it depends on the
     // actual filter chain used in other cases.
     size_t output_col_border;
   };
 
   template <size_t border>
   void AddStep(const FilterDefinition& filter_def) {
     JXL_DASSERT(num_filters < kMaxFilters);
     filters[num_filters].filter_def = filter_def;
 
     if (num_filters > 0) {
       // If it is not the first step we need to set the previous step output to
       // a portion of the cyclic storage. We only need as many rows as the
       // input of the current stage.
       constexpr size_t num_rows = 2 * border + 1;
       filters[num_filters - 1].SetOutputCyclicStorage<num_rows>(
           &storage, storage_rows_used);
       filters[num_filters].SetInputCyclicStorage<num_rows>(&storage,
                                                            storage_rows_used);
       storage_rows_used += num_rows;
       JXL_DASSERT(storage_rows_used <= kTotalStorageRows);
     }
     num_filters++;
   }
 
   // Tile storage for ApplyImageFeatures steps. Different groups of rows of this
   // image are used for the intermediate steps.
   Image3F storage;
   size_t storage_rows_used = 0;
 
   static const size_t kMaxFilters = 4;
   FilterStep filters[kMaxFilters];
   size_t num_filters = 0;
 
   // Whether we need to compute the sigma_row_ during application.
   bool compute_sigma = false;
 
+  // Rect to be processed in the image coordinates. This doesn't include any
+  // padding needed to produce the output.
+  Rect image_rect;
+
   // The total border needed to process this pipeline.
   size_t total_border = 0;
 };
 
 }  // namespace jxl
 
 #endif  // LIB_JXL_FILTERS_H_
