commit 7788fa11896f685ab8fac0171474178004e7de08
Author: Even Rouault <even.rouault@mines-paris.org>
Date:   Sat Mar 17 10:53:51 2018 +0000

    VRT: for consistency, make sure that VRT intermediate datatype demotion is done, e.g that a VRT band of type Byte, with a source of type Float32, requested as Float32 buffer involves Float32 -> Byte -> Float32 conversions
    
    git-svn-id: https://svn.osgeo.org/gdal/trunk@41838 f0d54148-0727-0410-94bb-9a71ac55c965

diff --git a/autotest/cpp/test_gdal.cpp b/autotest/cpp/test_gdal.cpp
index 200ec1aef2..7b0ad0cca4 100644
--- a/autotest/cpp/test_gdal.cpp
+++ b/autotest/cpp/test_gdal.cpp
@@ -38,432 +38,568 @@
 namespace tut
 {
     // Common fixture with test data
     struct test_gdal_data
     {
         // Expected number of drivers
         int drv_count_;
 
         test_gdal_data()
             : drv_count_(0)
         {
             // Windows CE port builds with fixed number of drivers
 #ifdef FRMT_aaigrid
             drv_count_++;
 #endif
 #ifdef FRMT_dted
             drv_count_++;
 #endif
 #ifdef FRMT_gtiff
             drv_count_++;
 #endif
         }
     };
 
     // Register test group
     typedef test_group<test_gdal_data> group;
     typedef group::object object;
     group test_gdal_group("GDAL");
 
     // Test GDAL driver manager access
     template<>
     template<>
     void object::test<1>()
     {
         GDALDriverManager* drv_mgr = nullptr;
         drv_mgr = GetGDALDriverManager();
         ensure("GetGDALDriverManager() is NULL", nullptr != drv_mgr);
     }
 
     // Test number of registered GDAL drivers
     template<>
     template<>
     void object::test<2>()
     {
 #ifdef WIN32CE
         ensure_equals("GDAL registered drivers count doesn't match",
             GDALGetDriverCount(), drv_count_);
 #endif
     }
 
     // Test if AAIGrid driver is registered
     template<>
     template<>
     void object::test<3>()
     {
         GDALDriverH drv = GDALGetDriverByName("AAIGrid");
 
 #ifdef FRMT_aaigrid
         ensure("AAIGrid driver is not registered", NULL != drv);
 #else
         (void)drv;
         ensure(true); // Skip
 #endif
     }
 
     // Test if DTED driver is registered
     template<>
     template<>
     void object::test<4>()
     {
         GDALDriverH drv = GDALGetDriverByName("DTED");
 
 #ifdef FRMT_dted
         ensure("DTED driver is not registered", NULL != drv);
 #else
         (void)drv;
         ensure(true); // Skip
 #endif
     }
 
     // Test if GeoTIFF driver is registered
     template<>
     template<>
     void object::test<5>()
     {
         GDALDriverH drv = GDALGetDriverByName("GTiff");
 
 #ifdef FRMT_gtiff
         ensure("GTiff driver is not registered", NULL != drv);
 #else
         (void)drv;
         ensure(true); // Skip
 #endif
     }
 
 #define ENSURE(cond) ensure(#cond, (cond))
 #define ENSURE_EQUALS(a, b) ensure_equals(#a " == " #b, (a), (b))
     
     // Test GDALDataTypeUnion()
     template<> template<> void object::test<6>()
     {
         for(int i=GDT_Byte;i<GDT_TypeCount;i++)
         {
             for(int j=GDT_Byte;j<GDT_TypeCount;j++)
             {
                 GDALDataType eDT1 = static_cast<GDALDataType>(i);
                 GDALDataType eDT2 = static_cast<GDALDataType>(j);
                 GDALDataType eDT = GDALDataTypeUnion(eDT1,eDT2 );
                 ENSURE( eDT == GDALDataTypeUnion(eDT2,eDT1) );
                 ENSURE( GDALGetDataTypeSize(eDT) >= GDALGetDataTypeSize(eDT1) );
                 ENSURE( GDALGetDataTypeSize(eDT) >= GDALGetDataTypeSize(eDT2) );
                 ENSURE( (GDALDataTypeIsComplex(eDT) && (GDALDataTypeIsComplex(eDT1) || GDALDataTypeIsComplex(eDT2))) ||
                         (!GDALDataTypeIsComplex(eDT) && !GDALDataTypeIsComplex(eDT1) && !GDALDataTypeIsComplex(eDT2)) );
                 
                 ENSURE( !(GDALDataTypeIsFloating(eDT1) || GDALDataTypeIsFloating(eDT2)) || GDALDataTypeIsFloating(eDT));
                 ENSURE( !(GDALDataTypeIsSigned(eDT1) || GDALDataTypeIsSigned(eDT2)) || GDALDataTypeIsSigned(eDT));
             }
         }
 
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_Int16, GDT_UInt16), GDT_Int32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_Int16, GDT_UInt32), GDT_Float64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_UInt32, GDT_Int16), GDT_Float64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_UInt32, GDT_CInt16), GDT_CFloat64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_Float32, GDT_CInt32), GDT_CFloat64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt16, GDT_UInt32), GDT_CFloat64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt16, GDT_CFloat32), GDT_CFloat32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt32, GDT_Byte), GDT_CInt32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt32, GDT_UInt16), GDT_CInt32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt32, GDT_Int16), GDT_CInt32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt32, GDT_UInt32), GDT_CFloat64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt32, GDT_Int32), GDT_CInt32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt32, GDT_Float32), GDT_CFloat64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt32, GDT_CInt16), GDT_CInt32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CInt32, GDT_CFloat32), GDT_CFloat64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CFloat32, GDT_Byte), GDT_CFloat32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CFloat32, GDT_UInt16), GDT_CFloat32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CFloat32, GDT_Int16), GDT_CFloat32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CFloat32, GDT_UInt32), GDT_CFloat64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CFloat32, GDT_Int32), GDT_CFloat64);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CFloat32, GDT_Float32), GDT_CFloat32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CFloat32, GDT_CInt16), GDT_CFloat32);
         ENSURE_EQUALS(GDALDataTypeUnion(GDT_CFloat32, GDT_CInt32), GDT_CFloat64);
     }
 
 #undef ENSURE
 #undef ENSURE_EQUALS
 
     // Test GDALAdjustValueToDataType()
     template<> template<> void object::test<7>()
     {
         int bClamped, bRounded;
 
         ensure( GDALAdjustValueToDataType(GDT_Byte,255.0,nullptr,nullptr) == 255.0);
         ensure( GDALAdjustValueToDataType(GDT_Byte,255.0,&bClamped,&bRounded) == 255.0 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Byte,254.4,&bClamped,&bRounded) == 254.0 && !bClamped && bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Byte,-1,&bClamped,&bRounded) == 0.0 && bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Byte,256.0,&bClamped,&bRounded) == 255.0 && bClamped && !bRounded);
 
         ensure( GDALAdjustValueToDataType(GDT_UInt16,65535.0,&bClamped,&bRounded) == 65535.0 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_UInt16,65534.4,&bClamped,&bRounded) == 65534.0 && !bClamped && bRounded);
         ensure( GDALAdjustValueToDataType(GDT_UInt16,-1,&bClamped,&bRounded) == 0.0 && bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_UInt16,65536.0,&bClamped,&bRounded) == 65535.0 && bClamped && !bRounded);
 
         ensure( GDALAdjustValueToDataType(GDT_Int16,-32768.0,&bClamped,&bRounded) == -32768.0 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Int16,32767.0,&bClamped,&bRounded) == 32767.0 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Int16,-32767.4,&bClamped,&bRounded) == -32767.0 && !bClamped && bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Int16,32766.4,&bClamped,&bRounded) == 32766.0 && !bClamped && bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Int16,-32769.0,&bClamped,&bRounded) == -32768.0 && bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Int16,32768.0,&bClamped,&bRounded) == 32767.0 && bClamped && !bRounded);
 
         ensure( GDALAdjustValueToDataType(GDT_UInt32,10000000.0,&bClamped,&bRounded) == 10000000.0 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_UInt32,10000000.4,&bClamped,&bRounded) == 10000000.0 && !bClamped && bRounded);
         ensure( GDALAdjustValueToDataType(GDT_UInt32,-1,&bClamped,&bRounded) == 0.0 && bClamped && !bRounded);
 
         ensure( GDALAdjustValueToDataType(GDT_Int32,-10000000.0,&bClamped,&bRounded) == -10000000.0 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Int32,10000000.0,&bClamped,&bRounded) == 10000000.0 && !bClamped && !bRounded);
 
         ensure( GDALAdjustValueToDataType(GDT_Float32, 0.0,&bClamped,&bRounded) == 0.0 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float32, 1e-50,&bClamped,&bRounded) == 0.0 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float32, 1.23,&bClamped,&bRounded) == static_cast<double>(1.23f) && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float32, -1e300,&bClamped,&bRounded) == -std::numeric_limits<float>::max() && bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float32, 1e300,&bClamped,&bRounded) == std::numeric_limits<float>::max() && bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float32, std::numeric_limits<float>::infinity(),&bClamped,&bRounded) == std::numeric_limits<float>::infinity() && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float32, -std::numeric_limits<float>::infinity(),&bClamped,&bRounded) == -std::numeric_limits<float>::infinity() && !bClamped && !bRounded);
         {
             double dfNan = std::numeric_limits<double>::quiet_NaN();
             double dfGot = GDALAdjustValueToDataType(GDT_Float32, dfNan,&bClamped,&bRounded);
             ensure( memcmp(&dfNan, &dfGot, sizeof(double)) == 0 && !bClamped && !bRounded);
         }
 
         ensure( GDALAdjustValueToDataType(GDT_Float64, 0.0,&bClamped,&bRounded) == 0.0 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float64, 1e-50,&bClamped,&bRounded) == 1e-50 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float64, -1e40,&bClamped,&bRounded) == -1e40 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float64, 1e40,&bClamped,&bRounded) == 1e40 && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float64, std::numeric_limits<float>::infinity(),&bClamped,&bRounded) == std::numeric_limits<float>::infinity() && !bClamped && !bRounded);
         ensure( GDALAdjustValueToDataType(GDT_Float64, -std::numeric_limits<float>::infinity(),&bClamped,&bRounded) == -std::numeric_limits<float>::infinity() && !bClamped && !bRounded);
         {
             double dfNan = std::numeric_limits<double>::quiet_NaN();
             double dfGot = GDALAdjustValueToDataType(GDT_Float64, dfNan,&bClamped,&bRounded);
             ensure( memcmp(&dfNan, &dfGot, sizeof(double)) == 0 && !bClamped && !bRounded);
         }
     }
 
     class FakeBand: public GDALRasterBand
     {
         protected:
             virtual CPLErr IReadBlock(int, int, void*) CPL_OVERRIDE { return CE_None; }
             virtual CPLErr IWriteBlock( int, int, void * ) CPL_OVERRIDE { return CE_None; }
 
         public:
                     FakeBand(int nXSize, int nYSize) { nBlockXSize = nXSize;
                                                        nBlockYSize = nYSize; }
     };
 
     class DatasetWithErrorInFlushCache: public GDALDataset
     {
             bool bHasFlushCache;
         public:
             DatasetWithErrorInFlushCache() : bHasFlushCache(false) { }
            ~DatasetWithErrorInFlushCache() { FlushCache(); }
             virtual void FlushCache(void) CPL_OVERRIDE
             {
                 if( !bHasFlushCache)
                     CPLError(CE_Failure, CPLE_AppDefined, "some error");
                 GDALDataset::FlushCache();
                 bHasFlushCache = true;
             }
             virtual CPLErr SetProjection(const char*) CPL_OVERRIDE { return CE_None; }
             virtual CPLErr SetGeoTransform(double*) CPL_OVERRIDE { return CE_None; }
 
             static GDALDataset* CreateCopy(const char*, GDALDataset*,
                                     int, char **,
                                     GDALProgressFunc,
                                     void *)
             {
                 return new DatasetWithErrorInFlushCache();
             }
 
             static GDALDataset* Create(const char*, int nXSize, int nYSize, int, GDALDataType, char ** )
             {
                 DatasetWithErrorInFlushCache* poDS = new DatasetWithErrorInFlushCache();
                 poDS->eAccess = GA_Update;
                 poDS->nRasterXSize = nXSize;
                 poDS->nRasterYSize = nYSize;
                 poDS->SetBand(1, new FakeBand(nXSize, nYSize));
                 return poDS;
             }
     };
 
     // Test that GDALTranslate() detects error in flush cache
     template<> template<> void object::test<8>()
     {
         GDALDriver* poDriver = new GDALDriver();
         poDriver->SetDescription("DatasetWithErrorInFlushCache");
         poDriver->pfnCreateCopy = DatasetWithErrorInFlushCache::CreateCopy;
         GetGDALDriverManager()->RegisterDriver( poDriver );
         const char* args[] = { "-of", "DatasetWithErrorInFlushCache", nullptr };
         GDALTranslateOptions* psOptions = GDALTranslateOptionsNew((char**)args, nullptr);
         GDALDatasetH hSrcDS = GDALOpen(GCORE_DATA_DIR "byte.tif", GA_ReadOnly);
         CPLErrorReset();
         CPLPushErrorHandler(CPLQuietErrorHandler);
         GDALDatasetH hOutDS = GDALTranslate("", hSrcDS, psOptions, nullptr);
         CPLPopErrorHandler();
         GDALClose(hSrcDS);
         GDALTranslateOptionsFree(psOptions);
         ensure(hOutDS == nullptr);
         ensure(CPLGetLastErrorType() != CE_None);
         GetGDALDriverManager()->DeregisterDriver( poDriver );
         delete poDriver;
     }
 
     // Test that GDALWarp() detects error in flush cache
     template<> template<> void object::test<9>()
     {
         GDALDriver* poDriver = new GDALDriver();
         poDriver->SetDescription("DatasetWithErrorInFlushCache");
         poDriver->pfnCreate = DatasetWithErrorInFlushCache::Create;
         GetGDALDriverManager()->RegisterDriver( poDriver );
         const char* args[] = { "-of", "DatasetWithErrorInFlushCache", nullptr };
         GDALWarpAppOptions* psOptions = GDALWarpAppOptionsNew((char**)args, nullptr);
         GDALDatasetH hSrcDS = GDALOpen(GCORE_DATA_DIR "byte.tif", GA_ReadOnly);
         CPLErrorReset();
         CPLPushErrorHandler(CPLQuietErrorHandler);
         GDALDatasetH hOutDS = GDALWarp("/", nullptr, 1, &hSrcDS, psOptions, nullptr);
         CPLPopErrorHandler();
         GDALClose(hSrcDS);
         GDALWarpAppOptionsFree(psOptions);
         ensure(hOutDS == nullptr);
         ensure(CPLGetLastErrorType() != CE_None);
         GetGDALDriverManager()->DeregisterDriver( poDriver );
         delete poDriver;
     }
 
     // Test that GDALSwapWords() with unaligned buffers
     template<> template<> void object::test<10>()
     {
         GByte abyBuffer[ 8 * 2 + 1 ] = { 0, 1, 2, 3, 4, 5, 6, 7, 255, 7, 6, 5, 4, 3, 2, 1, 0 };
         GDALSwapWords(abyBuffer, 4, 2, 9 );
         ensure( abyBuffer[0] == 3 );
         ensure( abyBuffer[1] == 2 );
         ensure( abyBuffer[2] == 1 );
         ensure( abyBuffer[3] == 0 );
 
         ensure( abyBuffer[9] == 4 );
         ensure( abyBuffer[10] == 5 );
         ensure( abyBuffer[11] == 6 );
         ensure( abyBuffer[12] == 7 );
         GDALSwapWords(abyBuffer, 4, 2, 9 );
 
         GDALSwapWords(abyBuffer, 8, 2, 9 );
         ensure( abyBuffer[0] == 7 );
         ensure( abyBuffer[1] == 6 );
         ensure( abyBuffer[2] == 5 );
         ensure( abyBuffer[3] == 4 );
         ensure( abyBuffer[4] == 3 );
         ensure( abyBuffer[5] == 2 );
         ensure( abyBuffer[6] == 1 );
         ensure( abyBuffer[7] == 0 );
 
         ensure( abyBuffer[9] == 0 );
         ensure( abyBuffer[10] == 1 );
         ensure( abyBuffer[11] == 2 );
         ensure( abyBuffer[12] == 3 );
         ensure( abyBuffer[13] == 4 );
         ensure( abyBuffer[14] == 5 );
         ensure( abyBuffer[15] == 6 );
         ensure( abyBuffer[16] == 7 );
         GDALSwapWords(abyBuffer, 4, 2, 9 );
 
     }
 
     // Test ARE_REAL_EQUAL()
     template<> template<> void object::test<11>()
     {
         ensure( ARE_REAL_EQUAL(0.0, 0.0) );
         ensure( !ARE_REAL_EQUAL(0.0, 0.1) );
         ensure( !ARE_REAL_EQUAL(0.1, 0.0) );
         ensure( ARE_REAL_EQUAL(1.0, 1.0) );
         ensure( !ARE_REAL_EQUAL(1.0, 0.99) );
         ensure( ARE_REAL_EQUAL(-std::numeric_limits<double>::min(), -std::numeric_limits<double>::min()) );
         ensure( ARE_REAL_EQUAL(std::numeric_limits<double>::min(), std::numeric_limits<double>::min()) );
         ensure( !ARE_REAL_EQUAL(std::numeric_limits<double>::min(), 0.0) );
         ensure( ARE_REAL_EQUAL(-std::numeric_limits<double>::max(), -std::numeric_limits<double>::max()) );
         ensure( ARE_REAL_EQUAL(std::numeric_limits<double>::max(), std::numeric_limits<double>::max()) );
         ensure( ARE_REAL_EQUAL(-std::numeric_limits<double>::infinity(), -std::numeric_limits<double>::infinity()) );
         ensure( ARE_REAL_EQUAL(std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity()) );
         ensure( !ARE_REAL_EQUAL(std::numeric_limits<double>::infinity(), std::numeric_limits<double>::max()) );
         ensure( ARE_REAL_EQUAL(-std::numeric_limits<double>::min(), -std::numeric_limits<double>::min()) );
 
         ensure( ARE_REAL_EQUAL(0.0f, 0.0f) );
         ensure( !ARE_REAL_EQUAL(0.0f, 0.1f) );
         ensure( !ARE_REAL_EQUAL(0.1f, 0.0f) );
         ensure( ARE_REAL_EQUAL(1.0f, 1.0f) );
         ensure( !ARE_REAL_EQUAL(1.0f, 0.99f) );
         ensure( ARE_REAL_EQUAL(-std::numeric_limits<float>::min(), -std::numeric_limits<float>::min()) );
         ensure( ARE_REAL_EQUAL(std::numeric_limits<float>::min(), std::numeric_limits<float>::min()) );
         ensure( !ARE_REAL_EQUAL(std::numeric_limits<float>::min(), 0.0f) );
         ensure( ARE_REAL_EQUAL(-std::numeric_limits<float>::max(), -std::numeric_limits<float>::max()) );
         ensure( ARE_REAL_EQUAL(std::numeric_limits<float>::max(), std::numeric_limits<float>::max()) );
         ensure( ARE_REAL_EQUAL(-std::numeric_limits<float>::infinity(), -std::numeric_limits<float>::infinity()) );
         ensure( ARE_REAL_EQUAL(std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity()) );
         ensure( !ARE_REAL_EQUAL(std::numeric_limits<float>::infinity(), std::numeric_limits<float>::max()) );
     }
 
     // Test GDALIsValueInRange()
     template<> template<> void object::test<12>()
     {
         ensure( GDALIsValueInRange<GByte>(0) );
         ensure( GDALIsValueInRange<GByte>(255) );
         ensure( !GDALIsValueInRange<GByte>(-1) );
         ensure( !GDALIsValueInRange<GByte>(256) );
         ensure( GDALIsValueInRange<float>(std::numeric_limits<float>::max()) );
         ensure( GDALIsValueInRange<float>(std::numeric_limits<float>::infinity()) );
         ensure( !GDALIsValueInRange<float>(std::numeric_limits<double>::max()) );
         ensure( GDALIsValueInRange<double>(std::numeric_limits<double>::infinity()) );
         ensure( !GDALIsValueInRange<double>(CPLAtof("nan")) );
         ensure( !GDALIsValueInRange<float>(CPLAtof("nan")) );
         ensure( !GDALIsValueInRange<GByte>(CPLAtof("nan")) );
     }
 
     // Test GDALDataTypeIsInteger()
     template<> template<> void object::test<13>()
     {
         ensure( !GDALDataTypeIsInteger(GDT_Unknown) );
         ensure_equals( GDALDataTypeIsInteger(GDT_Byte), TRUE );
         ensure_equals( GDALDataTypeIsInteger(GDT_UInt16), TRUE );
         ensure_equals( GDALDataTypeIsInteger(GDT_Int16), TRUE );
         ensure_equals( GDALDataTypeIsInteger(GDT_UInt32), TRUE );
         ensure_equals( GDALDataTypeIsInteger(GDT_Int32), TRUE );
         ensure( !GDALDataTypeIsInteger(GDT_Float32) );
         ensure( !GDALDataTypeIsInteger(GDT_Float64) );
         ensure_equals( GDALDataTypeIsInteger(GDT_CInt16), TRUE );
         ensure_equals( GDALDataTypeIsInteger(GDT_CInt32), TRUE );
         ensure( !GDALDataTypeIsInteger(GDT_CFloat32) );
         ensure( !GDALDataTypeIsInteger(GDT_CFloat64) );
     }
 
     // Test GDALDataTypeIsFloating()
     template<> template<> void object::test<14>()
     {
         ensure( !GDALDataTypeIsFloating(GDT_Unknown) );
         ensure( !GDALDataTypeIsFloating(GDT_Byte) );
         ensure( !GDALDataTypeIsFloating(GDT_UInt16) );
         ensure( !GDALDataTypeIsFloating(GDT_Int16) );
         ensure( !GDALDataTypeIsFloating(GDT_UInt32) );
         ensure( !GDALDataTypeIsFloating(GDT_Int32) );
         ensure_equals( GDALDataTypeIsFloating(GDT_Float32), TRUE );
         ensure_equals( GDALDataTypeIsFloating(GDT_Float64), TRUE );
         ensure( !GDALDataTypeIsFloating(GDT_CInt16) );
         ensure( !GDALDataTypeIsFloating(GDT_CInt32) );
         ensure_equals( GDALDataTypeIsFloating(GDT_CFloat32), TRUE );
         ensure_equals( GDALDataTypeIsFloating(GDT_CFloat64), TRUE );
     }
 
     // Test GDALDataTypeIsComplex()
     template<> template<> void object::test<15>()
     {
         ensure( !GDALDataTypeIsComplex(GDT_Unknown) );
         ensure( !GDALDataTypeIsComplex(GDT_Byte) );
         ensure( !GDALDataTypeIsComplex(GDT_UInt16) );
         ensure( !GDALDataTypeIsComplex(GDT_Int16) );
         ensure( !GDALDataTypeIsComplex(GDT_UInt32) );
         ensure( !GDALDataTypeIsComplex(GDT_Int32) );
         ensure( !GDALDataTypeIsComplex(GDT_Float32) );
         ensure( !GDALDataTypeIsComplex(GDT_Float64) );
         ensure_equals( GDALDataTypeIsComplex(GDT_CInt16), TRUE );
         ensure_equals( GDALDataTypeIsComplex(GDT_CInt32), TRUE );
         ensure_equals( GDALDataTypeIsComplex(GDT_CFloat32), TRUE );
         ensure_equals( GDALDataTypeIsComplex(GDT_CFloat64), TRUE );
     }
 
+    // Test GDALDataTypeIsConversionLossy()
+    template<> template<> void object::test<16>()
+    {
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_Byte) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_UInt16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_Int16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_UInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_Int32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_Float32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_Float64) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_CInt16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_CInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Byte, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_Byte) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_UInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_Int16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_UInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_Int32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_Float32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_Float64) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_CInt16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_CInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt16, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int16, GDT_Byte) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int16, GDT_UInt16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int16, GDT_Int16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int16, GDT_UInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int16, GDT_Int32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int16, GDT_Float32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int16, GDT_Float64) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int16, GDT_CInt16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int16, GDT_CInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int16, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int16, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_Byte) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_UInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_Int16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_UInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_Int32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_Float32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_Float64) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_CInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_CInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_UInt32, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int32, GDT_Byte) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int32, GDT_UInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int32, GDT_Int16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int32, GDT_UInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int32, GDT_Int32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int32, GDT_Float32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int32, GDT_Float64) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int32, GDT_CInt16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int32, GDT_CInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Int32, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Int32, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float32, GDT_Byte) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float32, GDT_UInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float32, GDT_Int16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float32, GDT_UInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float32, GDT_Int32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Float32, GDT_Float32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Float32, GDT_Float64) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float32, GDT_CInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float32, GDT_CInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Float32, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Float32, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float64, GDT_Byte) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float64, GDT_UInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float64, GDT_Int16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float64, GDT_UInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float64, GDT_Int32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float64, GDT_Float32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Float64, GDT_Float64) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float64, GDT_CInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float64, GDT_CInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_Float64, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_Float64, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_Byte) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_UInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_Int16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_UInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_Int32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_Float32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_Float64) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_CInt16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_CInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_CInt16, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_Byte) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_UInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_Int16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_UInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_Int32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_Float32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_Float64) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_CInt16) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_CInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_CInt32, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_Byte) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_UInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_Int16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_UInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_Int32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_Float32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_Float64) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_CInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_CInt32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_CFloat32, GDT_CFloat64) );
+
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_Byte) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_UInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_Int16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_UInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_Int32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_Float32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_Float64) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_CInt16) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_CInt32) );
+        ensure( GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_CFloat32) );
+        ensure( !GDALDataTypeIsConversionLossy(GDT_CFloat64, GDT_CFloat64) );
+    }
+
 } // namespace tut
diff --git a/autotest/gcore/vrt_read.py b/autotest/gcore/vrt_read.py
index 0e3933e034..756154ea6b 100755
--- a/autotest/gcore/vrt_read.py
+++ b/autotest/gcore/vrt_read.py
@@ -33,6 +33,7 @@
 import os
 import sys
 import shutil
+import struct
 
 sys.path.append( '../pymod' )
 
@@ -107,32 +108,31 @@ def vrt_read_2():
 def vrt_read_3():
 
     driver_tif = gdal.GetDriverByName("GTIFF")
 
     output_dst = driver_tif.Create( 'tmp/test_mosaic1.tif', 100, 100, 3, gdal.GDT_Byte)
     output_dst.GetRasterBand(1).Fill(255)
     output_dst = None
 
     output_dst = driver_tif.Create( 'tmp/test_mosaic2.tif', 100, 100, 3, gdal.GDT_Byte)
     output_dst.GetRasterBand(1).Fill(127)
     output_dst = None
 
     ds = gdal.Open('data/test_mosaic.vrt')
     # A simple Checksum() cannot detect if the fix works or not as
     # Checksum() reads line per line, and we must use IRasterIO() on multi-line request
     data = ds.GetRasterBand(1).ReadRaster(90,0,20,100)
-    import struct
     got = struct.unpack('B' * 20*100, data)
     for i in range(100):
         if got[i*20 + 9 ] != 255:
             gdaltest.post_reason('at line %d, did not find 255' % i)
             return 'fail'
     ds = None
 
     driver_tif.Delete('tmp/test_mosaic1.tif')
     driver_tif.Delete('tmp/test_mosaic2.tif')
 
     return 'success'
 
 
 ###############################################################################
 # Test complex source with complex data (#3977)
@@ -1173,32 +1173,31 @@ def vrt_read_25():
 def vrt_read_26():
 
     vrt_ds = gdal.Open("""<VRTDataset rasterXSize="22" rasterYSize="22">
   <VRTRasterBand dataType="Byte" band="1">
     <SimpleSource>
       <SourceFilename relativeToVRT="0">data/byte.tif</SourceFilename>
       <SourceBand>1</SourceBand>
       <SourceProperties RasterXSize="20" RasterYSize="20" DataType="Byte" BlockXSize="20" BlockYSize="20" />
       <SrcRect xOff="0" yOff="0" xSize="20" ySize="20" />
       <DstRect xOff="0" yOff="0" xSize="22" ySize="22" />
     </SimpleSource>
   </VRTRasterBand>
 </VRTDataset>""")
 
-    import struct
     full_data = vrt_ds.GetRasterBand(1).ReadRaster(0,0,22,22)
     full_data = struct.unpack('B' * 22 * 22, full_data)
 
     partial_data = vrt_ds.GetRasterBand(1).ReadRaster(1,1,1,1)
     partial_data = struct.unpack('B' * 1 * 1, partial_data)
 
     if partial_data[0] != full_data[22 + 1]:
         gdaltest.post_reason('fail')
         print(full_data)
         print(partial_data[0])
         print(full_data[22 + 1])
         return 'fail'
 
     return 'success'
 
 ###############################################################################
 # Test fix for https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1553
@@ -1304,25 +1303,61 @@ def vrt_read_29():
 def vrt_read_30():
 
     ds = gdal.Open("""<VRTDataset rasterXSize="2" rasterYSize="2">
   <VRTRasterBand dataType="Byte" band="1">
   </VRTRasterBand>
   <VRTRasterBand dataType="Byte" band="2">
   </VRTRasterBand>
   <VRTRasterBand dataType="Byte" band="3">
   </VRTRasterBand>
 </VRTDataset>""")
 
     data = ds.ReadRaster(0,0,2,2,2,2, buf_pixel_space = 3, buf_line_space = 2 * 3, buf_band_space = 1)
-    import struct
     got = struct.unpack('B' * 2*2*3, data)
     for i in range(2*2*3):
         if got[i] != 0:
             print(got)
             return 'fail'
     ds = None
 
     return 'success'
 
+###############################################################################
+# Check that we take into account intermediate data type demotion
+
+def vrt_read_31():
+
+    gdal.FileFromMemBuffer('/vsimem/in.asc',
+"""ncols        2
+nrows        2
+xllcorner    0
+yllcorner    0
+dx           1
+dy           1
+-255         1
+254          256""")
+
+    ds = gdal.Translate('', '/vsimem/in.asc', outputType = gdal.GDT_Byte, format = 'VRT')
+
+    data = ds.GetRasterBand(1).ReadRaster(0,0,2,2, buf_type = gdal.GDT_Float32)
+    got = struct.unpack('f' * 2*2, data)
+    if got != (0, 1, 254, 255):
+        gdaltest.post_reason('fail')
+        print(got)
+        return 'fail'
+
+    data = ds.ReadRaster(0,0,2,2, buf_type = gdal.GDT_Float32)
+    got = struct.unpack('f' * 2*2, data)
+    if got != (0, 1, 254, 255):
+        gdaltest.post_reason('fail')
+        print(got)
+        return 'fail'
+
+    ds = None
+
+    gdal.Unlink('/vsimem/in.asc')
+
+    return 'success'
+
 for item in init_list:
     ut = gdaltest.GDALTest( 'VRT', item[0], item[1], item[2] )
     if ut is None:
@@ -1360,6 +1395,7 @@ gdaltest_list.append( vrt_read_27 )
 gdaltest_list.append( vrt_read_28 )
 gdaltest_list.append( vrt_read_29 )
 gdaltest_list.append( vrt_read_30 )
+gdaltest_list.append( vrt_read_31 )
 
 if __name__ == '__main__':
 
diff --git a/gdal/frmts/postgisraster/postgisrasterrasterband.cpp b/gdal/frmts/postgisraster/postgisrasterrasterband.cpp
index 271cee120c..f77e784c8e 100644
--- a/gdal/frmts/postgisraster/postgisrasterrasterband.cpp
+++ b/gdal/frmts/postgisraster/postgisrasterrasterband.cpp
@@ -320,435 +320,436 @@ static int SortTilesByPKID(const void* a, const void* b)
 CPLErr PostGISRasterRasterBand::IRasterIO(GDALRWFlag eRWFlag, int nXOff,
     int nYOff, int nXSize, int nYSize, void * pData, int nBufXSize,
     int nBufYSize, GDALDataType eBufType,
     GSpacing nPixelSpace, GSpacing nLineSpace, GDALRasterIOExtraArg* psExtraArg)
 {
     /**
      * TODO: Write support not implemented yet
      **/
     if (eRWFlag == GF_Write) {
         ReportError(CE_Failure, CPLE_NotSupported,
             "Writing through PostGIS Raster band not supported yet");
 
         return CE_Failure;
     }
 
     /*******************************************************************
      * Do we have overviews that would be appropriate to satisfy this
      * request?
      ******************************************************************/
     if( (nBufXSize < nXSize || nBufYSize < nYSize) &&
         GetOverviewCount() > 0 )
     {
         if(OverviewRasterIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,
             pData, nBufXSize, nBufYSize, eBufType, nPixelSpace,
             nLineSpace, psExtraArg) == CE_None)
 
         return CE_None;
     }
 
     PostGISRasterDataset * poRDS = (PostGISRasterDataset *)poDS;
 
     int bSameWindowAsOtherBand =
         (nXOff == poRDS->nXOffPrev &&
          nYOff == poRDS->nYOffPrev &&
          nXSize == poRDS->nXSizePrev &&
          nYSize == poRDS->nYSizePrev);
     poRDS->nXOffPrev = nXOff;
     poRDS->nYOffPrev = nYOff;
     poRDS->nXSizePrev = nXSize;
     poRDS->nYSizePrev = nYSize;
 
     /* Logic to determine if bands are read in order 1, 2, ... N */
     /* If so, then use multi-band caching, otherwise do just single band caching */
     if( poRDS->bAssumeMultiBandReadPattern )
     {
         if( nBand != poRDS->nNextExpectedBand )
         {
             CPLDebug("PostGIS_Raster",
                     "Disabling multi-band caching since band access pattern does not match");
             poRDS->bAssumeMultiBandReadPattern = false;
             poRDS->nNextExpectedBand = 1;
         }
         else
         {
             poRDS->nNextExpectedBand ++;
             if( poRDS->nNextExpectedBand > poRDS->GetRasterCount() )
                 poRDS->nNextExpectedBand = 1;
         }
     }
     else
     {
         if( nBand == poRDS->nNextExpectedBand )
         {
             poRDS->nNextExpectedBand ++;
             if( poRDS->nNextExpectedBand > poRDS->GetRasterCount() )
             {
                 CPLDebug("PostGIS_Raster", "Re-enabling multi-band caching");
                 poRDS->bAssumeMultiBandReadPattern = true;
                 poRDS->nNextExpectedBand = 1;
             }
         }
     }
 
 #ifdef DEBUG_VERBOSE
     CPLDebug("PostGIS_Raster",
             "PostGISRasterRasterBand::IRasterIO: "
             "nBand = %d, nXOff = %d, nYOff = %d, nXSize = %d, nYSize = %d, nBufXSize = %d, nBufYSize = %d",
              nBand, nXOff, nYOff, nXSize,  nYSize, nBufXSize, nBufYSize);
 #endif
 
 #ifdef notdef
     /*******************************************************************
      * Optimization: We just have one tile. So, we can read it with
      * IReadBlock
      *
      * TODO: Review it. It's not working (see comment in
      * PostGISRasterDataset::ConstructOneDatasetFromTiles)
      ******************************************************************/
 
     if (poRDS->nTiles == 1) {
 
         return GDALRasterBand::IRasterIO(eRWFlag, nXOff, nYOff, nXSize,
             nYSize, pData, nBufXSize, nBufYSize, eBufType, nPixelSpace,
             nLineSpace, psExtraArg);
     }
 #endif
 
     /*******************************************************************
      * Several tiles: we first look in all our sources caches. Missing
      * blocks are queried
      ******************************************************************/
     double adfProjWin[8];
     int nFeatureCount = 0;
     CPLRectObj sAoi;
 
     poRDS->PolygonFromCoords(nXOff, nYOff, nXOff + nXSize, nYOff + nYSize, adfProjWin);
     // (p[6], p[7]) is the minimum (x, y), and (p[2], p[3]) the max
     sAoi.minx = adfProjWin[6];
     sAoi.maxx = adfProjWin[2];
     if( adfProjWin[7] < adfProjWin[3] )
     {
         sAoi.miny = adfProjWin[7];
         sAoi.maxy = adfProjWin[3];
     }
     else
     {
         sAoi.maxy = adfProjWin[7];
         sAoi.miny = adfProjWin[3];
     }
 
 #ifdef DEBUG_VERBOSE
     CPLDebug("PostGIS_Raster",
             "PostGISRasterRasterBand::IRasterIO: "
             "Intersection box: (%f, %f) - (%f, %f)", sAoi.minx,
             sAoi.miny, sAoi.maxx, sAoi.maxy);
 #endif
 
     if (poRDS->hQuadTree == nullptr)
     {
         ReportError(CE_Failure, CPLE_AppDefined,
             "Could not read metadata index.");
         return CE_Failure;
     }
 
     NullBuffer(pData, nBufXSize, nBufYSize, eBufType, static_cast<int>(nPixelSpace), static_cast<int>(nLineSpace));
 
     if( poRDS->bBuildQuadTreeDynamically && !bSameWindowAsOtherBand )
     {
         if( !(poRDS->LoadSources(nXOff, nYOff, nXSize, nYSize, nBand)) )
             return CE_Failure;
     }
 
     // Matching sources, to avoid a dumb for loop over the sources
     PostGISRasterTileDataset ** papsMatchingTiles =
         (PostGISRasterTileDataset **)
             CPLQuadTreeSearch(poRDS->hQuadTree, &sAoi, &nFeatureCount);
 
     // No blocks found. This is not an error (the raster may have holes)
     if (nFeatureCount == 0) {
         CPLFree(papsMatchingTiles);
 
         return CE_None;
     }
 
     int i;
 
     /**
      * We need to store the max, min coords for the missing tiles in
      * any place. This is as good as any other
      **/
     sAoi.minx = 0.0;
     sAoi.miny = 0.0;
     sAoi.maxx = 0.0;
     sAoi.maxy = 0.0;
 
     GIntBig nMemoryRequiredForTiles = 0;
     CPLString osIDsToFetch;
     int nTilesToFetch = 0;
     int nBandDataTypeSize = GDALGetDataTypeSize(eDataType) / 8;
 
     // Loop just over the intersecting sources
     for(i = 0; i < nFeatureCount; i++) {
         PostGISRasterTileDataset *poTile = papsMatchingTiles[i];
         PostGISRasterTileRasterBand* poTileBand =
             (PostGISRasterTileRasterBand *)poTile->GetRasterBand(nBand);
 
         nMemoryRequiredForTiles += poTileBand->GetXSize() * poTileBand->GetYSize() *
             nBandDataTypeSize;
 
         // Missing tile: we'll need to query for it
         if (!poTileBand->IsCached()) {
 
             // If we have a PKID, add the tile PKID to the list
             if (poTile->pszPKID != nullptr)
             {
                 if( !osIDsToFetch.empty() )
                     osIDsToFetch += ",";
                 osIDsToFetch += "'";
                 osIDsToFetch += poTile->pszPKID;
                 osIDsToFetch += "'";
             }
 
             double dfTileMinX, dfTileMinY, dfTileMaxX, dfTileMaxY;
             poTile->GetExtent(&dfTileMinX, &dfTileMinY,
                               &dfTileMaxX, &dfTileMaxY);
 
             /**
              * We keep the general max and min values of all the missing
              * tiles, to raise a query that intersect just that area.
              *
              * TODO: In case of just a few tiles and very separated,
              * this strategy is clearly suboptimal. We'll get our
              * missing tiles, but with a lot of other not needed tiles.
              *
              * A possible optimization will be to simply rely on the
              * I/O method of the source (must be implemented), in case
              * we have minus than a reasonable amount of tiles missing.
              * Another criteria to decide would be how separated the
              * tiles are. Two queries for just two adjacent tiles is
              * also a dumb strategy.
              **/
             if( nTilesToFetch == 0 )
             {
                 sAoi.minx = dfTileMinX;
                 sAoi.miny = dfTileMinY;
                 sAoi.maxx = dfTileMaxX;
                 sAoi.maxy = dfTileMaxY;
             }
             else
             {
                 if (dfTileMinX < sAoi.minx)
                     sAoi.minx = dfTileMinX;
 
                 if (dfTileMinY < sAoi.miny)
                     sAoi.miny = dfTileMinY;
 
                 if (dfTileMaxX > sAoi.maxx)
                     sAoi.maxx = dfTileMaxX;
 
                 if (dfTileMaxY > sAoi.maxy)
                     sAoi.maxy = dfTileMaxY;
             }
 
             nTilesToFetch ++;
         }
     }
 
     /* Determine caching strategy */
     int bAllBandCaching = FALSE;
     if (nTilesToFetch > 0)
     {
         GIntBig nCacheMax = (GIntBig) GDALGetCacheMax64();
         if( nMemoryRequiredForTiles > nCacheMax )
         {
             CPLDebug("PostGIS_Raster",
                     "For best performance, the block cache should be able to store " CPL_FRMT_GIB
                     " bytes for the tiles of the requested window, "
                     "but it is only " CPL_FRMT_GIB " byte large",
                     nMemoryRequiredForTiles, nCacheMax );
             nTilesToFetch = 0;
         }
 
         if( poRDS->GetRasterCount() > 1 && poRDS->bAssumeMultiBandReadPattern )
         {
             GIntBig nMemoryRequiredForTilesAllBands =
                 nMemoryRequiredForTiles * poRDS->GetRasterCount();
             if( nMemoryRequiredForTilesAllBands <= nCacheMax )
             {
                 bAllBandCaching = TRUE;
             }
             else
             {
                 CPLDebug("PostGIS_Raster", "Caching only this band, but not all bands. "
                          "Cache should be " CPL_FRMT_GIB " byte large for that",
                          nMemoryRequiredForTilesAllBands);
             }
         }
     }
 
     // Raise a query for missing tiles and cache them
     if (nTilesToFetch > 0) {
 
         /**
          * There are several options here, to raise the query.
          * - Get all the tiles which PKID is in a list of missing
          *   PKIDs.
          * - Get all the tiles that intersect a polygon constructed
          *   based on the (min - max) values calculated before.
          * - Get all the tiles with upper left pixel included in the
          *   range (min - max) calculated before.
          *
          * The first option is the most efficient one when a PKID exists.
          * After that, the second one is the most efficient one when a
          * spatial index exists.
          * The third one is the only one available when neither a PKID or spatial
          * index exist.
          **/
         CPLString osCommand;
 
         CPLString osRasterToFetch;
         if (bAllBandCaching)
             osRasterToFetch = pszColumn;
         else
             osRasterToFetch.Printf("ST_Band(%s, %d)", pszColumn, nBand);
 
         int bHasWhere = FALSE;
         if (!osIDsToFetch.empty() && (poRDS->bIsFastPK || !(poRDS->HasSpatialIndex())) ) {
             osCommand.Printf("SELECT %s, "
                 "ST_Metadata(%s), %s FROM %s.%s",
                 osRasterToFetch.c_str(), pszColumn,
                 poRDS->GetPrimaryKeyRef(), pszSchema, pszTable);
             if( nTilesToFetch < poRDS->m_nTiles || poRDS->bBuildQuadTreeDynamically )
             {
                 bHasWhere = TRUE;
                 osCommand += " WHERE ";
                 osCommand += poRDS->pszPrimaryKeyName;
                 osCommand += " IN (";
                 osCommand += osIDsToFetch;
                 osCommand += ")";
             }
         }
 
         else {
             bHasWhere = TRUE;
             osCommand.Printf("SELECT %s, ST_Metadata(%s), %s FROM %s.%s WHERE ",
                              osRasterToFetch.c_str(), pszColumn,
                              (poRDS->GetPrimaryKeyRef()) ? poRDS->GetPrimaryKeyRef() : "'foo'",
                              pszSchema, pszTable);
             if( poRDS->HasSpatialIndex() )
             {
                 osCommand += CPLSPrintf("%s && "
                         "ST_GeomFromText('POLYGON((%.18f %.18f,%.18f %.18f,%.18f %.18f,%.18f %.18f,%.18f %.18f))')",
                         pszColumn,
                         adfProjWin[0], adfProjWin[1],
                         adfProjWin[2], adfProjWin[3],
                         adfProjWin[4], adfProjWin[5],
                         adfProjWin[6], adfProjWin[7],
                         adfProjWin[0], adfProjWin[1]);
             }
             else
             {
                 #define EPS 1e-5
                 osCommand += CPLSPrintf("ST_UpperLeftX(%s)"
                     " BETWEEN %f AND %f AND ST_UpperLeftY(%s) BETWEEN "
                     "%f AND %f", pszColumn, sAoi.minx-EPS, sAoi.maxx+EPS,
                     pszColumn, sAoi.miny-EPS, sAoi.maxy+EPS);
             }
         }
 
         if( poRDS->pszWhere != nullptr )
         {
             if( bHasWhere )
                 osCommand += " AND (";
             else
                 osCommand += " WHERE (";
             osCommand += poRDS->pszWhere;
             osCommand += ")";
         }
 
         PGresult * poResult = PQexec(poRDS->poConn, osCommand.c_str());
 
 #ifdef DEBUG_QUERY
         CPLDebug("PostGIS_Raster",
             "PostGISRasterRasterBand::IRasterIO(): Query = \"%s\" --> number of rows = %d",
             osCommand.c_str(), poResult ? PQntuples(poResult) : 0 );
 #endif
 
         if (poResult == nullptr ||
             PQresultStatus(poResult) != PGRES_TUPLES_OK ||
             PQntuples(poResult) < 0) {
 
             if (poResult)
                 PQclear(poResult);
 
             CPLError(CE_Failure, CPLE_AppDefined,
                 "PostGISRasterRasterBand::IRasterIO(): %s",
                 PQerrorMessage(poRDS->poConn));
 
             // Free the object that holds pointers to matching tiles
             CPLFree(papsMatchingTiles);
             return CE_Failure;
         }
 
         /**
          * No data. Return the buffer filled with nodata values
          **/
         else if (PQntuples(poResult) == 0) {
             PQclear(poResult);
 
             // Free the object that holds pointers to matching tiles
             CPLFree(papsMatchingTiles);
             return CE_None;
         }
 
         /**
          * Ok, we loop over the results
          **/
         int nTuples = PQntuples(poResult);
         for(i = 0; i < nTuples; i++)
         {
             const char* pszMetadata = PQgetvalue(poResult, i, 1);
             const char* pszRaster = PQgetvalue(poResult, i, 0);
             const char *pszPKID = (poRDS->GetPrimaryKeyRef() != nullptr) ?  PQgetvalue(poResult, i, 2) : nullptr;
             poRDS->CacheTile(pszMetadata, pszRaster, pszPKID, nBand, bAllBandCaching);
         } // All tiles have been added to cache
 
         PQclear(poResult);
     } // End missing tiles
 
 /* -------------------------------------------------------------------- */
 /*      Overlay each source in turn over top this.                      */
 /* -------------------------------------------------------------------- */
 
     CPLErr eErr = CE_None;
     /* Sort tiles by ascending PKID, so that the draw order is deterministic. */
     if( poRDS->GetPrimaryKeyRef() != nullptr )
     {
         qsort(papsMatchingTiles, nFeatureCount, sizeof(PostGISRasterTileDataset*),
               SortTilesByPKID);
     }
 
     for(i = 0; i < nFeatureCount && eErr == CE_None; i++)
     {
         PostGISRasterTileDataset *poTile = papsMatchingTiles[i];
         PostGISRasterTileRasterBand* poTileBand =
             (PostGISRasterTileRasterBand *)poTile->GetRasterBand(nBand);
         eErr =
-            poTileBand->poSource->RasterIO( nXOff, nYOff, nXSize, nYSize,
+            poTileBand->poSource->RasterIO( eDataType,
+                                            nXOff, nYOff, nXSize, nYSize,
                                             pData, nBufXSize, nBufYSize,
                                             eBufType, nPixelSpace, nLineSpace, nullptr);
     }
 
     // Free the object that holds pointers to matching tiles
     CPLFree(papsMatchingTiles);
 
     return eErr;
 }
 
 /**
  * \brief Set the no data value for this band.
  * Parameters:
  *  - double: The nodata value
  * Returns:
  *  - CE_None.
  */
diff --git a/gdal/frmts/vrt/vrtdataset.cpp b/gdal/frmts/vrt/vrtdataset.cpp
index 79dceaa270..746c4c5174 100644
--- a/gdal/frmts/vrt/vrtdataset.cpp
+++ b/gdal/frmts/vrt/vrtdataset.cpp
@@ -1474,151 +1474,152 @@ CPLErr VRTDataset::AdviseRead( int nXOff, int nYOff, int nXSize, int nYSize,
 CPLErr VRTDataset::IRasterIO( GDALRWFlag eRWFlag,
                               int nXOff, int nYOff, int nXSize, int nYSize,
                               void * pData, int nBufXSize, int nBufYSize,
                               GDALDataType eBufType,
                               int nBandCount, int *panBandMap,
                               GSpacing nPixelSpace, GSpacing nLineSpace,
                               GSpacing nBandSpace,
                               GDALRasterIOExtraArg* psExtraArg )
 {
     bool bLocalCompatibleForDatasetIO = CPL_TO_BOOL(CheckCompatibleForDatasetIO());
     if( bLocalCompatibleForDatasetIO && eRWFlag == GF_Read &&
         (nBufXSize < nXSize || nBufYSize < nYSize) )
     {
         int bTried = FALSE;
         const CPLErr eErr = TryOverviewRasterIO( eRWFlag,
                                                  nXOff, nYOff, nXSize, nYSize,
                                                  pData, nBufXSize, nBufYSize,
                                                  eBufType,
                                                  nBandCount, panBandMap,
                                                  nPixelSpace, nLineSpace,
                                                  nBandSpace,
                                                  psExtraArg,
                                                  &bTried );
         if( bTried )
             return eErr;
 
         for(int iBand = 0; iBand < nBands; iBand++)
         {
             VRTSourcedRasterBand* poBand
                 = reinterpret_cast<VRTSourcedRasterBand *>( papoBands[iBand] );
 
             // If there are overviews, let VRTSourcedRasterBand::IRasterIO()
             // do the job.
             if( poBand->GetOverviewCount() != 0 )
             {
                 bLocalCompatibleForDatasetIO = false;
                 break;
             }
         }
     }
 
     // If resampling with non-nearest neighbour, we need to be careful
     // if the VRT band exposes a nodata value, but the sources do not have it
     if( bLocalCompatibleForDatasetIO && eRWFlag == GF_Read &&
         (nXSize != nBufXSize || nYSize != nBufYSize) &&
         psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )
     {
         for( int iBandIndex=0; iBandIndex<nBandCount; iBandIndex++ )
         {
             VRTSourcedRasterBand* poBand =
                 reinterpret_cast<VRTSourcedRasterBand*>(
                     GetRasterBand(panBandMap[iBandIndex]) );
             int bHasNoData = FALSE;
             const double dfNoDataValue = poBand->GetNoDataValue(&bHasNoData);
             if( bHasNoData )
             {
                 for( int i = 0; i < poBand->nSources; i++ )
                 {
                     VRTSimpleSource* poSource
                         = reinterpret_cast<VRTSimpleSource *>(
                             poBand->papoSources[i] );
                     int bSrcHasNoData = FALSE;
                     const double dfSrcNoData
                         = poSource->GetBand()->GetNoDataValue(&bSrcHasNoData);
                     if( !bSrcHasNoData || dfSrcNoData != dfNoDataValue )
                     {
                         bLocalCompatibleForDatasetIO = false;
                         break;
                     }
                 }
                 if( !bLocalCompatibleForDatasetIO )
                     break;
             }
         }
     }
 
     if( bLocalCompatibleForDatasetIO && eRWFlag == GF_Read )
     {
         for(int iBandIndex=0; iBandIndex<nBandCount; iBandIndex++)
         {
             VRTSourcedRasterBand* poBand
                 = reinterpret_cast<VRTSourcedRasterBand *>(
                     GetRasterBand( panBandMap[iBandIndex] ) );
 
             /* Dirty little trick to initialize the buffer without doing */
             /* any real I/O */
             const int nSavedSources = poBand->nSources;
             poBand->nSources = 0;
 
             GByte *pabyBandData
                 = reinterpret_cast<GByte *>( pData ) + iBandIndex * nBandSpace;
 
             poBand->IRasterIO(GF_Read, nXOff, nYOff, nXSize, nYSize,
                                 pabyBandData, nBufXSize, nBufYSize,
                                 eBufType,
                                 nPixelSpace, nLineSpace, psExtraArg);
 
             poBand->nSources = nSavedSources;
         }
 
         CPLErr eErr = CE_None;
         GDALProgressFunc  pfnProgressGlobal = psExtraArg->pfnProgress;
         void *pProgressDataGlobal = psExtraArg->pProgressData;
 
         // Use the last band, because when sources reference a GDALProxyDataset,
         // they don't necessary instantiate all underlying rasterbands.
         VRTSourcedRasterBand* poBand = reinterpret_cast<VRTSourcedRasterBand *>(
             papoBands[nBands - 1] );
         for( int iSource = 0;
              eErr == CE_None && iSource < poBand->nSources;
              iSource++ )
         {
             psExtraArg->pfnProgress = GDALScaledProgress;
             psExtraArg->pProgressData =
                 GDALCreateScaledProgress(
                     1.0 * iSource / poBand->nSources,
                     1.0 * (iSource + 1) / poBand->nSources,
                     pfnProgressGlobal,
                     pProgressDataGlobal );
 
             VRTSimpleSource* poSource = reinterpret_cast<VRTSimpleSource *>(
                 poBand->papoSources[iSource] );
 
-            eErr = poSource->DatasetRasterIO( nXOff, nYOff, nXSize, nYSize,
+            eErr = poSource->DatasetRasterIO( poBand->GetRasterDataType(),
+                                              nXOff, nYOff, nXSize, nYSize,
                                               pData, nBufXSize, nBufYSize,
                                               eBufType,
                                               nBandCount, panBandMap,
                                               nPixelSpace, nLineSpace,
                                               nBandSpace,
                                               psExtraArg );
 
             GDALDestroyScaledProgress( psExtraArg->pProgressData );
         }
 
         psExtraArg->pfnProgress = pfnProgressGlobal;
         psExtraArg->pProgressData = pProgressDataGlobal;
 
         return eErr;
     }
 
     return GDALDataset::IRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,
                                    pData, nBufXSize, nBufYSize,
                                    eBufType,
                                    nBandCount, panBandMap,
                                    nPixelSpace, nLineSpace, nBandSpace,
                                    psExtraArg );
 }
 
 /************************************************************************/
 /*                  UnsetPreservedRelativeFilenames()                   */
 /************************************************************************/
diff --git a/gdal/frmts/vrt/vrtdataset.h b/gdal/frmts/vrt/vrtdataset.h
index 142c15d94c..33a3c8a21c 100644
--- a/gdal/frmts/vrt/vrtdataset.h
+++ b/gdal/frmts/vrt/vrtdataset.h
@@ -85,36 +85,37 @@ class CPL_DLL VRTSource
 {
 public:
     virtual ~VRTSource();
 
-    virtual CPLErr  RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+    virtual CPLErr  RasterIO( GDALDataType eBandDataType,
+                              int nXOff, int nYOff, int nXSize, int nYSize,
                               void *pData, int nBufXSize, int nBufYSize,
                               GDALDataType eBufType,
                               GSpacing nPixelSpace, GSpacing nLineSpace,
                               GDALRasterIOExtraArg* psExtraArg ) = 0;
 
     virtual double GetMinimum( int nXSize, int nYSize, int *pbSuccess ) = 0;
     virtual double GetMaximum( int nXSize, int nYSize, int *pbSuccess ) = 0;
     virtual CPLErr ComputeRasterMinMax( int nXSize, int nYSize, int bApproxOK,
                                         double* adfMinMax ) = 0;
     virtual CPLErr ComputeStatistics( int nXSize, int nYSize,
                                       int bApproxOK,
                                       double *pdfMin, double *pdfMax,
                                       double *pdfMean, double *pdfStdDev,
                                       GDALProgressFunc pfnProgress,
                                       void *pProgressData ) = 0;
     virtual CPLErr  GetHistogram( int nXSize, int nYSize,
                                   double dfMin, double dfMax,
                                   int nBuckets, GUIntBig * panHistogram,
                                   int bIncludeOutOfRange, int bApproxOK,
                                   GDALProgressFunc pfnProgress,
                                   void *pProgressData ) = 0;
 
     virtual CPLErr  XMLInit( CPLXMLNode *psTree, const char *, void* ) = 0;
     virtual CPLXMLNode *SerializeToXML( const char *pszVRTPath ) = 0;
 
     virtual void   GetFileList(char*** ppapszFileList, int *pnSize,
                                int *pnMaxSize, CPLHashSet* hSetFiles);
 
     virtual int    IsSimpleSource() { return FALSE; }
     virtual CPLErr FlushCache() { return CE_None; }
 };
@@ -818,77 +819,79 @@ protected:
 public:
             VRTSimpleSource();
             VRTSimpleSource( const VRTSimpleSource* poSrcSource,
                              double dfXDstRatio, double dfYDstRatio );
     virtual ~VRTSimpleSource();
 
     virtual CPLErr  XMLInit( CPLXMLNode *psTree, const char *, void* ) override;
     virtual CPLXMLNode *SerializeToXML( const char *pszVRTPath ) override;
 
     void           SetSrcBand( GDALRasterBand * );
     void           SetSrcMaskBand( GDALRasterBand * );
     void           SetSrcWindow( double, double, double, double );
     void           SetDstWindow( double, double, double, double );
     void           SetNoDataValue( double dfNoDataValue );
     const CPLString& GetResampling() const { return m_osResampling; }
     void           SetResampling( const char* pszResampling );
 
     int            GetSrcDstWindow( int, int, int, int, int, int,
                                     double *pdfReqXOff, double *pdfReqYOff,
                                     double *pdfReqXSize, double *pdfReqYSize,
                                     int *, int *, int *, int *,
                                     int *, int *, int *, int * );
 
-    virtual CPLErr  RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+    virtual CPLErr  RasterIO( GDALDataType eBandDataType,
+                              int nXOff, int nYOff, int nXSize, int nYSize,
                               void *pData, int nBufXSize, int nBufYSize,
                               GDALDataType eBufType,
                               GSpacing nPixelSpace, GSpacing nLineSpace,
                               GDALRasterIOExtraArg* psExtraArg ) override;
 
     virtual double GetMinimum( int nXSize, int nYSize, int *pbSuccess ) override;
     virtual double GetMaximum( int nXSize, int nYSize, int *pbSuccess ) override;
     virtual CPLErr ComputeRasterMinMax( int nXSize, int nYSize, int bApproxOK,
                                         double* adfMinMax ) override;
     virtual CPLErr ComputeStatistics( int nXSize, int nYSize,
                                       int bApproxOK,
                                       double *pdfMin, double *pdfMax,
                                       double *pdfMean, double *pdfStdDev,
                                       GDALProgressFunc pfnProgress,
                                       void *pProgressData ) override;
     virtual CPLErr  GetHistogram( int nXSize, int nYSize,
                                   double dfMin, double dfMax,
                                   int nBuckets, GUIntBig * panHistogram,
                                   int bIncludeOutOfRange, int bApproxOK,
                                   GDALProgressFunc pfnProgress,
                                   void *pProgressData ) override;
 
     void            DstToSrc( double dfX, double dfY,
                               double &dfXOut, double &dfYOut );
     void            SrcToDst( double dfX, double dfY,
                               double &dfXOut, double &dfYOut );
 
     virtual void   GetFileList( char*** ppapszFileList, int *pnSize,
                                 int *pnMaxSize, CPLHashSet* hSetFiles ) override;
 
     virtual int    IsSimpleSource() override { return TRUE; }
     virtual const char* GetType() { return "SimpleSource"; }
     virtual CPLErr FlushCache() override;
 
     GDALRasterBand* GetBand();
     int             IsSameExceptBandNumber( VRTSimpleSource* poOtherSource );
     CPLErr          DatasetRasterIO(
+                               GDALDataType eBandDataType,
                                int nXOff, int nYOff, int nXSize, int nYSize,
                                void * pData, int nBufXSize, int nBufYSize,
                                GDALDataType eBufType,
                                int nBandCount, int *panBandMap,
                                GSpacing nPixelSpace, GSpacing nLineSpace,
                                GSpacing nBandSpace,
                                GDALRasterIOExtraArg* psExtraArg );
 
     void             UnsetPreservedRelativeFilenames();
 
     void             SetMaxValue( int nVal ) { m_nMaxValue = nVal; }
 };
 
 /************************************************************************/
 /*                          VRTAveragedSource                           */
 /************************************************************************/
@@ -897,33 +900,34 @@ class VRTAveragedSource : public VRTSimpleSource
 {
 public:
                     VRTAveragedSource();
-    virtual CPLErr  RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+    virtual CPLErr  RasterIO( GDALDataType eBandDataType,
+                              int nXOff, int nYOff, int nXSize, int nYSize,
                               void *pData, int nBufXSize, int nBufYSize,
                               GDALDataType eBufType,
                               GSpacing nPixelSpace, GSpacing nLineSpace,
                               GDALRasterIOExtraArg* psExtraArg ) override;
 
     virtual double GetMinimum( int nXSize, int nYSize, int *pbSuccess ) override;
     virtual double GetMaximum( int nXSize, int nYSize, int *pbSuccess ) override;
     virtual CPLErr ComputeRasterMinMax( int nXSize, int nYSize, int bApproxOK,
                                         double* adfMinMax ) override;
     virtual CPLErr ComputeStatistics( int nXSize, int nYSize,
                                       int bApproxOK,
                                       double *pdfMin, double *pdfMax,
                                       double *pdfMean, double *pdfStdDev,
                                       GDALProgressFunc pfnProgress,
                                       void *pProgressData ) override;
     virtual CPLErr  GetHistogram( int nXSize, int nYSize,
                                   double dfMin, double dfMax,
                                   int nBuckets, GUIntBig * panHistogram,
                                   int bIncludeOutOfRange, int bApproxOK,
                                   GDALProgressFunc pfnProgress,
                                   void *pProgressData ) override;
 
     virtual CPLXMLNode *SerializeToXML( const char *pszVRTPath ) override;
     virtual const char* GetType() override { return "AveragedSource"; }
 };
 
 /************************************************************************/
 /*                           VRTComplexSource                           */
 /************************************************************************/
@@ -964,51 +968,52 @@ protected:
 public:
                    VRTComplexSource();
                    VRTComplexSource(const VRTComplexSource* poSrcSource,
                                     double dfXDstRatio, double dfYDstRatio);
     virtual        ~VRTComplexSource();
 
-    virtual CPLErr RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+    virtual CPLErr RasterIO( GDALDataType eBandDataType,
+                             int nXOff, int nYOff, int nXSize, int nYSize,
                              void *pData, int nBufXSize, int nBufYSize,
                              GDALDataType eBufType,
                              GSpacing nPixelSpace, GSpacing nLineSpace,
                              GDALRasterIOExtraArg* psExtraArg ) override;
 
     virtual double GetMinimum( int nXSize, int nYSize, int *pbSuccess ) override;
     virtual double GetMaximum( int nXSize, int nYSize, int *pbSuccess ) override;
     virtual CPLErr ComputeRasterMinMax( int nXSize, int nYSize, int bApproxOK,
                                         double* adfMinMax ) override;
     virtual CPLErr ComputeStatistics( int nXSize, int nYSize,
                                       int bApproxOK,
                                       double *pdfMin, double *pdfMax,
                                       double *pdfMean, double *pdfStdDev,
                                       GDALProgressFunc pfnProgress,
                                       void *pProgressData ) override;
     virtual CPLErr  GetHistogram( int nXSize, int nYSize,
                                   double dfMin, double dfMax,
                                   int nBuckets, GUIntBig * panHistogram,
                                   int bIncludeOutOfRange, int bApproxOK,
                                   GDALProgressFunc pfnProgress,
                                   void *pProgressData ) override;
 
     virtual CPLXMLNode *SerializeToXML( const char *pszVRTPath ) override;
     virtual CPLErr XMLInit( CPLXMLNode *, const char *, void* ) override;
     virtual const char* GetType() override { return "ComplexSource"; }
 
     double  LookupValue( double dfInput );
 
     void    SetLinearScaling( double dfOffset, double dfScale );
     void    SetPowerScaling( double dfExponent,
                              double dfSrcMin,
                              double dfSrcMax,
                              double dfDstMin,
                              double dfDstMax );
     void    SetColorTableComponent( int nComponent );
 
     double         *m_padfLUTInputs;
     double         *m_padfLUTOutputs;
     int            m_nLUTItemCount;
 };
 
 /************************************************************************/
 /*                           VRTFilteredSource                          */
 /************************************************************************/
@@ -1027,20 +1032,21 @@ protected:
 public:
             VRTFilteredSource();
     virtual ~VRTFilteredSource();
 
     void    SetExtraEdgePixels( int );
     void    SetFilteringDataTypesSupported( int, GDALDataType * );
 
     virtual CPLErr  FilterData( int nXSize, int nYSize, GDALDataType eType,
                                 GByte *pabySrcData, GByte *pabyDstData ) = 0;
 
-    virtual CPLErr  RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+    virtual CPLErr  RasterIO( GDALDataType eBandDataType,
+                              int nXOff, int nYOff, int nXSize, int nYSize,
                               void *pData, int nBufXSize, int nBufYSize,
                               GDALDataType eBufType,
                               GSpacing nPixelSpace, GSpacing nLineSpace,
                               GDALRasterIOExtraArg* psExtraArg ) override;
 };
 
 /************************************************************************/
 /*                       VRTKernelFilteredSource                        */
 /************************************************************************/
@@ -1091,41 +1097,42 @@ class VRTFuncSource : public VRTSource
 {
 public:
             VRTFuncSource();
     virtual ~VRTFuncSource();
 
     virtual CPLErr  XMLInit( CPLXMLNode *, const char *, void* ) override { return CE_Failure; }
     virtual CPLXMLNode *SerializeToXML( const char *pszVRTPath ) override;
 
-    virtual CPLErr  RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+    virtual CPLErr  RasterIO( GDALDataType eBandDataType,
+                              int nXOff, int nYOff, int nXSize, int nYSize,
                               void *pData, int nBufXSize, int nBufYSize,
                               GDALDataType eBufType,
                               GSpacing nPixelSpace, GSpacing nLineSpace,
                               GDALRasterIOExtraArg* psExtraArg ) override;
 
     virtual double GetMinimum( int nXSize, int nYSize, int *pbSuccess ) override;
     virtual double GetMaximum( int nXSize, int nYSize, int *pbSuccess ) override;
     virtual CPLErr ComputeRasterMinMax( int nXSize, int nYSize, int bApproxOK,
                                         double* adfMinMax ) override;
     virtual CPLErr ComputeStatistics( int nXSize, int nYSize,
                                       int bApproxOK,
                                       double *pdfMin, double *pdfMax,
                                       double *pdfMean, double *pdfStdDev,
                                       GDALProgressFunc pfnProgress,
                                       void *pProgressData ) override;
     virtual CPLErr  GetHistogram( int nXSize, int nYSize,
                                   double dfMin, double dfMax,
                                   int nBuckets, GUIntBig * panHistogram,
                                   int bIncludeOutOfRange, int bApproxOK,
                                   GDALProgressFunc pfnProgress,
                                   void *pProgressData ) override;
 
     VRTImageReadFunc    pfnReadFunc;
     void               *pCBData;
     GDALDataType        eType;
 
     float               fNoDataValue;
 };
 
 #endif /* #ifndef DOXYGEN_SKIP */
 
 #endif /* ndef VIRTUALDATASET_H_INCLUDED */
diff --git a/gdal/frmts/vrt/vrtderivedrasterband.cpp b/gdal/frmts/vrt/vrtderivedrasterband.cpp
index 26a92906ab..bb2af5a962 100644
--- a/gdal/frmts/vrt/vrtderivedrasterband.cpp
+++ b/gdal/frmts/vrt/vrtderivedrasterband.cpp
@@ -1470,465 +1470,466 @@ bool VRTDerivedRasterBand::InitializePython()
 /**
  * Read/write a region of image data for this band.
  *
  * Each of the sources for this derived band will be read and passed to
  * the derived band pixel function.  The pixel function is responsible
  * for applying whatever algorithm is necessary to generate this band's
  * pixels from the sources.
  *
  * The sources will be read using the transfer type specified for sources
  * using SetSourceTransferType().  If no transfer type has been set for
  * this derived band, the band's data type will be used as the transfer type.
  *
  * @see gdalrasterband
  *
  * @param eRWFlag Either GF_Read to read a region of data, or GT_Write to
  * write a region of data.
  *
  * @param nXOff The pixel offset to the top left corner of the region
  * of the band to be accessed.  This would be zero to start from the left side.
  *
  * @param nYOff The line offset to the top left corner of the region
  * of the band to be accessed.  This would be zero to start from the top.
  *
  * @param nXSize The width of the region of the band to be accessed in pixels.
  *
  * @param nYSize The height of the region of the band to be accessed in lines.
  *
  * @param pData The buffer into which the data should be read, or from which
  * it should be written.  This buffer must contain at least nBufXSize *
  * nBufYSize words of type eBufType.  It is organized in left to right,
  * top to bottom pixel order.  Spacing is controlled by the nPixelSpace,
  * and nLineSpace parameters.
  *
  * @param nBufXSize The width of the buffer image into which the desired
  * region is to be read, or from which it is to be written.
  *
  * @param nBufYSize The height of the buffer image into which the desired
  * region is to be read, or from which it is to be written.
  *
  * @param eBufType The type of the pixel values in the pData data buffer.  The
  * pixel values will automatically be translated to/from the GDALRasterBand
  * data type as needed.
  *
  * @param nPixelSpace The byte offset from the start of one pixel value in
  * pData to the start of the next pixel value within a scanline.  If defaulted
  * (0) the size of the datatype eBufType is used.
  *
  * @param nLineSpace The byte offset from the start of one scanline in
  * pData to the start of the next.  If defaulted the size of the datatype
  * eBufType * nBufXSize is used.
  *
  * @return CE_Failure if the access fails, otherwise CE_None.
  */
 CPLErr VRTDerivedRasterBand::IRasterIO( GDALRWFlag eRWFlag,
                                         int nXOff, int nYOff, int nXSize,
                                         int nYSize, void * pData, int nBufXSize,
                                         int nBufYSize, GDALDataType eBufType,
                                         GSpacing nPixelSpace,
                                         GSpacing nLineSpace,
                                         GDALRasterIOExtraArg* psExtraArg )
 {
     if( eRWFlag == GF_Write )
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "Writing through VRTSourcedRasterBand is not supported." );
         return CE_Failure;
     }
 
     const int nBufTypeSize = GDALGetDataTypeSizeBytes(eBufType);
     GDALDataType eSrcType = eSourceTransferType;
     if( eSrcType == GDT_Unknown || eSrcType >= GDT_TypeCount ) {
         eSrcType = eBufType;
     }
     const int nSrcTypeSize = GDALGetDataTypeSizeBytes(eSrcType);
 
 /* -------------------------------------------------------------------- */
 /*      Initialize the buffer to some background value. Use the         */
 /*      nodata value if available.                                      */
 /* -------------------------------------------------------------------- */
     if( bSkipBufferInitialization )
     {
         // Do nothing
     }
     else if( nPixelSpace == nBufTypeSize &&
         (!m_bNoDataValueSet || m_dfNoDataValue == 0) ) {
         memset( pData, 0,
                 static_cast<size_t>(nBufXSize * nBufYSize * nPixelSpace) );
     }
     else if( m_bNoDataValueSet )
     {
         double dfWriteValue = 0.0;
         if( m_bNoDataValueSet )
             dfWriteValue = m_dfNoDataValue;
 
         for( int iLine = 0; iLine < nBufYSize; iLine++ )
         {
             GDALCopyWords(
                 &dfWriteValue, GDT_Float64, 0,
                 reinterpret_cast<GByte *>( pData ) + nLineSpace * iLine,
                 eBufType, static_cast<int>(nPixelSpace), nBufXSize );
         }
     }
 
 /* -------------------------------------------------------------------- */
 /*      Do we have overviews that would be appropriate to satisfy       */
 /*      this request?                                                   */
 /* -------------------------------------------------------------------- */
     if( (nBufXSize < nXSize || nBufYSize < nYSize)
         && GetOverviewCount() > 0 )
     {
         if( OverviewRasterIO(
                eRWFlag, nXOff, nYOff, nXSize, nYSize,
                pData, nBufXSize, nBufYSize,
                eBufType, nPixelSpace, nLineSpace, psExtraArg ) == CE_None )
             return CE_None;
     }
 
     /* ---- Get pixel function for band ---- */
     GDALDerivedPixelFunc pfnPixelFunc = nullptr;
 
     if( EQUAL(m_poPrivate->m_osLanguage, "C") )
     {
         pfnPixelFunc = VRTDerivedRasterBand::GetPixelFunction(pszFuncName);
         if( pfnPixelFunc == nullptr )
         {
             CPLError( CE_Failure, CPLE_IllegalArg,
                     "VRTDerivedRasterBand::IRasterIO:"
                     "Derived band pixel function '%s' not registered.",
                     this->pszFuncName) ;
             return CE_Failure;
         }
     }
 
     /* TODO: It would be nice to use a MallocBlock function for each
        individual buffer that would recycle blocks of memory from a
        cache by reassigning blocks that are nearly the same size.
        A corresponding FreeBlock might only truly free if the total size
        of freed blocks gets to be too great of a percentage of the size
        of the allocated blocks. */
 
     // Get buffers for each source.
     const int nBufferRadius = m_poPrivate->m_nBufferRadius;
     if( nBufferRadius > (INT_MAX - nBufXSize) / 2 ||
         nBufferRadius > (INT_MAX - nBufYSize) / 2 )
     {
         return CE_Failure;
     }
     const int nExtBufXSize = nBufXSize + 2 * nBufferRadius;
     const int nExtBufYSize = nBufYSize + 2 * nBufferRadius;
     void **pBuffers
         = reinterpret_cast<void **>( CPLMalloc(sizeof(void *) * nSources) );
     for( int iSource = 0; iSource < nSources; iSource++ ) {
         pBuffers[iSource] =
             VSI_MALLOC3_VERBOSE(nSrcTypeSize, nExtBufXSize, nExtBufYSize);
         if( pBuffers[iSource] == nullptr )
         {
             for (int i = 0; i < iSource; i++) {
                 VSIFree(pBuffers[i]);
             }
             CPLFree(pBuffers);
             return CE_Failure;
         }
 
         /* ------------------------------------------------------------ */
         /* #4045: Initialize the newly allocated buffers before handing */
         /* them off to the sources. These buffers are packed, so we     */
         /* don't need any special line-by-line handling when a nonzero  */
         /* nodata value is set.                                         */
         /* ------------------------------------------------------------ */
         if( !m_bNoDataValueSet || m_dfNoDataValue == 0 )
         {
             memset( pBuffers[iSource], 0, static_cast<size_t>(nSrcTypeSize) *
                     nExtBufXSize * nExtBufYSize );
         }
         else
         {
             GDALCopyWords( &m_dfNoDataValue, GDT_Float64, 0,
                            reinterpret_cast<GByte *>( pBuffers[iSource] ),
                            eSrcType, nSrcTypeSize,
                            nExtBufXSize * nExtBufYSize );
         }
     }
 
     GDALRasterIOExtraArg sExtraArg;
     GDALCopyRasterIOExtraArg(&sExtraArg, psExtraArg);
 
     int nXShiftInBuffer = 0;
     int nYShiftInBuffer = 0;
     int nExtBufXSizeReq = nExtBufXSize;
     int nExtBufYSizeReq = nExtBufYSize;
 
     int nXOffExt = nXOff;
     int nYOffExt = nYOff;
     int nXSizeExt = nXSize;
     int nYSizeExt = nYSize;
 
     if( nBufferRadius )
     {
         double dfXRatio = static_cast<double>(nXSize) / nBufXSize;
         double dfYRatio = static_cast<double>(nYSize) / nBufYSize;
 
         if( !sExtraArg.bFloatingPointWindowValidity )
         {
             sExtraArg.dfXOff = nXOff;
             sExtraArg.dfYOff = nYOff;
             sExtraArg.dfXSize = nXSize;
             sExtraArg.dfYSize = nYSize;
         }
 
         sExtraArg.dfXOff -= dfXRatio * nBufferRadius;
         sExtraArg.dfYOff -= dfYRatio * nBufferRadius;
         sExtraArg.dfXSize += 2 * dfXRatio * nBufferRadius;
         sExtraArg.dfYSize += 2 * dfYRatio * nBufferRadius;
         if( sExtraArg.dfXOff < 0 )
         {
             nXShiftInBuffer = -static_cast<int>(sExtraArg.dfXOff / dfXRatio);
             nExtBufXSizeReq -= nXShiftInBuffer;
             sExtraArg.dfXSize += sExtraArg.dfXOff;
             sExtraArg.dfXOff = 0;
         }
         if( sExtraArg.dfYOff < 0 )
         {
             nYShiftInBuffer = -static_cast<int>(sExtraArg.dfYOff / dfYRatio);
             nExtBufYSizeReq -= nYShiftInBuffer;
             sExtraArg.dfYSize += sExtraArg.dfYOff;
             sExtraArg.dfYOff = 0;
         }
         if( sExtraArg.dfXOff + sExtraArg.dfXSize > nRasterXSize )
         {
             nExtBufXSizeReq -= static_cast<int>((sExtraArg.dfXOff +
                         sExtraArg.dfXSize - nRasterXSize) / dfXRatio);
             sExtraArg.dfXSize = nRasterXSize - sExtraArg.dfXOff;
         }
         if( sExtraArg.dfYOff + sExtraArg.dfYSize > nRasterYSize )
         {
             nExtBufYSizeReq -= static_cast<int>((sExtraArg.dfYOff +
                         sExtraArg.dfYSize - nRasterYSize) / dfYRatio);
             sExtraArg.dfYSize = nRasterYSize - sExtraArg.dfYOff;
         }
 
         nXOffExt = static_cast<int>(sExtraArg.dfXOff);
         nYOffExt = static_cast<int>(sExtraArg.dfYOff);
         nXSizeExt = std::min(static_cast<int>(sExtraArg.dfXSize + 0.5),
                              nRasterXSize - nXOffExt);
         nYSizeExt = std::min(static_cast<int>(sExtraArg.dfYSize + 0.5),
                              nRasterYSize - nYOffExt);
     }
 
     // Load values for sources into packed buffers.
     CPLErr eErr = CE_None;
     for( int iSource = 0; iSource < nSources && eErr == CE_None; iSource++ ) {
         GByte* pabyBuffer = reinterpret_cast<GByte*>(pBuffers[iSource]);
         eErr = reinterpret_cast<VRTSource *>( papoSources[iSource] )->RasterIO(
+            eSrcType,
             nXOffExt, nYOffExt, nXSizeExt, nYSizeExt,
             pabyBuffer + (nYShiftInBuffer * nExtBufXSize +
                                             nXShiftInBuffer) * nSrcTypeSize,
             nExtBufXSizeReq, nExtBufYSizeReq,
             eSrcType,
             nSrcTypeSize,
             nSrcTypeSize * nExtBufXSize,
             &sExtraArg );
 
         // Extend first lines
         for( int iY = 0; iY < nYShiftInBuffer; iY++ )
         {
             memcpy( pabyBuffer + iY * nExtBufXSize * nSrcTypeSize,
                     pabyBuffer + nYShiftInBuffer * nExtBufXSize * nSrcTypeSize,
                     nExtBufXSize * nSrcTypeSize );
         }
         // Extend last lines
         for( int iY = nYShiftInBuffer + nExtBufYSizeReq; iY < nExtBufYSize; iY++ )
         {
             memcpy( pabyBuffer + iY * nExtBufXSize * nSrcTypeSize,
                     pabyBuffer + (nYShiftInBuffer + nExtBufYSizeReq - 1) *
                                                     nExtBufXSize * nSrcTypeSize,
                     nExtBufXSize * nSrcTypeSize );
         }
         // Extend first cols
         if( nXShiftInBuffer )
         {
             for( int iY = 0; iY < nExtBufYSize; iY ++ )
             {
                 for( int iX = 0; iX < nXShiftInBuffer; iX++ )
                 {
                     memcpy( pabyBuffer + (iY * nExtBufXSize + iX) * nSrcTypeSize,
                             pabyBuffer + (iY * nExtBufXSize +
                                                 nXShiftInBuffer) * nSrcTypeSize,
                             nSrcTypeSize );
                 }
             }
         }
         // Extent last cols
         if( nXShiftInBuffer + nExtBufXSizeReq < nExtBufXSize )
         {
             for( int iY = 0; iY < nExtBufYSize; iY ++ )
             {
                 for( int iX = nXShiftInBuffer + nExtBufXSizeReq;
                          iX < nExtBufXSize; iX++ )
                 {
                     memcpy( pabyBuffer + (iY * nExtBufXSize + iX) * nSrcTypeSize,
                             pabyBuffer + (iY * nExtBufXSize + nXShiftInBuffer +
                                             nExtBufXSizeReq - 1) * nSrcTypeSize,
                             nSrcTypeSize );
                 }
             }
         }
     }
 
     // Apply pixel function.
     if( eErr == CE_None && EQUAL(m_poPrivate->m_osLanguage, "Python") )
     {
         eErr = CE_Failure;
 
         // numpy doesn't have native cint16/cint32
         if( eSrcType == GDT_CInt16 || eSrcType == GDT_CInt32 )
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                      "CInt16/CInt32 data type not supported for SourceTransferType");
             goto end;
         }
         if( eDataType == GDT_CInt16 || eDataType == GDT_CInt32 )
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                      "CInt16/CInt32 data type not supported for data type");
             goto end;
         }
 
         if( !InitializePython() )
             goto end;
 
         GByte* pabyTmpBuffer = nullptr;
         // Do we need a temporary buffer or can we use directly the output
         // buffer ?
         if( nBufferRadius != 0 ||
             eDataType != eBufType ||
             nPixelSpace != nBufTypeSize ||
             nLineSpace != static_cast<GSpacing>(nBufTypeSize) * nBufXSize )
         {
             pabyTmpBuffer = reinterpret_cast<GByte*>(VSI_CALLOC_VERBOSE(
                             static_cast<size_t>(nExtBufXSize) * nExtBufYSize,
                             GDALGetDataTypeSizeBytes(eDataType)));
             if( !pabyTmpBuffer )
                 goto end;
         }
 
         {
         const bool bUseExclusiveLock = m_poPrivate->m_bExclusiveLock ||
                     ( m_poPrivate->m_bFirstTime &&
                     m_poPrivate->m_osCode.find("@jit") != std::string::npos);
         m_poPrivate->m_bFirstTime = false;
         VRT_GIL_Holder oHolder(bUseExclusiveLock);
 
         // Prepare target numpy array
         PyObject* poPyDstArray = GDALCreateNumpyArray(
                                     m_poPrivate->m_poGDALCreateNumpyArray,
                                     pabyTmpBuffer ? pabyTmpBuffer : pData,
                                     eDataType,
                                     nExtBufYSize,
                                     nExtBufXSize);
         if( !poPyDstArray )
         {
             VSIFree(pabyTmpBuffer);
             goto end;
         }
 
         // Wrap source buffers as input numpy arrays
         PyObject* pyArgInputArray = PyTuple_New(nSources);
         for( int i = 0; i < nSources; i++ )
         {
             GByte* pabyBuffer = reinterpret_cast<GByte*>(pBuffers[i]);
             PyObject* poPySrcArray = GDALCreateNumpyArray(
                         m_poPrivate->m_poGDALCreateNumpyArray,
                         pabyBuffer,
                         eSrcType,
                         nExtBufYSize,
                         nExtBufXSize);
             CPLAssert(poPySrcArray);
             PyTuple_SetItem(pyArgInputArray, i, poPySrcArray);
         }
 
         // Create arguments
         PyObject* pyArgs = PyTuple_New(10);
         PyTuple_SetItem(pyArgs, 0, pyArgInputArray);
         PyTuple_SetItem(pyArgs, 1, poPyDstArray);
         PyTuple_SetItem(pyArgs, 2, PyInt_FromLong(nXOff));
         PyTuple_SetItem(pyArgs, 3, PyInt_FromLong(nYOff));
         PyTuple_SetItem(pyArgs, 4, PyInt_FromLong(nXSize));
         PyTuple_SetItem(pyArgs, 5, PyInt_FromLong(nYSize));
         PyTuple_SetItem(pyArgs, 6, PyInt_FromLong(nRasterXSize));
         PyTuple_SetItem(pyArgs, 7, PyInt_FromLong(nRasterYSize));
         PyTuple_SetItem(pyArgs, 8, PyInt_FromLong(nBufferRadius));
 
         double adfGeoTransform[6];
         adfGeoTransform[0] = 0;
         adfGeoTransform[1] = 1;
         adfGeoTransform[2] = 0;
         adfGeoTransform[3] = 0;
         adfGeoTransform[4] = 0;
         adfGeoTransform[5] = 1;
         if( GetDataset() )
             GetDataset()->GetGeoTransform(adfGeoTransform);
         PyObject* pyGT = PyTuple_New(6);
         for(int i = 0; i < 6; i++ )
             PyTuple_SetItem(pyGT, i, PyFloat_FromDouble(adfGeoTransform[i]));
         PyTuple_SetItem(pyArgs, 9, pyGT);
 
         // Prepare kwargs
         PyObject* pyKwargs = PyDict_New();
         for( size_t i = 0; i < m_poPrivate->m_oFunctionArgs.size(); ++i )
         {
             const char* pszKey =
                 m_poPrivate->m_oFunctionArgs[i].first.c_str();
             const char* pszValue =
                 m_poPrivate->m_oFunctionArgs[i].second.c_str();
             PyDict_SetItemString(pyKwargs, pszKey,
                 PyString_FromStringAndSize(pszValue, strlen(pszValue)));
         }
 
         // Call user function
         PyObject* pRetValue = PyObject_Call(
                                         m_poPrivate->m_poUserFunction,
                                         pyArgs, pyKwargs);
 
         Py_DecRef(pyArgs);
         Py_DecRef(pyKwargs);
 
         if (PyErr_Occurred())
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                      "%s", GetPyExceptionString().c_str());
         }
         else
         {
             eErr = CE_None;
         }
         if( pRetValue )
             Py_DecRef(pRetValue);
         } // End of GIL section
 
         if( pabyTmpBuffer )
         {
             // Copy numpy destination array to user buffer
             for( int iY = 0; iY < nBufYSize; iY++ )
             {
                 size_t nSrcOffset = (static_cast<size_t>(iY + nBufferRadius) *
                     nExtBufXSize + nBufferRadius) *
                     GDALGetDataTypeSizeBytes(eDataType);
                 GDALCopyWords(pabyTmpBuffer + nSrcOffset,
                               eDataType,
                               GDALGetDataTypeSizeBytes(eDataType),
                               reinterpret_cast<GByte*>(pData) + iY * nLineSpace,
                               eBufType,
                               static_cast<int>(nPixelSpace),
                               nBufXSize);
             }
 
             VSIFree(pabyTmpBuffer);
         }
     }
     else if( eErr == CE_None && pfnPixelFunc != nullptr ) {
         eErr = pfnPixelFunc( reinterpret_cast<void **>( pBuffers ), nSources,
                              pData, nBufXSize, nBufYSize,
                              eSrcType, eBufType, static_cast<int>(nPixelSpace),
                              static_cast<int>(nLineSpace) );
     }
diff --git a/gdal/frmts/vrt/vrtfilters.cpp b/gdal/frmts/vrt/vrtfilters.cpp
index 1a769b21e6..342d166bb7 100644
--- a/gdal/frmts/vrt/vrtfilters.cpp
+++ b/gdal/frmts/vrt/vrtfilters.cpp
@@ -123,271 +123,273 @@ int VRTFilteredSource::IsTypeSupported( GDALDataType eTestType )
 /************************************************************************/
 
 CPLErr
-VRTFilteredSource::RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+VRTFilteredSource::RasterIO( GDALDataType eBandDataType,
+                             int nXOff, int nYOff, int nXSize, int nYSize,
                              void *pData, int nBufXSize, int nBufYSize,
                              GDALDataType eBufType,
                              GSpacing nPixelSpace,
                              GSpacing nLineSpace,
                              GDALRasterIOExtraArg* psExtraArg )
 
 {
 /* -------------------------------------------------------------------- */
 /*      For now we don't support filtered access to non-full            */
 /*      resolution requests. Just collect the data directly without     */
 /*      any operator.                                                   */
 /* -------------------------------------------------------------------- */
     if( nBufXSize != nXSize || nBufYSize != nYSize )
     {
-        return VRTComplexSource::RasterIO( nXOff, nYOff, nXSize, nYSize,
+        return VRTComplexSource::RasterIO( eBandDataType,
+                                           nXOff, nYOff, nXSize, nYSize,
                                            pData, nBufXSize, nBufYSize,
                                            eBufType, nPixelSpace, nLineSpace,
                                            psExtraArg );
     }
 
     // The window we will actually request from the source raster band.
     double dfReqXOff = 0.0;
     double dfReqYOff = 0.0;
     double dfReqXSize = 0.0;
     double dfReqYSize = 0.0;
     int nReqXOff = 0;
     int nReqYOff = 0;
     int nReqXSize = 0;
     int nReqYSize = 0;
 
     // The window we will actual set _within_ the pData buffer.
     int nOutXOff = 0;
     int nOutYOff = 0;
     int nOutXSize = 0;
     int nOutYSize = 0;
 
     if( !GetSrcDstWindow( nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize,
                         &dfReqXOff, &dfReqYOff, &dfReqXSize, &dfReqYSize,
                         &nReqXOff, &nReqYOff, &nReqXSize, &nReqYSize,
                         &nOutXOff, &nOutYOff, &nOutXSize, &nOutYSize ) )
         return CE_None;
 
     pData = reinterpret_cast<GByte *>( pData )
         + nPixelSpace * nOutXOff
         + nLineSpace * nOutYOff;
 
 /* -------------------------------------------------------------------- */
 /*      Determine the data type we want to request.  We try to match    */
 /*      the source or destination request, and if both those fail we    */
 /*      fallback to the first supported type at least as expressive     */
 /*      as the request.                                                 */
 /* -------------------------------------------------------------------- */
     GDALDataType eOperDataType = GDT_Unknown;
 
     if( IsTypeSupported( eBufType ) )
         eOperDataType = eBufType;
 
     if( eOperDataType == GDT_Unknown
         && IsTypeSupported( m_poRasterBand->GetRasterDataType() ) )
         eOperDataType = m_poRasterBand->GetRasterDataType();
 
     if( eOperDataType == GDT_Unknown )
     {
         for( int i = 0; i < m_nSupportedTypesCount; i++ )
         {
             if( GDALDataTypeUnion( m_aeSupportedTypes[i], eBufType )
                 == m_aeSupportedTypes[i] )
             {
                 eOperDataType = m_aeSupportedTypes[i];
             }
         }
     }
 
     if( eOperDataType == GDT_Unknown )
     {
         eOperDataType = m_aeSupportedTypes[0];
 
         for( int i = 1; i < m_nSupportedTypesCount; i++ )
         {
             if( GDALGetDataTypeSize( m_aeSupportedTypes[i] )
                 > GDALGetDataTypeSize( eOperDataType ) )
             {
                 eOperDataType = m_aeSupportedTypes[i];
             }
         }
     }
 
 /* -------------------------------------------------------------------- */
 /*      Allocate the buffer of data into which our imagery will be      */
 /*      read, with the extra edge pixels as well. This will be the      */
 /*      source data fed into the filter.                                */
 /* -------------------------------------------------------------------- */
     const int nExtraXSize = nOutXSize + 2 * m_nExtraEdgePixels;
     const int nExtraYSize = nOutYSize + 2 * m_nExtraEdgePixels;
 
     // FIXME? : risk of multiplication overflow
     GByte *pabyWorkData = static_cast<GByte *>(
         VSI_CALLOC_VERBOSE( nExtraXSize * nExtraYSize,
                    GDALGetDataTypeSize(eOperDataType) / 8 ) );
 
     if( pabyWorkData == nullptr )
     {
         return CE_Failure;
     }
 
     const int nPixelOffset = GDALGetDataTypeSizeBytes( eOperDataType );
     const int nLineOffset = nPixelOffset * nExtraXSize;
 
 /* -------------------------------------------------------------------- */
 /*      Allocate the output buffer in the same dimensions as the work   */
 /*      buffer. This allows the filter process to write edge pixels     */
 /*      if needed for two-pass (separable) filtering.                   */
 /* -------------------------------------------------------------------- */
     GByte *pabyOutData = static_cast<GByte *>(
         VSI_MALLOC3_VERBOSE( nExtraXSize, nExtraYSize, nPixelOffset ) );
     if( pabyOutData == nullptr )
     {
         CPLFree( pabyWorkData );
         return CE_Failure;
     }
 
 /* -------------------------------------------------------------------- */
 /*      Figure out the extended window that we want to load.  Note      */
 /*      that we keep track of the file window as well as the amount     */
 /*      we will need to edge fill past the edge of the source dataset.  */
 /* -------------------------------------------------------------------- */
     int nFileXOff = nReqXOff - m_nExtraEdgePixels;
     int nFileYOff = nReqYOff - m_nExtraEdgePixels;
     int nFileXSize = nExtraXSize;
     int nFileYSize = nExtraYSize;
 
     int nTopFill = 0;
     int nLeftFill = 0;
     int nRightFill = 0;
     int nBottomFill = 0;
 
     if( nFileXOff < 0 )
     {
         nLeftFill = -nFileXOff;
         nFileXOff = 0;
         nFileXSize -= nLeftFill;
     }
 
     if( nFileYOff < 0 )
     {
         nTopFill = -nFileYOff;
         nFileYOff = 0;
         nFileYSize -= nTopFill;
     }
 
     if( nFileXOff + nFileXSize > m_poRasterBand->GetXSize() )
     {
         nRightFill = nFileXOff + nFileXSize - m_poRasterBand->GetXSize();
         nFileXSize -= nRightFill;
     }
 
     if( nFileYOff + nFileYSize > m_poRasterBand->GetYSize() )
     {
         nBottomFill = nFileYOff + nFileYSize - m_poRasterBand->GetYSize();
         nFileYSize -= nBottomFill;
     }
 
 /* -------------------------------------------------------------------- */
 /*      Load the data.                                                  */
 /* -------------------------------------------------------------------- */
     {
         const bool bIsComplex = CPL_TO_BOOL( GDALDataTypeIsComplex(eOperDataType) );
         const CPLErr eErr
             = VRTComplexSource::RasterIOInternal<float>(
                 nFileXOff, nFileYOff, nFileXSize, nFileYSize,
                 pabyWorkData + nLineOffset * nTopFill + nPixelOffset * nLeftFill,
                 nFileXSize, nFileYSize, eOperDataType,
                 nPixelOffset, nLineOffset, psExtraArg,
                 bIsComplex ? GDT_CFloat32 : GDT_Float32 );
 
         if( eErr != CE_None )
         {
             VSIFree( pabyWorkData );
             VSIFree( pabyOutData );
 
             return eErr;
         }
     }
 
 /* -------------------------------------------------------------------- */
 /*      Fill in missing areas.  Note that we replicate the edge         */
 /*      valid values out.  We don't using "mirroring" which might be    */
 /*      more suitable for some times of filters.  We also don't mark    */
 /*      these pixels as "nodata" though perhaps we should.              */
 /* -------------------------------------------------------------------- */
     if( nLeftFill != 0 || nRightFill != 0 )
     {
         for( int i = nTopFill; i < nExtraYSize - nBottomFill; i++ )
         {
             if( nLeftFill != 0 )
                 GDALCopyWords( pabyWorkData + nPixelOffset * nLeftFill
                                + i * nLineOffset, eOperDataType, 0,
                                pabyWorkData + i * nLineOffset, eOperDataType,
                                nPixelOffset, nLeftFill );
 
             if( nRightFill != 0 )
                 GDALCopyWords( pabyWorkData + i * nLineOffset
                                + nPixelOffset * (nExtraXSize - nRightFill - 1),
                                eOperDataType, 0,
                                pabyWorkData + i * nLineOffset
                                + nPixelOffset * (nExtraXSize - nRightFill),
                                eOperDataType, nPixelOffset, nRightFill );
         }
     }
 
     for( int i = 0; i < nTopFill; i++ )
     {
         memcpy( pabyWorkData + i * nLineOffset,
                 pabyWorkData + nTopFill * nLineOffset,
                 nLineOffset );
     }
 
     for( int i = nExtraYSize - nBottomFill; i < nExtraYSize; i++ )
     {
         memcpy( pabyWorkData + i * nLineOffset,
                 pabyWorkData + (nExtraYSize - nBottomFill - 1) * nLineOffset,
                 nLineOffset );
     }
 
 /* -------------------------------------------------------------------- */
 /*      Filter the data.                                                */
 /* -------------------------------------------------------------------- */
     const CPLErr eErr = FilterData( nExtraXSize, nExtraYSize, eOperDataType,
                                     pabyWorkData, pabyOutData );
 
     VSIFree( pabyWorkData );
     if( eErr != CE_None )
     {
         VSIFree( pabyOutData );
 
         return eErr;
     }
 
 /* -------------------------------------------------------------------- */
 /*      Copy from work buffer to target buffer.                         */
 /* -------------------------------------------------------------------- */
     GByte *pabySrcRow =
         pabyOutData + (nLineOffset + nPixelOffset) * m_nExtraEdgePixels;
     GByte *pabyDstRow = reinterpret_cast<GByte *>( pData );
 
     for( int i = 0; i < nOutYSize; i++,
          pabySrcRow += nLineOffset, pabyDstRow += nLineSpace )
     {
         GDALCopyWords( pabySrcRow, eOperDataType, nPixelOffset,
                        pabyDstRow, eBufType, static_cast<int>(nPixelSpace),
                        nOutXSize );
     }
 
     VSIFree( pabyOutData );
 
     return CE_None;
 }
 
 /************************************************************************/
 /* ==================================================================== */
 /*                       VRTKernelFilteredSource                        */
 /* ==================================================================== */
 /************************************************************************/
 
 /************************************************************************/
 /*                      VRTKernelFilteredSource()                       */
 /************************************************************************/
diff --git a/gdal/frmts/vrt/vrtsourcedrasterband.cpp b/gdal/frmts/vrt/vrtsourcedrasterband.cpp
index 45dce67bd0..a2a96ed4e8 100644
--- a/gdal/frmts/vrt/vrtsourcedrasterband.cpp
+++ b/gdal/frmts/vrt/vrtsourcedrasterband.cpp
@@ -133,190 +133,191 @@ VRTSourcedRasterBand::~VRTSourcedRasterBand()
 CPLErr VRTSourcedRasterBand::IRasterIO( GDALRWFlag eRWFlag,
                                         int nXOff, int nYOff,
                                         int nXSize, int nYSize,
                                         void *pData,
                                         int nBufXSize, int nBufYSize,
                                         GDALDataType eBufType,
                                         GSpacing nPixelSpace,
                                         GSpacing nLineSpace,
                                         GDALRasterIOExtraArg *psExtraArg )
 
 {
     if( eRWFlag == GF_Write )
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "Writing through VRTSourcedRasterBand is not supported." );
         return CE_Failure;
     }
 
     // When using GDALProxyPoolDataset for sources, the recursion will not be
     // detected at VRT opening but when doing RasterIO. As the proxy pool will
     // return the already opened dataset, we can just test a member variable.
     // We allow 1, since IRasterIO() can be called from ComputeStatistics(),
     // which itself increments the recursion counter.
     if( m_nRecursionCounter > 1 )
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "VRTSourcedRasterBand::IRasterIO() called "
                   "recursively on the same band. "
                   "It looks like the VRT is referencing itself." );
         return CE_Failure;
     }
 
 /* ==================================================================== */
 /*      Do we have overviews that would be appropriate to satisfy       */
 /*      this request?                                                   */
 /* ==================================================================== */
     if( (nBufXSize < nXSize || nBufYSize < nYSize)
         && GetOverviewCount() > 0 )
     {
         if( OverviewRasterIO(
                eRWFlag, nXOff, nYOff, nXSize, nYSize,
                pData, nBufXSize, nBufYSize,
                eBufType, nPixelSpace, nLineSpace, psExtraArg ) == CE_None )
             return CE_None;
     }
 
     // If resampling with non-nearest neighbour, we need to be careful
     // if the VRT band exposes a nodata value, but the sources do not have it
     if( eRWFlag == GF_Read &&
         (nXSize != nBufXSize || nYSize != nBufYSize) &&
         psExtraArg->eResampleAlg != GRIORA_NearestNeighbour &&
         m_bNoDataValueSet )
     {
         for( int i = 0; i < nSources; i++ )
         {
             bool bFallbackToBase = false;
             if( !papoSources[i]->IsSimpleSource() )
             {
                 bFallbackToBase = true;
             }
             else
             {
                 VRTSimpleSource* const poSource
                     = reinterpret_cast<VRTSimpleSource *>( papoSources[i] );
                 // The window we will actually request from the source raster band.
                 double dfReqXOff = 0.0;
                 double dfReqYOff = 0.0;
                 double dfReqXSize = 0.0;
                 double dfReqYSize = 0.0;
                 int nReqXOff = 0;
                 int nReqYOff = 0;
                 int nReqXSize = 0;
                 int nReqYSize = 0;
 
                 // The window we will actual set _within_ the pData buffer.
                 int nOutXOff = 0;
                 int nOutYOff = 0;
                 int nOutXSize = 0;
                 int nOutYSize = 0;
 
                 if( !poSource->GetSrcDstWindow( nXOff, nYOff, nXSize, nYSize,
                                       nBufXSize, nBufYSize,
                                       &dfReqXOff, &dfReqYOff, &dfReqXSize, &dfReqYSize,
                                       &nReqXOff, &nReqYOff, &nReqXSize, &nReqYSize,
                                       &nOutXOff, &nOutYOff, &nOutXSize, &nOutYSize ) )
                 {
                     continue;
                 }
                 int bSrcHasNoData = FALSE;
                 const double dfSrcNoData =
                     poSource->GetBand()->GetNoDataValue(&bSrcHasNoData);
                 if( !bSrcHasNoData || dfSrcNoData != m_dfNoDataValue )
                     bFallbackToBase = true;
             }
             if( bFallbackToBase )
             {
                 return GDALRasterBand::IRasterIO( eRWFlag,
                                                   nXOff, nYOff, nXSize, nYSize,
                                                   pData, nBufXSize, nBufYSize,
                                                   eBufType,
                                                   nPixelSpace,
                                                   nLineSpace,
                                                   psExtraArg );
             }
         }
     }
 
 /* -------------------------------------------------------------------- */
 /*      Initialize the buffer to some background value. Use the         */
 /*      nodata value if available.                                      */
 /* -------------------------------------------------------------------- */
     if( bSkipBufferInitialization )
     {
         // Do nothing
     }
     else if( nPixelSpace == GDALGetDataTypeSizeBytes(eBufType) &&
          (!m_bNoDataValueSet || m_dfNoDataValue == 0.0) )
     {
         if( nLineSpace == nBufXSize * nPixelSpace )
         {
              memset( pData, 0, static_cast<size_t>(nBufYSize * nLineSpace) );
         }
         else
         {
             for( int iLine = 0; iLine < nBufYSize; iLine++ )
             {
                 memset( reinterpret_cast<GByte *>( pData )
                         + static_cast<GIntBig>(iLine) * nLineSpace,
                         0,
                         static_cast<size_t>(nBufXSize * nPixelSpace) );
             }
         }
     }
     else
     {
         double dfWriteValue = 0.0;
         if( m_bNoDataValueSet )
             dfWriteValue = m_dfNoDataValue;
 
         for( int iLine = 0; iLine < nBufYSize; iLine++ )
         {
             GDALCopyWords( &dfWriteValue, GDT_Float64, 0,
                            reinterpret_cast<GByte *>( pData )
                            + static_cast<GIntBig>( nLineSpace ) * iLine,
                            eBufType, static_cast<int>(nPixelSpace), nBufXSize );
         }
     }
 
     m_nRecursionCounter++;
 
     GDALProgressFunc const pfnProgressGlobal = psExtraArg->pfnProgress;
     void * const pProgressDataGlobal = psExtraArg->pProgressData;
 
 /* -------------------------------------------------------------------- */
 /*      Overlay each source in turn over top this.                      */
 /* -------------------------------------------------------------------- */
     CPLErr eErr = CE_None;
     for( int iSource = 0; eErr == CE_None && iSource < nSources; iSource++ )
     {
         psExtraArg->pfnProgress = GDALScaledProgress;
         psExtraArg->pProgressData =
             GDALCreateScaledProgress( 1.0 * iSource / nSources,
                                       1.0 * (iSource + 1) / nSources,
                                       pfnProgressGlobal,
                                       pProgressDataGlobal );
         if( psExtraArg->pProgressData == nullptr )
             psExtraArg->pfnProgress = nullptr;
 
         eErr =
-            papoSources[iSource]->RasterIO( nXOff, nYOff, nXSize, nYSize,
+            papoSources[iSource]->RasterIO( eDataType,
+                                            nXOff, nYOff, nXSize, nYSize,
                                             pData, nBufXSize, nBufYSize,
                                             eBufType, nPixelSpace, nLineSpace,
                                             psExtraArg);
 
         GDALDestroyScaledProgress( psExtraArg->pProgressData );
     }
 
     psExtraArg->pfnProgress = pfnProgressGlobal;
     psExtraArg->pProgressData = pProgressDataGlobal;
 
     m_nRecursionCounter--;
 
     return eErr;
 }
 
 /************************************************************************/
 /*                         IGetDataCoverageStatus()                     */
 /************************************************************************/
 
 #ifndef HAVE_GEOS
diff --git a/gdal/frmts/vrt/vrtsources.cpp b/gdal/frmts/vrt/vrtsources.cpp
index 48e802e393..2b4f26716f 100644
--- a/gdal/frmts/vrt/vrtsources.cpp
+++ b/gdal/frmts/vrt/vrtsources.cpp
@@ -1190,110 +1190,148 @@ int VRTSimpleSource::NeedMaxValAdjustment() const
 /************************************************************************/
 
 CPLErr
-VRTSimpleSource::RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+VRTSimpleSource::RasterIO( GDALDataType eBandDataType,
+                           int nXOff, int nYOff, int nXSize, int nYSize,
                            void *pData, int nBufXSize, int nBufYSize,
                            GDALDataType eBufType,
                            GSpacing nPixelSpace,
                            GSpacing nLineSpace,
                            GDALRasterIOExtraArg* psExtraArgIn )
 
 {
     GDALRasterIOExtraArg sExtraArg;
     INIT_RASTERIO_EXTRA_ARG(sExtraArg);
     GDALRasterIOExtraArg* psExtraArg = &sExtraArg;
 
     // The window we will actually request from the source raster band.
     double dfReqXOff = 0.0;
     double dfReqYOff = 0.0;
     double dfReqXSize = 0.0;
     double dfReqYSize = 0.0;
     int nReqXOff = 0;
     int nReqYOff = 0;
     int nReqXSize = 0;
     int nReqYSize = 0;
 
     // The window we will actual set _within_ the pData buffer.
     int nOutXOff = 0;
     int nOutYOff = 0;
     int nOutXSize = 0;
     int nOutYSize = 0;
 
     if( !GetSrcDstWindow( nXOff, nYOff, nXSize, nYSize,
                           nBufXSize, nBufYSize,
                           &dfReqXOff, &dfReqYOff, &dfReqXSize, &dfReqYSize,
                           &nReqXOff, &nReqYOff, &nReqXSize, &nReqYSize,
                           &nOutXOff, &nOutYOff, &nOutXSize, &nOutYSize ) )
     {
         return CE_None;
     }
 #if DEBUG_VERBOSE
     CPLDebug(
         "VRT",
         "nXOff=%d, nYOff=%d, nXSize=%d, nYSize=%d, nBufXSize=%d, nBufYSize=%d,\n"
         "dfReqXOff=%g, dfReqYOff=%g, dfReqXSize=%g, dfReqYSize=%g,\n"
         "nReqXOff=%d, nReqYOff=%d, nReqXSize=%d, nReqYSize=%d,\n"
         "nOutXOff=%d, nOutYOff=%d, nOutXSize=%d, nOutYSize=%d",
         nXOff, nYOff, nXSize, nYSize,
         nBufXSize, nBufYSize,
         dfReqXOff, dfReqYOff, dfReqXSize, dfReqYSize,
         nReqXOff, nReqYOff, nReqXSize, nReqYSize,
         nOutXOff, nOutYOff, nOutXSize, nOutYSize );
 #endif
 
 /* -------------------------------------------------------------------- */
 /*      Actually perform the IO request.                                */
 /* -------------------------------------------------------------------- */
     if( !m_osResampling.empty() )
     {
         psExtraArg->eResampleAlg = GDALRasterIOGetResampleAlg(m_osResampling);
     }
     else if( psExtraArgIn != nullptr )
     {
         psExtraArg->eResampleAlg = psExtraArgIn->eResampleAlg;
     }
     psExtraArg->bFloatingPointWindowValidity = TRUE;
     psExtraArg->dfXOff = dfReqXOff;
     psExtraArg->dfYOff = dfReqYOff;
     psExtraArg->dfXSize = dfReqXSize;
     psExtraArg->dfYSize = dfReqYSize;
 
     GByte* pabyOut =
         static_cast<unsigned char *>(pData)
         + nOutXOff * nPixelSpace
         + static_cast<GPtrDiff_t>(nOutYOff) * nLineSpace;
 
-    const CPLErr eErr =
-        m_poRasterBand->RasterIO(
-            GF_Read,
-            nReqXOff, nReqYOff, nReqXSize, nReqYSize,
-            pabyOut,
-            nOutXSize, nOutYSize,
-            eBufType, nPixelSpace, nLineSpace, psExtraArg );
+    CPLErr eErr = CE_Failure;
+
+    if( GDALDataTypeIsConversionLossy(m_poRasterBand->GetRasterDataType(),
+                                      eBandDataType) )
+    {
+        const int nBandDTSize = GDALGetDataTypeSizeBytes(eBandDataType);
+        void* pTemp = VSI_MALLOC3_VERBOSE(nOutXSize, nOutYSize, nBandDTSize);
+        if( pTemp )
+        {
+            eErr =
+                m_poRasterBand->RasterIO(
+                    GF_Read,
+                    nReqXOff, nReqYOff, nReqXSize, nReqYSize,
+                    pTemp,
+                    nOutXSize, nOutYSize,
+                    eBandDataType, 0, 0, psExtraArg );
+            if( eErr == CE_None )
+            {
+                GByte* pabyTemp = reinterpret_cast<GByte*>(pTemp);
+                for( int iY = 0; iY < nOutYSize; iY++ )
+                {
+                    GDALCopyWords(pabyTemp + static_cast<size_t>(iY) *
+                                                    nBandDTSize * nOutXSize,
+                                  eBandDataType, nBandDTSize,
+                                  pabyOut +
+                                    static_cast<size_t>(iY) * nLineSpace,
+                                  eBufType,
+                                  static_cast<int>(nPixelSpace),
+                                  nOutXSize);
+                }
+            }
+            VSIFree(pTemp);
+        }
+    }
+    else
+    {
+        eErr =
+            m_poRasterBand->RasterIO(
+                GF_Read,
+                nReqXOff, nReqYOff, nReqXSize, nReqYSize,
+                pabyOut,
+                nOutXSize, nOutYSize,
+                eBufType, nPixelSpace, nLineSpace, psExtraArg );
+    }
 
     if( NeedMaxValAdjustment() )
     {
         for( int j = 0; j < nOutYSize; j++ )
         {
             for( int i = 0; i < nOutXSize; i++ )
             {
                 int nVal = 0;
                 GDALCopyWords( pabyOut + j * nLineSpace + i * nPixelSpace,
                                eBufType, 0,
                                &nVal, GDT_Int32, 0,
                                1 );
                 if( nVal > m_nMaxValue )
                     nVal = m_nMaxValue;
                 GDALCopyWords( &nVal, GDT_Int32, 0,
                                pabyOut + j * nLineSpace + i * nPixelSpace,
                                eBufType, 0,
                                1);
             }
         }
     }
 
     return eErr;
 }
 
 /************************************************************************/
 /*                             GetMinimum()                             */
 /************************************************************************/
@@ -1519,113 +1557,158 @@ CPLErr VRTSimpleSource::GetHistogram(
 /************************************************************************/
 
 CPLErr VRTSimpleSource::DatasetRasterIO(
+    GDALDataType eBandDataType,
     int nXOff, int nYOff, int nXSize, int nYSize,
     void * pData, int nBufXSize, int nBufYSize,
     GDALDataType eBufType,
     int nBandCount, int *panBandMap,
     GSpacing nPixelSpace, GSpacing nLineSpace,
     GSpacing nBandSpace,
     GDALRasterIOExtraArg* psExtraArgIn )
 {
     if( !EQUAL(GetType(), "SimpleSource") )
     {
         CPLError(CE_Failure, CPLE_NotSupported,
                  "DatasetRasterIO() not implemented for %s", GetType());
         return CE_Failure;
     }
 
     GDALRasterIOExtraArg sExtraArg;
     INIT_RASTERIO_EXTRA_ARG(sExtraArg);
     GDALRasterIOExtraArg* psExtraArg = &sExtraArg;
 
     // The window we will actually request from the source raster band.
     double dfReqXOff = 0.0;
     double dfReqYOff = 0.0;
     double dfReqXSize = 0.0;
     double dfReqYSize = 0.0;
     int nReqXOff = 0;
     int nReqYOff = 0;
     int nReqXSize = 0;
     int nReqYSize = 0;
 
     // The window we will actual set _within_ the pData buffer.
     int nOutXOff = 0;
     int nOutYOff = 0;
     int nOutXSize = 0;
     int nOutYSize = 0;
 
     if( !GetSrcDstWindow( nXOff, nYOff, nXSize, nYSize,
                           nBufXSize, nBufYSize,
                           &dfReqXOff, &dfReqYOff, &dfReqXSize, &dfReqYSize,
                           &nReqXOff, &nReqYOff, &nReqXSize, &nReqYSize,
                           &nOutXOff, &nOutYOff, &nOutXSize, &nOutYSize ) )
     {
         return CE_None;
     }
 
     GDALDataset* poDS = m_poRasterBand->GetDataset();
     if( poDS == nullptr )
         return CE_Failure;
 
     if( !m_osResampling.empty() )
     {
         psExtraArg->eResampleAlg = GDALRasterIOGetResampleAlg(m_osResampling);
     }
     else if( psExtraArgIn != nullptr )
     {
         psExtraArg->eResampleAlg = psExtraArgIn->eResampleAlg;
     }
     psExtraArg->bFloatingPointWindowValidity = TRUE;
     psExtraArg->dfXOff = dfReqXOff;
     psExtraArg->dfYOff = dfReqYOff;
     psExtraArg->dfXSize = dfReqXSize;
     psExtraArg->dfYSize = dfReqYSize;
 
     GByte* pabyOut =
         static_cast<unsigned char *>(pData)
         + nOutXOff * nPixelSpace
         + (GPtrDiff_t)nOutYOff * nLineSpace;
-    const CPLErr eErr = poDS->RasterIO(
-        GF_Read,
-        nReqXOff, nReqYOff, nReqXSize, nReqYSize,
-        pabyOut,
-        nOutXSize, nOutYSize,
-        eBufType, nBandCount, panBandMap,
-        nPixelSpace, nLineSpace, nBandSpace, psExtraArg );
+
+    CPLErr eErr = CE_Failure;
+
+    if( GDALDataTypeIsConversionLossy(m_poRasterBand->GetRasterDataType(),
+                                      eBandDataType) )
+    {
+        const int nBandDTSize = GDALGetDataTypeSizeBytes(eBandDataType);
+        void* pTemp = VSI_MALLOC3_VERBOSE(nOutXSize, nOutYSize,
+                                          nBandDTSize * nBandCount);
+        if( pTemp )
+        {
+            eErr = poDS->RasterIO(
+                GF_Read,
+                nReqXOff, nReqYOff, nReqXSize, nReqYSize,
+                pTemp,
+                nOutXSize, nOutYSize,
+                eBandDataType, nBandCount, panBandMap,
+                0, 0, 0, psExtraArg );
+            if( eErr == CE_None )
+            {
+                GByte* pabyTemp = reinterpret_cast<GByte*>(pTemp);
+                const size_t nSrcBandSpace = static_cast<size_t>(nOutYSize) *
+                                                nOutXSize * nBandDTSize;
+                for( int iBand = 0; iBand < nBandCount; iBand ++ )
+                {
+                    for( int iY = 0; iY < nOutYSize; iY++ )
+                    {
+                        GDALCopyWords(pabyTemp + iBand * nSrcBandSpace +
+                                        static_cast<size_t>(iY) * nBandDTSize * nOutXSize,
+                                    eBandDataType, nBandDTSize,
+                                    pabyOut +
+                                        static_cast<size_t>(iY) * nLineSpace +
+                                        static_cast<size_t>(iBand) * nBandSpace,
+                                    eBufType, static_cast<int>(nPixelSpace),
+                                    nOutXSize);
+                    }
+                }
+            }
+            VSIFree(pTemp);
+        }
+    }
+    else
+    {
+        eErr = poDS->RasterIO(
+            GF_Read,
+            nReqXOff, nReqYOff, nReqXSize, nReqYSize,
+            pabyOut,
+            nOutXSize, nOutYSize,
+            eBufType, nBandCount, panBandMap,
+            nPixelSpace, nLineSpace, nBandSpace, psExtraArg );
+    }
 
     if( NeedMaxValAdjustment() )
     {
         for( int k = 0; k < nBandCount; k++ )
         {
             for( int j = 0; j < nOutYSize; j++ )
             {
                 for( int i = 0; i < nOutXSize; i++ )
                 {
                     int nVal = 0;
                     GDALCopyWords(
                         pabyOut + k * nBandSpace + j * nLineSpace +
                             i * nPixelSpace,
                         eBufType, 0,
                         &nVal, GDT_Int32, 0,
                         1 );
 
                     if( nVal > m_nMaxValue )
                         nVal = m_nMaxValue;
 
                     GDALCopyWords(
                         &nVal, GDT_Int32, 0,
                         pabyOut + k * nBandSpace + j * nLineSpace +
                             i * nPixelSpace,
                         eBufType, 0,
                         1 );
                 }
             }
         }
     }
 
     return eErr;
 }
 
 /************************************************************************/
 /*                          SetResampling()                             */
 /************************************************************************/
@@ -1670,190 +1753,191 @@ CPLXMLNode *VRTAveragedSource::SerializeToXML( const char *pszVRTPath )
 /************************************************************************/
 
 CPLErr
-VRTAveragedSource::RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+VRTAveragedSource::RasterIO( GDALDataType /*eBandDataType*/,
+                             int nXOff, int nYOff, int nXSize, int nYSize,
                              void *pData, int nBufXSize, int nBufYSize,
                              GDALDataType eBufType,
                              GSpacing nPixelSpace,
                              GSpacing nLineSpace,
                              GDALRasterIOExtraArg* psExtraArgIn )
 
 {
     GDALRasterIOExtraArg sExtraArg;
     INIT_RASTERIO_EXTRA_ARG(sExtraArg);
     GDALRasterIOExtraArg* psExtraArg = &sExtraArg;
 
     // The window we will actually request from the source raster band.
     double dfReqXOff = 0.0;
     double dfReqYOff = 0.0;
     double dfReqXSize = 0.0;
     double dfReqYSize = 0.0;
     int nReqXOff = 0;
     int nReqYOff = 0;
     int nReqXSize = 0;
     int nReqYSize = 0;
 
     // The window we will actual set _within_ the pData buffer.
     int nOutXOff = 0;
     int nOutYOff = 0;
     int nOutXSize = 0;
     int nOutYSize = 0;
 
     if( !GetSrcDstWindow( nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize,
                           &dfReqXOff, &dfReqYOff, &dfReqXSize, &dfReqYSize,
                           &nReqXOff, &nReqYOff, &nReqXSize, &nReqYSize,
                           &nOutXOff, &nOutYOff, &nOutXSize, &nOutYSize ) )
         return CE_None;
 
 /* -------------------------------------------------------------------- */
 /*      Allocate a temporary buffer to whole the full resolution        */
 /*      data from the area of interest.                                 */
 /* -------------------------------------------------------------------- */
     float * const pafSrc = static_cast<float *>(
         VSI_MALLOC3_VERBOSE(sizeof(float), nReqXSize, nReqYSize) );
     if( pafSrc == nullptr )
     {
         return CE_Failure;
     }
 
 /* -------------------------------------------------------------------- */
 /*      Load it.                                                        */
 /* -------------------------------------------------------------------- */
     if( !m_osResampling.empty() )
     {
         psExtraArg->eResampleAlg = GDALRasterIOGetResampleAlg(m_osResampling);
     }
     else if( psExtraArgIn != nullptr )
     {
         psExtraArg->eResampleAlg = psExtraArgIn->eResampleAlg;
     }
 
     psExtraArg->bFloatingPointWindowValidity = TRUE;
     psExtraArg->dfXOff = dfReqXOff;
     psExtraArg->dfYOff = dfReqYOff;
     psExtraArg->dfXSize = dfReqXSize;
     psExtraArg->dfYSize = dfReqYSize;
 
     const CPLErr eErr =
         m_poRasterBand->RasterIO( GF_Read,
                                   nReqXOff, nReqYOff, nReqXSize, nReqYSize,
                                   pafSrc, nReqXSize, nReqYSize, GDT_Float32,
                                   0, 0, psExtraArg );
 
     if( eErr != CE_None )
     {
         VSIFree( pafSrc );
         return eErr;
     }
 
 /* -------------------------------------------------------------------- */
 /*      Do the averaging.                                               */
 /* -------------------------------------------------------------------- */
     for( int iBufLine = nOutYOff; iBufLine < nOutYOff + nOutYSize; iBufLine++ )
     {
         const double dfYDst =
             (iBufLine / static_cast<double>(nBufYSize) ) * nYSize + nYOff;
 
         for( int iBufPixel = nOutXOff;
              iBufPixel < nOutXOff + nOutXSize;
              iBufPixel++ )
         {
             double dfXSrcStart, dfXSrcEnd, dfYSrcStart, dfYSrcEnd;
             int    iXSrcStart, iYSrcStart, iXSrcEnd, iYSrcEnd;
 
             const double dfXDst =
                 (iBufPixel / static_cast<double>(nBufXSize)) * nXSize + nXOff;
 
             // Compute the source image rectangle needed for this pixel.
             DstToSrc( dfXDst, dfYDst, dfXSrcStart, dfYSrcStart );
             DstToSrc( dfXDst+1.0, dfYDst+1.0, dfXSrcEnd, dfYSrcEnd );
 
             // Convert to integers, assuming that the center of the source
             // pixel must be in our rect to get included.
             if( dfXSrcEnd >= dfXSrcStart + 1 )
             {
                 iXSrcStart = static_cast<int>(floor(dfXSrcStart+0.5));
                 iXSrcEnd = static_cast<int>(floor(dfXSrcEnd+0.5));
             }
             else
             {
                 /* If the resampling factor is less than 100%, the distance */
                 /* between the source pixel is < 1, so we stick to nearest */
                 /* neighbour */
                 iXSrcStart = static_cast<int>(floor(dfXSrcStart));
                 iXSrcEnd = iXSrcStart + 1;
             }
             if( dfYSrcEnd >= dfYSrcStart + 1 )
             {
                 iYSrcStart = static_cast<int>(floor(dfYSrcStart+0.5));
                 iYSrcEnd = static_cast<int>(floor(dfYSrcEnd+0.5));
             }
             else
             {
                 iYSrcStart = static_cast<int>(floor(dfYSrcStart));
                 iYSrcEnd = iYSrcStart + 1;
             }
 
             // Transform into the coordinate system of the source *buffer*
             iXSrcStart -= nReqXOff;
             iYSrcStart -= nReqYOff;
             iXSrcEnd -= nReqXOff;
             iYSrcEnd -= nReqYOff;
 
             double dfSum = 0.0;
             int nPixelCount = 0;
 
             for( int iY = iYSrcStart; iY < iYSrcEnd; iY++ )
             {
                 if( iY < 0 || iY >= nReqYSize )
                     continue;
 
                 for( int iX = iXSrcStart; iX < iXSrcEnd; iX++ )
                 {
                     if( iX < 0 || iX >= nReqXSize )
                         continue;
 
                     const float fSampledValue = pafSrc[iX + iY * nReqXSize];
                     if( CPLIsNan(fSampledValue) )
                         continue;
 
                     if( m_bNoDataSet &&
                         GDALIsValueInRange<float>(m_dfNoDataValue) &&
                         ARE_REAL_EQUAL(fSampledValue,
                                        static_cast<float>(m_dfNoDataValue)))
                         continue;
 
                     nPixelCount++;
                     dfSum += pafSrc[iX + iY * nReqXSize];
                 }
             }
 
             if( nPixelCount == 0 )
                 continue;
 
             // Compute output value.
             const float dfOutputValue = static_cast<float>(dfSum / nPixelCount);
 
             // Put it in the output buffer.
             GByte *pDstLocation =
                 static_cast<GByte *>(pData)
                 + nPixelSpace * iBufPixel
                 + static_cast<GPtrDiff_t>(nLineSpace) * iBufLine;
 
             if( eBufType == GDT_Byte )
                 *pDstLocation =
                     static_cast<GByte>(
                         std::min(255.0, std::max(0.0, dfOutputValue + 0.5)) );
             else
                 GDALCopyWords( &dfOutputValue, GDT_Float32, 4,
                                pDstLocation, eBufType, 8, 1 );
         }
     }
 
     VSIFree( pafSrc );
 
     return CE_None;
 }
 
 /************************************************************************/
 /*                             GetMinimum()                             */
 /************************************************************************/
@@ -2299,101 +2383,102 @@ void VRTComplexSource::SetColorTableComponent( int nComponent )
 /************************************************************************/
 
 CPLErr
-VRTComplexSource::RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+VRTComplexSource::RasterIO( GDALDataType /*eBandDataType*/,
+                            int nXOff, int nYOff, int nXSize, int nYSize,
                             void *pData, int nBufXSize, int nBufYSize,
                             GDALDataType eBufType,
                             GSpacing nPixelSpace,
                             GSpacing nLineSpace,
                             GDALRasterIOExtraArg* psExtraArgIn )
 
 {
     GDALRasterIOExtraArg sExtraArg;
     INIT_RASTERIO_EXTRA_ARG(sExtraArg);
     GDALRasterIOExtraArg* psExtraArg = &sExtraArg;
 
     // The window we will actually request from the source raster band.
     double dfReqXOff = 0.0;
     double dfReqYOff = 0.0;
     double dfReqXSize = 0.0;
     double dfReqYSize = 0.0;
     int nReqXOff = 0;
     int nReqYOff = 0;
     int nReqXSize = 0;
     int nReqYSize = 0;
 
     // The window we will actual set _within_ the pData buffer.
     int nOutXOff = 0;
     int nOutYOff = 0;
     int nOutXSize = 0;
     int nOutYSize = 0;
 
     if( !GetSrcDstWindow( nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize,
                           &dfReqXOff, &dfReqYOff, &dfReqXSize, &dfReqYSize,
                           &nReqXOff, &nReqYOff, &nReqXSize, &nReqYSize,
                           &nOutXOff, &nOutYOff, &nOutXSize, &nOutYSize ) )
         return CE_None;
 #if DEBUG_VERBOSE
     CPLDebug(
         "VRT",
         "nXOff=%d, nYOff=%d, nXSize=%d, nYSize=%d, nBufXSize=%d, nBufYSize=%d,\n"
         "dfReqXOff=%g, dfReqYOff=%g, dfReqXSize=%g, dfReqYSize=%g,\n"
         "nReqXOff=%d, nReqYOff=%d, nReqXSize=%d, nReqYSize=%d,\n"
         "nOutXOff=%d, nOutYOff=%d, nOutXSize=%d, nOutYSize=%d",
         nXOff, nYOff, nXSize, nYSize,
         nBufXSize, nBufYSize,
         dfReqXOff, dfReqYOff, dfReqXSize, dfReqYSize,
         nReqXOff, nReqYOff, nReqXSize, nReqYSize,
         nOutXOff, nOutYOff, nOutXSize, nOutYSize );
 #endif
 
     if( !m_osResampling.empty() )
     {
         psExtraArg->eResampleAlg = GDALRasterIOGetResampleAlg(m_osResampling);
     }
     else if( psExtraArgIn != nullptr )
     {
         psExtraArg->eResampleAlg = psExtraArgIn->eResampleAlg;
     }
     psExtraArg->bFloatingPointWindowValidity = TRUE;
     psExtraArg->dfXOff = dfReqXOff;
     psExtraArg->dfYOff = dfReqYOff;
     psExtraArg->dfXSize = dfReqXSize;
     psExtraArg->dfYSize = dfReqYSize;
 
     const bool bIsComplex = CPL_TO_BOOL( GDALDataTypeIsComplex(eBufType) );
     CPLErr eErr;
     // For Int32, float32 isn't sufficiently precise as working data type
     if( eBufType == GDT_CInt32 || eBufType == GDT_CFloat64 ||
         eBufType == GDT_Int32 || eBufType == GDT_UInt32 ||
         eBufType == GDT_Float64 )
     {
         eErr = RasterIOInternal<double>(
                 nReqXOff, nReqYOff, nReqXSize, nReqYSize,
                 static_cast<GByte *>(pData) + nPixelSpace * nOutXOff
                     + static_cast<GPtrDiff_t>(nLineSpace) * nOutYOff,
                 nOutXSize, nOutYSize,
                 eBufType,
                 nPixelSpace, nLineSpace, psExtraArg,
                 bIsComplex ? GDT_CFloat64 : GDT_Float64);
     }
     else
     {
         eErr = RasterIOInternal<float>(
                 nReqXOff, nReqYOff, nReqXSize, nReqYSize,
                 static_cast<GByte *>(pData) + nPixelSpace * nOutXOff
                     + static_cast<GPtrDiff_t>(nLineSpace) * nOutYOff,
                 nOutXSize, nOutYSize,
                 eBufType,
                 nPixelSpace, nLineSpace, psExtraArg,
                 bIsComplex ? GDT_CFloat32 : GDT_Float32);
     }
 
     return eErr;
 }
 
 /************************************************************************/
 /*                          RasterIOInternal()                          */
 /************************************************************************/
 
 // nReqXOff, nReqYOff, nReqXSize, nReqYSize are expressed in source band
 // referential.
@@ -2782,40 +2867,41 @@ CPLXMLNode *VRTFuncSource::SerializeToXML( CPL_UNUSED const char * pszVRTPath )
 /************************************************************************/
 
 CPLErr
-VRTFuncSource::RasterIO( int nXOff, int nYOff, int nXSize, int nYSize,
+VRTFuncSource::RasterIO( GDALDataType /*eBandDataType*/,
+                         int nXOff, int nYOff, int nXSize, int nYSize,
                          void *pData, int nBufXSize, int nBufYSize,
                          GDALDataType eBufType,
                          GSpacing nPixelSpace,
                          GSpacing nLineSpace,
                          GDALRasterIOExtraArg* /* psExtraArg */ )
 {
     if( nPixelSpace*8 == GDALGetDataTypeSize( eBufType )
         && nLineSpace == nPixelSpace * nXSize
         && nBufXSize == nXSize && nBufYSize == nYSize
         && eBufType == eType )
     {
         return pfnReadFunc( pCBData,
                             nXOff, nYOff, nXSize, nYSize,
                             pData );
     }
     else
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "VRTFuncSource::RasterIO() - Irregular request." );
         CPLDebug("VRT", "Irregular request: %d,%d  %d,%d, %d,%d %d,%d %d,%d",
                 static_cast<int>(nPixelSpace)*8,
                 GDALGetDataTypeSize(eBufType),
                 static_cast<int>(nLineSpace),
                 static_cast<int>(nPixelSpace) * nXSize,
                 nBufXSize, nXSize,
                 nBufYSize, nYSize,
                 static_cast<int>(eBufType),
                 static_cast<int>(eType) );
 
         return CE_Failure;
     }
 }
 
 /************************************************************************/
 /*                             GetMinimum()                             */
 /************************************************************************/
diff --git a/gdal/gcore/gdal.h b/gdal/gcore/gdal.h
index 8a5ae31a7f..18f68c7b5e 100644
--- a/gdal/gcore/gdal.h
+++ b/gdal/gcore/gdal.h
@@ -88,7 +88,9 @@ GDALDataType CPL_DLL CPL_STDCALL GDALFindDataType( int nBits, int bSigned, int b
 GDALDataType CPL_DLL CPL_STDCALL GDALFindDataTypeForValue( double dValue, int bComplex );
 double CPL_DLL GDALAdjustValueToDataType( GDALDataType eDT, double dfValue, int* pbClamped, int* pbRounded );
 GDALDataType CPL_DLL CPL_STDCALL GDALGetNonComplexDataType( GDALDataType );
+int CPL_DLL CPL_STDCALL GDALDataTypeIsConversionLossy( GDALDataType eTypeFrom,
+                                                       GDALDataType eTypeTo );
 
 /**
 * status of the asynchronous stream
 */
diff --git a/gdal/gcore/gdal_misc.cpp b/gdal/gcore/gdal_misc.cpp
index 12a74e4f47..8b3fa9e93e 100644
--- a/gdal/gcore/gdal_misc.cpp
+++ b/gdal/gcore/gdal_misc.cpp
@@ -278,32 +278,32 @@ GDALDataType CPL_STDCALL GDALFindDataType(
 /**
  * \brief Finds the smallest data type able to support the provided value
  *
  * @param dValue value to support
  * @param bComplex is the value complex
  *
  * @return a best fit GDALDataType for supporting the value
  * @since GDAL 2.3
  */
 GDALDataType CPL_STDCALL GDALFindDataTypeForValue(
     double dValue, int bComplex )
 {
     const bool bFloating = round(dValue) != dValue;
     const bool bSigned = bFloating || dValue < 0;
     const int nBits = GetMinBitsForValue(dValue);
 
     return GDALFindDataType(nBits, bSigned, bFloating, bComplex);
 }
 
 /************************************************************************/
 /*                        GDALGetDataTypeSizeBytes()                    */
 /************************************************************************/
 
 /**
  * \brief Get data type size in <b>bytes</b>.
  *
  * Returns the size of a GDT_* type in bytes.  In contrast,
- * GDALGetDataTypeBits() returns the size in <b>bits</b>.
+ * GDALGetDataTypeSize() returns the size in <b>bits</b>.
  *
  * @param eDataType type, such as GDT_Byte.
  * @return the number of bytes or zero if it is not recognised.
  */
@@ -481,31 +481,89 @@ int CPL_STDCALL GDALDataTypeIsInteger( GDALDataType eDataType )
 int CPL_STDCALL GDALDataTypeIsSigned( GDALDataType eDataType )
 {
     switch( eDataType )
     {
       case GDT_Byte:
       case GDT_UInt16:
       case GDT_UInt32:
         return FALSE;
 
       default:
         return TRUE;
     }
 }
 
+/************************************************************************/
+/*                    GDALDataTypeIsConversionLossy()                   */
+/************************************************************************/
+
+/**
+ * \brief Is conversion from eTypeFrom to eTypeTo potentially lossy
+ *
+ * @param eTypeFrom input datatype
+ * @param eTypeTo output datatype
+ * @return TRUE if conversion from eTypeFrom to eTypeTo potentially lossy.
+ * @since GDAL 2.3
+ */
+
+int CPL_STDCALL GDALDataTypeIsConversionLossy( GDALDataType eTypeFrom,
+                                               GDALDataType eTypeTo )
+{
+    // E.g cfloat32 -> float32
+    if( GDALDataTypeIsComplex(eTypeFrom) && !GDALDataTypeIsComplex(eTypeTo) )
+        return TRUE;
+
+    eTypeFrom = GDALGetNonComplexDataType(eTypeFrom);
+    eTypeTo = GDALGetNonComplexDataType(eTypeTo);
+
+    if( GDALDataTypeIsInteger(eTypeTo) )
+    {
+        // E.g. float32 -> int32 
+        if( GDALDataTypeIsFloating(eTypeFrom) )
+            return TRUE;
+
+        // E.g. Int16 to UInt16
+        const int bIsFromSigned = GDALDataTypeIsSigned(eTypeFrom);
+        const int bIsToSigned = GDALDataTypeIsSigned(eTypeTo);
+        if( bIsFromSigned && !bIsToSigned )
+            return TRUE;
+
+        // E.g UInt32 to UInt16
+        const int nFromSize =  GDALGetDataTypeSize(eTypeFrom);
+        const int nToSize = GDALGetDataTypeSize(eTypeTo);
+        if( nFromSize > nToSize )
+            return TRUE;
+
+        // E.g UInt16 to Int16
+        if( nFromSize == nToSize && !bIsFromSigned && bIsToSigned )
+            return TRUE;
+
+        return FALSE;
+    }
+
+    if( eTypeTo == GDT_Float32 && (eTypeFrom == GDT_Int32 ||
+                                   eTypeFrom == GDT_UInt32 ||
+                                   eTypeFrom == GDT_Float64) )
+    {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
 /************************************************************************/
 /*                        GDALGetDataTypeName()                         */
 /************************************************************************/
 
 /**
  * \brief Get name of data type.
  *
  * Returns a symbolic name for the data type.  This is essentially the
  * the enumerated item name with the GDT_ prefix removed.  So GDT_Byte returns
  * "Byte".  The returned strings are static strings and should not be modified
  * or freed by the application.  These strings are useful for reporting
  * datatypes in debug statements, errors and other user output.
  *
  * @param eDataType type to get name of.
  * @return string corresponding to existing data type
  *         or NULL pointer if invalid type given.
  */
