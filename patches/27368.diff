commit df2af999105cd6c94ec8b533bcca498664b1aa16
Author: DavidKorczynski <david@adalogics.com>
Date:   Mon Feb 22 16:54:03 2021 +0000

    gzip: fix upper-bound decompression calculation. OSS-Fuzz 5072671825723392 (#3101)
    
    Signed-off-by: davkor <david@adalogics.com>

diff --git a/src/flb_gzip.c b/src/flb_gzip.c
index cb5359ed6..c3b1d3393 100644
--- a/src/flb_gzip.c
+++ b/src/flb_gzip.c
@@ -68,109 +68,98 @@ static inline void gzip_header(void *buf)
 int flb_gzip_compress(void *in_data, size_t in_len,
                       void **out_data, size_t *out_len)
 {
     int flush;
     int status;
     int footer_start;
     uint8_t *pb;
     size_t out_size;
     void *out_buf;
     z_stream strm;
     mz_ulong crc;
 
-
-    /*
-     * GZIP relies on an algorithm with worst-case expansion
-     * of 5 bytes per 32KB data. This means we need to create a variable
-     * length output, that depends on the input length.
-     * See RFC 1951 for details.
-     */
-    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;
-
     /*
-     * Max compressed size is equal to sum of:
-     *   10 byte header
-     *   8 byte foot
-     *   max input expansion
-     *   size of input
+     * Calculating the upper bound for a gzip compression is
+     * non-trivial, so we rely on miniz's own calculation
+     * to guarantee memory safety.
      */
-    out_size = 10 + 8 + max_input_expansion + in_len;
+    out_size = compressBound(in_len);
     out_buf = flb_malloc(out_size);
 
     if (!out_buf) {
         flb_errno();
         flb_error("[gzip] could not allocate outgoing buffer");
         return -1;
     }
 
     /* Initialize streaming buffer context */
     memset(&strm, '\0', sizeof(strm));
     strm.zalloc    = Z_NULL;
     strm.zfree     = Z_NULL;
     strm.opaque    = Z_NULL;
     strm.next_in   = in_data;
     strm.avail_in  = in_len;
     strm.total_out = 0;
 
     /* Deflate mode */
     deflateInit2(&strm, Z_DEFAULT_COMPRESSION,
                  Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);
 
     /*
      * Miniz don't support GZip format directly, instead we will:
      *
      * - append manual GZip magic bytes
      * - deflate raw content
      * - append manual CRC32 data
      */
     gzip_header(out_buf);
 
     /* Header offset */
     pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;
 
     flush = Z_NO_FLUSH;
     while (1) {
         strm.next_out  = pb + strm.total_out;
         strm.avail_out = out_size - (pb - (uint8_t *) out_buf);
 
         if (strm.avail_in == 0) {
             flush = Z_FINISH;
         }
 
         status = deflate(&strm, flush);
         if (status == Z_STREAM_END) {
             break;
         }
         else if (status != Z_OK) {
             deflateEnd(&strm);
             return -1;
         }
     }
 
     if (deflateEnd(&strm) != Z_OK) {
         flb_free(out_buf);
         return -1;
     }
     *out_len = strm.total_out;
 
     /* Construct the gzip checksum (CRC32 footer) */
     footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;
     pb = (uint8_t *) out_buf + footer_start;
 
     crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);
     *pb++ = crc & 0xFF;
     *pb++ = (crc >> 8) & 0xFF;
     *pb++ = (crc >> 16) & 0xFF;
     *pb++ = (crc >> 24) & 0xFF;
     *pb++ = in_len & 0xFF;
     *pb++ = (in_len >> 8) & 0xFF;
     *pb++ = (in_len >> 16) & 0xFF;
     *pb++ = (in_len >> 24) & 0xFF;
 
     /* Set the real buffer size for the caller */
     *out_len += FLB_GZIP_HEADER_OFFSET + 8;
     *out_data = out_buf;
 
     return 0;
 }
 
 /* Uncompress (inflate) GZip data */
