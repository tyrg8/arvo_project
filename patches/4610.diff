commit 9866c9649507f177233ca96feefac8b12e36a91f
Author: Varun Khaneja <ca.aawc@yahoo.com>
Date:   Wed Jan 24 16:55:40 2018 -0800

    5.6.1.5: Fixes bugs found through fuzzing

diff --git a/arccmt.cpp b/arccmt.cpp
index 33f2204..ca98b10 100644
--- a/arccmt.cpp
+++ b/arccmt.cpp
@@ -3,126 +3,126 @@ static bool IsAnsiEscComment(const wchar *Data,size_t Size);
 bool Archive::GetComment(Array<wchar> *CmtData)
 {
   if (!MainComment)
     return false;
   SaveFilePos SavePos(*this);
 
 #ifndef SFX_MODULE
   uint CmtLength;
   if (Format==RARFMT14)
   {
     Seek(SFXSize+SIZEOF_MAINHEAD14,SEEK_SET);
     CmtLength=GetByte();
     CmtLength+=(GetByte()<<8);
   }
   else
 #endif
   {
     if (MainHead.CommentInHeader)
     {
       // Old style (RAR 2.9) archive comment embedded into the main 
       // archive header.
       Seek(SFXSize+SIZEOF_MARKHEAD3+SIZEOF_MAINHEAD3,SEEK_SET);
-      if (!ReadHeader())
+      if (!ReadHeader() || GetHeaderType()!=HEAD3_CMT)
         return false;
     }
     else
     {
       // Current (RAR 3.0+) version of archive comment.
       Seek(GetStartPos(),SEEK_SET);
       return SearchSubBlock(SUBHEAD_TYPE_CMT)!=0 && ReadCommentData(CmtData);
     }
 #ifndef SFX_MODULE
     // Old style (RAR 2.9) comment header embedded into the main 
     // archive header.
     if (BrokenHeader)
     {
       uiMsg(UIERROR_CMTBROKEN,FileName);
       return false;
     }
     CmtLength=CommHead.HeadSize-SIZEOF_COMMHEAD;
 #endif
   }
 #ifndef SFX_MODULE
   if (Format==RARFMT14 && MainHead.PackComment || Format!=RARFMT14 && CommHead.Method!=0x30)
   {
     if (Format!=RARFMT14 && (CommHead.UnpVer < 15 || CommHead.UnpVer > VER_UNPACK || CommHead.Method > 0x35))
       return false;
     ComprDataIO DataIO;
     DataIO.SetTestMode(true);
     uint UnpCmtLength;
     if (Format==RARFMT14)
     {
 #ifdef RAR_NOCRYPT
       return false;
 #else
       UnpCmtLength=GetByte();
       UnpCmtLength+=(GetByte()<<8);
       CmtLength-=2;
       DataIO.SetCmt13Encryption();
       CommHead.UnpVer=15;
 #endif
     }
     else
       UnpCmtLength=CommHead.UnpSize;
     DataIO.SetFiles(this,NULL);
     DataIO.EnableShowProgress(false);
     DataIO.SetPackedSizeToRead(CmtLength);
     DataIO.UnpHash.Init(HASH_CRC32,1);
     DataIO.SetNoFileHeader(true); // this->FileHead is not filled yet.
 
     Unpack CmtUnpack(&DataIO);
     CmtUnpack.Init(0x10000,false);
     CmtUnpack.SetDestSize(UnpCmtLength);
     CmtUnpack.DoUnpack(CommHead.UnpVer,false);
 
     if (Format!=RARFMT14 && (DataIO.UnpHash.GetCRC32()&0xffff)!=CommHead.CommCRC)
     {
       uiMsg(UIERROR_CMTBROKEN,FileName);
       return false;
     }
     else
     {
       byte *UnpData;
       size_t UnpDataSize;
       DataIO.GetUnpackedData(&UnpData,&UnpDataSize);
 #ifdef _WIN_ALL
       // If we ever decide to extend it to Android, we'll need to alloc
       // 4x memory for OEM to UTF-8 output here.
       OemToCharBuffA((char *)UnpData,(char *)UnpData,(DWORD)UnpDataSize);
 #endif
       CmtData->Alloc(UnpDataSize+1);
       memset(CmtData->Addr(0),0,CmtData->Size()*sizeof(wchar));
       CharToWide((char *)UnpData,CmtData->Addr(0),CmtData->Size());
       CmtData->Alloc(wcslen(CmtData->Addr(0)));
     }
   }
   else
   {
     if (CmtLength==0)
       return false;
     Array<byte> CmtRaw(CmtLength);
     int ReadSize=Read(&CmtRaw[0],CmtLength);
     if (ReadSize>=0 && (uint)ReadSize<CmtLength) // Comment is shorter than declared.
     {
       CmtLength=ReadSize;
       CmtRaw.Alloc(CmtLength);
     }
 
     if (Format!=RARFMT14 && CommHead.CommCRC!=(~CRC32(0xffffffff,&CmtRaw[0],CmtLength)&0xffff))
     {
       uiMsg(UIERROR_CMTBROKEN,FileName);
       return false;
     }
     CmtData->Alloc(CmtLength+1);
     CmtRaw.Push(0);
 #ifdef _WIN_ALL
     // If we ever decide to extend it to Android, we'll need to alloc
     // 4x memory for OEM to UTF-8 output here.
     OemToCharA((char *)&CmtRaw[0],(char *)&CmtRaw[0]);
 #endif
     CharToWide((char *)&CmtRaw[0],CmtData->Addr(0),CmtData->Size());
     CmtData->Alloc(wcslen(CmtData->Addr(0)));
   }
 #endif
   return CmtData->Size() > 0;
 }
diff --git a/archive.cpp b/archive.cpp
index 401fc34..23372b1 100644
--- a/archive.cpp
+++ b/archive.cpp
@@ -10,50 +10,48 @@
 Archive::Archive(RAROptions *InitCmd)
 {
   Cmd=NULL; // Just in case we'll have an exception in 'new' below.
 
   DummyCmd=(InitCmd==NULL);
   Cmd=DummyCmd ? (new RAROptions):InitCmd;
 
   OpenShared=Cmd->OpenShared;
   Format=RARFMT15;
   Solid=false;
   Volume=false;
   MainComment=false;
   Locked=false;
   Signed=false;
   FirstVolume=false;
   NewNumbering=false;
   SFXSize=0;
   LatestTime.Reset();
   Protected=false;
   Encrypted=false;
   FailedHeaderDecryption=false;
   BrokenHeader=false;
   LastReadBlock=0;
 
   CurBlockPos=0;
   NextBlockPos=0;
 
-  RecoverySize=-1;
-  RecoveryPercent=-1;
 
   memset(&MainHead,0,sizeof(MainHead));
   memset(&CryptHead,0,sizeof(CryptHead));
   memset(&EndArcHead,0,sizeof(EndArcHead));
 
   VolNumber=0;
   VolWrite=0;
   AddingFilesSize=0;
   AddingHeadersSize=0;
   *FirstVolumeName=0;
 
   Splitting=false;
   NewArchive=false;
 
   SilentOpen=false;
 
 #ifdef USE_QOPEN
   ProhibitQOpen=false;
 #endif
 
 }
diff --git a/archive.hpp b/archive.hpp
index 473912f..5b53a68 100644
--- a/archive.hpp
+++ b/archive.hpp
@@ -23,136 +23,134 @@ enum ADDSUBDATA_FLAGS
 class Archive:public File
 {
   private:
     void UpdateLatestTime(FileHeader *CurBlock);
     void ConvertNameCase(wchar *Name);
     void ConvertFileHeader(FileHeader *hd);
     void WriteBlock50(HEADER_TYPE HeaderType,BaseBlock *wb,bool OnlySetSize,bool NonFinalWrite);
     size_t ReadHeader14();
     size_t ReadHeader15();
     size_t ReadHeader50();
     void ProcessExtra50(RawRead *Raw,size_t ExtraSize,BaseBlock *bb);
     void RequestArcPassword();
     void UnexpEndArcMsg();
     void BrokenHeaderMsg();
     void UnkEncVerMsg(const wchar *Name);
     void UnkEncVerMsg();
     bool ReadCommentData(Array<wchar> *CmtData);
 
 #if !defined(RAR_NOCRYPT)
     CryptData HeadersCrypt;
 #endif
     ComprDataIO SubDataIO;
     bool DummyCmd;
     RAROptions *Cmd;
 
-    int64 RecoverySize;
-    int RecoveryPercent;
 
     RarTime LatestTime;
     int LastReadBlock;
     HEADER_TYPE CurHeaderType;
 
     bool SilentOpen;
 #ifdef USE_QOPEN
     QuickOpen QOpen;
     bool ProhibitQOpen;
 #endif
 #ifdef USE_ARCMEM
     ArcMemory ArcMem;
 #endif
   public:
     Archive(RAROptions *InitCmd=NULL);
     ~Archive();
     static RARFORMAT IsSignature(const byte *D,size_t Size);
     bool IsArchive(bool EnableBroken);
     size_t SearchBlock(HEADER_TYPE HeaderType);
     size_t SearchSubBlock(const wchar *Type);
     size_t SearchRR();
     void WriteBlock(HEADER_TYPE HeaderType,BaseBlock *wb=NULL,bool OnlySetSize=false,bool NonFinalWrite=false);
     void SetBlockSize(HEADER_TYPE HeaderType,BaseBlock *wb=NULL) {WriteBlock(HeaderType,wb,true);}
     size_t ReadHeader();
     void CheckArc(bool EnableBroken);
     void CheckOpen(const wchar *Name);
     bool WCheckOpen(const wchar *Name);
     bool GetComment(Array<wchar> *CmtData);
     void ViewComment();
     void SetLatestTime(RarTime *NewTime);
     void SeekToNext();
     bool CheckAccess();
     bool IsArcDir();
     void ConvertAttributes();
     void VolSubtractHeaderSize(size_t SubSize);
     uint FullHeaderSize(size_t Size);
     int64 GetStartPos();
     void AddSubData(byte *SrcData,uint64 DataSize,File *SrcFile,
          const wchar *Name,uint Flags);
     bool ReadSubData(Array<byte> *UnpData,File *DestFile);
     HEADER_TYPE GetHeaderType() {return CurHeaderType;};
     RAROptions* GetRAROptions() {return Cmd;}
     void SetSilentOpen(bool Mode) {SilentOpen=Mode;}
 #if 0
     void GetRecoveryInfo(bool Required,int64 *Size,int *Percent);
 #endif
     bool Open(const wchar *Name,uint Mode=FMF_READ);
     bool Close();
     int Read(void *Data,size_t Size);
     void Seek(int64 Offset,int Method);
     int64 Tell();
     bool IsOpened();
 #ifdef USE_QOPEN
     void QOpenUnload() {QOpen.Unload();}
     void SetProhibitQOpen(bool Mode) {ProhibitQOpen=Mode;}
 #endif
 
     BaseBlock ShortBlock;
     MarkHeader MarkHead;
     MainHeader MainHead;
     CryptHeader CryptHead;
     FileHeader FileHead;
     EndArcHeader EndArcHead;
     SubBlockHeader SubBlockHead;
     FileHeader SubHead;
     CommentHeader CommHead;
     ProtectHeader ProtectHead;
     AVHeader AVHead;
     SignHeader SignHead;
     UnixOwnersHeader UOHead;
     MacFInfoHeader MACHead;
     EAHeader EAHead;
     StreamHeader StreamHead;
 
     int64 CurBlockPos;
     int64 NextBlockPos;
 
     RARFORMAT Format;
     bool Solid;
     bool Volume;
     bool MainComment;
     bool Locked;
     bool Signed;
     bool FirstVolume;
     bool NewNumbering;
     bool Protected;
     bool Encrypted;
     size_t SFXSize;
     bool BrokenHeader;
     bool FailedHeaderDecryption;
 
 #if !defined(RAR_NOCRYPT)
     byte ArcSalt[SIZE_SALT50];
 #endif
 
     bool Splitting;
 
     uint VolNumber;
     int64 VolWrite;
     uint64 AddingFilesSize;
     uint64 AddingHeadersSize;
 
     bool NewArchive;
 
     wchar FirstVolumeName[NM];
 };
 
 
 #endif
diff --git a/arcmem.cpp b/arcmem.cpp
index a849785..e916ec3 100644
--- a/arcmem.cpp
+++ b/arcmem.cpp
@@ -37,17 +37,22 @@ bool ArcMemory::Read(void *Data,size_t Size,size_t &Result)
 bool ArcMemory::Seek(int64 Offset,int Method)
 {
   if (!Loaded)
     return false;
   if (Method==SEEK_SET)
-    SeekPos=Min(Offset,ArcData.Size());
+  {
+    if (Offset<0)
+      SeekPos=0;
+    else
+      SeekPos=Min((uint64)Offset,ArcData.Size());
+  }
   else
     if (Method==SEEK_CUR || Method==SEEK_END)
     {
       if (Method==SEEK_END)
         SeekPos=ArcData.Size();
       SeekPos+=(uint64)Offset;
       if (SeekPos>ArcData.Size())
         SeekPos=Offset<0 ? 0 : ArcData.Size();
     }
   return true;
 }
diff --git a/arcread.cpp b/arcread.cpp
index 6b3de71..7694e01 100644
--- a/arcread.cpp
+++ b/arcread.cpp
@@ -134,437 +134,431 @@ inline int64 SafeAdd(int64 v1,int64 v2,int64 f)
 size_t Archive::ReadHeader15()
 {
   RawRead Raw(this);
 
   bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD3;
 
   if (Decrypt)
   {
 #ifdef RAR_NOCRYPT // For rarext.dll and unrar_nocrypt.dll.
     return 0;
 #else
     RequestArcPassword();
 
     byte Salt[SIZE_SALT30];
     if (Read(Salt,SIZE_SALT30)!=SIZE_SALT30)
     {
       UnexpEndArcMsg();
       return 0;
     }
     HeadersCrypt.SetCryptKeys(false,CRYPT_RAR30,&Cmd->Password,Salt,NULL,0,NULL,NULL);
     Raw.SetCrypt(&HeadersCrypt);
 #endif
   }
 
   Raw.Read(SIZEOF_SHORTBLOCKHEAD);
   if (Raw.Size()==0)
   {
     UnexpEndArcMsg();
     return 0;
   }
 
   ShortBlock.HeadCRC=Raw.Get2();
 
   ShortBlock.Reset();
 
   uint HeaderType=Raw.Get1();
   ShortBlock.Flags=Raw.Get2();
   ShortBlock.SkipIfUnknown=(ShortBlock.Flags & SKIP_IF_UNKNOWN)!=0;
   ShortBlock.HeadSize=Raw.Get2();
 
   ShortBlock.HeaderType=(HEADER_TYPE)HeaderType;
   if (ShortBlock.HeadSize<SIZEOF_SHORTBLOCKHEAD)
   {
     BrokenHeaderMsg();
     return 0;
   }
 
   // For simpler further processing we map header types common
   // for RAR 1.5 and 5.0 formats to RAR 5.0 values. It does not include
   // header types specific for RAR 1.5 - 4.x only.
   switch(ShortBlock.HeaderType)
   {
     case HEAD3_MAIN:    ShortBlock.HeaderType=HEAD_MAIN;     break;
     case HEAD3_FILE:    ShortBlock.HeaderType=HEAD_FILE;     break;
     case HEAD3_SERVICE: ShortBlock.HeaderType=HEAD_SERVICE;  break;
     case HEAD3_ENDARC:  ShortBlock.HeaderType=HEAD_ENDARC;   break;
   }
   CurHeaderType=ShortBlock.HeaderType;
 
   if (ShortBlock.HeaderType==HEAD3_CMT)
   {
     // Old style (up to RAR 2.9) comment header embedded into main
     // or file header. We must not read the entire ShortBlock.HeadSize here
     // to not break the comment processing logic later.
     Raw.Read(SIZEOF_COMMHEAD-SIZEOF_SHORTBLOCKHEAD);
   }
   else
     if (ShortBlock.HeaderType==HEAD_MAIN && (ShortBlock.Flags & MHD_COMMENT)!=0)
     {
       // Old style (up to RAR 2.9) main archive comment embedded into
       // the main archive header found. While we can read the entire 
       // ShortBlock.HeadSize here and remove this part of "if", it would be
       // waste of memory, because we'll read and process this comment data
       // in other function anyway and we do not need them here now.
       Raw.Read(SIZEOF_MAINHEAD3-SIZEOF_SHORTBLOCKHEAD);
     }
     else
       Raw.Read(ShortBlock.HeadSize-SIZEOF_SHORTBLOCKHEAD);
 
   NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize);
 
   switch(ShortBlock.HeaderType)
   {
     case HEAD_MAIN:
       MainHead.Reset();
       *(BaseBlock *)&MainHead=ShortBlock;
       MainHead.HighPosAV=Raw.Get2();
       MainHead.PosAV=Raw.Get4();
 
       Volume=(MainHead.Flags & MHD_VOLUME)!=0;
       Solid=(MainHead.Flags & MHD_SOLID)!=0;
       Locked=(MainHead.Flags & MHD_LOCK)!=0;
       Protected=(MainHead.Flags & MHD_PROTECT)!=0;
       Encrypted=(MainHead.Flags & MHD_PASSWORD)!=0;
       Signed=MainHead.PosAV!=0 || MainHead.HighPosAV!=0;
       MainHead.CommentInHeader=(MainHead.Flags & MHD_COMMENT)!=0;
     
       // Only for encrypted 3.0+ archives. 2.x archives did not have this
       // flag, so for non-encrypted archives, we'll set it later based on
       // file attributes.
       FirstVolume=(MainHead.Flags & MHD_FIRSTVOLUME)!=0;
 
       NewNumbering=(MainHead.Flags & MHD_NEWNUMBERING)!=0;
       break;
     case HEAD_FILE:
     case HEAD_SERVICE:
       {
         bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;
         FileHeader *hd=FileBlock ? &FileHead:&SubHead;
         hd->Reset();
 
         *(BaseBlock *)hd=ShortBlock;
 
         hd->SplitBefore=(hd->Flags & LHD_SPLIT_BEFORE)!=0;
         hd->SplitAfter=(hd->Flags & LHD_SPLIT_AFTER)!=0;
         hd->Encrypted=(hd->Flags & LHD_PASSWORD)!=0;
         hd->SaltSet=(hd->Flags & LHD_SALT)!=0;
         hd->Solid=FileBlock && (hd->Flags & LHD_SOLID)!=0;
         hd->SubBlock=!FileBlock && (hd->Flags & LHD_SOLID)!=0;
         hd->Dir=(hd->Flags & LHD_WINDOWMASK)==LHD_DIRECTORY;
         hd->WinSize=hd->Dir ? 0:0x10000<<((hd->Flags & LHD_WINDOWMASK)>>5);
         hd->CommentInHeader=(hd->Flags & LHD_COMMENT)!=0;
         hd->Version=(hd->Flags & LHD_VERSION)!=0;
         
         hd->DataSize=Raw.Get4();
         uint LowUnpSize=Raw.Get4();
         hd->HostOS=Raw.Get1();
 
         hd->FileHash.Type=HASH_CRC32;
         hd->FileHash.CRC32=Raw.Get4();
 
         uint FileTime=Raw.Get4();
         hd->UnpVer=Raw.Get1();
+
+        // RAR15 did not use the special dictionary size to mark dirs.
+        if (hd->UnpVer<20 && (hd->FileAttr & 0x10)!=0)
+          hd->Dir=true;
+
         hd->Method=Raw.Get1()-0x30;
         size_t NameSize=Raw.Get2();
         hd->FileAttr=Raw.Get4();
 
         hd->CryptMethod=CRYPT_NONE;
         if (hd->Encrypted)
           switch(hd->UnpVer)
           {
             case 13: hd->CryptMethod=CRYPT_RAR13; break;
             case 15: hd->CryptMethod=CRYPT_RAR15; break;
             case 20: 
             case 26: hd->CryptMethod=CRYPT_RAR20; break;
             default: hd->CryptMethod=CRYPT_RAR30; break;
           }
 
         hd->HSType=HSYS_UNKNOWN;
         if (hd->HostOS==HOST_UNIX || hd->HostOS==HOST_BEOS)
           hd->HSType=HSYS_UNIX;
         else
           if (hd->HostOS<HOST_MAX)
             hd->HSType=HSYS_WINDOWS;
 
         hd->RedirType=FSREDIR_NONE;
 
         // RAR 4.x Unix symlink.
         if (hd->HostOS==HOST_UNIX && (hd->FileAttr & 0xF000)==0xA000)
         {
           hd->RedirType=FSREDIR_UNIXSYMLINK;
           *hd->RedirName=0;
         }
 
         hd->Inherited=!FileBlock && (hd->SubFlags & SUBHEAD_FLAGS_INHERITED)!=0;
         
         hd->LargeFile=(hd->Flags & LHD_LARGE)!=0;
 
         uint HighPackSize,HighUnpSize;
         if (hd->LargeFile)
         {
           HighPackSize=Raw.Get4();
           HighUnpSize=Raw.Get4();
           hd->UnknownUnpSize=(LowUnpSize==0xffffffff && HighUnpSize==0xffffffff);
         }
         else 
         {
           HighPackSize=HighUnpSize=0;
           // UnpSize equal to 0xffffffff without LHD_LARGE flag indicates
           // that we do not know the unpacked file size and must unpack it
           // until we find the end of file marker in compressed data.
           hd->UnknownUnpSize=(LowUnpSize==0xffffffff);
         }
         hd->PackSize=INT32TO64(HighPackSize,hd->DataSize);
         hd->UnpSize=INT32TO64(HighUnpSize,LowUnpSize);
         if (hd->UnknownUnpSize)
           hd->UnpSize=INT64NDF;
 
         char FileName[NM*4];
         size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);
         Raw.GetB((byte *)FileName,ReadNameSize);
         FileName[ReadNameSize]=0;
 
         if (FileBlock)
         {
           *hd->FileName=0;
           if ((hd->Flags & LHD_UNICODE)!=0)
           {
             EncodeFileName NameCoder;
             size_t Length=strlen(FileName);
             Length++;
             if (ReadNameSize>Length)
-              NameCoder.Decode(FileName,(byte *)FileName+Length,
+              NameCoder.Decode(FileName,ReadNameSize,(byte *)FileName+Length,
                                ReadNameSize-Length,hd->FileName,
                                ASIZE(hd->FileName));
           }
 
           if (*hd->FileName==0)
             ArcCharToWide(FileName,hd->FileName,ASIZE(hd->FileName),ACTW_OEM);
 
 #ifndef SFX_MODULE
           ConvertNameCase(hd->FileName);
 #endif
           ConvertFileHeader(hd);
         }
         else
         {
           CharToWide(FileName,hd->FileName,ASIZE(hd->FileName));
 
           // Calculate the size of optional data.
           int DataSize=int(hd->HeadSize-NameSize-SIZEOF_FILEHEAD3);
           if ((hd->Flags & LHD_SALT)!=0)
             DataSize-=SIZE_SALT30;
 
           if (DataSize>0)
           {
             // Here we read optional additional fields for subheaders.
             // They are stored after the file name and before salt.
             hd->SubData.Alloc(DataSize);
             Raw.GetB(&hd->SubData[0],DataSize);
-            if (hd->CmpName(SUBHEAD_TYPE_RR))
-            {
-              byte *D=&hd->SubData[8];
-              RecoverySize=D[0]+((uint)D[1]<<8)+((uint)D[2]<<16)+((uint)D[3]<<24);
-              RecoverySize*=512; // Sectors to size.
-              int64 CurPos=Tell();
-              RecoveryPercent=ToPercent(RecoverySize,CurPos);
-              // Round fractional percent exceeding .5 to upper value.
-              if (ToPercent(RecoverySize+CurPos/200,CurPos)>RecoveryPercent)
-                RecoveryPercent++;
-            }
+
           }
 
           if (hd->CmpName(SUBHEAD_TYPE_CMT))
             MainComment=true;
         }
         if ((hd->Flags & LHD_SALT)!=0)
           Raw.GetB(hd->Salt,SIZE_SALT30);
         hd->mtime.SetDos(FileTime);
         if ((hd->Flags & LHD_EXTTIME)!=0)
         {
           ushort Flags=Raw.Get2();
           RarTime *tbl[4];
           tbl[0]=&FileHead.mtime;
           tbl[1]=&FileHead.ctime;
           tbl[2]=&FileHead.atime;
           tbl[3]=NULL; // Archive time is not used now.
           for (int I=0;I<4;I++)
           {
             RarTime *CurTime=tbl[I];
             uint rmode=Flags>>(3-I)*4;
             if ((rmode & 8)==0 || CurTime==NULL)
               continue;
             if (I!=0)
             {
               uint DosTime=Raw.Get4();
               CurTime->SetDos(DosTime);
             }
             RarLocalTime rlt;
             CurTime->GetLocal(&rlt);
             if (rmode & 4)
               rlt.Second++;
             rlt.Reminder=0;
             int count=rmode&3;
             for (int J=0;J<count;J++)
             {
               byte CurByte=Raw.Get1();
               rlt.Reminder|=(((uint)CurByte)<<((J+3-count)*8));
             }
             // Convert from 100ns RAR precision to REMINDER_PRECISION.
             rlt.Reminder*=RarTime::REMINDER_PRECISION/10000000;
             CurTime->SetLocal(&rlt);
           }
         }
         // Set to 0 in case of overflow, so end of ReadHeader cares about it.
         NextBlockPos=SafeAdd(NextBlockPos,hd->PackSize,0);
 
         bool CRCProcessedOnly=hd->CommentInHeader;
         ushort HeaderCRC=Raw.GetCRC15(CRCProcessedOnly);
         if (hd->HeadCRC!=HeaderCRC)
         {
           BrokenHeader=true;
           ErrHandler.SetErrorCode(RARX_WARNING);
 
           // If we have a broken encrypted header, we do not need to display
           // the error message here, because it will be displayed for such
           // headers later in this function. Also such headers are unlikely
           // to have anything sensible in file name field, so it is useless
           // to display the file name.
           if (!Decrypt)
             uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);
         }
       }
       break;
     case HEAD_ENDARC:
       *(BaseBlock *)&EndArcHead=ShortBlock;
       EndArcHead.NextVolume=(EndArcHead.Flags & EARC_NEXT_VOLUME)!=0;
       EndArcHead.DataCRC=(EndArcHead.Flags & EARC_DATACRC)!=0;
       EndArcHead.RevSpace=(EndArcHead.Flags & EARC_REVSPACE)!=0;
       EndArcHead.StoreVolNumber=(EndArcHead.Flags & EARC_VOLNUMBER)!=0;
       if (EndArcHead.DataCRC)
         EndArcHead.ArcDataCRC=Raw.Get4();
       if (EndArcHead.StoreVolNumber)
         VolNumber=EndArcHead.VolNumber=Raw.Get2();
       break;
 #ifndef SFX_MODULE
     case HEAD3_CMT:
       *(BaseBlock *)&CommHead=ShortBlock;
       CommHead.UnpSize=Raw.Get2();
       CommHead.UnpVer=Raw.Get1();
       CommHead.Method=Raw.Get1();
       CommHead.CommCRC=Raw.Get2();
       break;
     case HEAD3_SIGN:
       *(BaseBlock *)&SignHead=ShortBlock;
       SignHead.CreationTime=Raw.Get4();
       SignHead.ArcNameSize=Raw.Get2();
       SignHead.UserNameSize=Raw.Get2();
       break;
     case HEAD3_AV:
       *(BaseBlock *)&AVHead=ShortBlock;
       AVHead.UnpVer=Raw.Get1();
       AVHead.Method=Raw.Get1();
       AVHead.AVVer=Raw.Get1();
       AVHead.AVInfoCRC=Raw.Get4();
       break;
     case HEAD3_PROTECT:
       *(BaseBlock *)&ProtectHead=ShortBlock;
       ProtectHead.DataSize=Raw.Get4();
       ProtectHead.Version=Raw.Get1();
       ProtectHead.RecSectors=Raw.Get2();
       ProtectHead.TotalBlocks=Raw.Get4();
       Raw.GetB(ProtectHead.Mark,8);
       NextBlockPos+=ProtectHead.DataSize;
-      RecoverySize=ProtectHead.RecSectors*512;
       break;
     case HEAD3_OLDSERVICE:
       *(BaseBlock *)&SubBlockHead=ShortBlock;
       SubBlockHead.DataSize=Raw.Get4();
       NextBlockPos+=SubBlockHead.DataSize;
       SubBlockHead.SubType=Raw.Get2();
       SubBlockHead.Level=Raw.Get1();
       switch(SubBlockHead.SubType)
       {
         case UO_HEAD:
           *(SubBlockHeader *)&UOHead=SubBlockHead;
           UOHead.OwnerNameSize=Raw.Get2();
           UOHead.GroupNameSize=Raw.Get2();
           if (UOHead.OwnerNameSize>=ASIZE(UOHead.OwnerName))
             UOHead.OwnerNameSize=ASIZE(UOHead.OwnerName)-1;
           if (UOHead.GroupNameSize>=ASIZE(UOHead.GroupName))
             UOHead.GroupNameSize=ASIZE(UOHead.GroupName)-1;
           Raw.GetB(UOHead.OwnerName,UOHead.OwnerNameSize);
           Raw.GetB(UOHead.GroupName,UOHead.GroupNameSize);
           UOHead.OwnerName[UOHead.OwnerNameSize]=0;
           UOHead.GroupName[UOHead.GroupNameSize]=0;
           break;
         case MAC_HEAD:
           *(SubBlockHeader *)&MACHead=SubBlockHead;
           MACHead.fileType=Raw.Get4();
           MACHead.fileCreator=Raw.Get4();
           break;
         case EA_HEAD:
         case BEEA_HEAD:
         case NTACL_HEAD:
           *(SubBlockHeader *)&EAHead=SubBlockHead;
           EAHead.UnpSize=Raw.Get4();
           EAHead.UnpVer=Raw.Get1();
           EAHead.Method=Raw.Get1();
           EAHead.EACRC=Raw.Get4();
           break;
         case STREAM_HEAD:
           *(SubBlockHeader *)&StreamHead=SubBlockHead;
           StreamHead.UnpSize=Raw.Get4();
           StreamHead.UnpVer=Raw.Get1();
           StreamHead.Method=Raw.Get1();
           StreamHead.StreamCRC=Raw.Get4();
           StreamHead.StreamNameSize=Raw.Get2();
           if (StreamHead.StreamNameSize>=ASIZE(StreamHead.StreamName))
             StreamHead.StreamNameSize=ASIZE(StreamHead.StreamName)-1;
           Raw.GetB(StreamHead.StreamName,StreamHead.StreamNameSize);
           StreamHead.StreamName[StreamHead.StreamNameSize]=0;
           break;
       }
       break;
 #endif
     default:
       if (ShortBlock.Flags & LONG_BLOCK)
         NextBlockPos+=Raw.Get4();
       break;
   }
   
   ushort HeaderCRC=Raw.GetCRC15(false);
 
   // Old AV header does not have header CRC properly set.
   if (ShortBlock.HeadCRC!=HeaderCRC && ShortBlock.HeaderType!=HEAD3_SIGN &&
       ShortBlock.HeaderType!=HEAD3_AV)
   {
     bool Recovered=false;
     if (ShortBlock.HeaderType==HEAD_ENDARC && EndArcHead.RevSpace)
     {
       // Last 7 bytes of recovered volume can contain zeroes, because
       // REV files store its own information (volume number, etc.) here.
       SaveFilePos SavePos(*this);
       int64 Length=Tell();
       Seek(Length-7,SEEK_SET);
       Recovered=true;
       for (int J=0;J<7;J++)
         if (GetByte()!=0)
           Recovered=false;
     }
     if (!Recovered)
     {
       BrokenHeader=true;
       ErrHandler.SetErrorCode(RARX_CRC);
 
       if (Decrypt)
       {
         uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);
         FailedHeaderDecryption=true;
         return 0;
       }
     }
   }
 
   return Raw.Size();
 }
@@ -1184,71 +1178,72 @@ void Archive::ProcessExtra50(RawRead *Raw,size_t ExtraSize,BaseBlock *bb)
 #ifndef SFX_MODULE
 size_t Archive::ReadHeader14()
 {
   RawRead Raw(this);
   if (CurBlockPos<=(int64)SFXSize)
   {
     Raw.Read(SIZEOF_MAINHEAD14);
     MainHead.Reset();
     byte Mark[4];
     Raw.GetB(Mark,4);
     uint HeadSize=Raw.Get2();
     byte Flags=Raw.Get1();
     NextBlockPos=CurBlockPos+HeadSize;
     CurHeaderType=HEAD_MAIN;
 
     Volume=(Flags & MHD_VOLUME)!=0;
     Solid=(Flags & MHD_SOLID)!=0;
     Locked=(Flags & MHD_LOCK)!=0;
     MainHead.CommentInHeader=(Flags & MHD_COMMENT)!=0;
     MainHead.PackComment=(Flags & MHD_PACK_COMMENT)!=0;
   }
   else
   {
     Raw.Read(SIZEOF_FILEHEAD14);
     FileHead.Reset();
 
     FileHead.HeaderType=HEAD_FILE;
     FileHead.DataSize=Raw.Get4();
     FileHead.UnpSize=Raw.Get4();
     FileHead.FileHash.Type=HASH_RAR14;
     FileHead.FileHash.CRC32=Raw.Get2();
     FileHead.HeadSize=Raw.Get2();
     uint FileTime=Raw.Get4();
     FileHead.FileAttr=Raw.Get1();
     FileHead.Flags=Raw.Get1()|LONG_BLOCK;
     FileHead.UnpVer=(Raw.Get1()==2) ? 13 : 10;
     size_t NameSize=Raw.Get1();
     FileHead.Method=Raw.Get1();
 
     FileHead.SplitBefore=(FileHead.Flags & LHD_SPLIT_BEFORE)!=0;
     FileHead.SplitAfter=(FileHead.Flags & LHD_SPLIT_AFTER)!=0;
     FileHead.Encrypted=(FileHead.Flags & LHD_PASSWORD)!=0;
     FileHead.CryptMethod=FileHead.Encrypted ? CRYPT_RAR13:CRYPT_NONE;
 
     FileHead.PackSize=FileHead.DataSize;
     FileHead.WinSize=0x10000;
+    FileHead.Dir=(FileHead.FileAttr & 0x10)!=0;
 
     FileHead.HostOS=HOST_MSDOS;
     FileHead.HSType=HSYS_WINDOWS;
 
     FileHead.mtime.SetDos(FileTime);
 
     Raw.Read(NameSize);
 
     char FileName[NM];
     Raw.GetB((byte *)FileName,Min(NameSize,ASIZE(FileName)));
     FileName[NameSize]=0;
     IntToExt(FileName,FileName,ASIZE(FileName));
     CharToWide(FileName,FileHead.FileName,ASIZE(FileHead.FileName));
     ConvertNameCase(FileHead.FileName);
 
     if (Raw.Size()!=0)
       NextBlockPos=CurBlockPos+FileHead.HeadSize+FileHead.PackSize;
     CurHeaderType=HEAD_FILE;
   }
   return NextBlockPos>CurBlockPos ? Raw.Size() : 0;
 }
 #endif
 
 
 #ifndef SFX_MODULE
@@ -1335,51 +1330,49 @@ void Archive::ConvertAttributes()
 
 void Archive::ConvertFileHeader(FileHeader *hd)
 {
-  if (Format==RARFMT15 && hd->UnpVer<20 && (hd->FileAttr & 0x10))
-    hd->Dir=true;
   if (hd->HSType==HSYS_UNKNOWN)
     if (hd->Dir)
       hd->FileAttr=0x10;
     else
       hd->FileAttr=0x20;
 
 #ifdef _WIN_ALL
   if (hd->HSType==HSYS_UNIX) // Convert Unix, OS X and Android decomposed chracters to Windows precomposed.
     ConvertToPrecomposed(hd->FileName,ASIZE(hd->FileName));
 #endif
 
   for (wchar *s=hd->FileName;*s!=0;s++)
   {
 #ifdef _UNIX
     // Backslash is the invalid character for Windows file headers,
     // but it can present in Unix file names extracted in Unix.
     if (*s=='\\' && Format==RARFMT50 && hd->HSType==HSYS_WINDOWS)
       *s='_';
 #endif
 
 #if defined(_WIN_ALL) || defined(_EMX)
     // RAR 5.0 archives do not use '\' as path separator, so if we see it,
     // it means that it is a part of Unix file name, which we cannot
     // extract in Windows.
     if (*s=='\\' && Format==RARFMT50)
       *s='_';
 
     // ':' in file names is allowed in Unix, but not in Windows.
     // Even worse, file data will be written to NTFS stream on NTFS,
     // so automatic name correction on file create error in extraction 
     // routine does not work. In Windows and DOS versions we better 
     // replace ':' now.
     if (*s==':')
       *s='_';
 #endif
 
     // This code must be performed only after other path separator checks,
     // because it produces backslashes illegal for some of checks above.
     // Backslash is allowed in file names in Unix, but not in Windows.
     // Still, RAR 4.x uses backslashes as path separator even in Unix.
     // Forward slash is not allowed in both systems. In RAR 5.0 we use
     // the forward slash as universal path separator.
     if (*s=='/' || *s=='\\' && Format!=RARFMT50)
       *s=CPATHDIVIDER;
   }
 }
diff --git a/dll.cpp b/dll.cpp
index c88337d..b5eada5 100644
--- a/dll.cpp
+++ b/dll.cpp
@@ -33,116 +33,118 @@ HANDLE PASCAL RAROpenArchive(struct RAROpenArchiveData *r)
 HANDLE PASCAL RAROpenArchiveEx(struct RAROpenArchiveDataEx *r)
 {
   DataSet *Data=NULL;
   try
   {
+    ErrHandler.Clean();
+
     r->OpenResult=0;
     Data=new DataSet;
     Data->Cmd.DllError=0;
     Data->OpenMode=r->OpenMode;
     Data->Cmd.FileArgs.AddString(L"*");
 
     char AnsiArcName[NM];
     *AnsiArcName=0;
     if (r->ArcName!=NULL)
     {
       strncpyz(AnsiArcName,r->ArcName,ASIZE(AnsiArcName));
 #ifdef _WIN_ALL
       if (!AreFileApisANSI())
       {
         OemToCharBuffA(r->ArcName,AnsiArcName,ASIZE(AnsiArcName));
         AnsiArcName[ASIZE(AnsiArcName)-1]=0;
       }
 #endif
     }
 
     wchar ArcName[NM];
     GetWideName(AnsiArcName,r->ArcNameW,ArcName,ASIZE(ArcName));
 
     Data->Cmd.AddArcName(ArcName);
     Data->Cmd.Overwrite=OVERWRITE_ALL;
     Data->Cmd.VersionControl=1;
 
     Data->Cmd.Callback=r->Callback;
     Data->Cmd.UserData=r->UserData;
 
     // Open shared mode is added by request of dll users, who need to
     // browse and unpack archives while downloading.
     Data->Cmd.OpenShared = true;
     if (!Data->Arc.Open(ArcName,FMF_OPENSHARED))
     {
       r->OpenResult=ERAR_EOPEN;
       delete Data;
       return NULL;
     }
     if (!Data->Arc.IsArchive(true))
     {
       if (Data->Cmd.DllError!=0)
         r->OpenResult=Data->Cmd.DllError;
       else
       {
         RAR_EXIT ErrCode=ErrHandler.GetErrorCode();
         if (ErrCode!=RARX_SUCCESS && ErrCode!=RARX_WARNING)
           r->OpenResult=RarErrorToDll(ErrCode);
         else
           r->OpenResult=ERAR_BAD_ARCHIVE;
       }
       delete Data;
       return NULL;
     }
     r->Flags=0;
     
     if (Data->Arc.Volume)
       r->Flags|=0x01;
     if (Data->Arc.Locked)
       r->Flags|=0x04;
     if (Data->Arc.Solid)
       r->Flags|=0x08;
     if (Data->Arc.NewNumbering)
       r->Flags|=0x10;
     if (Data->Arc.Signed)
       r->Flags|=0x20;
     if (Data->Arc.Protected)
       r->Flags|=0x40;
     if (Data->Arc.Encrypted)
       r->Flags|=0x80;
     if (Data->Arc.FirstVolume)
       r->Flags|=0x100;
 
     Array<wchar> CmtDataW;
     if (r->CmtBufSize!=0 && Data->Arc.GetComment(&CmtDataW))
     {
       Array<char> CmtData(CmtDataW.Size()*4+1);
       memset(&CmtData[0],0,CmtData.Size());
       WideToChar(&CmtDataW[0],&CmtData[0],CmtData.Size()-1);
       size_t Size=strlen(&CmtData[0])+1;
 
       r->Flags|=2;
       r->CmtState=Size>r->CmtBufSize ? ERAR_SMALL_BUF:1;
       r->CmtSize=(uint)Min(Size,r->CmtBufSize);
       memcpy(r->CmtBuf,&CmtData[0],r->CmtSize-1);
       if (Size<=r->CmtBufSize)
         r->CmtBuf[r->CmtSize-1]=0;
     }
     else
       r->CmtState=r->CmtSize=0;
     Data->Extract.ExtractArchiveInit(Data->Arc);
     return (HANDLE)Data;
   }
   catch (RAR_EXIT ErrCode)
   {
     if (Data!=NULL && Data->Cmd.DllError!=0)
       r->OpenResult=Data->Cmd.DllError;
     else
       r->OpenResult=RarErrorToDll(ErrCode);
     if (Data != NULL)
       delete Data;
     return NULL;
   }
   catch (std::bad_alloc&) // Catch 'new' exception.
   {
     r->OpenResult=ERAR_NO_MEMORY;
     if (Data != NULL)
       delete Data;
   }
   return NULL; // To make compilers happy.
 }
diff --git a/encname.cpp b/encname.cpp
index 5556af3..84731a7 100644
--- a/encname.cpp
+++ b/encname.cpp
@@ -11,59 +11,59 @@ EncodeFileName::EncodeFileName()
 
 
 
-void EncodeFileName::Decode(char *Name,byte *EncName,size_t EncSize,wchar *NameW,
-                            size_t MaxDecSize)
+void EncodeFileName::Decode(char *Name,size_t NameSize,byte *EncName,size_t EncSize,
+                            wchar *NameW,size_t MaxDecSize)
 {
   size_t EncPos=0,DecPos=0;
   byte HighByte=EncPos<EncSize ? EncName[EncPos++] : 0;
   while (EncPos<EncSize && DecPos<MaxDecSize)
   {
     if (FlagBits==0)
     {
       if (EncPos>=EncSize)
         break;
       Flags=EncName[EncPos++];
       FlagBits=8;
     }
     switch(Flags>>6)
     {
       case 0:
         if (EncPos>=EncSize)
           break;
         NameW[DecPos++]=EncName[EncPos++];
         break;
       case 1:
         if (EncPos>=EncSize)
           break;
         NameW[DecPos++]=EncName[EncPos++]+(HighByte<<8);
         break;
       case 2:
         if (EncPos+1>=EncSize)
           break;
         NameW[DecPos++]=EncName[EncPos]+(EncName[EncPos+1]<<8);
         EncPos+=2;
         break;
       case 3:
         {
           if (EncPos>=EncSize)
             break;
           int Length=EncName[EncPos++];
           if ((Length & 0x80)!=0)
           {
             if (EncPos>=EncSize)
               break;
             byte Correction=EncName[EncPos++];
-            for (Length=(Length&0x7f)+2;Length>0 && DecPos<MaxDecSize;Length--,DecPos++)
+            for (Length=(Length&0x7f)+2;Length>0 && DecPos<MaxDecSize && DecPos<NameSize;Length--,DecPos++)
               NameW[DecPos]=((Name[DecPos]+Correction)&0xff)+(HighByte<<8);
           }
           else
-            for (Length+=2;Length>0 && DecPos<MaxDecSize;Length--,DecPos++)
+            for (Length+=2;Length>0 && DecPos<MaxDecSize && DecPos<NameSize;Length--,DecPos++)
               NameW[DecPos]=Name[DecPos];
         }
         break;
     }
     Flags<<=2;
     FlagBits-=2;
   }
   NameW[DecPos<MaxDecSize ? DecPos:MaxDecSize-1]=0;
 }
diff --git a/encname.hpp b/encname.hpp
index 3e7786f..538bcb6 100644
--- a/encname.hpp
+++ b/encname.hpp
@@ -4,17 +4,17 @@
 class EncodeFileName
 {
   private:
     void AddFlags(int Value);
 
     byte *EncName;
     byte Flags;
     uint FlagBits;
     size_t FlagsPos;
     size_t DestSize;
   public:
     EncodeFileName();
     size_t Encode(char *Name,wchar *NameW,byte *EncName);
-    void Decode(char *Name,byte *EncName,size_t EncSize,wchar *NameW,size_t MaxDecSize);
+    void Decode(char *Name,size_t NameSize,byte *EncName,size_t EncSize,wchar *NameW,size_t MaxDecSize);
 };
 
 #endif
diff --git a/errhnd.cpp b/errhnd.cpp
index e862bb3..b2f76a8 100644
--- a/errhnd.cpp
+++ b/errhnd.cpp
@@ -37,14 +37,15 @@ void ErrorHandler::OpenError(const wchar *FileName)
 void ErrorHandler::CloseError(const wchar *FileName)
 {
   if (!UserBreak)
   {
     uiMsg(UIERROR_FILECLOSE,FileName);
     SysErrMsg();
   }
   // We must not call Exit and throw an exception here, because this function
   // is called from File object destructor and can be invoked when stack
   // unwinding while handling another exception. Throwing a new exception
   // when stack unwinding is prohibited and terminates a program.
+  // If necessary, we can check std::uncaught_exception() before throw.
   SetErrorCode(RARX_FATAL);
 }
 
@@ -324,50 +325,63 @@ void ErrorHandler::Throw(RAR_EXIT Code)
 }
 
 
-void ErrorHandler::SysErrMsg()
+bool ErrorHandler::GetSysErrMsg(wchar *Msg,size_t Size)
 {
 #if !defined(SFX_MODULE) && !defined(SILENT)
 #ifdef _WIN_ALL
-  wchar *lpMsgBuf=NULL;
   int ErrType=GetLastError();
-  if (ErrType!=0 && FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
-              NULL,ErrType,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
-              (LPTSTR)&lpMsgBuf,0,NULL))
-  {
-    wchar *CurMsg=lpMsgBuf;
-    while (CurMsg!=NULL)
-    {
-      while (*CurMsg=='\r' || *CurMsg=='\n')
-        CurMsg++;
-      if (*CurMsg==0)
-        break;
-      wchar *EndMsg=wcschr(CurMsg,'\r');
-      if (EndMsg==NULL)
-        EndMsg=wcschr(CurMsg,'\n');
-      if (EndMsg!=NULL)
-      {
-        *EndMsg=0;
-        EndMsg++;
-      }
-      uiMsg(UIERROR_SYSERRMSG,CurMsg);
-      CurMsg=EndMsg;
-    }
-  }
-  LocalFree( lpMsgBuf );
+  if (ErrType!=0)
+    return FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
+                         NULL,ErrType,MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
+                         Msg,(DWORD)Size,NULL)!=0;
 #endif
 
 #if defined(_UNIX) || defined(_EMX)
   if (errno!=0)
   {
     char *err=strerror(errno);
     if (err!=NULL)
     {
-      wchar Msg[1024];
-      CharToWide(err,Msg,ASIZE(Msg));
-      uiMsg(UIERROR_SYSERRMSG,Msg);
+      CharToWide(err,Msg,Size);
+      return true;
     }
   }
 #endif
+#endif
+  return false;
+}
+
+
+void ErrorHandler::SysErrMsg()
+{
+#if !defined(SFX_MODULE) && !defined(SILENT)
+  wchar Msg[1024];
+  if (!GetSysErrMsg(Msg,ASIZE(Msg)))
+    return;
+#ifdef _WIN_ALL
+  wchar *CurMsg=Msg;
+  while (CurMsg!=NULL)
+  {
+    while (*CurMsg=='\r' || *CurMsg=='\n')
+      CurMsg++;
+    if (*CurMsg==0)
+      break;
+    wchar *EndMsg=wcschr(CurMsg,'\r');
+    if (EndMsg==NULL)
+      EndMsg=wcschr(CurMsg,'\n');
+    if (EndMsg!=NULL)
+    {
+      *EndMsg=0;
+      EndMsg++;
+    }
+    uiMsg(UIERROR_SYSERRMSG,CurMsg);
+    CurMsg=EndMsg;
+  }
+#endif
+
+#if defined(_UNIX) || defined(_EMX)
+  uiMsg(UIERROR_SYSERRMSG,Msg);
+#endif
 
 #endif
 }
diff --git a/errhnd.hpp b/errhnd.hpp
index 26df96d..c360c6c 100644
--- a/errhnd.hpp
+++ b/errhnd.hpp
@@ -21,50 +21,51 @@ enum RAR_EXIT // RAR exit code.
 class ErrorHandler
 {
   private:
     RAR_EXIT ExitCode;
     uint ErrCount;
     bool EnableBreak;
     bool Silent;
     bool DisableShutdown; // Shutdown is not suitable after last error.
   public:
     ErrorHandler();
     void Clean();
     void MemoryError();
     void OpenError(const wchar *FileName);
     void CloseError(const wchar *FileName);
     void ReadError(const wchar *FileName);
     bool AskRepeatRead(const wchar *FileName);
     void WriteError(const wchar *ArcName,const wchar *FileName);
     void WriteErrorFAT(const wchar *FileName);
     bool AskRepeatWrite(const wchar *FileName,bool DiskFull);
     void SeekError(const wchar *FileName);
     void GeneralErrMsg(const wchar *fmt,...);
     void MemoryErrorMsg();
     void OpenErrorMsg(const wchar *FileName);
     void OpenErrorMsg(const wchar *ArcName,const wchar *FileName);
     void CreateErrorMsg(const wchar *FileName);
     void CreateErrorMsg(const wchar *ArcName,const wchar *FileName);
     void ReadErrorMsg(const wchar *FileName);
     void ReadErrorMsg(const wchar *ArcName,const wchar *FileName);
     void WriteErrorMsg(const wchar *ArcName,const wchar *FileName);
     void ArcBrokenMsg(const wchar *ArcName);
     void ChecksumFailedMsg(const wchar *ArcName,const wchar *FileName);
     void UnknownMethodMsg(const wchar *ArcName,const wchar *FileName);
     void Exit(RAR_EXIT ExitCode);
     void SetErrorCode(RAR_EXIT Code);
     RAR_EXIT GetErrorCode() {return ExitCode;}
     uint GetErrorCount() {return ErrCount;}
     void SetSignalHandlers(bool Enable);
     void Throw(RAR_EXIT Code);
     void SetSilent(bool Mode) {Silent=Mode;};
+    bool GetSysErrMsg(wchar *Msg,size_t Size);
     void SysErrMsg();
     int GetSystemErrorCode();
     void SetSystemErrorCode(int Code);
     bool IsShutdownEnabled() {return !DisableShutdown;}
 
     bool UserBreak; // Ctrl+Break is pressed.
     bool MainExit; // main() is completed.
 };
 
 
 #endif
diff --git a/qopen.cpp b/qopen.cpp
index 97851ca..f0a4d87 100644
--- a/qopen.cpp
+++ b/qopen.cpp
@@ -62,53 +62,56 @@ void QuickOpen::Close()
 void QuickOpen::Load(uint64 BlockPos)
 {
   if (!Loaded)
   {
     // If loading for the first time, perform additional intialization.
     SeekPos=Arc->Tell();
     UnsyncSeekPos=false;
 
     SaveFilePos SavePos(*Arc);
     Arc->Seek(BlockPos,SEEK_SET);
 
     // If BlockPos points to original main header, we'll have the infinite
     // recursion, because ReadHeader() for main header will attempt to load
     // QOpen and call QuickOpen::Load again. If BlockPos points to long chain
     // of other main headers, we'll have multiple recursive calls of this
     // function wasting resources. So we prohibit QOpen temporarily to
     // prevent this. ReadHeader() calls QOpen.Init and sets MainHead Locator
     // and QOpenOffset fields, so we cannot use them to prohibit QOpen.
     Arc->SetProhibitQOpen(true);
     size_t ReadSize=Arc->ReadHeader();
     Arc->SetProhibitQOpen(false);
 
     if (ReadSize==0 || Arc->GetHeaderType()!=HEAD_SERVICE ||
         !Arc->SubHead.CmpName(SUBHEAD_TYPE_QOPEN))
       return;
     QLHeaderPos=Arc->CurBlockPos;
     RawDataStart=Arc->Tell();
     RawDataSize=Arc->SubHead.UnpSize;
 
     Loaded=true; // Set only after all file processing calls like Tell, Seek, ReadHeader.
   }
 
   if (Arc->SubHead.Encrypted)
   {
     RAROptions *Cmd=Arc->GetRAROptions();
 #ifndef RAR_NOCRYPT
     if (Cmd->Password.IsSet())
       Crypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,Arc->SubHead.Salt,
                          Arc->SubHead.InitV,Arc->SubHead.Lg2Count,
                          Arc->SubHead.HashKey,Arc->SubHead.PswCheck);
     else
 #endif
+    {
+      Loaded=false;
       return;
+    }
   }
 
   RawDataPos=0;
   ReadBufSize=0;
   ReadBufPos=0;
   LastReadHeader.Reset();
   LastReadHeaderPos=0;
 
   ReadBuffer();
 }
diff --git a/savepos.hpp b/savepos.hpp
index df61710..10a0664 100644
--- a/savepos.hpp
+++ b/savepos.hpp
@@ -4,18 +4,24 @@
 class SaveFilePos
 {
   private:
     File *SaveFile;
     int64 SavePos;
   public:
     SaveFilePos(File &Src)
     {
       SaveFile=&Src;
       SavePos=Src.Tell();
     }
     ~SaveFilePos()
     {
-      SaveFile->Seek(SavePos,SEEK_SET);
+      // If file is already closed by current exception processing,
+      // we would get uneeded error messages and an exception inside of
+      // exception and terminate if we try to seek without checking
+      // if file is still opened. We should not also restore the position
+      // if external code closed the file on purpose.
+      if (SaveFile->IsOpened())
+        SaveFile->Seek(SavePos,SEEK_SET);
     }
 };
 
 #endif
diff --git a/strfn.cpp b/strfn.cpp
index 283c67b..4ecc719 100644
--- a/strfn.cpp
+++ b/strfn.cpp
@@ -15,49 +15,53 @@ const wchar *NullToEmpty(const wchar *Str)
 void IntToExt(const char *Src,char *Dest,size_t DestSize)
 {
 #ifdef _WIN_ALL
   // OemToCharBuff does not stop at 0, so let's check source length.
   size_t SrcLength=strlen(Src)+1;
   if (DestSize>SrcLength)
     DestSize=SrcLength;
   OemToCharBuffA(Src,Dest,(DWORD)DestSize);
   Dest[DestSize-1]=0;
 #else
   if (Dest!=Src)
     strncpyz(Dest,Src,DestSize);
 #endif
 }
 
 
-// Convert archived names to Unicode. Allow user to select a code page in GUI.
+// Convert archived names and comments to Unicode.
+// Allows user to select a code page in GUI.
 void ArcCharToWide(const char *Src,wchar *Dest,size_t DestSize,ACTW_ENCODING Encoding)
 {
 #if defined(_WIN_ALL) // Console Windows RAR.
   if (Encoding==ACTW_UTF8)
     UtfToWide(Src,Dest,DestSize);
   else
   {
-    char NameA[NM];
+    Array<char> NameA;
     if (Encoding==ACTW_OEM)
     {
-      IntToExt(Src,NameA,ASIZE(NameA));
-      Src=NameA;
+      NameA.Alloc(DestSize+1);
+      IntToExt(Src,&NameA[0],NameA.Size());
+      Src=&NameA[0];
     }
     CharToWide(Src,Dest,DestSize);
   }
 #else // RAR for Unix.
   if (Encoding==ACTW_UTF8)
     UtfToWide(Src,Dest,DestSize);
   else
     CharToWide(Src,Dest,DestSize);
 #endif
   // Ensure that we return a zero terminate string for security reason.
   // While [Jni]CharToWide might already do it, be protected in case of future
   // changes in these functions.
   if (DestSize>0)
     Dest[DestSize-1]=0;
 }
 
 
+
+
 int stricomp(const char *s1,const char *s2)
 {
 #ifdef _WIN_ALL
diff --git a/strfn.hpp b/strfn.hpp
index 7faac42..6c47b2a 100644
--- a/strfn.hpp
+++ b/strfn.hpp
@@ -8,6 +8,7 @@ void IntToExt(const char *Src,char *Dest,size_t DestSize);
 enum ACTW_ENCODING { ACTW_DEFAULT, ACTW_OEM, ACTW_UTF8};
 void ArcCharToWide(const char *Src,wchar *Dest,size_t DestSize,ACTW_ENCODING Encoding);
 
+
 int stricomp(const char *s1,const char *s2);
 int strnicomp(const char *s1,const char *s2,size_t n);
 wchar* RemoveEOL(wchar *Str);
diff --git a/unpack20.cpp b/unpack20.cpp
index a7a41c3..93c8ba0 100644
--- a/unpack20.cpp
+++ b/unpack20.cpp
@@ -2,8 +2,9 @@
 
 void Unpack::CopyString20(uint Length,uint Distance)
 {
-  LastDist=OldDist[OldDistPtr++ & 3]=Distance;
+  LastDist=OldDist[OldDistPtr++]=Distance;
+  OldDistPtr = OldDistPtr & 3; // Needed if RAR 1.5 file is called after RAR 2.0.
   LastLength=Length;
   DestUnpSize-=Length;
   CopyString(Length,Distance);
 }
