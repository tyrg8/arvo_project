commit 4364700c01bb55bc664106e6c8b997849ec69228
Author: John Safranek <john@wolfssl.com>
Date:   Fri Oct 16 15:35:23 2020 -0700

    DH Fix
    These changes fix several fuzz testing reports. (ZD 11088 and ZD 11101)
    1. In GetDhPublicKey(), the DH Pubkey is owned by the SSL session. It
       doesn't need to be in the check for weOwnDh before freeing. There
       could be a chance it leaks.
    2. In GeneratePublicDh() and GeneratePrivateDh(), the size of the
       destination buffer should be stored at the location pointed to by the
       size pointer. Check that before writing into the destination buffer.
    3. Ensure the size of the private and public key values are in the size
       value before generating or getting the DH keys.

diff --git a/src/internal.c b/src/internal.c
index 8a5cc24e0..c4464a3e2 100644
--- a/src/internal.c
+++ b/src/internal.c
@@ -21143,202 +21143,203 @@ static void FreeDskeArgs(WOLFSSL* ssl, void* pArgs)
 #ifndef NO_DH
 static int GetDhPublicKey(WOLFSSL* ssl, const byte* input, word32 size,
                           DskeArgs* args)
 {
     int             ret = 0;
     word16          length;
 #ifdef HAVE_FFDHE
     const DhParams* params = NULL;
     int             group = 0;
 #endif
 
     if (ssl->buffers.weOwnDH) {
         if (ssl->buffers.serverDH_P.buffer) {
             XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,
                     DYNAMIC_TYPE_PUBLIC_KEY);
             ssl->buffers.serverDH_P.buffer = NULL;
         }
 
         if (ssl->buffers.serverDH_G.buffer) {
             XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,
                     DYNAMIC_TYPE_PUBLIC_KEY);
             ssl->buffers.serverDH_G.buffer = NULL;
         }
 
-        if (ssl->buffers.serverDH_Pub.buffer) {
-            XFREE(ssl->buffers.serverDH_Pub.buffer, ssl->heap,
-                    DYNAMIC_TYPE_PUBLIC_KEY);
-            ssl->buffers.serverDH_Pub.buffer = NULL;
-        }
+    }
+
+    if (ssl->buffers.serverDH_Pub.buffer) {
+        XFREE(ssl->buffers.serverDH_Pub.buffer, ssl->heap,
+                DYNAMIC_TYPE_PUBLIC_KEY);
+        ssl->buffers.serverDH_Pub.buffer = NULL;
     }
 
     /* p */
     if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ato16(input + args->idx, &length);
     args->idx += OPAQUE16_LEN;
 
     if ((args->idx - args->begin) + length > size) {
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     if (length < ssl->options.minDhKeySz) {
         WOLFSSL_MSG("Server using a DH key that is too small");
         SendAlert(ssl, alert_fatal, handshake_failure);
         ERROR_OUT(DH_KEY_SIZE_E, exit_gdpk);
     }
     if (length > ssl->options.maxDhKeySz) {
         WOLFSSL_MSG("Server using a DH key that is too big");
         SendAlert(ssl, alert_fatal, handshake_failure);
         ERROR_OUT(DH_KEY_SIZE_E, exit_gdpk);
     }
 
     ssl->buffers.serverDH_P.buffer =
         (byte*)XMALLOC(length, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
     if (ssl->buffers.serverDH_P.buffer) {
         ssl->buffers.serverDH_P.length = length;
     }
     else {
         ERROR_OUT(MEMORY_ERROR, exit_gdpk);
     }
 
     XMEMCPY(ssl->buffers.serverDH_P.buffer, input + args->idx,
                                                         length);
     args->idx += length;
 
     ssl->options.dhKeySz = length;
 
     /* g */
     if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
         XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,
                 DYNAMIC_TYPE_PUBLIC_KEY);
         ssl->buffers.serverDH_P.buffer = NULL;
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ato16(input + args->idx, &length);
     args->idx += OPAQUE16_LEN;
 
     if ((args->idx - args->begin) + length > size) {
         XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,
                 DYNAMIC_TYPE_PUBLIC_KEY);
         ssl->buffers.serverDH_P.buffer = NULL;
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ssl->buffers.serverDH_G.buffer =
         (byte*)XMALLOC(length, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
     if (ssl->buffers.serverDH_G.buffer) {
         ssl->buffers.serverDH_G.length = length;
     }
     else {
         XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,
                 DYNAMIC_TYPE_PUBLIC_KEY);
         ssl->buffers.serverDH_P.buffer = NULL;
         ERROR_OUT(MEMORY_ERROR, exit_gdpk);
     }
 
     XMEMCPY(ssl->buffers.serverDH_G.buffer, input + args->idx,
                                                         length);
     args->idx += length;
 
     /* pub */
     if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
         XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,
                 DYNAMIC_TYPE_PUBLIC_KEY);
         ssl->buffers.serverDH_P.buffer = NULL;
         XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,
                 DYNAMIC_TYPE_PUBLIC_KEY);
         ssl->buffers.serverDH_G.buffer = NULL;
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ato16(input + args->idx, &length);
     args->idx += OPAQUE16_LEN;
 
     if ((args->idx - args->begin) + length > size) {
         XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,
                 DYNAMIC_TYPE_PUBLIC_KEY);
         ssl->buffers.serverDH_P.buffer = NULL;
         XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,
                 DYNAMIC_TYPE_PUBLIC_KEY);
         ssl->buffers.serverDH_G.buffer = NULL;
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ssl->buffers.serverDH_Pub.buffer =
         (byte*)XMALLOC(length, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
     if (ssl->buffers.serverDH_Pub.buffer) {
         ssl->buffers.serverDH_Pub.length = length;
     }
     else {
         XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,
                 DYNAMIC_TYPE_PUBLIC_KEY);
         ssl->buffers.serverDH_P.buffer = NULL;
         XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,
                 DYNAMIC_TYPE_PUBLIC_KEY);
         ssl->buffers.serverDH_G.buffer = NULL;
         ERROR_OUT(MEMORY_ERROR, exit_gdpk);
     }
 
     XMEMCPY(ssl->buffers.serverDH_Pub.buffer, input + args->idx,
                                                         length);
     ssl->buffers.weOwnDH = 1;
     args->idx += length;
 
 #ifdef HAVE_FFDHE
     switch (ssl->options.dhKeySz) {
     #ifdef HAVE_FFDHE_2048
         case 2048/8:
             params = wc_Dh_ffdhe2048_Get();
             group = WOLFSSL_FFDHE_2048;
             break;
     #endif
     #ifdef HAVE_FFDHE_3072
         case 3072/8:
             params = wc_Dh_ffdhe3072_Get();
             group = WOLFSSL_FFDHE_3072;
             break;
     #endif
     #ifdef HAVE_FFDHE_4096
         case 4096/8:
             params = wc_Dh_ffdhe4096_Get();
             group = WOLFSSL_FFDHE_4096;
             break;
     #endif
     #ifdef HAVE_FFDHE_6144
         case 6144/8:
             params = wc_Dh_ffdhe6144_Get();
             group = WOLFSSL_FFDHE_6144;
             break;
     #endif
     #ifdef HAVE_FFDHE_8192
         case 8192/8:
             params = wc_Dh_ffdhe8192_Get();
             group = WOLFSSL_FFDHE_8192;
             break;
     #endif
         default:
             break;
     }
 
     if (params == NULL || params->g_len != ssl->buffers.serverDH_G.length ||
             (XMEMCMP(ssl->buffers.serverDH_G.buffer, params->g,
                     params->g_len) != 0) ||
             (XMEMCMP(ssl->buffers.serverDH_P.buffer, params->p,
                     params->p_len) != 0)) {
         WOLFSSL_MSG("Server not using FFDHE parameters");
     #ifdef WOLFSSL_REQUIRE_FFDHE
         SendAlert(ssl, alert_fatal, handshake_failure);
         ERROR_OUT(DH_PARAMS_NOT_FFDHE_E, exit_gdpk);
     #endif
     }
     else {
         ssl->namedGroup = group;
     #if !defined(WOLFSSL_OLD_PRIME_CHECK) && !defined(HAVE_FIPS) && \
         !defined(HAVE_SELFTEST)
         ssl->options.dhDoKeyTest = 0;
     #endif
     }
 #endif /* HAVE_FFDHE */
@@ -22760,1216 +22761,1215 @@ static void FreeSckeArgs(WOLFSSL* ssl, void* pArgs)
 /* handle generation client_key_exchange (16) */
 int SendClientKeyExchange(WOLFSSL* ssl)
 {
     int ret = 0;
 #ifdef WOLFSSL_ASYNC_CRYPT
     SckeArgs* args = (SckeArgs*)ssl->async.args;
     typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
     (void)sizeof(args_test);
 #else
     SckeArgs  args[1];
 #endif
 
     WOLFSSL_START(WC_FUNC_CLIENT_KEY_EXCHANGE_SEND);
     WOLFSSL_ENTER("SendClientKeyExchange");
 
 #ifdef OPENSSL_EXTRA
     ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
     ssl->cbmode = SSL_CB_MODE_WRITE;
     if (ssl->CBIS != NULL)
         ssl->CBIS(ssl, SSL_CB_CONNECT_LOOP, SSL_SUCCESS);
 #endif
 
 #ifdef WOLFSSL_ASYNC_CRYPT
     ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
     if (ret != WC_NOT_PENDING_E) {
         /* Check for error */
         if (ret < 0)
             goto exit_scke;
     }
     else
 #endif
     {
         /* Reset state */
         ret = 0;
         ssl->options.asyncState = TLS_ASYNC_BEGIN;
         XMEMSET(args, 0, sizeof(SckeArgs));
     #ifdef WOLFSSL_ASYNC_CRYPT
         ssl->async.freeArgs = FreeSckeArgs;
     #endif
     }
 
     switch(ssl->options.asyncState)
     {
         case TLS_ASYNC_BEGIN:
         {
             switch (ssl->specs.kea) {
             #ifndef NO_RSA
                 case rsa_kea:
                     if (ssl->peerRsaKey == NULL ||
                         ssl->peerRsaKeyPresent == 0) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
                     break;
             #endif
             #ifndef NO_DH
                 case diffie_hellman_kea:
                     if (ssl->buffers.serverDH_P.buffer == NULL ||
                         ssl->buffers.serverDH_G.buffer == NULL ||
                         ssl->buffers.serverDH_Pub.buffer == NULL) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
                     break;
             #endif /* NO_DH */
             #ifndef NO_PSK
                 case psk_kea:
                     /* sanity check that PSK client callback has been set */
                     if (ssl->options.client_psk_cb == NULL) {
                         WOLFSSL_MSG("No client PSK callback set");
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
                     break;
             #endif /* NO_PSK */
             #if !defined(NO_DH) && !defined(NO_PSK)
                 case dhe_psk_kea:
                     if (ssl->buffers.serverDH_P.buffer == NULL ||
                         ssl->buffers.serverDH_G.buffer == NULL ||
                         ssl->buffers.serverDH_Pub.buffer == NULL) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
 
                     /* sanity check that PSK client callback has been set */
                     if (ssl->options.client_psk_cb == NULL) {
                         WOLFSSL_MSG("No client PSK callback set");
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
                     break;
             #endif /* !NO_DH && !NO_PSK */
             #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                 case ecdhe_psk_kea:
                     /* sanity check that PSK client callback has been set */
                     if (ssl->options.client_psk_cb == NULL) {
                         WOLFSSL_MSG("No client PSK callback set");
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->peerX25519KeyPresent) {
                         /* Check client ECC public key */
                         if (!ssl->peerX25519Key || !ssl->peerX25519Key->dp) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
 
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X25519SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         /* create private key */
                         ssl->hsType = DYNAMIC_TYPE_CURVE25519;
                         ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ret = X25519MakeKey(ssl, (curve25519_key*)ssl->hsKey,
                                             ssl->peerX25519Key);
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->peerX448KeyPresent) {
                         /* Check client ECC public key */
                         if (!ssl->peerX448Key) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
 
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X448SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         /* create private key */
                         ssl->hsType = DYNAMIC_TYPE_CURVE448;
                         ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ret = X448MakeKey(ssl, (curve448_key*)ssl->hsKey,
                                           ssl->peerX448Key);
                         break;
                     }
                 #endif
                     /* Check client ECC public key */
                     if (!ssl->peerEccKey || !ssl->peerEccKeyPresent ||
                                             !ssl->peerEccKey->dp) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
 
                 #ifdef HAVE_PK_CALLBACKS
                     /* if callback then use it for shared secret */
                     if (ssl->ctx->EccSharedSecretCb != NULL) {
                         break;
                     }
                 #endif
 
                     /* create ephemeral private key */
                     ssl->hsType = DYNAMIC_TYPE_ECC;
                     ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                     if (ret != 0) {
                         goto exit_scke;
                     }
 
                     ret = EccMakeKey(ssl, (ecc_key*)ssl->hsKey, ssl->peerEccKey);
 
                     break;
             #endif /* (HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448) && !NO_PSK */
             #ifdef HAVE_NTRU
                 case ntru_kea:
                     if (ssl->peerNtruKeyPresent == 0) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
                     break;
             #endif /* HAVE_NTRU */
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 case ecc_diffie_hellman_kea:
                 {
                 #ifdef HAVE_ECC
                     ecc_key* peerKey;
                 #endif
 
             #ifdef HAVE_PK_CALLBACKS
                     /* if callback then use it for shared secret */
                 #ifdef HAVE_CURVE25519
                     if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                         if (ssl->ctx->X25519SharedSecretCb != NULL)
                             break;
                     }
                     else
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->ecdhCurveOID == ECC_X448_OID) {
                         if (ssl->ctx->X448SharedSecretCb != NULL)
                             break;
                     }
                     else
                 #endif
                     if (ssl->ctx->EccSharedSecretCb != NULL) {
                         break;
                     }
             #endif /* HAVE_PK_CALLBACKS */
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->peerX25519KeyPresent) {
                         if (!ssl->peerX25519Key || !ssl->peerX25519Key->dp) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
 
                         /* create private key */
                         ssl->hsType = DYNAMIC_TYPE_CURVE25519;
                         ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ret = X25519MakeKey(ssl, (curve25519_key*)ssl->hsKey,
                                             ssl->peerX25519Key);
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->peerX448KeyPresent) {
                         if (!ssl->peerX448Key) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
 
                         /* create private key */
                         ssl->hsType = DYNAMIC_TYPE_CURVE448;
                         ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ret = X448MakeKey(ssl, (curve448_key*)ssl->hsKey,
                                           ssl->peerX448Key);
                         break;
                     }
                 #endif
                 #ifdef HAVE_ECC
                     if (ssl->specs.static_ecdh) {
                         /* Note: EccDsa is really fixed Ecc key here */
                         if (!ssl->peerEccDsaKey || !ssl->peerEccDsaKeyPresent) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
                         peerKey = ssl->peerEccDsaKey;
                     }
                     else {
                         if (!ssl->peerEccKey || !ssl->peerEccKeyPresent) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
                         peerKey = ssl->peerEccKey;
                     }
                     if (peerKey == NULL) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
 
                     /* create ephemeral private key */
                     ssl->hsType = DYNAMIC_TYPE_ECC;
                     ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                     if (ret != 0) {
                         goto exit_scke;
                     }
 
                     ret = EccMakeKey(ssl, (ecc_key*)ssl->hsKey, peerKey);
                 #endif
 
                     break;
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 default:
                     ret = BAD_KEA_TYPE_E;
             } /* switch(ssl->specs.kea) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_scke;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_BUILD;
         } /* case TLS_ASYNC_BEGIN */
         FALL_THROUGH;
 
         case TLS_ASYNC_BUILD:
         {
             args->encSz = MAX_ENCRYPT_SZ;
             args->encSecret = (byte*)XMALLOC(args->encSz, ssl->heap,
                                                     DYNAMIC_TYPE_SECRET);
             if (args->encSecret == NULL) {
                 ERROR_OUT(MEMORY_E, exit_scke);
             }
             if (ssl->arrays->preMasterSecret == NULL) {
                 ssl->arrays->preMasterSz = ENCRYPT_LEN;
                 ssl->arrays->preMasterSecret = (byte*)XMALLOC(ENCRYPT_LEN,
                                                 ssl->heap, DYNAMIC_TYPE_SECRET);
                 if (ssl->arrays->preMasterSecret == NULL) {
                     ERROR_OUT(MEMORY_E, exit_scke);
                 }
                 XMEMSET(ssl->arrays->preMasterSecret, 0, ENCRYPT_LEN);
             }
 
             switch(ssl->specs.kea)
             {
             #ifndef NO_RSA
                 case rsa_kea:
                 {
                     /* build PreMasterSecret with RNG data */
                     #if defined(WOLFSSL_RENESAS_TSIP_TLS) && \
                        !defined(NO_WOLFSSL_RENESAS_TSIP_TLS_SESSION)
                     if (tsip_useable(ssl)) {
                         ret = tsip_generatePremasterSecret(
                         &ssl->arrays->preMasterSecret[VERSION_SZ],
                         ENCRYPT_LEN - VERSION_SZ);
                     } else {
                     #endif
                         ret = wc_RNG_GenerateBlock(ssl->rng,
                             &ssl->arrays->preMasterSecret[VERSION_SZ],
                             SECRET_LEN - VERSION_SZ);
                     #if defined(WOLFSSL_RENESAS_TSIP_TLS) && \
                        !defined(NO_WOLFSSL_RENESAS_TSIP_TLS_SESSION)
                     }
                     #endif
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ssl->arrays->preMasterSecret[0] = ssl->chVersion.major;
                         ssl->arrays->preMasterSecret[1] = ssl->chVersion.minor;
 
                     ssl->arrays->preMasterSz = SECRET_LEN;
 
                     break;
                 }
             #endif /* !NO_RSA */
             #ifndef NO_DH
                 case diffie_hellman_kea:
                 {
                     ssl->buffers.sig.length = ENCRYPT_LEN;
                     ssl->buffers.sig.buffer = (byte*)XMALLOC(ENCRYPT_LEN,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                     if (ssl->buffers.sig.buffer == NULL) {
                         ERROR_OUT(MEMORY_E, exit_scke);
                     }
 
                     ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                     if (ret != 0) {
                         goto exit_scke;
                     }
 
                     #if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST) && \
                         !defined(WOLFSSL_OLD_PRIME_CHECK)
                     if (ssl->options.dhDoKeyTest &&
                         !ssl->options.dhKeyTested)
                     {
                         ret = wc_DhSetCheckKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length,
                             NULL, 0, 0, ssl->rng);
                         if (ret != 0) {
                             goto exit_scke;
                         }
                         ssl->options.dhKeyTested = 1;
                     }
                     else
                     #endif
                     {
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
                         if (ret != 0) {
                             goto exit_scke;
                         }
                     }
 
                     /* for DH, encSecret is Yc, agree is pre-master */
                     ret = DhGenKeyPair(ssl, ssl->buffers.serverDH_Key,
                         ssl->buffers.sig.buffer, (word32*)&ssl->buffers.sig.length,
                         args->encSecret, &args->encSz);
 
                     /* set the max agree result size */
                     ssl->arrays->preMasterSz = ENCRYPT_LEN;
                     break;
                 }
             #endif /* !NO_DH */
             #ifndef NO_PSK
                 case psk_kea:
                 {
                     byte* pms = ssl->arrays->preMasterSecret;
                     ssl->arrays->psk_keySz = ssl->options.client_psk_cb(ssl,
                         ssl->arrays->server_hint, ssl->arrays->client_identity,
                         MAX_PSK_ID_LEN, ssl->arrays->psk_key, MAX_PSK_KEY_LEN);
                     if (ssl->arrays->psk_keySz == 0 ||
                         ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
                     ssl->arrays->client_identity[MAX_PSK_ID_LEN] = '\0'; /* null term */
                     args->encSz = (word32)XSTRLEN(ssl->arrays->client_identity);
                     if (args->encSz > MAX_PSK_ID_LEN) {
                         ERROR_OUT(CLIENT_ID_ERROR, exit_scke);
                     }
                     XMEMCPY(args->encSecret, ssl->arrays->client_identity,
                                                                 args->encSz);
 
                     /* make psk pre master secret */
                     /* length of key + length 0s + length of key + key */
                     c16toa((word16)ssl->arrays->psk_keySz, pms);
                     pms += OPAQUE16_LEN;
                     XMEMSET(pms, 0, ssl->arrays->psk_keySz);
                     pms += ssl->arrays->psk_keySz;
                     c16toa((word16)ssl->arrays->psk_keySz, pms);
                     pms += OPAQUE16_LEN;
                     XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->preMasterSz = (ssl->arrays->psk_keySz * 2) +
                         (2 * OPAQUE16_LEN);
                     ForceZero(ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->psk_keySz = 0; /* No further need */
                     break;
                 }
             #endif /* !NO_PSK */
             #if !defined(NO_DH) && !defined(NO_PSK)
                 case dhe_psk_kea:
                 {
                     word32 esSz = 0;
                     args->output = args->encSecret;
 
                     ssl->arrays->psk_keySz = ssl->options.client_psk_cb(ssl,
                          ssl->arrays->server_hint, ssl->arrays->client_identity,
                          MAX_PSK_ID_LEN, ssl->arrays->psk_key, MAX_PSK_KEY_LEN);
                     if (ssl->arrays->psk_keySz == 0 ||
                                      ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
                     ssl->arrays->client_identity[MAX_PSK_ID_LEN] = '\0'; /* null term */
                     esSz = (word32)XSTRLEN(ssl->arrays->client_identity);
 
                     if (esSz > MAX_PSK_ID_LEN) {
                         ERROR_OUT(CLIENT_ID_ERROR, exit_scke);
                     }
 
                     ssl->buffers.sig.length = ENCRYPT_LEN;
                     ssl->buffers.sig.buffer = (byte*)XMALLOC(ENCRYPT_LEN,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                     if (ssl->buffers.sig.buffer == NULL) {
                         ERROR_OUT(MEMORY_E, exit_scke);
                     }
 
                     c16toa((word16)esSz, args->output);
                     args->output += OPAQUE16_LEN;
                     XMEMCPY(args->output, ssl->arrays->client_identity, esSz);
                     args->output += esSz;
+                    args->length = args->encSz - esSz - OPAQUE16_LEN;
                     args->encSz = esSz + OPAQUE16_LEN;
 
-                    args->length = 0;
-
                     ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                     if (ret != 0) {
                         goto exit_scke;
                     }
 
                     #if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST) && \
                         !defined(WOLFSSL_OLD_PRIME_CHECK)
                     if (ssl->options.dhDoKeyTest &&
                         !ssl->options.dhKeyTested)
                     {
                         ret = wc_DhSetCheckKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length,
                             NULL, 0, 0, ssl->rng);
                         if (ret != 0) {
                             goto exit_scke;
                         }
                         ssl->options.dhKeyTested = 1;
                     }
                     else
                     #endif
                     {
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
                         if (ret != 0) {
                             goto exit_scke;
                         }
                     }
 
                     /* for DH, encSecret is Yc, agree is pre-master */
                     ret = DhGenKeyPair(ssl, ssl->buffers.serverDH_Key,
                         ssl->buffers.sig.buffer, (word32*)&ssl->buffers.sig.length,
                         args->output + OPAQUE16_LEN, &args->length);
                     break;
                 }
             #endif /* !NO_DH && !NO_PSK */
             #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                 case ecdhe_psk_kea:
                 {
                     word32 esSz = 0;
                     args->output = args->encSecret;
 
                     /* Send PSK client identity */
                     ssl->arrays->psk_keySz = ssl->options.client_psk_cb(ssl,
                          ssl->arrays->server_hint, ssl->arrays->client_identity,
                          MAX_PSK_ID_LEN, ssl->arrays->psk_key, MAX_PSK_KEY_LEN);
                     if (ssl->arrays->psk_keySz == 0 ||
                                      ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
                     ssl->arrays->client_identity[MAX_PSK_ID_LEN] = '\0'; /* null term */
                     esSz = (word32)XSTRLEN(ssl->arrays->client_identity);
                     if (esSz > MAX_PSK_ID_LEN) {
                         ERROR_OUT(CLIENT_ID_ERROR, exit_scke);
                     }
 
                     /* place size and identity in output buffer sz:identity */
                     c16toa((word16)esSz, args->output);
                     args->output += OPAQUE16_LEN;
                     XMEMCPY(args->output, ssl->arrays->client_identity, esSz);
                     args->output += esSz;
                     args->encSz = esSz + OPAQUE16_LEN;
 
                     /* length is used for public key size */
                     args->length = MAX_ENCRYPT_SZ;
 
                     /* Create shared ECC key leaving room at the beginning
                        of buffer for size of shared key. */
                     ssl->arrays->preMasterSz = ENCRYPT_LEN - OPAQUE16_LEN;
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X25519SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         ret = wc_curve25519_export_public_ex(
                                 (curve25519_key*)ssl->hsKey,
                                 args->output + OPAQUE8_LEN, &args->length,
                                 EC25519_LITTLE_ENDIAN);
                         if (ret != 0) {
                             ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                         }
 
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->ecdhCurveOID == ECC_X448_OID) {
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X448SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         ret = wc_curve448_export_public_ex(
                                 (curve448_key*)ssl->hsKey,
                                 args->output + OPAQUE8_LEN, &args->length,
                                 EC448_LITTLE_ENDIAN);
                         if (ret != 0) {
                             ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                         }
 
                         break;
                     }
                 #endif
                 #ifdef HAVE_PK_CALLBACKS
                     /* if callback then use it for shared secret */
                     if (ssl->ctx->EccSharedSecretCb != NULL) {
                         break;
                     }
                 #endif
 
                     /* Place ECC key in output buffer, leaving room for size */
                     ret = wc_ecc_export_x963((ecc_key*)ssl->hsKey,
                                     args->output + OPAQUE8_LEN, &args->length);
                     if (ret != 0) {
                         ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                     }
 
                     break;
                 }
             #endif /* (HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448) && !NO_PSK */
             #ifdef HAVE_NTRU
                 case ntru_kea:
                 {
                     ret = wc_RNG_GenerateBlock(ssl->rng,
                                   ssl->arrays->preMasterSecret, SECRET_LEN);
                     if (ret != 0) {
                         goto exit_scke;
                     }
 
                     ssl->arrays->preMasterSz = SECRET_LEN;
                     args->encSz = MAX_ENCRYPT_SZ;
                     break;
                 }
             #endif /* HAVE_NTRU */
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 case ecc_diffie_hellman_kea:
                 {
                     ssl->arrays->preMasterSz = ENCRYPT_LEN;
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->hsType == DYNAMIC_TYPE_CURVE25519) {
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X25519SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         ret = wc_curve25519_export_public_ex(
                                 (curve25519_key*)ssl->hsKey,
                                 args->encSecret + OPAQUE8_LEN, &args->encSz,
                                 EC25519_LITTLE_ENDIAN);
                         if (ret != 0) {
                             ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                         }
 
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->hsType == DYNAMIC_TYPE_CURVE448) {
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X448SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         ret = wc_curve448_export_public_ex(
                                 (curve448_key*)ssl->hsKey,
                                 args->encSecret + OPAQUE8_LEN, &args->encSz,
                                 EC448_LITTLE_ENDIAN);
                         if (ret != 0) {
                             ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                         }
 
                         break;
                     }
                 #endif
                 #if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)
                 #ifdef HAVE_PK_CALLBACKS
                     /* if callback then use it for shared secret */
                     if (ssl->ctx->EccSharedSecretCb != NULL) {
                         break;
                     }
                 #endif
 
                     /* Place ECC key in buffer, leaving room for size */
                     ret = wc_ecc_export_x963((ecc_key*)ssl->hsKey,
                                 args->encSecret + OPAQUE8_LEN, &args->encSz);
                     if (ret != 0) {
                         ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                     }
                 #endif /* HAVE_ECC */
                     break;
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 default:
                     ret = BAD_KEA_TYPE_E;
             } /* switch(ssl->specs.kea) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_scke;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_DO;
         } /* case TLS_ASYNC_BUILD */
         FALL_THROUGH;
 
         case TLS_ASYNC_DO:
         {
             switch(ssl->specs.kea)
             {
             #ifndef NO_RSA
                 case rsa_kea:
                 {
                     #if defined(WOLFSSL_RENESAS_TSIP_TLS) && \
                        !defined(NO_WOLFSSL_RENESAS_TSIP_TLS_SESSION)
                     if (tsip_useable(ssl) &&
                                      wc_RsaEncryptSize(ssl->peerRsaKey) == 256) {
                         ret = tsip_generateEncryptPreMasterSecret(ssl,
                                                             args->encSecret,
                                                             &args->encSz);
 
                     } else
                     #endif
                         ret = RsaEnc(ssl,
                             ssl->arrays->preMasterSecret, SECRET_LEN,
                             args->encSecret, &args->encSz,
                             ssl->peerRsaKey,
                         #if defined(HAVE_PK_CALLBACKS)
                             &ssl->buffers.peerRsaKey
                         #else
                             NULL
                         #endif
                         );
 
                     break;
                 }
             #endif /* !NO_RSA */
             #ifndef NO_DH
                 case diffie_hellman_kea:
                 {
                     ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                         ssl->buffers.sig.buffer, ssl->buffers.sig.length,
                         ssl->buffers.serverDH_Pub.buffer,
                         ssl->buffers.serverDH_Pub.length,
                         ssl->arrays->preMasterSecret,
                         &ssl->arrays->preMasterSz);
                     break;
                 }
             #endif /* !NO_DH */
             #ifndef NO_PSK
                 case psk_kea:
                 {
                     break;
                 }
             #endif /* !NO_PSK */
             #if !defined(NO_DH) && !defined(NO_PSK)
                 case dhe_psk_kea:
                 {
                     ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                         ssl->buffers.sig.buffer, ssl->buffers.sig.length,
                         ssl->buffers.serverDH_Pub.buffer,
                         ssl->buffers.serverDH_Pub.length,
                         ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                         &ssl->arrays->preMasterSz);
                     break;
                 }
             #endif /* !NO_DH && !NO_PSK */
             #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                 case ecdhe_psk_kea:
                 {
                 #ifdef HAVE_CURVE25519
                     if (ssl->peerX25519KeyPresent) {
                         ret = X25519SharedSecret(ssl,
                             (curve25519_key*)ssl->hsKey, ssl->peerX25519Key,
                             args->output + OPAQUE8_LEN, &args->length,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_CLIENT_END
                         );
                         if (!ssl->specs.static_ecdh
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                         #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                    (void**)&ssl->peerX25519Key);
                             ssl->peerX25519KeyPresent = 0;
                         }
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->peerX448KeyPresent) {
                         ret = X448SharedSecret(ssl,
                             (curve448_key*)ssl->hsKey, ssl->peerX448Key,
                             args->output + OPAQUE8_LEN, &args->length,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_CLIENT_END
                         );
                         if (!ssl->specs.static_ecdh
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                         #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                      (void**)&ssl->peerX448Key);
                             ssl->peerX448KeyPresent = 0;
                         }
                         break;
                     }
                 #endif
                     ret = EccSharedSecret(ssl,
                         (ecc_key*)ssl->hsKey, ssl->peerEccKey,
                         args->output + OPAQUE8_LEN, &args->length,
                         ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                         &ssl->arrays->preMasterSz,
                         WOLFSSL_CLIENT_END
                     );
                 #ifdef WOLFSSL_ASYNC_CRYPT
                     if (ret != WC_PENDING_E)
                 #endif
                     {
                         FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                         ssl->peerEccKeyPresent = 0;
                     }
                     break;
                 }
             #endif /* (HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448) && !NO_PSK */
             #ifdef HAVE_NTRU
                 case ntru_kea:
                 {
                     word32 rc;
                     word16 tmpEncSz = (word16)args->encSz;
                     DRBG_HANDLE drbg;
 
                     rc = ntru_crypto_drbg_external_instantiate(GetEntropy, &drbg);
                     if (rc != DRBG_OK) {
                         ERROR_OUT(NTRU_DRBG_ERROR, exit_scke);
                     }
                     rc = ntru_crypto_ntru_encrypt(drbg, ssl->peerNtruKeyLen,
                                                   ssl->peerNtruKey,
                                                   ssl->arrays->preMasterSz,
                                                   ssl->arrays->preMasterSecret,
                                                   &tmpEncSz,
                                                   args->encSecret);
                     args->encSz = tmpEncSz;
                     ntru_crypto_drbg_uninstantiate(drbg);
                     if (rc != NTRU_OK) {
                         ERROR_OUT(NTRU_ENCRYPT_ERROR, exit_scke);
                     }
                     ret = 0;
                     break;
                 }
             #endif /* HAVE_NTRU */
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 case ecc_diffie_hellman_kea:
                 {
                 #ifdef HAVE_ECC
                     ecc_key* peerKey;
                 #endif
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->peerX25519KeyPresent) {
                         ret = X25519SharedSecret(ssl,
                             (curve25519_key*)ssl->hsKey, ssl->peerX25519Key,
                             args->encSecret + OPAQUE8_LEN, &args->encSz,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_CLIENT_END
                         );
                         if (!ssl->specs.static_ecdh
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                         #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                    (void**)&ssl->peerX25519Key);
                             ssl->peerX25519KeyPresent = 0;
                         }
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->peerX448KeyPresent) {
                         ret = X448SharedSecret(ssl,
                             (curve448_key*)ssl->hsKey, ssl->peerX448Key,
                             args->encSecret + OPAQUE8_LEN, &args->encSz,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_CLIENT_END
                         );
                         if (!ssl->specs.static_ecdh
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                         #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                      (void**)&ssl->peerX448Key);
                             ssl->peerX448KeyPresent = 0;
                         }
                         break;
                     }
                 #endif
                 #ifdef HAVE_ECC
                     peerKey = (ssl->specs.static_ecdh) ?
                               ssl->peerEccDsaKey : ssl->peerEccKey;
 
                     ret = EccSharedSecret(ssl,
                         (ecc_key*)ssl->hsKey, peerKey,
                         args->encSecret + OPAQUE8_LEN, &args->encSz,
                         ssl->arrays->preMasterSecret,
                         &ssl->arrays->preMasterSz,
                         WOLFSSL_CLIENT_END
                     );
                     if (!ssl->specs.static_ecdh
                 #ifdef WOLFSSL_ASYNC_CRYPT
                         && ret != WC_PENDING_E
                 #endif
                      && !ssl->options.keepResources) {
                         FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                         ssl->peerEccKeyPresent = 0;
                     }
                 #endif
 
                     break;
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 default:
                     ret = BAD_KEA_TYPE_E;
             } /* switch(ssl->specs.kea) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_scke;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_VERIFY;
         } /* case TLS_ASYNC_DO */
         FALL_THROUGH;
 
         case TLS_ASYNC_VERIFY:
         {
             switch(ssl->specs.kea)
             {
             #ifndef NO_RSA
                 case rsa_kea:
                 {
                     break;
                 }
             #endif /* !NO_RSA */
             #ifndef NO_DH
                 case diffie_hellman_kea:
                 {
                     break;
                 }
             #endif /* !NO_DH */
             #ifndef NO_PSK
                 case psk_kea:
                 {
                     break;
                 }
             #endif /* !NO_PSK */
             #if !defined(NO_DH) && !defined(NO_PSK)
                 case dhe_psk_kea:
                 {
                     byte* pms = ssl->arrays->preMasterSecret;
 
                     /* validate args */
                     if (args->output == NULL || args->length == 0) {
                         ERROR_OUT(BAD_FUNC_ARG, exit_scke);
                     }
 
                     c16toa((word16)args->length, args->output);
                     args->encSz += args->length + OPAQUE16_LEN;
                     c16toa((word16)ssl->arrays->preMasterSz, pms);
                     ssl->arrays->preMasterSz += OPAQUE16_LEN;
                     pms += ssl->arrays->preMasterSz;
 
                     /* make psk pre master secret */
                     /* length of key + length 0s + length of key + key */
                     c16toa((word16)ssl->arrays->psk_keySz, pms);
                     pms += OPAQUE16_LEN;
                     XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->preMasterSz +=
                                          ssl->arrays->psk_keySz + OPAQUE16_LEN;
                     ForceZero(ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->psk_keySz = 0; /* No further need */
                     break;
                 }
             #endif /* !NO_DH && !NO_PSK */
             #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                 case ecdhe_psk_kea:
                 {
                     byte* pms = ssl->arrays->preMasterSecret;
 
                     /* validate args */
                     if (args->output == NULL || args->length > ENCRYPT_LEN) {
                         ERROR_OUT(BAD_FUNC_ARG, exit_scke);
                     }
 
                     /* place size of public key in output buffer */
                     *args->output = (byte)args->length;
                     args->encSz += args->length + OPAQUE8_LEN;
 
                     /* Create pre master secret is the concatenation of
                        eccSize + eccSharedKey + pskSize + pskKey */
                     c16toa((word16)ssl->arrays->preMasterSz, pms);
                     ssl->arrays->preMasterSz += OPAQUE16_LEN;
                     pms += ssl->arrays->preMasterSz;
 
                     c16toa((word16)ssl->arrays->psk_keySz, pms);
                     pms += OPAQUE16_LEN;
                     XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->preMasterSz +=
                                           ssl->arrays->psk_keySz + OPAQUE16_LEN;
 
                     ForceZero(ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->psk_keySz = 0; /* No further need */
                     break;
                 }
             #endif /* (HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448) && !NO_PSK */
             #ifdef HAVE_NTRU
                 case ntru_kea:
                 {
                     break;
                 }
             #endif /* HAVE_NTRU */
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 case ecc_diffie_hellman_kea:
                 {
                     /* place size of public key in buffer */
                     *args->encSecret = (byte)args->encSz;
                     args->encSz += OPAQUE8_LEN;
                     break;
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 default:
                     ret = BAD_KEA_TYPE_E;
             } /* switch(ssl->specs.kea) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_scke;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_FINALIZE;
         } /* case TLS_ASYNC_VERIFY */
         FALL_THROUGH;
 
         case TLS_ASYNC_FINALIZE:
         {
             word32 tlsSz = 0;
             word32 idx = 0;
 
         #ifdef HAVE_QSH
             word32 qshSz = 0;
             if (ssl->peerQSHKeyPresent) {
                 qshSz = QSH_KeyGetSize(ssl);
             }
         #endif
 
             if (ssl->options.tls || ssl->specs.kea == diffie_hellman_kea) {
                 tlsSz = 2;
             }
 
             if (ssl->specs.kea == ecc_diffie_hellman_kea ||
                 ssl->specs.kea == dhe_psk_kea ||
                 ssl->specs.kea == ecdhe_psk_kea) { /* always off */
                 tlsSz = 0;
             }
 
             idx = HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
             args->sendSz = args->encSz + tlsSz + idx;
 
         #ifdef WOLFSSL_DTLS
             if (ssl->options.dtls) {
                 idx    += DTLS_HANDSHAKE_EXTRA + DTLS_RECORD_EXTRA;
                 args->sendSz += DTLS_HANDSHAKE_EXTRA + DTLS_RECORD_EXTRA;
             }
         #endif
 
             if (IsEncryptionOn(ssl, 1)) {
                 args->sendSz += MAX_MSG_EXTRA;
             }
 
         #ifdef HAVE_QSH
             args->encSz += qshSz;
             args->sendSz += qshSz;
         #endif
 
             /* check for available size */
             if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                 goto exit_scke;
             }
 
             /* get output buffer */
             args->output = ssl->buffers.outputBuffer.buffer +
                            ssl->buffers.outputBuffer.length;
 
         #ifdef HAVE_QSH
             if (ssl->peerQSHKeyPresent) {
                 byte idxSave = idx;
                 idx = args->sendSz - qshSz;
 
                 if (QSH_KeyExchangeWrite(ssl, 0) != 0) {
                     ERROR_OUT(MEMORY_E, exit_scke);
                 }
 
                 /* extension type */
                 c16toa(TLSX_QUANTUM_SAFE_HYBRID, args->output + idx);
                 idx += OPAQUE16_LEN;
 
                 /* write to output and check amount written */
                 if (TLSX_QSHPK_Write(ssl->QSH_secret->list,
                             args->output + idx) > qshSz - OPAQUE16_LEN) {
                     ERROR_OUT(MEMORY_E, exit_scke);
                 }
 
                 idx = idxSave;
             }
         #endif
 
             AddHeaders(args->output, args->encSz + tlsSz, client_key_exchange, ssl);
 
         #ifdef HAVE_QSH
             if (ssl->peerQSHKeyPresent) {
                 args->encSz -= qshSz;
             }
         #endif
             if (tlsSz) {
                 c16toa((word16)args->encSz, &args->output[idx]);
                 idx += OPAQUE16_LEN;
             }
             XMEMCPY(args->output + idx, args->encSecret, args->encSz);
             idx += args->encSz;
 
             if (IsEncryptionOn(ssl, 1)) {
                 int recordHeaderSz = RECORD_HEADER_SZ;
 
                 if (ssl->options.dtls)
                     recordHeaderSz += DTLS_RECORD_EXTRA;
                 args->inputSz = idx - recordHeaderSz; /* buildmsg adds rechdr */
                 args->input = (byte*)XMALLOC(args->inputSz, ssl->heap,
                                                        DYNAMIC_TYPE_IN_BUFFER);
                 if (args->input == NULL) {
                     ERROR_OUT(MEMORY_E, exit_scke);
                 }
 
                 XMEMCPY(args->input, args->output + recordHeaderSz,
                                                                 args->inputSz);
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_END;
         } /* case TLS_ASYNC_FINALIZE */
         FALL_THROUGH;
 
         case TLS_ASYNC_END:
         {
             if (IsEncryptionOn(ssl, 1)) {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl) &&
                         (ret = DtlsMsgPoolSave(ssl, args->input, args->inputSz, client_key_exchange)) != 0) {
                     goto exit_scke;
                 }
             #endif
                 ret = BuildMessage(ssl, args->output, args->sendSz,
                             args->input, args->inputSz, handshake, 1, 0, 0, CUR_ORDER);
                 XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 args->input = NULL; /* make sure its not double free'd on cleanup */
 
                 if (ret >= 0) {
                     args->sendSz = ret;
                     ret = 0;
                 }
             }
             else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, args->output, args->sendSz, client_key_exchange)) != 0) {
                         goto exit_scke;
                     }
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
                 ret = HashOutput(ssl, args->output, args->sendSz, 0);
             }
 
             if (ret != 0) {
                 goto exit_scke;
             }
 
         #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
             if (ssl->hsInfoOn)
                 AddPacketName(ssl, "ClientKeyExchange");
             if (ssl->toInfoOn)
                 AddPacketInfo(ssl, "ClientKeyExchange", handshake,
                             args->output, args->sendSz, WRITE_PROTO, ssl->heap);
         #endif
 
             ssl->buffers.outputBuffer.length += args->sendSz;
 
             if (!ssl->options.groupMessages) {
                 ret = SendBuffered(ssl);
             }
             if (ret == 0 || ret == WANT_WRITE) {
                 int tmpRet = MakeMasterSecret(ssl);
                 if (tmpRet != 0) {
                     ret = tmpRet;   /* save WANT_WRITE unless more serious */
                 }
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
             }
             break;
         }
         default:
             ret = INPUT_CASE_ERROR;
     } /* switch(ssl->options.asyncState) */
@@ -24556,5532 +24556,5536 @@ int SetTicket(WOLFSSL* ssl, const byte* ticket, word32 length)
 /* handle processing of session_ticket (4) */
 static int DoSessionTicket(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
     word32 size)
 {
     word32 begin = *inOutIdx;
     word32 lifetime;
     word16 length;
     int    ret;
 
     if (ssl->expect_session_ticket == 0) {
         WOLFSSL_MSG("Unexpected session ticket");
         return SESSION_TICKET_EXPECT_E;
     }
 
     if (OPAQUE32_LEN > size)
         return BUFFER_ERROR;
 
     ato32(input + *inOutIdx, &lifetime);
     *inOutIdx += OPAQUE32_LEN;
 
     if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
         return BUFFER_ERROR;
 
     ato16(input + *inOutIdx, &length);
     *inOutIdx += OPAQUE16_LEN;
 
     if ((*inOutIdx - begin) + length > size)
         return BUFFER_ERROR;
 
     if ((ret = SetTicket(ssl, input + *inOutIdx, length)) != 0)
         return ret;
     *inOutIdx += length;
     if (length > 0) {
         ssl->timeout = lifetime;
 #ifndef NO_SESSION_CACHE
         AddSession(ssl);
 #endif
     }
 
     if (IsEncryptionOn(ssl, 0)) {
         *inOutIdx += ssl->keys.padSz;
     #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
         if (ssl->options.startedETMRead)
             *inOutIdx += MacSize(ssl);
     #endif
     }
 
     ssl->expect_session_ticket = 0;
 
     return 0;
 }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #endif /* HAVE_SESSION_TICKET */
 
 #endif /* NO_WOLFSSL_CLIENT */
 
 #ifndef NO_CERTS
 
 #ifdef HAVE_PK_CALLBACKS
     int GetPrivateKeySigSize(WOLFSSL* ssl)
     {
         int sigSz = 0;
 
         if (ssl == NULL)
             return 0;
 
         switch (ssl->buffers.keyType) {
         #ifndef NO_RSA
         #ifdef WC_RSA_PSS
             case rsa_pss_sa_algo:
         #endif
             case rsa_sa_algo:
                 sigSz = ssl->buffers.keySz;
                 ssl->hsType = DYNAMIC_TYPE_RSA;
                 break;
         #endif
         #ifdef HAVE_ECC
             case ecc_dsa_sa_algo:
                 sigSz = wc_ecc_sig_size_calc(ssl->buffers.keySz);
                 ssl->hsType = DYNAMIC_TYPE_ECC;
                 break;
         #endif
         #ifdef HAVE_ED25519
             case ed25519_sa_algo:
                 sigSz = ED25519_SIG_SIZE; /* fixed known value */
                 ssl->hsType = DYNAMIC_TYPE_ED25519;
                 break;
         #endif
         #ifdef HAVE_ED448
             case ed448_sa_algo:
                 sigSz = ED448_SIG_SIZE; /* fixed known value */
                 ssl->hsType = DYNAMIC_TYPE_ED448;
                 break;
         #endif
             default:
                 break;
         }
         return sigSz;
     }
 #endif /* HAVE_PK_CALLBACKS */
 
 #endif /* NO_CERTS */
 
 #ifdef HAVE_ECC
     /* returns the WOLFSSL_* version of the curve from the OID sum */
     word16 GetCurveByOID(int oidSum) {
         switch(oidSum) {
     #if defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP160R1_OID:
                 return WOLFSSL_ECC_SECP160R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_SECPR2
             case ECC_SECP160R2_OID:
                 return WOLFSSL_ECC_SECP160R2;
         #endif /* HAVE_ECC_SECPR2 */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP160K1_OID:
                 return WOLFSSL_ECC_SECP160K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP192R1_OID:
                 return WOLFSSL_ECC_SECP192R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP192K1_OID:
                 return WOLFSSL_ECC_SECP192K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP224R1_OID:
                 return WOLFSSL_ECC_SECP224R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP224K1_OID:
                 return WOLFSSL_ECC_SECP224K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if !defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP256R1_OID:
                 return WOLFSSL_ECC_SECP256R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP256K1_OID:
                 return WOLFSSL_ECC_SECP256K1;
         #endif /* HAVE_ECC_KOBLITZ */
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP256R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP256R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP384R1_OID:
                 return WOLFSSL_ECC_SECP384R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP384R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP384R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP512R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP512R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP521R1_OID:
                 return WOLFSSL_ECC_SECP521R1;
         #endif /* !NO_ECC_SECP */
     #endif
             default:
                 WOLFSSL_MSG("Curve OID not compiled in or implemented");
                 return 0;
         }
     }
 #endif /* HAVE_ECC */
 
 
 #ifndef NO_WOLFSSL_SERVER
 
 #ifndef WOLFSSL_NO_TLS12
 
     /* handle generation of server_hello (2) */
     int SendServerHello(WOLFSSL* ssl)
     {
         int    ret;
         byte   *output;
         word16 length;
         word32 idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int    sendSz;
         byte   sessIdSz = ID_LEN;
         byte   echoId   = 0;  /* ticket echo id flag */
         byte   cacheOff = 0;  /* session cache off flag */
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_SEND);
         WOLFSSL_ENTER("SendServerHello");
 
         length = VERSION_SZ + RAN_LEN
                + ID_LEN + ENUM_LEN
                + SUITE_LEN
                + ENUM_LEN;
 
 #ifdef HAVE_TLS_EXTENSIONS
         ret = TLSX_GetResponseSize(ssl, server_hello, &length);
         if (ret != 0)
             return ret;
     #ifdef HAVE_SESSION_TICKET
         if (ssl->options.useTicket) {
             /* echo session id sz can be 0,32 or bogus len in between */
             sessIdSz = ssl->arrays->sessionIDSz;
             if (sessIdSz > ID_LEN) {
                 WOLFSSL_MSG("Bad bogus session id len");
                 return BUFFER_ERROR;
             }
             if (!IsAtLeastTLSv1_3(ssl->version))
                 length -= (ID_LEN - sessIdSz);  /* adjust ID_LEN assumption */
             echoId = 1;
         }
     #endif /* HAVE_SESSION_TICKET */
 #else
         if (ssl->options.haveEMS) {
             length += HELLO_EXT_SZ_SZ + HELLO_EXT_SZ;
         }
 #endif
 
         /* is the session cache off at build or runtime */
 #ifdef NO_SESSION_CACHE
         cacheOff = 1;
 #else
         if (ssl->options.sessionCacheOff == 1) {
             cacheOff = 1;
         }
 #endif
 
         /* if no session cache don't send a session ID unless we're echoing
          * an ID as part of session tickets */
         if (echoId == 0 && cacheOff == 1) {
             length -= ID_LEN;    /* adjust ID_LEN assumption */
             sessIdSz = 0;
         }
 
         sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
         #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             /* Server Hello should use the same sequence number as the
              * Client Hello. */
             ssl->keys.dtls_sequence_number_hi = ssl->keys.curSeq_hi;
             ssl->keys.dtls_sequence_number_lo = ssl->keys.curSeq_lo;
             idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
         }
         #endif /* WOLFSSL_DTLS */
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, length, server_hello, ssl);
 
         /* now write to output */
         /* first version */
         output[idx++] = (byte)ssl->version.major;
         output[idx++] = (byte)ssl->version.minor;
 
         /* then random and session id */
         if (!ssl->options.resuming) {
             /* generate random part and session id */
             ret = wc_RNG_GenerateBlock(ssl->rng, output + idx,
                 RAN_LEN + sizeof(sessIdSz) + sessIdSz);
             if (ret != 0)
                 return ret;
 
 #ifdef WOLFSSL_TLS13
             if (TLSv1_3_Capable(ssl)) {
                 /* TLS v1.3 capable server downgraded. */
                 XMEMCPY(output + idx + RAN_LEN - (TLS13_DOWNGRADE_SZ + 1),
                         tls13Downgrade, TLS13_DOWNGRADE_SZ);
                 output[idx + RAN_LEN - 1] = (byte)IsAtLeastTLSv1_2(ssl);
             }
             else
 #endif
             if (ssl->ctx->method->version.major == SSLv3_MAJOR &&
                           ssl->ctx->method->version.minor == TLSv1_2_MINOR &&
 #ifdef OPENSSL_EXTRA
                           (wolfSSL_get_options(ssl) & SSL_OP_NO_TLSv1_2) == 0 &&
 #endif
                                                        !IsAtLeastTLSv1_2(ssl)) {
                 /* TLS v1.2 capable server downgraded. */
                 XMEMCPY(output + idx + RAN_LEN - (TLS13_DOWNGRADE_SZ + 1),
                         tls13Downgrade, TLS13_DOWNGRADE_SZ);
                 output[idx + RAN_LEN - 1] = 0;
             }
 
             /* store info in SSL for later */
             XMEMCPY(ssl->arrays->serverRandom, output + idx, RAN_LEN);
             idx += RAN_LEN;
             output[idx++] = sessIdSz;
             XMEMCPY(ssl->arrays->sessionID, output + idx, sessIdSz);
             ssl->arrays->sessionIDSz = sessIdSz;
         }
         else {
             /* If resuming, use info from SSL */
             XMEMCPY(output + idx, ssl->arrays->serverRandom, RAN_LEN);
             idx += RAN_LEN;
             output[idx++] = sessIdSz;
             XMEMCPY(output + idx, ssl->arrays->sessionID, sessIdSz);
         }
         idx += sessIdSz;
 
 #ifdef SHOW_SECRETS
         {
             int j;
             printf("server random: ");
             for (j = 0; j < RAN_LEN; j++)
                 printf("%02x", ssl->arrays->serverRandom[j]);
             printf("\n");
         }
 #endif
 
         /* then cipher suite */
         output[idx++] = ssl->options.cipherSuite0;
         output[idx++] = ssl->options.cipherSuite;
 
         /* then compression */
         if (ssl->options.usingCompression)
             output[idx++] = ZLIB_COMPRESSION;
         else
             output[idx++] = NO_COMPRESSION;
 
         /* last, extensions */
 #ifdef HAVE_TLS_EXTENSIONS
         {
             word16 offset = 0;
             ret = TLSX_WriteResponse(ssl, output + idx, server_hello, &offset);
             if (ret != 0)
                 return ret;
             idx += offset;
         }
 #else
 #ifdef HAVE_EXTENDED_MASTER
         if (ssl->options.haveEMS) {
             c16toa(HELLO_EXT_SZ, output + idx);
             idx += HELLO_EXT_SZ_SZ;
 
             c16toa(HELLO_EXT_EXTMS, output + idx);
             idx += HELLO_EXT_TYPE_SZ;
             c16toa(0, output + idx);
             /*idx += HELLO_EXT_SZ_SZ;*/
             /* idx is not used after this point. uncomment the line above
              * if adding any more extensions in the future. */
         }
 #endif
 #endif
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, server_hello)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, server_hello)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ServerHello");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "ServerHello", handshake, output, sendSz,
                           WRITE_PROTO, ssl->heap);
     #endif
 
         ssl->options.serverState = SERVER_HELLO_COMPLETE;
         ssl->buffers.outputBuffer.length += sendSz;
 
         if (ssl->options.groupMessages)
             ret = 0;
         else
             ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendServerHello", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_SEND);
 
         return ret;
     }
 
 
 #if defined(HAVE_ECC)
 
     static byte SetCurveId(ecc_key* key)
     {
         if (key == NULL || key->dp == NULL) {
             WOLFSSL_MSG("SetCurveId: Invalid key!");
             return 0;
         }
 
         return (byte)GetCurveByOID(key->dp->oidSum);
     }
 
 #endif /* HAVE_ECC */
 
     typedef struct SskeArgs {
         byte*  output; /* not allocated */
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                                                 !defined(NO_RSA)
         byte*  sigDataBuf;
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         byte*  exportBuf;
     #endif
     #ifndef NO_RSA
         byte*  verifySig;
     #endif
         byte*  input;
         word32 idx;
         word32 tmpSigSz;
         word32 length;
         word32 sigSz;
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                                                 !defined(NO_RSA)
         word32 sigDataSz;
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         word32 exportSz;
     #endif
     #ifdef HAVE_QSH
         word32 qshSz;
     #endif
         int    sendSz;
         int    inputSz;
     } SskeArgs;
 
     static void FreeSskeArgs(WOLFSSL* ssl, void* pArgs)
     {
         SskeArgs* args = (SskeArgs*)pArgs;
 
         (void)ssl;
 
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         if (args->exportBuf) {
             XFREE(args->exportBuf, ssl->heap, DYNAMIC_TYPE_DER);
             args->exportBuf = NULL;
         }
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                            (!defined(NO_DH) && !defined(NO_RSA))
         if (args->sigDataBuf) {
             XFREE(args->sigDataBuf, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
             args->sigDataBuf = NULL;
         }
     #endif
     #ifndef NO_RSA
         if (args->verifySig) {
             XFREE(args->verifySig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
             args->verifySig = NULL;
         }
     #endif
         (void)args;
     }
 
     /* handle generation of server_key_exchange (12) */
     int SendServerKeyExchange(WOLFSSL* ssl)
     {
         int ret;
     #ifdef WOLFSSL_ASYNC_CRYPT
         SskeArgs* args = (SskeArgs*)ssl->async.args;
         typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
         (void)sizeof(args_test);
     #else
         SskeArgs  args[1];
     #endif
 
         WOLFSSL_START(WC_FUNC_SERVER_KEY_EXCHANGE_SEND);
         WOLFSSL_ENTER("SendServerKeyExchange");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NOT_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_sske;
         }
         else
     #endif
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(SskeArgs));
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async.freeArgs = FreeSskeArgs;
         #endif
         }
 
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
             #ifdef HAVE_QSH
                 if (ssl->peerQSHKeyPresent && ssl->options.haveQSH) {
                     args->qshSz = QSH_KeyGetSize(ssl);
                 }
             #endif
 
                 /* Do some checks / debug msgs */
                 switch(ssl->specs.kea)
                 {
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         WOLFSSL_MSG("Using ephemeral ECDH PSK");
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC)
                     case ecc_diffie_hellman_kea:
                     {
                         if (ssl->specs.static_ecdh) {
                             WOLFSSL_MSG("Using Static ECDH, not sending "
                                         "ServerKeyExchange");
                             ERROR_OUT(0, exit_sske);
                         }
 
                         WOLFSSL_MSG("Using ephemeral ECDH");
                         break;
                     }
                 #endif /* HAVE_ECC */
                 }
 
                 /* Preparing keys */
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && (!defined(NO_PSK) || !defined(NO_RSA))
                 #if !defined(NO_PSK)
                     case dhe_psk_kea:
                 #endif
                 #if !defined(NO_RSA)
                     case diffie_hellman_kea:
                 #endif
                     {
                         /* Allocate DH key buffers and generate key */
                         if (ssl->buffers.serverDH_P.buffer == NULL ||
                             ssl->buffers.serverDH_G.buffer == NULL) {
                             ERROR_OUT(NO_DH_PARAMS, exit_sske);
                         }
 
                         if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and FreeHandshakeResources */
                             ssl->buffers.serverDH_Pub.buffer = (byte*)XMALLOC(
                                     ssl->buffers.serverDH_P.length + OPAQUE16_LEN,
                                     ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
                             if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
+                            ssl->buffers.serverDH_Pub.length =
+                                ssl->buffers.serverDH_P.length + OPAQUE16_LEN;
                         }
 
                         if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and FreeHandshakeResources */
                             ssl->buffers.serverDH_Priv.buffer = (byte*)XMALLOC(
                                     ssl->buffers.serverDH_P.length + OPAQUE16_LEN,
                                     ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
                             if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
+                            ssl->buffers.serverDH_Priv.length =
+                                ssl->buffers.serverDH_P.length + OPAQUE16_LEN;
                         }
 
                         ssl->options.dhKeySz =
                                 (word16)ssl->buffers.serverDH_P.length;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_sske;
                         }
 
                         #if !defined(WOLFSSL_OLD_PRIME_CHECK) && \
                             !defined(HAVE_FIPS) && \
                             !defined(HAVE_SELFTEST)
                         if (ssl->options.dhDoKeyTest &&
                             !ssl->options.dhKeyTested)
                         {
                             ret = wc_DhSetCheckKey(
                                 ssl->buffers.serverDH_Key,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length,
                                 NULL, 0, 0, ssl->rng);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                             ssl->options.dhKeyTested = 1;
                         }
                         else
                         #endif
                         {
                             ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         ret = DhGenKeyPair(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             (word32*)&ssl->buffers.serverDH_Priv.length,
                             ssl->buffers.serverDH_Pub.buffer,
                             (word32*)&ssl->buffers.serverDH_Pub.length);
                         break;
                     }
                 #endif /* !NO_DH && (!NO_PSK || !NO_RSA) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                         /* Fall through to create temp ECC key */
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             /* need ephemeral key now, create it if missing */
                             if (ssl->eccTempKey == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->eccTempKey);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 ret = X25519MakeKey(ssl,
                                         (curve25519_key*)ssl->eccTempKey, NULL);
                                 if (ret == 0 || ret == WC_PENDING_E) {
                                     ssl->eccTempKeyPresent =
                                         DYNAMIC_TYPE_CURVE25519;
                                 }
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             /* need ephemeral key now, create it if missing */
                             if (ssl->eccTempKey == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->eccTempKey);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 ret = X448MakeKey(ssl,
                                           (curve448_key*)ssl->eccTempKey, NULL);
                                 if (ret == 0 || ret == WC_PENDING_E) {
                                     ssl->eccTempKeyPresent =
                                         DYNAMIC_TYPE_CURVE448;
                                 }
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_ECC
                         /* need ephemeral key now, create it if missing */
                         if (ssl->eccTempKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->eccTempKey);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         if (ssl->eccTempKeyPresent == 0) {
                             ret = EccMakeKey(ssl, ssl->eccTempKey, NULL);
                             if (ret == 0 || ret == WC_PENDING_E) {
                                 ssl->eccTempKeyPresent = DYNAMIC_TYPE_ECC;
                             }
                         }
                     #endif
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                     default:
                         /* Skip ServerKeyExchange */
                         goto exit_sske;
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* case TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
             #if (!defined(NO_DH) && !defined(NO_RSA)) || (defined(HAVE_ECC) || \
                              defined(HAVE_CURVE25519) || defined(HAVE_CURVE448))
                 word32 preSigSz, preSigIdx;
             #endif
 
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
 
                         if (ssl->arrays->server_hint[0] == 0) {
                             ERROR_OUT(0, exit_sske); /* don't send */
                         }
 
                         /* include size part */
                         args->length = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (args->length > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
 
                         args->length += HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
 
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* key data */
                     #ifdef HAVE_QSH
                         c16toa((word16)(args->length - args->qshSz -
                                         HINT_LEN_SZ), args->output + args->idx);
                     #else
                         c16toa((word16)(args->length - HINT_LEN_SZ),
                                                       args->output + args->idx);
                     #endif
 
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->arrays->server_hint,
                                 args->length - HINT_LEN_SZ);
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         word32 hintLen;
 
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = LENGTH_SZ * 3 + /* p, g, pub */
                                  ssl->buffers.serverDH_P.length +
                                  ssl->buffers.serverDH_G.length +
                                  ssl->buffers.serverDH_Pub.length;
 
                         /* include size part */
                         hintLen = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (hintLen > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
                         args->length += hintLen + HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* key data */
                         c16toa((word16)hintLen, args->output + args->idx);
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                             ssl->arrays->server_hint, hintLen);
                         args->idx += hintLen;
 
                         /* add p, g, pub */
                         c16toa((word16)ssl->buffers.serverDH_P.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length);
                         args->idx += ssl->buffers.serverDH_P.length;
 
                         /*  g */
                         c16toa((word16)ssl->buffers.serverDH_G.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length);
                         args->idx += ssl->buffers.serverDH_G.length;
 
                         /*  pub */
                         c16toa((word16)ssl->buffers.serverDH_Pub.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_Pub.buffer,
                                 ssl->buffers.serverDH_Pub.length);
                         /* No need to update idx, since sizes are already set */
                         /* args->idx += ssl->buffers.serverDH_Pub.length; */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         word32 hintLen;
 
                         /* curve type, named curve, length(1) */
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;
 
                         args->exportSz = MAX_EXPORT_ECC_SZ;
                         args->exportBuf = (byte*)XMALLOC(args->exportSz,
                                             ssl->heap, DYNAMIC_TYPE_DER);
                         if (args->exportBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             if (wc_curve25519_export_public_ex(
                                     (curve25519_key*)ssl->eccTempKey,
                                     args->exportBuf, &args->exportSz,
                                     EC25519_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             if (wc_curve448_export_public_ex(
                                     (curve448_key*)ssl->eccTempKey,
                                     args->exportBuf, &args->exportSz,
                                     EC448_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                         {
                             if (wc_ecc_export_x963(ssl->eccTempKey,
                                        args->exportBuf, &args->exportSz) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         args->length += args->exportSz;
 
                         /* include size part */
                         hintLen = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (hintLen > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
                         args->length += hintLen + HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         /* key data */
                         c16toa((word16)hintLen, args->output + args->idx);
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                             ssl->arrays->server_hint, hintLen);
                         args->idx += hintLen;
 
                         /* ECC key exchange data */
                         args->output[args->idx++] = named_curve;
                         args->output[args->idx++] = 0x00;          /* leading zero */
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X25519;
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X448;
                         else
                     #endif
                         {
                     #ifdef HAVE_ECC
                             args->output[args->idx++] =
                                                     SetCurveId(ssl->eccTempKey);
                     #endif
                         }
                         args->output[args->idx++] = (byte)args->exportSz;
                         XMEMCPY(args->output + args->idx, args->exportBuf,
                                                                 args->exportSz);
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         enum wc_HashType hashType;
 
                         /* curve type, named curve, length(1) */
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;
 
                         /* Export temp ECC key and add to length */
                         args->exportSz = MAX_EXPORT_ECC_SZ;
                         args->exportBuf = (byte*)XMALLOC(args->exportSz,
                                             ssl->heap, DYNAMIC_TYPE_DER);
                         if (args->exportBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             if (wc_curve25519_export_public_ex(
                                         (curve25519_key*)ssl->eccTempKey,
                                         args->exportBuf, &args->exportSz,
                                         EC25519_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             if (wc_curve448_export_public_ex(
                                         (curve448_key*)ssl->eccTempKey,
                                         args->exportBuf, &args->exportSz,
                                         EC448_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                         {
                     #if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)
                             if (wc_ecc_export_x963(ssl->eccTempKey,
                                        args->exportBuf, &args->exportSz) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                      #endif
                         }
                         args->length += args->exportSz;
 
                         preSigSz  = args->length;
                         preSigIdx = args->idx;
 
                         if (ssl->buffers.key == NULL) {
                         #ifdef HAVE_PK_CALLBACKS
                             if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)) {
                                 args->tmpSigSz = GetPrivateKeySigSize(ssl);
                                 if (args->tmpSigSz == 0) {
                                     ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                                 }
                             }
                             else
                         #endif
                                 ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                         }
                         else {
                             switch(ssl->suites->sigAlgo) {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = rsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 args->tmpSigSz = (word32)keySz;
                                 break;
                             }
                         #endif /* !NO_RSA */
                         #ifdef HAVE_ECC
                             case ecc_dsa_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ecc_dsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                                 /* worst case estimate */
                                 args->tmpSigSz = keySz;
                                 break;
                             }
                         #endif
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ed25519_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 /* worst case estimate */
                                 args->tmpSigSz = ED25519_SIG_SIZE;
                                 break;
                             }
                         #endif /* HAVE_ED25519 */
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ed448_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 /* worst case estimate */
                                 args->tmpSigSz = ED448_SIG_SIZE;
                                 break;
                             }
                         #endif /* HAVE_ED448 */
                             default:
                                 ERROR_OUT(ALGO_ID_E, exit_sske);  /* unsupported type */
                             } /* switch(ssl->specs.sig_algo) */
                         }
 
                         /* sig length */
                         args->length += LENGTH_SZ;
                         args->length += args->tmpSigSz;
 
                         if (IsAtLeastTLSv1_2(ssl)) {
                             args->length += HASH_SIG_SIZE;
                         }
 
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             preSigIdx = args->idx;
                         }
                     #endif
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         /* record and message headers will be added below, when we're sure
                            of the sig length */
 
                         /* key exchange data */
                         args->output[args->idx++] = named_curve;
                         args->output[args->idx++] = 0x00;          /* leading zero */
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X25519;
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X448;
                         else
                     #endif
                         {
                     #ifdef HAVE_ECC
                             args->output[args->idx++] =
                                                     SetCurveId(ssl->eccTempKey);
                     #endif
                         }
                         args->output[args->idx++] = (byte)args->exportSz;
                         XMEMCPY(args->output + args->idx, args->exportBuf, args->exportSz);
                         args->idx += args->exportSz;
 
                         /* Determine hash type */
                         if (IsAtLeastTLSv1_2(ssl)) {
                             EncodeSigAlg(ssl->suites->hashAlgo,
                                          ssl->suites->sigAlgo,
                                          &args->output[args->idx]);
                             args->idx += 2;
 
                             hashType = HashAlgoToType(ssl->suites->hashAlgo);
                             if (hashType == WC_HASH_TYPE_NONE) {
                                 ERROR_OUT(ALGO_ID_E, exit_sske);
                             }
 
                         } else {
                             /* only using sha and md5 for rsa */
                         #ifndef NO_OLD_TLS
                             hashType = WC_HASH_TYPE_SHA;
                             if (ssl->suites->sigAlgo == rsa_sa_algo) {
                                 hashType = WC_HASH_TYPE_MD5_SHA;
                             }
                         #else
                             ERROR_OUT(ALGO_ID_E, exit_sske);
                         #endif
                         }
 
                         /* Signature length will be written later, when we're sure what it is */
 
                     #ifdef HAVE_FUZZER
                         if (ssl->fuzzerCb) {
                             ssl->fuzzerCb(ssl, args->output + preSigIdx,
                                 preSigSz, FUZZ_SIGNATURE, ssl->fuzzerCtx);
                         }
                     #endif
 
                         /* Assemble buffer to hash for signature */
                         args->sigDataSz = RAN_LEN + RAN_LEN + preSigSz;
                         args->sigDataBuf = (byte*)XMALLOC(args->sigDataSz,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                         if (args->sigDataBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                         XMEMCPY(args->sigDataBuf, ssl->arrays->clientRandom,
                                                                        RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN,
                                             ssl->arrays->serverRandom, RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN+RAN_LEN,
                                 args->output + preSigIdx, preSigSz);
 
                         if (ssl->suites->sigAlgo != ed25519_sa_algo &&
                                         ssl->suites->sigAlgo != ed448_sa_algo) {
                             ssl->buffers.sig.length =
                                                  wc_HashGetDigestSize(hashType);
                             if ((int)ssl->buffers.sig.length < 0) {
                                 ERROR_OUT(HASH_TYPE_E, exit_sske);
                             }
                             ssl->buffers.sig.buffer = (byte*)XMALLOC(
                                             ssl->buffers.sig.length,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                             if (ssl->buffers.sig.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
 
                             /* Perform hash */
                             ret = wc_Hash(hashType, args->sigDataBuf,
                                                        args->sigDataSz,
                                                        ssl->buffers.sig.buffer,
                                                        ssl->buffers.sig.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         args->sigSz = args->tmpSigSz;
 
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                             case rsa_sa_algo:
                             {
                                 /* For TLS 1.2 re-encode signature */
                                 if (IsAtLeastTLSv1_2(ssl)) {
                                     byte* encodedSig = (byte*)XMALLOC(
                                                   MAX_ENCODED_SIG_SZ, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     if (encodedSig == NULL) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
 
                                     ssl->buffers.sig.length =
                                         wc_EncodeSignature(encodedSig,
                                             ssl->buffers.sig.buffer,
                                             ssl->buffers.sig.length,
                                             TypeHash(ssl->suites->hashAlgo));
 
                                     /* Replace sig buffer with new one */
                                     XFREE(ssl->buffers.sig.buffer, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     ssl->buffers.sig.buffer = encodedSig;
                                 }
 
                                 /* write sig size here */
                                 c16toa((word16)args->sigSz,
                                     args->output + args->idx);
                                 args->idx += LENGTH_SZ;
                                 break;
                             }
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                                 /* write sig size here */
                                 c16toa((word16)args->sigSz,
                                     args->output + args->idx);
                                 args->idx += LENGTH_SZ;
                                 break;
                         #endif
                         #endif /* !NO_RSA */
                             case ecc_dsa_sa_algo:
                             {
                                 break;
                             }
                         #ifdef  HAVE_ED25519
                             case ed25519_sa_algo:
                                 ret = Ed25519CheckPubKey(ssl);
                                 if (ret != 0)
                                     goto exit_sske;
                                 break;
                         #endif /* HAVE_ED25519 */
                         #ifdef  HAVE_ED448
                             case ed448_sa_algo:
                                 ret = Ed448CheckPubKey(ssl);
                                 if (ret != 0)
                                     goto exit_sske;
                                 break;
                         #endif /* HAVE_ED448 */
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         enum wc_HashType hashType;
 
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = LENGTH_SZ * 3;  /* p, g, pub */
                         args->length += ssl->buffers.serverDH_P.length +
                                         ssl->buffers.serverDH_G.length +
                                         ssl->buffers.serverDH_Pub.length;
 
                         preSigIdx = args->idx;
                         preSigSz  = args->length;
 
                         if (!ssl->options.usingAnon_cipher) {
                             word16 keySz;
 
                             /* sig length */
                             args->length += LENGTH_SZ;
 
                             if (ssl->buffers.key == NULL) {
                             #ifdef HAVE_PK_CALLBACKS
                                 if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx))
                                     keySz = (word32)GetPrivateKeySigSize(ssl);
                                 else
                             #endif
                                     ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                             }
                             else
                             {
                                 if (ssl->buffers.keyType == 0)
                                     ssl->buffers.keyType = rsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (keySz == 0) { /* test if keySz has error */
                                 ERROR_OUT(keySz, exit_sske);
                             }
 
                             args->tmpSigSz = (word32)keySz;
                             args->length += args->tmpSigSz;
 
                             if (IsAtLeastTLSv1_2(ssl)) {
                                 args->length += HASH_SIG_SIZE;
                             }
                         }
 
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             preSigIdx = args->idx;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* add p, g, pub */
                         c16toa((word16)ssl->buffers.serverDH_P.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_P.buffer,
                                               ssl->buffers.serverDH_P.length);
                         args->idx += ssl->buffers.serverDH_P.length;
 
                         /*  g */
                         c16toa((word16)ssl->buffers.serverDH_G.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_G.buffer,
                                               ssl->buffers.serverDH_G.length);
                         args->idx += ssl->buffers.serverDH_G.length;
 
                         /*  pub */
                         c16toa((word16)ssl->buffers.serverDH_Pub.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_Pub.buffer,
                                               ssl->buffers.serverDH_Pub.length);
                         args->idx += ssl->buffers.serverDH_Pub.length;
 
                     #ifdef HAVE_FUZZER
                         if (ssl->fuzzerCb) {
                             ssl->fuzzerCb(ssl, args->output + preSigIdx,
                                 preSigSz, FUZZ_SIGNATURE, ssl->fuzzerCtx);
                         }
                     #endif
 
                         if (ssl->options.usingAnon_cipher) {
                             break;
                         }
 
                         /* Determine hash type */
                         if (IsAtLeastTLSv1_2(ssl)) {
                             EncodeSigAlg(ssl->suites->hashAlgo,
                                          ssl->suites->sigAlgo,
                                          &args->output[args->idx]);
                             args->idx += 2;
 
                             hashType = HashAlgoToType(ssl->suites->hashAlgo);
                             if (hashType == WC_HASH_TYPE_NONE) {
                                 ERROR_OUT(ALGO_ID_E, exit_sske);
                             }
                         } else {
                             /* only using sha and md5 for rsa */
                         #ifndef NO_OLD_TLS
                             hashType = WC_HASH_TYPE_SHA;
                             if (ssl->suites->sigAlgo == rsa_sa_algo) {
                                 hashType = WC_HASH_TYPE_MD5_SHA;
                             }
                         #else
                             ERROR_OUT(ALGO_ID_E, exit_sske);
                         #endif
                         }
 
                         /* signature size */
                         c16toa((word16)args->tmpSigSz, args->output + args->idx);
                         args->idx += LENGTH_SZ;
 
                         /* Assemble buffer to hash for signature */
                         args->sigDataSz = RAN_LEN + RAN_LEN + preSigSz;
                         args->sigDataBuf = (byte*)XMALLOC(args->sigDataSz,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                         if (args->sigDataBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                         XMEMCPY(args->sigDataBuf, ssl->arrays->clientRandom,
                                                                     RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN,
                                         ssl->arrays->serverRandom, RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN+RAN_LEN,
                             args->output + preSigIdx, preSigSz);
 
                         if (ssl->suites->sigAlgo != ed25519_sa_algo &&
                                         ssl->suites->sigAlgo != ed448_sa_algo) {
                             ssl->buffers.sig.length =
                                                  wc_HashGetDigestSize(hashType);
                             ssl->buffers.sig.buffer = (byte*)XMALLOC(
                                              ssl->buffers.sig.length, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                             if (ssl->buffers.sig.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
 
                             /* Perform hash */
                             ret = wc_Hash(hashType, args->sigDataBuf,
                                                        args->sigDataSz,
                                                        ssl->buffers.sig.buffer,
                                                        ssl->buffers.sig.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         args->sigSz = args->tmpSigSz;
 
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                             case rsa_sa_algo:
                             {
                                 /* For TLS 1.2 re-encode signature */
                                 if (IsAtLeastTLSv1_2(ssl)) {
                                     byte* encodedSig = (byte*)XMALLOC(
                                                   MAX_ENCODED_SIG_SZ, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     if (encodedSig == NULL) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
 
                                     ssl->buffers.sig.length =
                                         wc_EncodeSignature(encodedSig,
                                             ssl->buffers.sig.buffer,
                                             ssl->buffers.sig.length,
                                             TypeHash(ssl->suites->hashAlgo));
 
                                     /* Replace sig buffer with new one */
                                     XFREE(ssl->buffers.sig.buffer, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     ssl->buffers.sig.buffer = encodedSig;
                                 }
                                 break;
                             }
                         #endif /* NO_RSA */
                         } /* switch (ssl->suites->sigAlgo) */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* case TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC)  || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 ret = RsaSign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + args->idx,
                                     &args->sigSz,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key,
                                     ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif /* !NO_RSA */
                         #ifdef HAVE_ECC
                             case ecc_dsa_sa_algo:
                             {
                                 ecc_key* key = (ecc_key*)ssl->hsKey;
 
                                 ret = EccSign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif /* HAVE_ECC */
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                             {
                                 ed25519_key* key = (ed25519_key*)ssl->hsKey;
 
                                 ret = Ed25519Sign(ssl,
                                     args->sigDataBuf, args->sigDataSz,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                             {
                                 ed448_key* key = (ed448_key*)ssl->hsKey;
 
                                 ret = Ed448Sign(ssl,
                                     args->sigDataBuf, args->sigDataSz,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (ssl->options.usingAnon_cipher) {
                                     break;
                                 }
 
                                 ret = RsaSign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + args->idx,
                                     &args->sigSz,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key,
                                     ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif /* NO_RSA */
                         } /* switch (ssl->suites->sigAlgo) */
 
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* case TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) ||  \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         switch(ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (args->verifySig == NULL) {
                                     if (args->sigSz == 0) {
                                         ERROR_OUT(BAD_COND_E, exit_sske);
                                     }
                                     args->verifySig = (byte*)XMALLOC(
                                                     args->sigSz, ssl->heap,
                                                     DYNAMIC_TYPE_SIGNATURE);
                                     if (!args->verifySig) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
                                     XMEMCPY(args->verifySig,
                                         args->output + args->idx, args->sigSz);
                                 }
 
                                 /* check for signature faults */
                                 ret = VerifyRsaSign(ssl,
                                     args->verifySig, args->sigSz,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key, ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif
                             case ecc_dsa_sa_algo:
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                         #endif
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                         #endif
                             {
                                 /* Now that we know the real sig size, write it. */
                                 c16toa((word16)args->sigSz,
                                                     args->output + args->idx);
 
                                 /* And adjust length and sendSz from estimates */
                                 args->length += args->sigSz - args->tmpSigSz;
                                 args->sendSz += args->sigSz - args->tmpSigSz;
                                 break;
                             }
                             default:
                                 ERROR_OUT(ALGO_ID_E, exit_sske);  /* unsupported type */
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifndef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (ssl->options.usingAnon_cipher) {
                                     break;
                                 }
 
                                 if (args->verifySig == NULL) {
                                     if (args->sigSz == 0) {
                                         ERROR_OUT(BAD_COND_E, exit_sske);
                                     }
                                     args->verifySig = (byte*)XMALLOC(
                                                       args->sigSz, ssl->heap,
                                                       DYNAMIC_TYPE_SIGNATURE);
                                     if (!args->verifySig) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
                                     XMEMCPY(args->verifySig,
                                         args->output + args->idx, args->sigSz);
                                 }
 
                                 /* check for signature faults */
                                 ret = VerifyRsaSign(ssl,
                                     args->verifySig, args->sigSz,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key, ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif
                         } /* switch (ssl->suites->sigAlgo) */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* case TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
             #ifdef HAVE_QSH
                 if (ssl->peerQSHKeyPresent) {
                     if (args->qshSz > 0) {
                         args->idx = args->sendSz - args->qshSz;
                         if (QSH_KeyExchangeWrite(ssl, 1) != 0) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
 
                         /* extension type */
                         c16toa(TLSX_QUANTUM_SAFE_HYBRID,
                                                     args->output + args->idx);
                         args->idx += OPAQUE16_LEN;
 
                         /* write to output and check amount written */
                         if (TLSX_QSHPK_Write(ssl->QSH_secret->list,
                             args->output + args->idx) >
                                                 args->qshSz - OPAQUE16_LEN) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     }
                 }
             #endif
 
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 if (ssl->specs.kea == ecdhe_psk_kea ||
                     ssl->specs.kea == ecc_diffie_hellman_kea) {
                     /* Check output to make sure it was set */
                     if (args->output) {
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
                     }
                     else {
                         ERROR_OUT(BUFFER_ERROR, exit_sske);
                     }
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 if (IsEncryptionOn(ssl, 1)) {
                     args->inputSz = args->length + HANDSHAKE_HEADER_SZ;
                     if (ssl->options.dtls)
                         args->inputSz += DTLS_HANDSHAKE_EXTRA;
                     args->input = (byte*)XMALLOC(args->inputSz, ssl->heap,
                                                         DYNAMIC_TYPE_IN_BUFFER);
                     if (args->input == NULL) {
                         ERROR_OUT(MEMORY_E, exit_sske);
                     }
 
                     if (args->output == NULL) {
                         ERROR_OUT(BUFFER_ERROR, exit_sske);
                     }
 
                     if (!ssl->options.dtls)
                         XMEMCPY(args->input, args->output + RECORD_HEADER_SZ,
                                                                  args->inputSz);
                     else
                         XMEMCPY(args->input, args->output + DTLS_RECORD_HEADER_SZ,
                                                                  args->inputSz);
 
                     #ifdef WOLFSSL_DTLS
                     if (IsDtlsNotSctpMode(ssl) &&
                         (ret = DtlsMsgPoolSave(ssl, args->input, args->inputSz, server_key_exchange))
                             != 0) {
                         goto exit_sske;
                     }
                     #endif
                     ret = BuildMessage(ssl, args->output, args->sendSz,
                                 args->input, args->inputSz, handshake, 1, 0, 0, CUR_ORDER);
                     XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                     args->input = NULL;
                         /* make sure its not double free'd on cleanup */
 
                     if (ret >= 0) {
                         args->sendSz = ret;
                         ret = 0;
                     }
                 }
                 else {
                 #ifdef WOLFSSL_DTLS
                     if (IsDtlsNotSctpMode(ssl)) {
                         if ((ret = DtlsMsgPoolSave(ssl,
                                             args->output, args->sendSz, server_key_exchange)) != 0) {
                             goto exit_sske;
                         }
                     }
 
                     if (ssl->options.dtls)
                         DtlsSEQIncrement(ssl, CUR_ORDER);
                 #endif
 
                     ret = HashOutput(ssl, args->output, args->sendSz, 0);
                     if (ret != 0) {
                         goto exit_sske;
                     }
                 }
 
             #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
                 if (ssl->hsInfoOn) {
                     AddPacketName(ssl, "ServerKeyExchange");
                 }
                 if (ssl->toInfoOn) {
                     AddPacketInfo(ssl, "ServerKeyExchange", handshake,
                         args->output, args->sendSz, WRITE_PROTO, ssl->heap);
                 }
             #endif
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* case TLS_ASYNC_FINALIZE */
             FALL_THROUGH;
 
             case TLS_ASYNC_END:
             {
                 ssl->buffers.outputBuffer.length += args->sendSz;
                 if (!ssl->options.groupMessages) {
                     ret = SendBuffered(ssl);
                 }
 
                 ssl->options.serverState = SERVER_KEYEXCHANGE_COMPLETE;
                 break;
             }
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_sske:
 
         WOLFSSL_LEAVE("SendServerKeyExchange", ret);
         WOLFSSL_END(WC_FUNC_SERVER_KEY_EXCHANGE_SEND);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E)
             return ret;
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
         /* Final cleanup */
         FreeSskeArgs(ssl, args);
         FreeKeyExchange(ssl);
 
         return ret;
     }
 
 #if defined(HAVE_SERVER_RENEGOTIATION_INFO) || defined(HAVE_FALLBACK_SCSV) || \
                                                             defined(OPENSSL_ALL)
 
     /* search suites for specific one, idx on success, negative on error */
 #ifndef WOLFSSL_TLS13
     static
 #endif
     int FindSuite(Suites* suites, byte first, byte second)
     {
         int i;
 
         if (suites == NULL || suites->suiteSz == 0) {
             WOLFSSL_MSG("Suites pointer error or suiteSz 0");
             return SUITES_ERROR;
         }
 
         for (i = 0; i < suites->suiteSz-1; i += SUITE_LEN) {
             if (suites->suites[i]   == first &&
                 suites->suites[i+1] == second )
                 return i;
         }
 
         return MATCH_SUITE_ERROR;
     }
 
 #endif
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
     /* Make sure server cert/key are valid for this suite, true on success */
     static int VerifyServerSuite(WOLFSSL* ssl, word16 idx)
     {
         int  haveRSA = !ssl->options.haveStaticECC;
         int  havePSK = 0;
         byte first;
         byte second;
 
         WOLFSSL_ENTER("VerifyServerSuite");
 
         if (ssl->suites == NULL) {
             WOLFSSL_MSG("Suites pointer error");
             return 0;
         }
 
         first   = ssl->suites->suites[idx];
         second  = ssl->suites->suites[idx+1];
 
         #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
         #endif
 
         if (ssl->options.haveNTRU)
             haveRSA = 0;
 
         if (CipherRequires(first, second, REQUIRES_RSA)) {
             WOLFSSL_MSG("Requires RSA");
             if (haveRSA == 0) {
                 WOLFSSL_MSG("Don't have RSA");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_DHE)) {
             WOLFSSL_MSG("Requires DHE");
             if (ssl->options.haveDH == 0) {
                 WOLFSSL_MSG("Don't have DHE");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_ECC)) {
             WOLFSSL_MSG("Requires ECC");
             if (ssl->options.haveECC == 0) {
                 WOLFSSL_MSG("Don't have ECC");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_ECC_STATIC)) {
             WOLFSSL_MSG("Requires static ECC");
             if (ssl->options.haveStaticECC == 0) {
                 WOLFSSL_MSG("Don't have static ECC");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_PSK)) {
             WOLFSSL_MSG("Requires PSK");
             if (havePSK == 0) {
                 WOLFSSL_MSG("Don't have PSK");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_NTRU)) {
             WOLFSSL_MSG("Requires NTRU");
             if (ssl->options.haveNTRU == 0) {
                 WOLFSSL_MSG("Don't have NTRU");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_RSA_SIG)) {
             WOLFSSL_MSG("Requires RSA Signature");
             if (ssl->options.side == WOLFSSL_SERVER_END &&
                                            ssl->options.haveECDSAsig == 1) {
                 WOLFSSL_MSG("Don't have RSA Signature");
                 return 0;
             }
         }
 
 #if !defined(WOLFSSL_OLDTLS_AEAD_CIPHERSUITES)
         if (CipherRequires(first, second, REQUIRES_AEAD)) {
             WOLFSSL_MSG("Requires AEAD");
             if (ssl->version.major == SSLv3_MAJOR &&
                                            ssl->version.minor < TLSv1_2_MINOR) {
                 WOLFSSL_MSG("Version of SSL does not support AEAD ciphers");
                 return 0;
             }
 
         }
 #endif
 
 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                        defined(HAVE_CURVE448)) && defined(HAVE_SUPPORTED_CURVES)
         if (!TLSX_ValidateSupportedCurves(ssl, first, second)) {
             WOLFSSL_MSG("Don't have matching curves");
             return 0;
         }
 #endif
 
         /* ECCDHE is always supported if ECC on */
 
 #ifdef HAVE_QSH
         /* need to negotiate a classic suite in addition to TLS_QSH */
         if (first == QSH_BYTE && second == TLS_QSH) {
             if (TLSX_SupportExtensions(ssl)) {
                 ssl->options.haveQSH = 1; /* matched TLS_QSH */
             }
             else {
                 WOLFSSL_MSG("Version of SSL connection does not support "
                             "TLS_QSH");
             }
             return 0;
         }
 #endif
 
 #ifdef WOLFSSL_TLS13
         if (IsAtLeastTLSv1_3(ssl->version) &&
             ssl->options.side == WOLFSSL_SERVER_END) {
             /* Try to establish a key share. */
             int ret = TLSX_KeyShare_Establish(ssl);
             if (ret == KEY_SHARE_ERROR)
                 ssl->options.serverState = SERVER_HELLO_RETRY_REQUEST_COMPLETE;
             else if (ret != 0)
                 return 0;
         }
         else if (first == TLS13_BYTE || (first == ECC_BYTE &&
                 (second == TLS_SHA256_SHA256 || second == TLS_SHA384_SHA384))) {
             /* Can't negotiate TLS 1.3 cipher suites with lower protocol
              * version. */
             return 0;
         }
 #endif
 
         return 1;
     }
 
 #ifndef NO_WOLFSSL_SERVER
     static int CompareSuites(WOLFSSL* ssl, Suites* peerSuites, word16 i,
                              word16 j)
     {
         if (ssl->suites->suites[i]   == peerSuites->suites[j] &&
             ssl->suites->suites[i+1] == peerSuites->suites[j+1] ) {
 
             if (VerifyServerSuite(ssl, i)) {
                 int result;
                 WOLFSSL_MSG("Verified suite validity");
                 ssl->options.cipherSuite0 = ssl->suites->suites[i];
                 ssl->options.cipherSuite  = ssl->suites->suites[i+1];
                 result = SetCipherSpecs(ssl);
                 if (result == 0) {
                     result = PickHashSigAlgo(ssl, peerSuites->hashSigAlgo,
                                                      peerSuites->hashSigAlgoSz);
                 }
                 return result;
             }
             else {
                 WOLFSSL_MSG("Could not verify suite validity, continue");
             }
         }
 
         return MATCH_SUITE_ERROR;
     }
 
     int MatchSuite(WOLFSSL* ssl, Suites* peerSuites)
     {
         int ret;
         word16 i, j;
 
         WOLFSSL_ENTER("MatchSuite");
 
         /* & 0x1 equivalent % 2 */
         if (peerSuites->suiteSz == 0 || peerSuites->suiteSz & 0x1)
             return BUFFER_ERROR;
 
         if (ssl->suites == NULL)
             return SUITES_ERROR;
 
         if (!ssl->options.useClientOrder) {
             /* Server order */
             for (i = 0; i < ssl->suites->suiteSz; i += 2) {
                 for (j = 0; j < peerSuites->suiteSz; j += 2) {
                     ret = CompareSuites(ssl, peerSuites, i, j);
                     if (ret != MATCH_SUITE_ERROR)
                         return ret;
                 }
             }
         }
         else {
             /* Client order */
             for (j = 0; j < peerSuites->suiteSz; j += 2) {
                 for (i = 0; i < ssl->suites->suiteSz; i += 2) {
                     ret = CompareSuites(ssl, peerSuites, i, j);
                     if (ret != MATCH_SUITE_ERROR)
                         return ret;
                 }
             }
         }
 
         return MATCH_SUITE_ERROR;
     }
 #endif
 
 #ifdef OLD_HELLO_ALLOWED
 
     /* process old style client hello, deprecate? */
     int ProcessOldClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                               word32 inSz, word16 sz)
     {
         word32          idx = *inOutIdx;
         word16          sessionSz;
         word16          randomSz;
         word16          i, j;
         ProtocolVersion pv;
         Suites          clSuites;
         int ret = -1;
 
         (void)inSz;
         WOLFSSL_MSG("Got old format client hello");
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn)
             AddLateName("ClientHello", &ssl->timeoutInfo);
 #endif
 
         /* manually hash input since different format */
 #ifndef NO_OLD_TLS
 #ifndef NO_MD5
         wc_Md5Update(&ssl->hsHashes->hashMd5, input + idx, sz);
 #endif
 #ifndef NO_SHA
         wc_ShaUpdate(&ssl->hsHashes->hashSha, input + idx, sz);
 #endif
 #endif
 #ifndef NO_SHA256
         if (IsAtLeastTLSv1_2(ssl)) {
             int shaRet = wc_Sha256Update(&ssl->hsHashes->hashSha256,
                                          input + idx, sz);
             if (shaRet != 0)
                 return shaRet;
         }
 #endif
 
         /* does this value mean client_hello? */
         idx++;
 
         /* version */
         pv.major = input[idx++];
         pv.minor = input[idx++];
         ssl->chVersion = pv;  /* store */
 
         if (ssl->version.minor > pv.minor) {
             byte haveRSA = 0;
             byte havePSK = 0;
             int  keySz   = 0;
 
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 return VERSION_ERROR;
             }
             if (pv.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 return VERSION_ERROR;
             }
             if (pv.minor == SSLv3_MINOR) {
                 /* turn off tls */
                 WOLFSSL_MSG("\tdowngrading to SSLv3");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = SSLv3_MINOR;
             }
             else if (pv.minor == TLSv1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1");
                 /* turn off tls 1.1+ */
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = TLSv1_MINOR;
             }
             else if (pv.minor == TLSv1_1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                 ssl->version.minor  = TLSv1_1_MINOR;
             }
             else if (pv.minor == TLSv1_2_MINOR) {
                 WOLFSSL_MSG("    downgrading to TLSv1.2");
                 ssl->version.minor  = TLSv1_2_MINOR;
             }
 #ifndef NO_RSA
             haveRSA = 1;
 #endif
 #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
 #endif
 #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
 #endif
 
             InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveNTRU,
                        ssl->options.haveECDSAsig, ssl->options.haveECC,
                        ssl->options.haveStaticECC, ssl->options.side);
         }
 
         /* suite size */
         ato16(&input[idx], &clSuites.suiteSz);
         idx += OPAQUE16_LEN;
 
         if (clSuites.suiteSz > WOLFSSL_MAX_SUITE_SZ)
             return BUFFER_ERROR;
         /* Make sure the suiteSz is a multiple of 3. (Old Client Hello) */
         if (clSuites.suiteSz % 3 != 0)
             return BUFFER_ERROR;
         clSuites.hashSigAlgoSz = 0;
 
         /* session size */
         ato16(&input[idx], &sessionSz);
         idx += OPAQUE16_LEN;
 
         if (sessionSz > ID_LEN)
             return BUFFER_ERROR;
 
         /* random size */
         ato16(&input[idx], &randomSz);
         idx += OPAQUE16_LEN;
 
         if (randomSz > RAN_LEN)
             return BUFFER_ERROR;
 
         /* suites */
         for (i = 0, j = 0; i < clSuites.suiteSz; i += 3) {
             byte first = input[idx++];
             if (!first) { /* implicit: skip sslv2 type */
                 XMEMCPY(&clSuites.suites[j], &input[idx], SUITE_LEN);
                 j += SUITE_LEN;
             }
             idx += SUITE_LEN;
         }
         clSuites.suiteSz = j;
 
         /* session id */
         if (sessionSz) {
             XMEMCPY(ssl->arrays->sessionID, input + idx, sessionSz);
             ssl->arrays->sessionIDSz = (byte)sessionSz;
             idx += sessionSz;
             ssl->options.resuming = 1;
         }
 
         /* random */
         if (randomSz < RAN_LEN)
             XMEMSET(ssl->arrays->clientRandom, 0, RAN_LEN - randomSz);
         XMEMCPY(&ssl->arrays->clientRandom[RAN_LEN - randomSz], input + idx,
                randomSz);
         idx += randomSz;
 
         if (ssl->options.usingCompression)
             ssl->options.usingCompression = 0;  /* turn off */
 
         ssl->options.clientState = CLIENT_HELLO_COMPLETE;
         ssl->cbmode = SSL_CB_MODE_WRITE;
         *inOutIdx = idx;
 
         ssl->options.haveSessionId = 1;
         /* DoClientHello uses same resume code */
         if (ssl->options.resuming) {  /* let's try */
             WOLFSSL_SESSION* session = GetSession(ssl,
                                                   ssl->arrays->masterSecret, 1);
             #ifdef HAVE_SESSION_TICKET
                 if (ssl->options.useTicket == 1) {
                     session = &ssl->session;
                 }
             #endif
 
             if (!session) {
                 WOLFSSL_MSG("Session lookup for resume failed");
                 ssl->options.resuming = 0;
             } else {
             #ifdef HAVE_EXT_CACHE
                 wolfSSL_SESSION_free(session);
             #endif
                 if (MatchSuite(ssl, &clSuites) < 0) {
                     WOLFSSL_MSG("Unsupported cipher suite, OldClientHello");
                     return UNSUPPORTED_SUITE;
                 }
 
                 ret = wc_RNG_GenerateBlock(ssl->rng, ssl->arrays->serverRandom,
                                                                        RAN_LEN);
                 if (ret != 0)
                     return ret;
 
                 #ifdef NO_OLD_TLS
                     ret = DeriveTlsKeys(ssl);
                 #else
                     #ifndef NO_TLS
                         if (ssl->options.tls)
                             ret = DeriveTlsKeys(ssl);
                     #endif
                         if (!ssl->options.tls)
                             ret = DeriveKeys(ssl);
                 #endif
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
 
                 return ret;
             }
         }
 
         ret = MatchSuite(ssl, &clSuites);
         if (ret != 0)return ret;
         return SanityCheckMsgReceived(ssl, client_hello);
     }
 
 #endif /* OLD_HELLO_ALLOWED */
 
 #ifndef WOLFSSL_NO_TLS12
 
     int HandleTlsResumption(WOLFSSL* ssl, int bogusID, Suites* clSuites)
     {
         int ret = 0;
         WOLFSSL_SESSION* session;
 
         (void)bogusID;
 
         session = GetSession(ssl, ssl->arrays->masterSecret, 1);
         #ifdef HAVE_SESSION_TICKET
             if (ssl->options.useTicket == 1) {
                 session = &ssl->session;
             } else if (bogusID == 1 && ssl->options.rejectTicket == 0) {
                 WOLFSSL_MSG("Bogus session ID without session ticket");
                 return BUFFER_ERROR;
             }
         #endif
 
         if (!session) {
             WOLFSSL_MSG("Session lookup for resume failed");
             ssl->options.resuming = 0;
         }
         else if (session->haveEMS != ssl->options.haveEMS) {
             /* RFC 7627, 5.3, server-side */
             /* if old sess didn't have EMS, but new does, full handshake */
             if (!session->haveEMS && ssl->options.haveEMS) {
                 WOLFSSL_MSG("Attempting to resume a session that didn't "
                             "use EMS with a new session with EMS. Do full "
                             "handshake.");
                 ssl->options.resuming = 0;
             }
             /* if old sess used EMS, but new doesn't, MUST abort */
             else if (session->haveEMS && !ssl->options.haveEMS) {
                 WOLFSSL_MSG("Trying to resume a session with EMS without "
                             "using EMS");
             #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, handshake_failure);
             #endif
                 #ifdef HAVE_EXT_CACHE
                     wolfSSL_SESSION_free(session);
                 #endif
                 return EXT_MASTER_SECRET_NEEDED_E;
             }
         #ifdef HAVE_EXT_CACHE
             wolfSSL_SESSION_free(session);
         #endif
         }
         else {
         #ifndef NO_RESUME_SUITE_CHECK
             int j;
 
             /* Check client suites include the one in session */
             for (j = 0; j < clSuites->suiteSz; j += 2) {
                 if (clSuites->suites[j] == session->cipherSuite0 &&
                                 clSuites->suites[j+1] == session->cipherSuite) {
                     break;
                 }
             }
             if (j == clSuites->suiteSz) {
                 WOLFSSL_MSG("Prev session's cipher suite not in ClientHello");
             #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, illegal_parameter);
             #endif
                 return UNSUPPORTED_SUITE;
             }
         #endif
 
         #ifdef HAVE_EXT_CACHE
             wolfSSL_SESSION_free(session);
         #endif
             if (MatchSuite(ssl, clSuites) < 0) {
                 WOLFSSL_MSG("Unsupported cipher suite, ClientHello");
                 return UNSUPPORTED_SUITE;
             }
 
             ret = wc_RNG_GenerateBlock(ssl->rng, ssl->arrays->serverRandom,
                                                                        RAN_LEN);
             if (ret != 0)
                 return ret;
 
             #ifdef NO_OLD_TLS
                 ret = DeriveTlsKeys(ssl);
             #else
                 #ifndef NO_TLS
                     if (ssl->options.tls)
                         ret = DeriveTlsKeys(ssl);
                 #endif
                     if (!ssl->options.tls)
                         ret = DeriveKeys(ssl);
             #endif
             ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
         }
 
         return ret;
     }
 
 
     /* handle processing of client_hello (1) */
     int DoClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                              word32 helloSz)
     {
         byte            b;
         byte            bogusID = 0;   /* flag for a bogus session id */
         ProtocolVersion pv;
         Suites          clSuites;
         word32          i = *inOutIdx;
         word32          begin = i;
         int             ret = 0;
 #ifdef WOLFSSL_DTLS
         Hmac            cookieHmac;
         byte            peerCookie[MAX_COOKIE_LEN];
         byte            peerCookieSz = 0;
         byte            cookieType;
         byte            cookieSz = 0;
 
         XMEMSET(&cookieHmac, 0, sizeof(Hmac));
 #endif /* WOLFSSL_DTLS */
 
         WOLFSSL_START(WC_FUNC_CLIENT_HELLO_DO);
         WOLFSSL_ENTER("DoClientHello");
 
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn) AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn) AddLateName("ClientHello", &ssl->timeoutInfo);
 #endif
         /* protocol version, random and session id length check */
         if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
             return BUFFER_ERROR;
 
         /* protocol version */
         XMEMCPY(&pv, input + i, OPAQUE16_LEN);
         ssl->chVersion = pv;   /* store */
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) && !ssl->options.resuming) {
             #if defined(NO_SHA) && defined(NO_SHA256)
                 #error "DTLS needs either SHA or SHA-256"
             #endif /* NO_SHA && NO_SHA256 */
 
             #if !defined(NO_SHA) && defined(NO_SHA256)
                 cookieType = WC_SHA;
                 cookieSz = WC_SHA_DIGEST_SIZE;
             #endif /* NO_SHA */
             #ifndef NO_SHA256
                 cookieType = WC_SHA256;
                 cookieSz = WC_SHA256_DIGEST_SIZE;
             #endif /* NO_SHA256 */
             ret = wc_HmacSetKey(&cookieHmac, cookieType,
                                 ssl->buffers.dtlsCookieSecret.buffer,
                                 ssl->buffers.dtlsCookieSecret.length);
             if (ret != 0) goto out;
             ret = wc_HmacUpdate(&cookieHmac,
                                 (const byte*)ssl->buffers.dtlsCtx.peer.sa,
                                 ssl->buffers.dtlsCtx.peer.sz);
             if (ret != 0) goto out;
             ret = wc_HmacUpdate(&cookieHmac, input + i, OPAQUE16_LEN);
             if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
         i += OPAQUE16_LEN;
 
         /* Legacy protocol version cannot negotiate TLS 1.3 or higher. */
         if (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR)
             pv.minor = TLSv1_2_MINOR;
 
         if ((!ssl->options.dtls && ssl->version.minor > pv.minor) ||
             (ssl->options.dtls && ssl->version.minor != DTLS_MINOR
              && ssl->version.minor != DTLSv1_2_MINOR && pv.minor != DTLS_MINOR
              && pv.minor != DTLSv1_2_MINOR)) {
 
             word16 haveRSA = 0;
             word16 havePSK = 0;
             int    keySz   = 0;
 
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 ret = VERSION_ERROR;
                 goto out;
             }
             if (pv.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 ret = VERSION_ERROR;
                 goto out;
             }
 
             if (pv.minor == SSLv3_MINOR) {
                 /* turn off tls */
                 WOLFSSL_MSG("\tdowngrading to SSLv3");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = SSLv3_MINOR;
             }
             else if (pv.minor == TLSv1_MINOR) {
                 /* turn off tls 1.1+ */
                 WOLFSSL_MSG("\tdowngrading to TLSv1");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = TLSv1_MINOR;
             }
             else if (pv.minor == TLSv1_1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                 ssl->version.minor  = TLSv1_1_MINOR;
             }
             else if (pv.minor == TLSv1_2_MINOR) {
                 WOLFSSL_MSG("    downgrading to TLSv1.2");
                 ssl->version.minor  = TLSv1_2_MINOR;
             }
 #ifndef NO_RSA
             haveRSA = 1;
 #endif
 #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
 #endif
 #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
 #endif
             InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveNTRU,
                        ssl->options.haveECDSAsig, ssl->options.haveECC,
                        ssl->options.haveStaticECC, ssl->options.side);
         }
 
 #ifdef OPENSSL_EXTRA
         /* check if option is set to not allow the current version
          * set from either wolfSSL_set_options or wolfSSL_CTX_set_options */
         if (!ssl->options.dtls && ssl->options.downgrade &&
                 ssl->options.mask > 0) {
             int reset = 0;
             if (ssl->version.minor == TLSv1_2_MINOR &&
              (ssl->options.mask & SSL_OP_NO_TLSv1_2) == SSL_OP_NO_TLSv1_2) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.2, Downgrading");
                 ssl->version.minor = TLSv1_1_MINOR;
                 reset = 1;
             }
             if (ssl->version.minor == TLSv1_1_MINOR &&
              (ssl->options.mask & SSL_OP_NO_TLSv1_1) == SSL_OP_NO_TLSv1_1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.1, Downgrading");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = TLSv1_MINOR;
                 reset = 1;
             }
             if (ssl->version.minor == TLSv1_MINOR &&
                 (ssl->options.mask & SSL_OP_NO_TLSv1) == SSL_OP_NO_TLSv1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1, Downgrading");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = SSLv3_MINOR;
                 reset = 1;
             }
             if (ssl->version.minor == SSLv3_MINOR &&
                 (ssl->options.mask & SSL_OP_NO_SSLv3) == SSL_OP_NO_SSLv3) {
                 WOLFSSL_MSG("\tError, option set to not allow SSLv3");
                 ret = VERSION_ERROR;
                 goto out;
             }
 
             if (ssl->version.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 ret = VERSION_ERROR;
                 goto out;
             }
 
             if (reset) {
                 word16 haveRSA = 0;
                 word16 havePSK = 0;
                 int    keySz   = 0;
 
             #ifndef NO_RSA
                 haveRSA = 1;
             #endif
             #ifndef NO_PSK
                 havePSK = ssl->options.havePSK;
             #endif
             #ifndef NO_CERTS
                 keySz = ssl->buffers.keySz;
             #endif
 
                 /* reset cipher suites to account for TLS version change */
                 InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveNTRU,
                        ssl->options.haveECDSAsig, ssl->options.haveECC,
                        ssl->options.haveStaticECC, ssl->options.side);
             }
         }
 #endif
 
         /* random */
         XMEMCPY(ssl->arrays->clientRandom, input + i, RAN_LEN);
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) && !ssl->options.resuming) {
             ret = wc_HmacUpdate(&cookieHmac, input + i, RAN_LEN);
             if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
         i += RAN_LEN;
 
 #ifdef SHOW_SECRETS
         {
             int j;
             printf("client random: ");
             for (j = 0; j < RAN_LEN; j++)
                 printf("%02x", ssl->arrays->clientRandom[j]);
             printf("\n");
         }
 #endif
 
         /* session id */
         b = input[i++];
 
 #ifdef HAVE_SESSION_TICKET
         if (b > 0 && b < ID_LEN) {
             bogusID = 1;
             WOLFSSL_MSG("Client sent bogus session id, let's allow for echo");
         }
 #endif
 
         if (b == ID_LEN || bogusID) {
             if ((i - begin) + b > helloSz) {
                 ret = BUFFER_ERROR;
                 goto out;
             }
 
             XMEMCPY(ssl->arrays->sessionID, input + i, b);
 #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) &&
                     !ssl->options.resuming) {
                 ret = wc_HmacUpdate(&cookieHmac, input + i - 1, b + 1);
                 if (ret != 0) goto out;
             }
 #endif /* WOLFSSL_DTLS */
             ssl->arrays->sessionIDSz = b;
             i += b;
             ssl->options.resuming = 1; /* client wants to resume */
             WOLFSSL_MSG("Client wants to resume session");
         }
         else if (b) {
             WOLFSSL_MSG("Invalid session ID size");
             ret = BUFFER_ERROR; /* session ID nor 0 neither 32 bytes long */
             goto out;
         }
 
         #ifdef WOLFSSL_DTLS
             /* cookie */
             if (ssl->options.dtls) {
 
                 if ((i - begin) + OPAQUE8_LEN > helloSz) {
                     ret = BUFFER_ERROR;
                     goto out;
                 }
 
                 peerCookieSz = input[i++];
 
                 if (peerCookieSz) {
                     if (peerCookieSz > MAX_COOKIE_LEN) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     if ((i - begin) + peerCookieSz > helloSz) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     XMEMCPY(peerCookie, input + i, peerCookieSz);
 
                     i += peerCookieSz;
                 }
             }
         #endif
 
         /* suites */
         if ((i - begin) + OPAQUE16_LEN > helloSz) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         ato16(&input[i], &clSuites.suiteSz);
         i += OPAQUE16_LEN;
 
         /* Cipher suite lists are always multiples of two in length. */
         if (clSuites.suiteSz % 2 != 0) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         /* suites and compression length check */
         if ((i - begin) + clSuites.suiteSz + OPAQUE8_LEN > helloSz) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         if (clSuites.suiteSz > WOLFSSL_MAX_SUITE_SZ) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         XMEMCPY(clSuites.suites, input + i, clSuites.suiteSz);
 
 #ifdef HAVE_SERVER_RENEGOTIATION_INFO
         /* check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV suite */
         if (FindSuite(&clSuites, 0, TLS_EMPTY_RENEGOTIATION_INFO_SCSV) >= 0) {
             TLSX* extension;
 
             /* check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV suite */
             ret = TLSX_AddEmptyRenegotiationInfo(&ssl->extensions, ssl->heap);
             if (ret != WOLFSSL_SUCCESS)
                 goto out;
 
             extension = TLSX_Find(ssl->extensions, TLSX_RENEGOTIATION_INFO);
             if (extension) {
                 ssl->secure_renegotiation =
                                           (SecureRenegotiation*)extension->data;
                 ssl->secure_renegotiation->enabled = 1;
             }
         }
 #endif /* HAVE_SERVER_RENEGOTIATION_INFO */
 #if defined(HAVE_FALLBACK_SCSV) || defined(OPENSSL_ALL)
         /* check for TLS_FALLBACK_SCSV suite */
         if (FindSuite(&clSuites, TLS_FALLBACK_SCSV, 0) >= 0) {
             WOLFSSL_MSG("Found Fallback SCSV");
             if (ssl->ctx->method->version.minor > pv.minor) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 SendAlert(ssl, alert_fatal, inappropriate_fallback);
                 ret = VERSION_ERROR;
                 goto out;
             }
         }
 #endif
 
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) && !ssl->options.resuming) {
             ret = wc_HmacUpdate(&cookieHmac,
                                     input + i - OPAQUE16_LEN,
                                     clSuites.suiteSz + OPAQUE16_LEN);
             if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
         i += clSuites.suiteSz;
         clSuites.hashSigAlgoSz = 0;
 
         /* compression length */
         b = input[i++];
 
         if ((i - begin) + b > helloSz) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         if (b == 0) {
             WOLFSSL_MSG("No compression types in list");
 #ifdef WOLFSSL_EXTRA_ALERTS
             SendAlert(ssl, alert_fatal, decode_error);
 #endif
             ret = COMPRESSION_ERROR;
             goto out;
         }
 
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl)) {
             if (!IsSCR(ssl) && !ssl->options.resuming) {
                 byte newCookie[MAX_COOKIE_LEN];
 
                 ret = wc_HmacUpdate(&cookieHmac, input + i - 1, b + 1);
                 if (ret != 0) goto out;
                 ret = wc_HmacFinal(&cookieHmac, newCookie);
                 if (ret != 0) goto out;
 
                 /* If a cookie callback is set, call it to overwrite the cookie.
                  * This should be deprecated. The code now calculates the cookie
                  * using an HMAC as expected. */
                 if (ssl->ctx->CBIOCookie != NULL &&
                     ssl->ctx->CBIOCookie(ssl, newCookie, cookieSz,
                                                  ssl->IOCB_CookieCtx) != cookieSz) {
                     ret = COOKIE_ERROR;
                     goto out;
                 }
 
                 /* Check the cookie, see if we progress the state machine. */
                 if (peerCookieSz != cookieSz ||
                     XMEMCMP(peerCookie, newCookie, cookieSz) != 0) {
 
                     /* Send newCookie to client in a HelloVerifyRequest message
                      * and let the state machine alone. */
                     ssl->msgsReceived.got_client_hello = 0;
                     ssl->keys.dtls_handshake_number = 0;
                     ssl->keys.dtls_expected_peer_handshake_number = 0;
                     *inOutIdx += helloSz;
                     ret = SendHelloVerifyRequest(ssl, newCookie, cookieSz);
                     goto out;
                 }
             }
 
             /* This was skipped in the DTLS case so we could handle the hello
              * verify request. */
             ret = HashInput(ssl, input + *inOutIdx, helloSz);
             if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
 
         {
             /* compression match types */
             int matchNo = 0;
             int matchZlib = 0;
 
             while (b--) {
                 byte comp = input[i++];
 
                 if (comp == NO_COMPRESSION) {
                     matchNo = 1;
                 }
                 if (comp == ZLIB_COMPRESSION) {
                     matchZlib = 1;
                 }
             }
 
             if (ssl->options.usingCompression == 0 && matchNo) {
                 WOLFSSL_MSG("Matched No Compression");
             } else if (ssl->options.usingCompression && matchZlib) {
                 WOLFSSL_MSG("Matched zlib Compression");
             } else if (ssl->options.usingCompression && matchNo) {
                 WOLFSSL_MSG("Could only match no compression, turning off");
                 ssl->options.usingCompression = 0;  /* turn off */
             } else {
                 WOLFSSL_MSG("Could not match compression");
 #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, illegal_parameter);
 #endif
                 ret = COMPRESSION_ERROR;
                 goto out;
             }
         }
 
         *inOutIdx = i;
 
         /* tls extensions */
         if ((i - begin) < helloSz) {
 #ifdef HAVE_TLS_EXTENSIONS
         #ifdef HAVE_QSH
             QSH_Init(ssl);
         #endif
             if (TLSX_SupportExtensions(ssl))
 #else
             if (IsAtLeastTLSv1_2(ssl))
 #endif
             {
                 /* Process the hello extension. Skip unsupported. */
                 word16 totalExtSz;
 
 #ifdef HAVE_TLS_EXTENSIONS
                 /* auto populate extensions supported unless user defined */
                 if ((ret = TLSX_PopulateExtensions(ssl, 1)) != 0)
                     goto out;
 #endif
 
                 if ((i - begin) + OPAQUE16_LEN > helloSz) {
                     ret = BUFFER_ERROR;
                     goto out;
                 }
 
                 ato16(&input[i], &totalExtSz);
                 i += OPAQUE16_LEN;
 
                 if ((i - begin) + totalExtSz > helloSz) {
                     ret = BUFFER_ERROR;
                     goto out;
                 }
 
 #ifdef HAVE_TLS_EXTENSIONS
                 /* tls extensions */
                 if ((ret = TLSX_Parse(ssl, (byte *) input + i, totalExtSz,
                                       client_hello, &clSuites)))
                     goto out;
     #ifdef WOLFSSL_TLS13
                 if (TLSX_Find(ssl->extensions,
                                              TLSX_SUPPORTED_VERSIONS) != NULL) {
                     WOLFSSL_MSG(
                             "Client attempting to connect with higher version");
                     ret = VERSION_ERROR;
                     goto out;
                 }
     #endif
     #if defined(OPENSSL_ALL) || defined(HAVE_STUNNEL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)
                 if((ret=SNI_Callback(ssl)))
                     goto out;
                 ssl->options.side = WOLFSSL_SERVER_END;
     #endif
 
                 i += totalExtSz;
 #else
                 while (totalExtSz) {
                     word16 extId, extSz;
 
                     if (OPAQUE16_LEN + OPAQUE16_LEN > totalExtSz) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     ato16(&input[i], &extId);
                     i += OPAQUE16_LEN;
                     ato16(&input[i], &extSz);
                     i += OPAQUE16_LEN;
 
                     if (OPAQUE16_LEN + OPAQUE16_LEN + extSz > totalExtSz) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     if (extId == HELLO_EXT_SIG_ALGO) {
                         word16 hashSigAlgoSz;
 
                         ato16(&input[i], &hashSigAlgoSz);
                         i += OPAQUE16_LEN;
 
                         if (OPAQUE16_LEN + hashSigAlgoSz > extSz) {
                             ret = BUFFER_ERROR;
                             goto out;
                         }
 
                         if (hashSigAlgoSz % 2 != 0) {
                             ret = BUFFER_ERROR;
                             goto out;
                         }
 
                         clSuites.hashSigAlgoSz = hashSigAlgoSz;
                         if (clSuites.hashSigAlgoSz > WOLFSSL_MAX_SIGALGO) {
                             WOLFSSL_MSG("ClientHello SigAlgo list exceeds max, "
                                                                   "truncating");
                             clSuites.hashSigAlgoSz = WOLFSSL_MAX_SIGALGO;
                         }
 
                         XMEMCPY(clSuites.hashSigAlgo, &input[i],
                                                       clSuites.hashSigAlgoSz);
 
                         i += hashSigAlgoSz;
                     }
 #ifdef HAVE_EXTENDED_MASTER
                     else if (extId == HELLO_EXT_EXTMS)
                         ssl->options.haveEMS = 1;
 #endif
                     else
                         i += extSz;
 
                     totalExtSz -= OPAQUE16_LEN + OPAQUE16_LEN + extSz;
                 }
 #endif
                 *inOutIdx = i;
             }
             else
                 *inOutIdx = begin + helloSz; /* skip extensions */
         }
 
         ssl->options.clientState   = CLIENT_HELLO_COMPLETE;
         ssl->options.haveSessionId = 1;
 
         /* ProcessOld uses same resume code */
         if (ssl->options.resuming) {
             ret = HandleTlsResumption(ssl, bogusID, &clSuites);
             if (ret != 0)
                 goto out;
 
             #ifdef HAVE_SECURE_RENEGOTIATION
             if (ssl->secure_renegotiation &&
                     ssl->secure_renegotiation->enabled &&
                     IsEncryptionOn(ssl, 0))
                 ssl->secure_renegotiation->startScr = 1;
             #endif
 
             if (ssl->options.clientState == CLIENT_KEYEXCHANGE_COMPLETE) {
                 WOLFSSL_LEAVE("DoClientHello", ret);
                 WOLFSSL_END(WC_FUNC_CLIENT_HELLO_DO);
 
                 goto out;
             }
         }
 
 #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_DH_DEFAULT_PARAMS)
     #if defined(HAVE_FFDHE) && defined(HAVE_SUPPORTED_CURVES)
         if (TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS) != NULL) {
             /* Set FFDHE parameters or clear DHE parameters if FFDH parameters
              * present and no matches in the server's list. */
             ret = TLSX_SupportedFFDHE_Set(ssl);
             if (ret != 0)
                 goto out;
         }
     #endif
 #endif
 
         ret = MatchSuite(ssl, &clSuites);
 #ifdef WOLFSSL_EXTRA_ALERTS
         if (ret == BUFFER_ERROR)
             SendAlert(ssl, alert_fatal, decode_error);
         else if (ret < 0)
             SendAlert(ssl, alert_fatal, handshake_failure);
 #endif
 
 #ifdef HAVE_SECURE_RENEGOTIATION
         if (ssl->secure_renegotiation && ssl->secure_renegotiation->enabled &&
                 IsEncryptionOn(ssl, 0)) {
             ssl->secure_renegotiation->startScr = 1;
         }
 #endif
 #ifdef WOLFSSL_DTLS
         if (ret == 0 && ssl->options.dtls)
             DtlsMsgPoolReset(ssl);
 #endif
         WOLFSSL_LEAVE("DoClientHello", ret);
         WOLFSSL_END(WC_FUNC_CLIENT_HELLO_DO);
 
     out:
 
 #ifdef WOLFSSL_DTLS
         wc_HmacFree(&cookieHmac);
 #endif
 
         return ret;
     }
 
 
 #if (!defined(NO_RSA) || defined(HAVE_ECC) || defined(HAVE_ED25519) || \
                         defined(HAVE_ED448)) && !defined(WOLFSSL_NO_CLIENT_AUTH)
 
     typedef struct DcvArgs {
         byte*  output; /* not allocated */
         word32 sendSz;
         word16 sz;
         word32 sigSz;
         word32 idx;
         word32 begin;
         byte   hashAlgo;
         byte   sigAlgo;
     } DcvArgs;
 
     static void FreeDcvArgs(WOLFSSL* ssl, void* pArgs)
     {
         DcvArgs* args = (DcvArgs*)pArgs;
 
         (void)ssl;
         (void)args;
     }
 
     /* handle processing of certificate_verify (15) */
     static int DoCertificateVerify(WOLFSSL* ssl, byte* input,
                                 word32* inOutIdx, word32 size)
     {
         int ret = 0;
     #ifdef WOLFSSL_ASYNC_CRYPT
         DcvArgs* args = (DcvArgs*)ssl->async.args;
         typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
         (void)sizeof(args_test);
     #else
         DcvArgs  args[1];
     #endif
 
         WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);
         WOLFSSL_ENTER("DoCertificateVerify");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NOT_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_dcv;
         }
         else
     #endif
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(DcvArgs));
             args->hashAlgo = sha_mac;
             args->sigAlgo = anonymous_sa_algo;
             args->idx = *inOutIdx;
             args->begin = *inOutIdx;
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async.freeArgs = FreeDcvArgs;
         #endif
         }
 
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
             #ifdef WOLFSSL_CALLBACKS
                 if (ssl->hsInfoOn)
                     AddPacketName(ssl, "CertificateVerify");
                 if (ssl->toInfoOn)
                     AddLateName("CertificateVerify", &ssl->timeoutInfo);
             #endif
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* case TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
                 if (IsAtLeastTLSv1_2(ssl)) {
                     if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > size) {
                         ERROR_OUT(BUFFER_ERROR, exit_dcv);
                     }
 
                     DecodeSigAlg(&input[args->idx], &args->hashAlgo,
                                  &args->sigAlgo);
                     args->idx += 2;
                 }
             #ifndef NO_RSA
                 else if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0)
                     args->sigAlgo = rsa_sa_algo;
             #endif
             #ifdef HAVE_ECC
                 else if (ssl->peerEccDsaKeyPresent)
                     args->sigAlgo = ecc_dsa_sa_algo;
             #endif
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 else if (ssl->peerEd25519KeyPresent)
                     args->sigAlgo = ed25519_sa_algo;
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 else if (ssl->peerEd448KeyPresent)
                     args->sigAlgo = ed448_sa_algo;
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
                 if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                     ERROR_OUT(BUFFER_ERROR, exit_dcv);
                 }
 
                 ato16(input + args->idx, &args->sz);
                 args->idx += OPAQUE16_LEN;
 
                 if ((args->idx - args->begin) + args->sz > size ||
                                                     args->sz > ENCRYPT_LEN) {
                     ERROR_OUT(BUFFER_ERROR, exit_dcv);
                 }
 
             #ifdef HAVE_ECC
                 if (ssl->peerEccDsaKeyPresent) {
 
                     WOLFSSL_MSG("Doing ECC peer cert verify");
 
                 /* make sure a default is defined */
                 #if !defined(NO_SHA)
                     SetDigest(ssl, sha_mac);
                 #elif !defined(NO_SHA256)
                     SetDigest(ssl, sha256_mac);
                 #elif defined(WOLFSSL_SHA384)
                     SetDigest(ssl, sha384_mac);
                 #elif defined(WOLFSSL_SHA512)
                     SetDigest(ssl, sha512_mac);
                 #else
                     #error No digest enabled for ECC sig verify
                 #endif
 
                     if (IsAtLeastTLSv1_2(ssl)) {
                         if (args->sigAlgo != ecc_dsa_sa_algo) {
                             WOLFSSL_MSG("Oops, peer sent ECC key but not in verify");
                         }
 
                         SetDigest(ssl, args->hashAlgo);
                     }
                 }
             #endif /* HAVE_ECC */
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 if (ssl->peerEd25519KeyPresent) {
                     WOLFSSL_MSG("Doing ED25519 peer cert verify");
                     if (IsAtLeastTLSv1_2(ssl) &&
                                              args->sigAlgo != ed25519_sa_algo) {
                         WOLFSSL_MSG(
                                "Oops, peer sent ED25519 key but not in verify");
                     }
                 }
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 if (ssl->peerEd448KeyPresent) {
                     WOLFSSL_MSG("Doing ED448 peer cert verify");
                     if (IsAtLeastTLSv1_2(ssl) &&
                                                args->sigAlgo != ed448_sa_algo) {
                         WOLFSSL_MSG(
                                  "Oops, peer sent ED448 key but not in verify");
                     }
                 }
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* case TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
             #ifndef NO_RSA
                 if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {
                     WOLFSSL_MSG("Doing RSA peer cert verify");
 
                     ret = RsaVerify(ssl,
                         input + args->idx,
                         args->sz,
                         &args->output,
                         args->sigAlgo, args->hashAlgo,
                         ssl->peerRsaKey,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerRsaKey
                     #else
                         NULL
                     #endif
                     );
                     if (ret >= 0) {
                         if (args->sigAlgo == rsa_sa_algo)
                             args->sendSz = ret;
                         else {
                             args->sigSz = ret;
                             args->sendSz = ssl->buffers.digest.length;
                         }
                         ret = 0;
                     }
                 }
             #endif /* !NO_RSA */
             #ifdef HAVE_ECC
                 if (ssl->peerEccDsaKeyPresent) {
                     WOLFSSL_MSG("Doing ECC peer cert verify");
 
                     ret = EccVerify(ssl,
                         input + args->idx, args->sz,
                         ssl->buffers.digest.buffer, ssl->buffers.digest.length,
                         ssl->peerEccDsaKey,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEccDsaKey
                     #else
                         NULL
                     #endif
                     );
                 }
             #endif /* HAVE_ECC */
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 if (ssl->peerEd25519KeyPresent) {
                     WOLFSSL_MSG("Doing Ed25519 peer cert verify");
 
                     ret = Ed25519Verify(ssl,
                         input + args->idx, args->sz,
                         ssl->hsHashes->messages, ssl->hsHashes->prevLen,
                         ssl->peerEd25519Key,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEd25519Key
                     #else
                         NULL
                     #endif
                     );
                 }
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 if (ssl->peerEd448KeyPresent) {
                     WOLFSSL_MSG("Doing Ed448 peer cert verify");
 
                     ret = Ed448Verify(ssl,
                         input + args->idx, args->sz,
                         ssl->hsHashes->messages, ssl->hsHashes->prevLen,
                         ssl->peerEd448Key,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEd448Key
                     #else
                         NULL
                     #endif
                     );
                 }
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
             #ifdef WOLFSSL_ASYNC_CRYPT
                 /* handle async pending */
                 if (ret == WC_PENDING_E)
                     goto exit_dcv;
             #endif
 
                 /* Check for error */
                 if (ret != 0) {
                     ret = SIG_VERIFY_E;
                     goto exit_dcv;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* case TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
             #ifndef NO_RSA
                 if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {
                     if (IsAtLeastTLSv1_2(ssl)) {
                     #ifdef WC_RSA_PSS
                         if (args->sigAlgo == rsa_pss_sa_algo) {
                             SetDigest(ssl, args->hashAlgo);
 
                         #ifdef HAVE_SELFTEST
                             ret = wc_RsaPSS_CheckPadding(
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             args->output, args->sigSz,
                                             HashAlgoToType(args->hashAlgo));
                         #else
                             ret = wc_RsaPSS_CheckPadding_ex(
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             args->output, args->sigSz,
                                             HashAlgoToType(args->hashAlgo), -1,
                                             mp_count_bits(&ssl->peerRsaKey->n));
                         #endif
                             if (ret != 0) {
                                 ret = SIG_VERIFY_E;
                                 goto exit_dcv;
                             }
                         }
                         else
                     #endif
                         {
                         #ifdef WOLFSSL_SMALL_STACK
                             byte* encodedSig;
                         #else
                             byte  encodedSig[MAX_ENCODED_SIG_SZ];
                         #endif
 
                         #ifdef WOLFSSL_SMALL_STACK
                             encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
                                              ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                             if (encodedSig == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_dcv);
                             }
                         #endif
 
                             if (args->sigAlgo != rsa_sa_algo) {
                                 WOLFSSL_MSG("Oops, peer sent RSA key but not "
                                             "in verify");
                             }
 
                             SetDigest(ssl, args->hashAlgo);
 
                             args->sigSz = wc_EncodeSignature(encodedSig,
                                 ssl->buffers.digest.buffer,
                                 ssl->buffers.digest.length,
                                 TypeHash(args->hashAlgo));
 
                             if (args->sendSz != args->sigSz || !args->output ||
                                 XMEMCMP(args->output, encodedSig,
                                     min(args->sigSz, MAX_ENCODED_SIG_SZ)) != 0) {
                                 ret = VERIFY_CERT_ERROR;
                             }
 
                         #ifdef WOLFSSL_SMALL_STACK
                             XFREE(encodedSig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                         #endif
                         }
                     }
                     else {
                         if (args->sendSz != FINISHED_SZ || !args->output ||
                             XMEMCMP(args->output,
                                 &ssl->hsHashes->certHashes, FINISHED_SZ) != 0) {
                             ret = VERIFY_CERT_ERROR;
                         }
                     }
                 }
             #endif /* !NO_RSA */
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* case TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
                 if (IsEncryptionOn(ssl, 0)) {
                     args->idx += ssl->keys.padSz;
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead)
                         args->idx += MacSize(ssl);
             #endif
                 }
 
                 ssl->options.havePeerVerify = 1;
 
                 /* Set final index */
                 args->idx += args->sz;
                 *inOutIdx = args->idx;
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* case TLS_ASYNC_FINALIZE */
 
             case TLS_ASYNC_END:
             {
                 break;
             }
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_dcv:
 
         WOLFSSL_LEAVE("DoCertificateVerify", ret);
         WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E) {
             /* Mark message as not received so it can process again */
             ssl->msgsReceived.got_certificate_verify = 0;
 
             return ret;
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
     #ifdef WOLFSSL_EXTRA_ALERTS
         if (ret == BUFFER_ERROR)
             SendAlert(ssl, alert_fatal, decode_error);
         else if (ret == SIG_VERIFY_E)
             SendAlert(ssl, alert_fatal, decrypt_error);
         else if (ret != 0)
             SendAlert(ssl, alert_fatal, bad_certificate);
     #endif
         /* Digest is not allocated, so do this to prevent free */
         ssl->buffers.digest.buffer = NULL;
         ssl->buffers.digest.length = 0;
 
         /* Final cleanup */
         FreeDcvArgs(ssl, args);
         FreeKeyExchange(ssl);
 
         return ret;
     }
 
 #endif /* (!NO_RSA || ECC || ED25519 || ED448) && !WOLFSSL_NO_CLIENT_AUTH */
 
     /* handle generation of server_hello_done (14) */
     int SendServerHelloDone(WOLFSSL* ssl)
     {
         byte* output;
         int   sendSz = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int   ret;
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_DONE_SEND);
         WOLFSSL_ENTER("SendServerHelloDone");
 
     #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls)
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
     #endif
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, 0, server_hello_done, ssl);
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, server_hello_done)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, server_hello_done)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ServerHelloDone");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "ServerHelloDone", handshake, output, sendSz,
                     WRITE_PROTO, ssl->heap);
     #endif
         ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendServerHelloDone", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_DONE_SEND);
 
         return ret;
     }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #ifdef HAVE_SESSION_TICKET
 
 #define WOLFSSL_TICKET_FIXED_SZ (WOLFSSL_TICKET_NAME_SZ + \
                 WOLFSSL_TICKET_IV_SZ + WOLFSSL_TICKET_MAC_SZ + LENGTH_SZ)
 #define WOLFSSL_TICKET_ENC_SZ (SESSION_TICKET_LEN - WOLFSSL_TICKET_FIXED_SZ)
 
     /* our ticket format */
     typedef struct InternalTicket {
         ProtocolVersion pv;                    /* version when ticket created */
         byte            suite[SUITE_LEN];      /* cipher suite when created */
         byte            msecret[SECRET_LEN];   /* master secret */
         word32          timestamp;             /* born on */
         word16          haveEMS;               /* have extended master secret */
 #ifdef WOLFSSL_TLS13
         word32          ageAdd;                /* Obfuscation of age */
         word16          namedGroup;            /* Named group used */
         TicketNonce     ticketNonce;           /* Ticket nonce */
     #ifdef WOLFSSL_EARLY_DATA
         word32          maxEarlyDataSz;        /* Max size of early data */
     #endif
 #endif
     } InternalTicket;
 
     /* RFC 5077 defines this for session tickets */
     /* fit within SESSION_TICKET_LEN */
     typedef struct ExternalTicket {
         byte key_name[WOLFSSL_TICKET_NAME_SZ];  /* key context name */
         byte iv[WOLFSSL_TICKET_IV_SZ];          /* this ticket's iv */
         byte enc_len[LENGTH_SZ];                /* encrypted length */
         byte enc_ticket[WOLFSSL_TICKET_ENC_SZ]; /* encrypted internal ticket */
         byte mac[WOLFSSL_TICKET_MAC_SZ];        /* total mac */
         /* !! if add to structure, add to TICKET_FIXED_SZ !! */
     } ExternalTicket;
 
     /* create a new session ticket, 0 on success */
     int CreateTicket(WOLFSSL* ssl)
     {
         InternalTicket  it;
         ExternalTicket* et = (ExternalTicket*)ssl->session.ticket;
         int encLen;
         int ret;
         byte zeros[WOLFSSL_TICKET_MAC_SZ];   /* biggest cmp size */
 
         XMEMSET(&it, 0, sizeof(it));
 
         /* build internal */
         it.pv.major = ssl->version.major;
         it.pv.minor = ssl->version.minor;
 
         it.suite[0] = ssl->options.cipherSuite0;
         it.suite[1] = ssl->options.cipherSuite;
 
     #ifdef WOLFSSL_EARLY_DATA
         it.maxEarlyDataSz = ssl->options.maxEarlyDataSz;
     #endif
 
         if (!ssl->options.tls1_3) {
             XMEMCPY(it.msecret, ssl->arrays->masterSecret, SECRET_LEN);
             c32toa(LowResTimer(), (byte*)&it.timestamp);
             it.haveEMS = ssl->options.haveEMS;
         }
         else {
 #ifdef WOLFSSL_TLS13
             /* Client adds to ticket age to obfuscate. */
             ret = wc_RNG_GenerateBlock(ssl->rng, (byte*)&it.ageAdd,
                                                              sizeof(it.ageAdd));
             if (ret != 0)
                 return BAD_TICKET_ENCRYPT;
             ssl->session.ticketAdd = it.ageAdd;
             it.namedGroup = ssl->session.namedGroup;
             it.timestamp = TimeNowInMilliseconds();
             /* Resumption master secret. */
             XMEMCPY(it.msecret, ssl->session.masterSecret, SECRET_LEN);
             XMEMCPY(&it.ticketNonce, &ssl->session.ticketNonce,
                                                            sizeof(TicketNonce));
 #endif
         }
 
         /* encrypt */
         encLen = WOLFSSL_TICKET_ENC_SZ;  /* max size user can use */
         if (ssl->ctx->ticketEncCb == NULL) {
             ret = WOLFSSL_TICKET_RET_FATAL;
         }
         else {
             /* build external */
             XMEMCPY(et->enc_ticket, &it, sizeof(InternalTicket));
 
             ret = ssl->ctx->ticketEncCb(ssl, et->key_name, et->iv, et->mac, 1,
                                     et->enc_ticket, sizeof(InternalTicket),
                                     &encLen, ssl->ctx->ticketEncCtx);
             if (ret != WOLFSSL_TICKET_RET_OK) {
                 ForceZero(et->enc_ticket, sizeof(it));
             }
         }
         if (ret == WOLFSSL_TICKET_RET_OK) {
             if (encLen < (int)sizeof(InternalTicket) ||
                 encLen > WOLFSSL_TICKET_ENC_SZ) {
                 ForceZero(&it, sizeof(it));
                 ForceZero(et->enc_ticket, sizeof(it));
                 WOLFSSL_MSG("Bad user ticket encrypt size");
                 return BAD_TICKET_KEY_CB_SZ;
             }
 
             /* sanity checks on encrypt callback */
 
             /* internal ticket can't be the same if encrypted */
             if (XMEMCMP(et->enc_ticket, &it, sizeof(InternalTicket)) == 0) {
                 ForceZero(&it, sizeof(it));
                 ForceZero(et->enc_ticket, sizeof(it));
                 WOLFSSL_MSG("User ticket encrypt didn't encrypt");
                 return BAD_TICKET_ENCRYPT;
             }
 
             ForceZero(&it, sizeof(it));
             XMEMSET(zeros, 0, sizeof(zeros));
 
             /* name */
             if (XMEMCMP(et->key_name, zeros, WOLFSSL_TICKET_NAME_SZ) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't set name");
                 return BAD_TICKET_ENCRYPT;
             }
 
             /* iv */
             if (XMEMCMP(et->iv, zeros, WOLFSSL_TICKET_IV_SZ) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't set iv");
                 return BAD_TICKET_ENCRYPT;
             }
 
             /* mac */
             if (XMEMCMP(et->mac, zeros, WOLFSSL_TICKET_MAC_SZ) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't set mac");
                 return BAD_TICKET_ENCRYPT;
             }
 
             /* set size */
             c16toa((word16)encLen, et->enc_len);
             ssl->session.ticketLen = (word16)(encLen + WOLFSSL_TICKET_FIXED_SZ);
             if (encLen < WOLFSSL_TICKET_ENC_SZ) {
                 /* move mac up since whole enc buffer not used */
                 XMEMMOVE(et->enc_ticket +encLen, et->mac,WOLFSSL_TICKET_MAC_SZ);
             }
         }
 
         return ret;
     }
 
 
     /* Parse ticket sent by client, returns callback return value */
     int DoClientTicket(WOLFSSL* ssl, const byte* input, word32 len)
     {
         ExternalTicket* et;
         InternalTicket  it;
         int             ret;
         int             outLen;
         word16          inLen;
 
         WOLFSSL_START(WC_FUNC_TICKET_DO);
         WOLFSSL_ENTER("DoClientTicket");
 
         if (len > SESSION_TICKET_LEN ||
              len < (word32)(sizeof(InternalTicket) + WOLFSSL_TICKET_FIXED_SZ)) {
             return BAD_TICKET_MSG_SZ;
         }
 
         et = (ExternalTicket*)input;
 
         /* decrypt */
         ato16(et->enc_len, &inLen);
         if (inLen > (word16)(len - WOLFSSL_TICKET_FIXED_SZ)) {
             return BAD_TICKET_MSG_SZ;
         }
         outLen = inLen;   /* may be reduced by user padding */
 
         if (ssl->ctx->ticketEncCb == NULL) {
             ret = WOLFSSL_TICKET_RET_FATAL;
         }
         else {
             ret = ssl->ctx->ticketEncCb(ssl, et->key_name, et->iv,
                                     et->enc_ticket + inLen, 0,
                                     et->enc_ticket, inLen, &outLen,
                                     ssl->ctx->ticketEncCtx);
         }
         if (ret == WOLFSSL_TICKET_RET_FATAL || ret < 0) return ret;
         if (outLen > (int)inLen || outLen < (int)sizeof(InternalTicket)) {
             WOLFSSL_MSG("Bad user ticket decrypt len");
             return BAD_TICKET_KEY_CB_SZ;
         }
 
         /* copy the decrypted ticket to avoid alignment issues */
         XMEMCPY(&it, et->enc_ticket, sizeof(InternalTicket));
         ForceZero(et->enc_ticket, sizeof(it));
 
         /* get master secret */
         if (ret == WOLFSSL_TICKET_RET_OK || ret == WOLFSSL_TICKET_RET_CREATE) {
             if (ssl->version.minor < it.pv.minor) {
                 ForceZero(&it, sizeof(it));
                 WOLFSSL_MSG("Ticket has greater version");
                 return VERSION_ERROR;
             }
             else if (ssl->version.minor > it.pv.minor) {
                 if (!ssl->options.downgrade) {
                     ForceZero(&it, sizeof(it));
                     WOLFSSL_MSG("Ticket has lesser version");
                     return VERSION_ERROR;
                 }
 
                 WOLFSSL_MSG("Downgrading protocol due to ticket");
 
                 if (it.pv.minor < ssl->options.minDowngrade) {
                     ForceZero(&it, sizeof(it));
                     return VERSION_ERROR;
                 }
                 ssl->version.minor = it.pv.minor;
             }
 
 
             if (!IsAtLeastTLSv1_3(ssl->version)) {
                 XMEMCPY(ssl->arrays->masterSecret, it.msecret, SECRET_LEN);
                 /* Copy the haveExtendedMasterSecret property from the ticket to
                  * the saved session, so the property may be checked later. */
                 ssl->session.haveEMS = it.haveEMS;
             #ifndef NO_RESUME_SUITE_CHECK
                 ssl->session.cipherSuite0 = it.suite[0];
                 ssl->session.cipherSuite = it.suite[1];
             #endif
             }
             else {
 #ifdef WOLFSSL_TLS13
                 /* Restore information to renegotiate. */
                 ssl->session.ticketSeen = it.timestamp;
                 ssl->session.ticketAdd = it.ageAdd;
                 ssl->session.cipherSuite0 = it.suite[0];
                 ssl->session.cipherSuite = it.suite[1];
     #ifdef WOLFSSL_EARLY_DATA
                 ssl->session.maxEarlyDataSz = it.maxEarlyDataSz;
     #endif
                 /* Resumption master secret. */
                 XMEMCPY(ssl->session.masterSecret, it.msecret, SECRET_LEN);
                 XMEMCPY(&ssl->session.ticketNonce, &it.ticketNonce,
                                                            sizeof(TicketNonce));
                 ssl->session.namedGroup = it.namedGroup;
 #endif
             }
         }
 
         ForceZero(&it, sizeof(it));
 
         WOLFSSL_LEAVE("DoClientTicket", ret);
         WOLFSSL_END(WC_FUNC_TICKET_DO);
 
         return ret;
     }
 
 
     /* send Session Ticket */
     int SendTicket(WOLFSSL* ssl)
     {
         byte*              output;
         int                ret;
         int                sendSz;
         word32             length = SESSION_HINT_SZ + LENGTH_SZ;
         word32             idx    = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
 
         WOLFSSL_START(WC_FUNC_TICKET_SEND);
         WOLFSSL_ENTER("SendTicket");
 
         if (ssl->options.createTicket) {
             ret = CreateTicket(ssl);
             if (ret != 0) return ret;
         }
 
         length += ssl->session.ticketLen;
         sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
         if (!ssl->options.dtls) {
             if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone)
                 sendSz += MAX_MSG_EXTRA;
         }
         else {
         #ifdef WOLFSSL_DTLS
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
             idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
         #endif
         }
 
         if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone)
             sendSz += cipherExtraData(ssl);
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, length, session_ticket, ssl);
 
         /* hint */
         c32toa(ssl->ctx->ticketHint, output + idx);
         idx += SESSION_HINT_SZ;
 
         /* length */
         c16toa(ssl->session.ticketLen, output + idx);
         idx += LENGTH_SZ;
 
         /* ticket */
         XMEMCPY(output + idx, ssl->session.ticket, ssl->session.ticketLen);
         idx += ssl->session.ticketLen;
 
         if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         }
         else {
             #ifdef WOLFSSL_DTLS
             if (ssl->options.dtls) {
                 if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, session_ticket)) != 0)
                     return ret;
 
                 DtlsSEQIncrement(ssl, CUR_ORDER);
             }
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         if (!ssl->options.groupMessages)
             ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendTicket", ret);
         WOLFSSL_END(WC_FUNC_TICKET_SEND);
 
         return ret;
     }
 
 #endif /* HAVE_SESSION_TICKET */
 
 #ifndef WOLFSSL_NO_TLS12
 
 #if defined(HAVE_SECURE_RENEGOTIATION) && \
     defined(HAVE_SERVER_RENEGOTIATION_INFO) && \
     !defined(WOLFSSL_NO_SERVER)
 
     /* handle generation of server's hello_request (0) */
     int SendHelloRequest(WOLFSSL* ssl)
     {
         byte* output;
         int sendSz = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int ret;
 
         WOLFSSL_START(WC_FUNC_HELLO_REQUEST_SEND);
         WOLFSSL_ENTER("SendHelloRequest");
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         if (ssl->options.dtls)
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, 0, hello_request, ssl);
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 0, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         }
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendHelloRequest", ret);
         WOLFSSL_END(WC_FUNC_HELLO_REQUEST_SEND);
 
         return ret;
     }
 
 #endif /* HAVE_SECURE_RENEGOTIATION && HAVE_SERVER_RENEGOTIATION_INFO */
 
 #ifdef WOLFSSL_DTLS
     /* handle generation of DTLS hello_verify_request (3) */
     static int SendHelloVerifyRequest(WOLFSSL* ssl,
                                       const byte* cookie, byte cookieSz)
     {
         byte* output;
         int   length = VERSION_SZ + ENUM_LEN + cookieSz;
         int   idx    = DTLS_RECORD_HEADER_SZ + DTLS_HANDSHAKE_HEADER_SZ;
         int   sendSz = length + idx;
         int   ret;
 
         /* are we in scr */
         if (IsEncryptionOn(ssl, 1)) {
             sendSz += MAX_MSG_EXTRA;
         }
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         /* Hello Verify Request should use the same sequence number as the
          * Client Hello. */
         ssl->keys.dtls_sequence_number_hi = ssl->keys.curSeq_hi;
         ssl->keys.dtls_sequence_number_lo = ssl->keys.curSeq_lo;
         AddHeaders(output, length, hello_verify_request, ssl);
 
 #ifdef OPENSSL_EXTRA
         output[idx++] = DTLS_MAJOR;
         output[idx++] = DTLS_MINOR;
 #else
         output[idx++] = ssl->version.major;
         output[idx++] = ssl->version.minor;
 #endif
 
         output[idx++] = cookieSz;
         if (cookie == NULL || cookieSz == 0)
             return COOKIE_ERROR;
 
         XMEMCPY(output + idx, cookie, cookieSz);
 
 #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "HelloVerifyRequest");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "HelloVerifyRequest", handshake, output,
                           sendSz, WRITE_PROTO, ssl->heap);
 #endif
 
         /* are we in scr */
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ + length; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 0, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         }
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         return SendBuffered(ssl);
     }
 #endif /* WOLFSSL_DTLS */
 
     typedef struct DckeArgs {
         byte*  output; /* not allocated */
         word32 length;
         word32 idx;
         word32 begin;
         word32 sigSz;
     #ifndef NO_RSA
         int    lastErr;
     #endif
     } DckeArgs;
 
     static void FreeDckeArgs(WOLFSSL* ssl, void* pArgs)
     {
         DckeArgs* args = (DckeArgs*)pArgs;
 
         (void)ssl;
         (void)args;
     }
 
     /* handle processing client_key_exchange (16) */
     static int DoClientKeyExchange(WOLFSSL* ssl, byte* input, word32* inOutIdx,
                                                                     word32 size)
     {
         int ret;
     #ifdef WOLFSSL_ASYNC_CRYPT
         DckeArgs* args = (DckeArgs*)ssl->async.args;
         typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
         (void)sizeof(args_test);
     #else
         DckeArgs  args[1];
     #endif
 
         (void)size;
         (void)input;
 
         WOLFSSL_START(WC_FUNC_CLIENT_KEY_EXCHANGE_DO);
         WOLFSSL_ENTER("DoClientKeyExchange");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NOT_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_dcke;
         }
         else
     #endif /* WOLFSSL_ASYNC_CRYPT */
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(DckeArgs));
             args->idx = *inOutIdx;
             args->begin = *inOutIdx;
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async.freeArgs = FreeDckeArgs;
         #endif
         }
 
         /* Do Client Key Exchange State Machine */
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
                 /* Sanity checks */
                 if (ssl->options.side != WOLFSSL_SERVER_END) {
                     WOLFSSL_MSG("Client received client keyexchange, attack?");
                     WOLFSSL_ERROR(ssl->error = SIDE_ERROR);
                     ERROR_OUT(WOLFSSL_FATAL_ERROR, exit_dcke);
                 }
 
                 if (ssl->options.clientState < CLIENT_HELLO_COMPLETE) {
                     WOLFSSL_MSG("Client sending keyexchange at wrong time");
                     SendAlert(ssl, alert_fatal, unexpected_message);
                     ERROR_OUT(OUT_OF_ORDER_E, exit_dcke);
                 }
 
             #ifndef NO_CERTS
                 if (ssl->options.verifyPeer && ssl->options.failNoCert) {
                     if (!ssl->options.havePeerCert) {
                         WOLFSSL_MSG("client didn't present peer cert");
                         ERROR_OUT(NO_PEER_CERT, exit_dcke);
                     }
                 }
 
                 if (ssl->options.verifyPeer && ssl->options.failNoCertxPSK) {
                     if (!ssl->options.havePeerCert &&
                                              !ssl->options.usingPSK_cipher) {
                         WOLFSSL_MSG("client didn't present peer cert");
                         return NO_PEER_CERT;
                     }
                 }
             #endif /* !NO_CERTS */
 
             #if defined(WOLFSSL_CALLBACKS)
                 if (ssl->hsInfoOn) {
                     AddPacketName(ssl, "ClientKeyExchange");
                 }
                 if (ssl->toInfoOn) {
                     AddLateName("ClientKeyExchange", &ssl->timeoutInfo);
                 }
             #endif
 
                 if (ssl->arrays->preMasterSecret == NULL) {
                     ssl->arrays->preMasterSz = ENCRYPT_LEN;
                     ssl->arrays->preMasterSecret = (byte*)XMALLOC(ENCRYPT_LEN,
                                                 ssl->heap, DYNAMIC_TYPE_SECRET);
                     if (ssl->arrays->preMasterSecret == NULL) {
                         ERROR_OUT(MEMORY_E, exit_dcke);
                     }
                     XMEMSET(ssl->arrays->preMasterSecret, 0, ENCRYPT_LEN);
                 }
 
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* sanity check that PSK server callback has been set */
                         if (ssl->options.server_psk_cb == NULL) {
                            WOLFSSL_MSG("No server PSK callback set");
                            ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         /* make sure private key exists */
                         if (ssl->buffers.key == NULL ||
                                             ssl->buffers.key->buffer == NULL) {
                             ERROR_OUT(NO_PRIVATE_KEY, exit_dcke);
                         }
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         /* sanity check that PSK server callback has been set */
                         if (ssl->options.server_psk_cb == NULL) {
                             WOLFSSL_MSG("No server PSK callback set");
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         /* sanity check that PSK server callback has been set */
                         if (ssl->options.server_psk_cb == NULL) {
                             WOLFSSL_MSG("No server PSK callback set");
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         WOLFSSL_MSG("Bad kea type");
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         word16 keySz;
 
                         ssl->buffers.keyType = rsa_sa_algo;
                         ret = DecodePrivateKey(ssl, &keySz);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
                         args->length = (word32)keySz;
                         ssl->arrays->preMasterSz = SECRET_LEN;
 
                         if (ssl->options.tls) {
                             word16 check;
 
                             if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                                 ERROR_OUT(BUFFER_ERROR, exit_dcke);
                             }
 
                             ato16(input + args->idx, &check);
                             args->idx += OPAQUE16_LEN;
 
                             if ((word32)check != args->length) {
                                 WOLFSSL_MSG("RSA explicit size doesn't match");
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 SendAlert(ssl, alert_fatal, bad_record_mac);
                         #endif
                                 ERROR_OUT(RSA_PRIVATE_ERROR, exit_dcke);
                             }
                         }
 
                         if ((args->idx - args->begin) + args->length > size) {
                             WOLFSSL_MSG("RSA message too big");
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         /* pre-load PreMasterSecret with RNG data */
                         ret = wc_RNG_GenerateBlock(ssl->rng,
                             &ssl->arrays->preMasterSecret[VERSION_SZ],
                             SECRET_LEN - VERSION_SZ);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
 
                         args->output = NULL;
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         byte* pms = ssl->arrays->preMasterSecret;
                         word16 ci_sz;
 
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &ci_sz);
                         args->idx += OPAQUE16_LEN;
 
                         if (ci_sz > MAX_PSK_ID_LEN) {
                             ERROR_OUT(CLIENT_ID_ERROR, exit_dcke);
                         }
 
                         if ((args->idx - args->begin) + ci_sz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         XMEMCPY(ssl->arrays->client_identity,
                                                     input + args->idx, ci_sz);
                         args->idx += ci_sz;
 
                         ssl->arrays->client_identity[ci_sz] = '\0'; /* null term */
                         ssl->arrays->psk_keySz = ssl->options.server_psk_cb(ssl,
                             ssl->arrays->client_identity, ssl->arrays->psk_key,
                             MAX_PSK_KEY_LEN);
 
                         if (ssl->arrays->psk_keySz == 0 ||
                                 ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
 
                         /* make psk pre master secret */
                         /* length of key + length 0s + length of key + key */
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMSET(pms, 0, ssl->arrays->psk_keySz);
                         pms += ssl->arrays->psk_keySz;
 
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz =
                             (ssl->arrays->psk_keySz * 2) + (OPAQUE16_LEN * 2);
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         word16 cipherLen;
                         word16 plainLen = ENCRYPT_LEN;
 
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &cipherLen);
                         args->idx += OPAQUE16_LEN;
 
                         if (cipherLen > MAX_NTRU_ENCRYPT_SZ) {
                             ERROR_OUT(NTRU_KEY_ERROR, exit_dcke);
                         }
 
                         if ((args->idx - args->begin) + cipherLen > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         if (NTRU_OK != ntru_crypto_ntru_decrypt(
                                     (word16) ssl->buffers.key->length,
                                     ssl->buffers.key->buffer, cipherLen,
                                     input + args->idx, &plainLen,
                                     ssl->arrays->preMasterSecret)) {
                             ERROR_OUT(NTRU_DECRYPT_ERROR, exit_dcke);
                         }
 
                         if (plainLen != SECRET_LEN) {
                             ERROR_OUT(NTRU_DECRYPT_ERROR, exit_dcke);
                         }
 
                         args->idx += cipherLen;
                         ssl->arrays->preMasterSz = plainLen;
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                     #ifdef HAVE_ECC
                         ecc_key* private_key = ssl->eccTempKey;
 
                         /* handle static private key */
                         if (ssl->specs.static_ecdh &&
                                           ssl->ecdhCurveOID != ECC_X25519_OID &&
                                           ssl->ecdhCurveOID != ECC_X448_OID) {
                             word16 keySz;
 
                             ssl->buffers.keyType = ecc_dsa_sa_algo;
                             ret = DecodePrivateKey(ssl, &keySz);
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                             private_key = (ecc_key*)ssl->hsKey;
                         }
                     #endif
 
                         /* import peer ECC key */
                         if ((args->idx - args->begin) + OPAQUE8_LEN > size) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, decode_error);
                         #endif
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->length = input[args->idx++];
 
                         if ((args->idx - args->begin) + args->length > size) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, decode_error);
                         #endif
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X25519SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
                             if (ssl->peerX25519Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->peerX25519Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX25519KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                ssl->peerX25519Key);
                                 ssl->peerX25519KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve25519_check_public(
                                     input + args->idx, args->length,
                                     EC25519_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve25519_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX25519Key,
                                     EC25519_LITTLE_ENDIAN)) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 SendAlert(ssl, alert_fatal, illegal_parameter);
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->arrays->preMasterSz = CURVE25519_KEYSIZE;
 
                             ssl->peerX25519KeyPresent = 1;
 
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X448SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
                             if (ssl->peerX448Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->peerX448Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX448KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                ssl->peerX448Key);
                                 ssl->peerX448KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve448_check_public(
                                     input + args->idx, args->length,
                                     EC448_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve448_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX448Key,
                                     EC448_LITTLE_ENDIAN)) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 SendAlert(ssl, alert_fatal, illegal_parameter);
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->arrays->preMasterSz = CURVE448_KEY_SIZE;
 
                             ssl->peerX448KeyPresent = 1;
 
                             break;
                         }
                     #endif
                 #ifdef HAVE_ECC
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->EccSharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         if (!ssl->specs.static_ecdh &&
                             ssl->eccTempKeyPresent == 0) {
                             WOLFSSL_MSG("Ecc ephemeral key not made correctly");
                             ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                         }
 
                         if (ssl->peerEccKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->peerEccKey);
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         } else if (ssl->peerEccKeyPresent) {
                             ret = ReuseKey(ssl, DYNAMIC_TYPE_ECC,
                                            ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         }
 
                         if (wc_ecc_import_x963_ex(input + args->idx,
                                                   args->length, ssl->peerEccKey,
                                                   private_key->dp->id)) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, illegal_parameter);
                         #endif
                             ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                         }
 
                         ssl->arrays->preMasterSz = private_key->dp->size;
 
                         ssl->peerEccKeyPresent = 1;
                 #endif /* HAVE_ECC */
 
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         word16 clientPubSz;
 
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientPubSz);
                         args->idx += OPAQUE16_LEN;
 
                         if ((args->idx - args->begin) + clientPubSz > size) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, decode_error);
                         #endif
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->sigSz = clientPubSz;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
 
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
 
                         /* set the max agree result size */
                         ssl->arrays->preMasterSz = ENCRYPT_LEN;
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         word16 clientSz;
 
                         /* Read in the PSK hint */
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientSz);
                         args->idx += OPAQUE16_LEN;
                         if (clientSz > MAX_PSK_ID_LEN) {
                             ERROR_OUT(CLIENT_ID_ERROR, exit_dcke);
                         }
 
                         if ((args->idx - args->begin) + clientSz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         XMEMCPY(ssl->arrays->client_identity, input + args->idx,
                                                                     clientSz);
                         args->idx += clientSz;
                         ssl->arrays->client_identity[clientSz] = '\0'; /* null term */
 
                         /* Read in the DHE business */
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientSz);
                         args->idx += OPAQUE16_LEN;
 
                         if ((args->idx - args->begin) + clientSz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->sigSz = clientSz;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
 
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
 
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         word16 clientSz;
 
                         /* Read in the PSK hint */
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientSz);
                         args->idx += OPAQUE16_LEN;
                         if (clientSz > MAX_PSK_ID_LEN) {
                             ERROR_OUT(CLIENT_ID_ERROR, exit_dcke);
                         }
                         if ((args->idx - args->begin) + clientSz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         XMEMCPY(ssl->arrays->client_identity,
                                                    input + args->idx, clientSz);
                         args->idx += clientSz;
                         ssl->arrays->client_identity[clientSz] = '\0'; /* null term */
 
                         /* import peer ECC key */
                         if ((args->idx - args->begin) + OPAQUE8_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->length = input[args->idx++];
 
                         if ((args->idx - args->begin) + args->length > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->sigSz = ENCRYPT_LEN - OPAQUE16_LEN;
 
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X25519SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 WOLFSSL_MSG(
                                      "X25519 ephemeral key not made correctly");
                                 ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                             }
 
                             if (ssl->peerX25519Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->peerX25519Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX25519KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                ssl->peerX25519Key);
                                 ssl->peerX25519KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve25519_check_public(
                                     input + args->idx, args->length,
                                     EC25519_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve25519_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX25519Key,
                                     EC25519_LITTLE_ENDIAN)) {
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->peerX25519KeyPresent = 1;
 
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X448SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 WOLFSSL_MSG(
                                        "X448 ephemeral key not made correctly");
                                 ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                             }
 
                             if (ssl->peerX448Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->peerX448Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX448KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                ssl->peerX448Key);
                                 ssl->peerX448KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve448_check_public(
                                     input + args->idx, args->length,
                                     EC448_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve448_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX448Key,
                                     EC448_LITTLE_ENDIAN)) {
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->peerX448KeyPresent = 1;
 
                             break;
                         }
                     #endif
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->EccSharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         if (ssl->eccTempKeyPresent == 0) {
                             WOLFSSL_MSG("Ecc ephemeral key not made correctly");
                             ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                         }
 
                         if (ssl->peerEccKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->peerEccKey);
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         }
                         else if (ssl->peerEccKeyPresent) {
                             ret = ReuseKey(ssl, DYNAMIC_TYPE_ECC,
                                            ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         }
                         if (wc_ecc_import_x963_ex(input + args->idx,
                                  args->length, ssl->peerEccKey,
                                  ssl->eccTempKey->dp->id)) {
                             ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                         }
 
                         ssl->peerEccKeyPresent = 1;
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         RsaKey* key = (RsaKey*)ssl->hsKey;
 
                         ret = RsaDec(ssl,
                             input + args->idx,
                             args->length,
                             &args->output,
                             &args->sigSz,
                             key,
                         #ifdef HAVE_PK_CALLBACKS
                             ssl->buffers.key
                         #else
                             NULL
                         #endif
                         );
 
                         /*  Errors that can occur here that should be
                          *  indistinguishable:
                          *       RSA_BUFFER_E, RSA_PAD_E and RSA_PRIVATE_ERROR
                          */
                     #ifdef WOLFSSL_ASYNC_CRYPT
                         if (ret == WC_PENDING_E)
                             goto exit_dcke;
                     #endif
                         if (ret == BAD_FUNC_ARG)
                             goto exit_dcke;
 
                         args->lastErr = ret - (SECRET_LEN - args->sigSz);
                         ret = 0;
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         void* private_key = ssl->eccTempKey;
                         (void)private_key;
 
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             ret = X25519SharedSecret(ssl,
                                 (curve25519_key*)private_key,
                                 ssl->peerX25519Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret,
                                 &ssl->arrays->preMasterSz,
                                 WOLFSSL_SERVER_END
                             );
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             ret = X448SharedSecret(ssl,
                                 (curve448_key*)private_key,
                                 ssl->peerX448Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret,
                                 &ssl->arrays->preMasterSz,
                                 WOLFSSL_SERVER_END
                             );
                             break;
                         }
                     #endif
                     #ifdef HAVE_ECC
                         if (ssl->specs.static_ecdh) {
                             private_key = ssl->hsKey;
                         }
 
                         /* Generate shared secret */
                         ret = EccSharedSecret(ssl,
                             (ecc_key*)private_key, ssl->peerEccKey,
                             input + args->idx, &args->length,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_SERVER_END
                         );
                     #ifdef WOLFSSL_ASYNC_CRYPT
                         if (ret != WC_PENDING_E)
                     #endif
                         {
                             FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                         }
                     #endif
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             ssl->buffers.serverDH_Priv.length,
                             input + args->idx,
                             (word16)args->sigSz,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz);
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             ssl->buffers.serverDH_Priv.length,
                             input + args->idx,
                             (word16)args->sigSz,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &ssl->arrays->preMasterSz);
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             ret = X25519SharedSecret(ssl,
                                 (curve25519_key*)ssl->eccTempKey,
                                 ssl->peerX25519Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                                 &args->sigSz,
                                 WOLFSSL_SERVER_END
                             );
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             if (ret != WC_PENDING_E)
                         #endif
                             {
                                 FreeKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                    (void**)&ssl->peerX25519Key);
                                 ssl->peerX25519KeyPresent = 0;
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             ret = X448SharedSecret(ssl,
                                 (curve448_key*)ssl->eccTempKey,
                                 ssl->peerX448Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                                 &args->sigSz,
                                 WOLFSSL_SERVER_END
                             );
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             if (ret != WC_PENDING_E)
                         #endif
                             {
                                 FreeKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                      (void**)&ssl->peerX448Key);
                                 ssl->peerX448KeyPresent = 0;
                             }
                             break;
                         }
                     #endif
                         /* Generate shared secret */
                         ret = EccSharedSecret(ssl,
                             ssl->eccTempKey, ssl->peerEccKey,
                             input + args->idx, &args->length,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &args->sigSz,
                             WOLFSSL_SERVER_END
                         );
                         if (!ssl->specs.static_ecdh
                     #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                     #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                         }
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         byte mask;
                         int i;
 
                         /* Add the signature length to idx */
                         args->idx += args->length;
 
                     #ifdef DEBUG_WOLFSSL
                         /* check version (debug warning message only) */
                         if (args->output != NULL) {
                             if (args->output[0] != ssl->chVersion.major ||
                                 args->output[1] != ssl->chVersion.minor) {
                                 WOLFSSL_MSG("preMasterSecret version mismatch");
                             }
                         }
                     #endif
 
                         /* RFC5246 7.4.7.1:
                          * Treat incorrectly formatted message blocks and/or
                          * mismatched version numbers in a manner
                          * indistinguishable from correctly formatted RSA blocks
                          */
 
                         ret = args->lastErr;
                         args->lastErr = 0; /* reset */
                         /* On error 'ret' will be negative - top bit set */
                         mask = ((unsigned int)ret >>
                                                    ((sizeof(ret) * 8) - 1)) - 1;
 
                         /* build PreMasterSecret */
                         ssl->arrays->preMasterSecret[0] = ssl->chVersion.major;
                         ssl->arrays->preMasterSecret[1] = ssl->chVersion.minor;
 
                         if (args->output != NULL) {
                             /* Use random secret on error */
                             for (i = VERSION_SZ; i < SECRET_LEN; i++) {
                                 ssl->arrays->preMasterSecret[i] =
                                      ctMaskSel(mask, args->output[i],
                                                ssl->arrays->preMasterSecret[i]);
                             }
                         }
                         /* preMasterSecret has RNG and version set
                          * return proper length and ignore error
                          * error will be caught as decryption error
                          */
                         args->sigSz = SECRET_LEN;
                         ret = 0;
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         /* skip past the imported peer key */
                         args->idx += args->length;
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         args->idx += (word16)args->sigSz;
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         byte* pms = ssl->arrays->preMasterSecret;
                         word16 clientSz = (word16)args->sigSz;
 
                         args->idx += clientSz;
                         c16toa((word16)ssl->arrays->preMasterSz, pms);
                         ssl->arrays->preMasterSz += OPAQUE16_LEN;
                         pms += ssl->arrays->preMasterSz;
 
                         /* Use the PSK hint to look up the PSK and add it to the
                          * preMasterSecret here. */
                         ssl->arrays->psk_keySz = ssl->options.server_psk_cb(ssl,
                             ssl->arrays->client_identity, ssl->arrays->psk_key,
                             MAX_PSK_KEY_LEN);
 
                         if (ssl->arrays->psk_keySz == 0 ||
                                 ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
 
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMCPY(pms, ssl->arrays->psk_key,
                                                     ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz += ssl->arrays->psk_keySz +
                                                                 OPAQUE16_LEN;
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         byte* pms = ssl->arrays->preMasterSecret;
                         word16 clientSz = (word16)args->sigSz;
 
                         /* skip past the imported peer key */
                         args->idx += args->length;
 
                         /* Add preMasterSecret */
                         c16toa(clientSz, pms);
                         ssl->arrays->preMasterSz = OPAQUE16_LEN + clientSz;
                         pms += ssl->arrays->preMasterSz;
 
                         /* Use the PSK hint to look up the PSK and add it to the
                          * preMasterSecret here. */
                         ssl->arrays->psk_keySz = ssl->options.server_psk_cb(ssl,
                             ssl->arrays->client_identity, ssl->arrays->psk_key,
                             MAX_PSK_KEY_LEN);
 
                         if (ssl->arrays->psk_keySz == 0 ||
                                    ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
 
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz +=
                                       ssl->arrays->psk_keySz + OPAQUE16_LEN;
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
                 if (IsEncryptionOn(ssl, 0)) {
                     args->idx += ssl->keys.padSz;
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead)
                         args->idx += MacSize(ssl);
             #endif
                 }
 
             #ifdef HAVE_QSH
                 word16 name;
 
                 if (ssl->options.haveQSH) {
                     /* extension name */
                     ato16(input + args->idx, &name);
                     args->idx += OPAQUE16_LEN;
 
                     if (name == TLSX_QUANTUM_SAFE_HYBRID) {
                         int    qshSz;
                         /* if qshSz is larger than 0 it is the
                            length of buffer used */
                         if ((qshSz = TLSX_QSHCipher_Parse(ssl,
                                 input + args->idx,
                                 size - args->idx + args->begin, 1)) < 0) {
                             ERROR_OUT(qshSz, exit_dcke);
                         }
                         args->idx += qshSz;
                     }
                     else {
                         /* unknown extension sent client ignored handshake */
                         ERROR_OUT(BUFFER_ERROR, exit_dcke);
                     }
                 }
             #endif /* HAVE_QSH */
                 ret = MakeMasterSecret(ssl);
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* TLS_ASYNC_FINALIZE */
             FALL_THROUGH;
 
             case TLS_ASYNC_END:
             {
                 /* Set final index */
                 *inOutIdx = args->idx;
 
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
             #ifndef NO_CERTS
                 if (ssl->options.verifyPeer) {
                     ret = BuildCertHashes(ssl, &ssl->hsHashes->certHashes);
                 }
             #endif
                 break;
             } /* TLS_ASYNC_END */
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_dcke:
 
         WOLFSSL_LEAVE("DoClientKeyExchange", ret);
         WOLFSSL_END(WC_FUNC_CLIENT_KEY_EXCHANGE_DO);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E) {
             /* Mark message as not received so it can process again */
             ssl->msgsReceived.got_client_key_exchange = 0;
 
             return ret;
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
         /* Cleanup PMS */
         if (ssl->arrays->preMasterSecret != NULL) {
             ForceZero(ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz);
         }
         ssl->arrays->preMasterSz = 0;
 
         /* Final cleanup */
         FreeDckeArgs(ssl, args);
         FreeKeyExchange(ssl);
 
         return ret;
     }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #if defined(OPENSSL_ALL) || defined(HAVE_STUNNEL) || defined(WOLFSSL_NGINX) || \
     defined(WOLFSSL_HAPROXY)
     int SNI_Callback(WOLFSSL* ssl)
     {
         /* Stunnel supports a custom sni callback to switch an SSL's ctx
         * when SNI is received. Call it now if exists */
         if(ssl && ssl->ctx && ssl->ctx->sniRecvCb) {
             WOLFSSL_MSG("Calling custom sni callback");
             if(ssl->ctx->sniRecvCb(ssl, NULL, ssl->ctx->sniRecvCbArg)
                     == alert_fatal) {
                 WOLFSSL_MSG("Error in custom sni callback. Fatal alert");
                 SendAlert(ssl, alert_fatal, unrecognized_name);
                 return FATAL_ERROR;
             }
         }
         return 0;
     }
 #endif /* OPENSSL_ALL || HAVE_STUNNEL || WOLFSSL_NGINX || WOLFSSL_HAPROXY */
 
 #endif /* NO_WOLFSSL_SERVER */
 
 
 #ifdef WOLFSSL_ASYNC_CRYPT
diff --git a/wolfcrypt/src/dh.c b/wolfcrypt/src/dh.c
index 7661ff2b9..efabd4edf 100644
--- a/wolfcrypt/src/dh.c
+++ b/wolfcrypt/src/dh.c
@@ -1166,63 +1166,67 @@ static int GeneratePrivateDh186(DhKey* key, WC_RNG* rng, byte* priv,
 static int GeneratePrivateDh(DhKey* key, WC_RNG* rng, byte* priv,
                              word32* privSz)
 {
 #ifndef WC_NO_RNG
     int ret = 0;
     word32 sz = 0;
 
 #ifndef WOLFSSL_NO_DH186
     if (mp_iszero(&key->q) == MP_NO) {
 
         /* q param available, use NIST FIPS 186-4, "B.1.1 Key Pair
          * Generation Using Extra Random Bits" */
         ret = GeneratePrivateDh186(key, rng, priv, privSz);
 
     } else
 #endif
     {
 
         sz = mp_unsigned_bin_size(&key->p);
 
         /* Table of predetermined values from the operation
            2 * DiscreteLogWorkFactor(sz * WOLFSSL_BIT_SIZE) /
            WOLFSSL_BIT_SIZE + 1
            Sizes in table checked against RFC 3526
          */
         WOLFSSL_DH_ROUND(sz); /* if using fixed points only, then round up */
         switch (sz) {
             case 128:  sz = 21; break;
             case 256:  sz = 29; break;
             case 384:  sz = 34; break;
             case 512:  sz = 39; break;
             case 640:  sz = 42; break;
             case 768:  sz = 46; break;
             case 896:  sz = 49; break;
             case 1024: sz = 52; break;
             default:
             #ifndef WOLFSSL_DH_CONST
                 /* if using floating points and size of p is not in table */
                 sz = min(sz, 2 * DiscreteLogWorkFactor(sz * WOLFSSL_BIT_SIZE) /
                                            WOLFSSL_BIT_SIZE + 1);
                 break;
             #else
                 return BAD_FUNC_ARG;
             #endif
         }
 
-        ret = wc_RNG_GenerateBlock(rng, priv, sz);
+        if (sz > *privSz)
+            ret = WC_KEY_SIZE_E;
+
+        if (ret == 0)
+            ret = wc_RNG_GenerateBlock(rng, priv, sz);
 
         if (ret == 0) {
             priv[0] |= 0x0C;
             *privSz = sz;
         }
     }
 
     return ret;
 #else
     (void)key;
     (void)rng;
     (void)priv;
     (void)privSz;
     return NOT_COMPILED_IN;
 #endif /* WC_NO_RNG */
 }
@@ -1231,72 +1235,80 @@ static int GeneratePrivateDh(DhKey* key, WC_RNG* rng, byte* priv,
 static int GeneratePublicDh(DhKey* key, byte* priv, word32 privSz,
     byte* pub, word32* pubSz)
 {
     int ret = 0;
 #ifndef WOLFSSL_SP_MATH
 #ifdef WOLFSSL_SMALL_STACK
     mp_int* x;
     mp_int* y;
 #else
     mp_int x[1];
     mp_int y[1];
 #endif
 #endif
+    word32 binSz;
 
 #ifdef WOLFSSL_HAVE_SP_DH
 #ifndef WOLFSSL_SP_NO_2048
     if (mp_count_bits(&key->p) == 2048)
         return sp_DhExp_2048(&key->g, priv, privSz, &key->p, pub, pubSz);
 #endif
 #ifndef WOLFSSL_SP_NO_3072
     if (mp_count_bits(&key->p) == 3072)
         return sp_DhExp_3072(&key->g, priv, privSz, &key->p, pub, pubSz);
 #endif
 #ifdef WOLFSSL_SP_4096
     if (mp_count_bits(&key->p) == 4096)
         return sp_DhExp_4096(&key->g, priv, privSz, &key->p, pub, pubSz);
 #endif
 #endif
 
 #ifndef WOLFSSL_SP_MATH
 #ifdef WOLFSSL_SMALL_STACK
     x = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_DH);
     if (x == NULL)
         return MEMORY_E;
     y = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_DH);
     if (y == NULL) {
         XFREE(x, key->heap, DYNAMIC_TYPE_DH);
         return MEMORY_E;
     }
 #endif
     if (mp_init_multi(x, y, 0, 0, 0, 0) != MP_OKAY) {
     #ifdef WOLFSSL_SMALL_STACK
         XFREE(y, key->heap, DYNAMIC_TYPE_DH);
         XFREE(x, key->heap, DYNAMIC_TYPE_DH);
     #endif
         return MP_INIT_E;
     }
 
     if (mp_read_unsigned_bin(x, priv, privSz) != MP_OKAY)
         ret = MP_READ_E;
 
     if (ret == 0 && mp_exptmod(&key->g, x, &key->p, y) != MP_OKAY)
         ret = MP_EXPTMOD_E;
 
+    if (ret == 0) {
+        binSz = mp_unsigned_bin_size(y);
+        if (binSz > *pubSz) {
+            ret = WC_KEY_SIZE_E;
+        }
+    }
+
     if (ret == 0 && mp_to_unsigned_bin(y, pub) != MP_OKAY)
         ret = MP_TO_E;
 
     if (ret == 0)
-        *pubSz = mp_unsigned_bin_size(y);
+        *pubSz = binSz;
 
     mp_clear(y);
     mp_clear(x);
 #ifdef WOLFSSL_SMALL_STACK
     XFREE(y, key->heap, DYNAMIC_TYPE_DH);
     XFREE(x, key->heap, DYNAMIC_TYPE_DH);
 #endif
 #else
     ret = WC_KEY_SIZE_E;
 #endif
 
     return ret;
 }
diff --git a/wolfcrypt/test/test.c b/wolfcrypt/test/test.c
index fee483566..8d390ec5f 100644
--- a/wolfcrypt/test/test.c
+++ b/wolfcrypt/test/test.c
@@ -14607,96 +14607,101 @@ static int dh_test_check_pubvalue(void)
 static int dh_test_ffdhe(WC_RNG *rng, const DhParams* params)
 {
     int    ret;
     word32 privSz, pubSz, privSz2, pubSz2;
 #ifdef WOLFSSL_SMALL_STACK
     byte   *priv = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte   *pub = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte   *priv2 = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte   *pub2 = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte   *agree = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte   *agree2 = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     DhKey  *key = (DhKey *)XMALLOC(sizeof *key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     DhKey  *key2 = (DhKey *)XMALLOC(sizeof *key2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
 #else
     byte   priv[FFDHE_KEY_SIZE];
     byte   pub[FFDHE_KEY_SIZE];
     byte   priv2[FFDHE_KEY_SIZE];
     byte   pub2[FFDHE_KEY_SIZE];
     byte   agree[FFDHE_KEY_SIZE];
     byte   agree2[FFDHE_KEY_SIZE];
     DhKey  key_buf, *key = &key_buf;
     DhKey  key2_buf, *key2 = &key2_buf;
 #endif
     word32 agreeSz = FFDHE_KEY_SIZE;
     word32 agreeSz2 = FFDHE_KEY_SIZE;
 
 #ifdef WOLFSSL_SMALL_STACK
     if ((priv == NULL) ||
         (pub == NULL) ||
         (priv2 == NULL) ||
         (pub2 == NULL) ||
         (agree == NULL) ||
         (agree2 == NULL) ||
         (key == NULL) ||
         (key2 == NULL))
         ERROR_OUT(-7835, done);
 #endif
 
+    pubSz = FFDHE_KEY_SIZE;
+    pubSz2 = FFDHE_KEY_SIZE;
+    privSz = FFDHE_KEY_SIZE;
+    privSz2 = FFDHE_KEY_SIZE;
+
     XMEMSET(key, 0, sizeof *key);
     XMEMSET(key2, 0, sizeof *key2);
 
     ret = wc_InitDhKey_ex(key, HEAP_HINT, devId);
     if (ret != 0) {
         ERROR_OUT(-7826, done);
     }
     ret = wc_InitDhKey_ex(key2, HEAP_HINT, devId);
     if (ret != 0) {
         ERROR_OUT(-7827, done);
     }
 
     ret = wc_DhSetKey(key, params->p, params->p_len, params->g, params->g_len);
     if (ret != 0) {
         ERROR_OUT(-7828, done);
     }
 
     ret = wc_DhSetKey(key2, params->p, params->p_len, params->g,
                                                                  params->g_len);
     if (ret != 0) {
         ERROR_OUT(-7829, done);
     }
 
     ret = wc_DhGenerateKeyPair(key, rng, priv, &privSz, pub, &pubSz);
 #if defined(WOLFSSL_ASYNC_CRYPT)
     ret = wc_AsyncWait(ret, key.asyncDev, WC_ASYNC_FLAG_NONE);
 #endif
     if (ret != 0) {
         ERROR_OUT(-7830, done);
     }
 
     ret = wc_DhGenerateKeyPair(key2, rng, priv2, &privSz2, pub2, &pubSz2);
 #if defined(WOLFSSL_ASYNC_CRYPT)
     ret = wc_AsyncWait(ret, key2.asyncDev, WC_ASYNC_FLAG_NONE);
 #endif
     if (ret != 0) {
         ERROR_OUT(-7831, done);
     }
 
     ret = wc_DhAgree(key, agree, &agreeSz, priv, privSz, pub2, pubSz2);
 #if defined(WOLFSSL_ASYNC_CRYPT)
     ret = wc_AsyncWait(ret, key.asyncDev, WC_ASYNC_FLAG_NONE);
 #endif
     if (ret != 0) {
         ERROR_OUT(-7832, done);
     }
 
     ret = wc_DhAgree(key2, agree2, &agreeSz2, priv2, privSz2, pub, pubSz);
 #if defined(WOLFSSL_ASYNC_CRYPT)
     ret = wc_AsyncWait(ret, key2.asyncDev, WC_ASYNC_FLAG_NONE);
 #endif
     if (ret != 0) {
         ERROR_OUT(-7833, done);
     }
 
     if (agreeSz != agreeSz2 || XMEMCMP(agree, agree2, agreeSz)) {
         ERROR_OUT(-7834, done);
     }
@@ -14737,253 +14742,258 @@ done:
 static int dh_test(void)
 {
     int    ret;
     word32 bytes;
     word32 idx = 0, privSz, pubSz, privSz2, pubSz2;
     WC_RNG rng;
     int keyInit = 0;
 
 #define DH_TEST_TMP_SIZE 1024
 #if !defined(USE_CERT_BUFFERS_3072) && !defined(USE_CERT_BUFFERS_4096)
     #define DH_TEST_BUF_SIZE 256
 #else
     #define DH_TEST_BUF_SIZE 512
 #endif
     word32 agreeSz = DH_TEST_BUF_SIZE;
     word32 agreeSz2 = DH_TEST_BUF_SIZE;
 
 #ifdef WOLFSSL_SMALL_STACK
     DhKey  *key = (DhKey *)XMALLOC(sizeof *key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     DhKey  *key2 = (DhKey *)XMALLOC(sizeof *key2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte *tmp = (byte *)XMALLOC(DH_TEST_TMP_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte *priv = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte *pub = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte *priv2 = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte *pub2 = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte *agree = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     byte *agree2 = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
 
     if ((tmp == NULL) || (priv == NULL) || (pub == NULL) ||
-	(priv2 == NULL) || (pub2 == NULL) || (agree == NULL) ||
-	(agree2 == NULL))
+        (priv2 == NULL) || (pub2 == NULL) || (agree == NULL) ||
+        (agree2 == NULL))
         ERROR_OUT(-7960, done);
 #else
     DhKey  key_buf, *key = &key_buf;
     DhKey  key2_buf, *key2 = &key2_buf;
     byte tmp[DH_TEST_TMP_SIZE];
     byte priv[DH_TEST_BUF_SIZE];
     byte pub[DH_TEST_BUF_SIZE];
     byte priv2[DH_TEST_BUF_SIZE];
     byte pub2[DH_TEST_BUF_SIZE];
     byte agree[DH_TEST_BUF_SIZE];
     byte agree2[DH_TEST_BUF_SIZE];
 #endif
 
 #ifdef USE_CERT_BUFFERS_1024
     XMEMCPY(tmp, dh_key_der_1024, (size_t)sizeof_dh_key_der_1024);
     bytes = (size_t)sizeof_dh_key_der_1024;
 #elif defined(USE_CERT_BUFFERS_2048)
     XMEMCPY(tmp, dh_key_der_2048, (size_t)sizeof_dh_key_der_2048);
     bytes = (size_t)sizeof_dh_key_der_2048;
 #elif defined(USE_CERT_BUFFERS_3072)
     XMEMCPY(tmp, dh_key_der_3072, (size_t)sizeof_dh_key_der_3072);
     bytes = (size_t)sizeof_dh_key_der_3072;
 #elif defined(USE_CERT_BUFFERS_4096)
     XMEMCPY(tmp, dh_key_der_4096, (size_t)sizeof_dh_key_der_4096);
     bytes = (size_t)sizeof_dh_key_der_4096;
 #elif defined(NO_ASN)
     /* don't use file, no DER parsing */
 #elif !defined(NO_FILESYSTEM)
     {
         XFILE file = XFOPEN(dhParamsFile, "rb");
         if (! file)
             ERROR_OUT(-7900, done);
 
         bytes = (word32) XFREAD(tmp, 1, DH_TEST_TMP_SIZE, file);
         XFCLOSE(file);
     }
 #else
     /* No DH key to use. */
     ERROR_OUT(-7901, done);
 #endif /* USE_CERT_BUFFERS */
 
     (void)idx;
     (void)tmp;
     (void)bytes;
 
+    pubSz = DH_TEST_BUF_SIZE;
+    pubSz2 = DH_TEST_BUF_SIZE;
+    privSz = DH_TEST_BUF_SIZE;
+    privSz2 = DH_TEST_BUF_SIZE;
+
     XMEMSET(&rng, 0, sizeof(rng));
     /* Use API for coverage. */
     ret = wc_InitDhKey(key);
     if (ret != 0) {
         ERROR_OUT(-7902, done);
     }
     wc_FreeDhKey(key);
 
     ret = wc_InitDhKey_ex(key, HEAP_HINT, devId);
     if (ret != 0) {
         ERROR_OUT(-7903, done);
     }
     keyInit = 1;
     ret = wc_InitDhKey_ex(key2, HEAP_HINT, devId);
     if (ret != 0) {
         ERROR_OUT(-7904, done);
     }
 
 #ifdef NO_ASN
     ret = wc_DhSetKey(key, dh_p, sizeof(dh_p), dh_g, sizeof(dh_g));
     if (ret != 0) {
         ERROR_OUT(-7905, done);
     }
 
     ret = wc_DhSetKey(key2, dh_p, sizeof(dh_p), dh_g, sizeof(dh_g));
     if (ret != 0) {
         ERROR_OUT(-7906, done);
     }
 #else
     ret = wc_DhKeyDecode(tmp, &idx, key, bytes);
     if (ret != 0) {
         ERROR_OUT(-7907, done);
     }
 
     idx = 0;
     ret = wc_DhKeyDecode(tmp, &idx, key2, bytes);
     if (ret != 0) {
         ERROR_OUT(-7908, done);
     }
 #endif
 
 #ifndef HAVE_FIPS
     ret = wc_InitRng_ex(&rng, HEAP_HINT, devId);
 #else
     ret = wc_InitRng(&rng);
 #endif
     if (ret != 0) {
         ERROR_OUT(-7909, done);
     }
 
     ret = wc_DhGenerateKeyPair(key, &rng, priv, &privSz, pub, &pubSz);
 #if defined(WOLFSSL_ASYNC_CRYPT)
     ret = wc_AsyncWait(ret, key.asyncDev, WC_ASYNC_FLAG_NONE);
 #endif
     if (ret != 0) {
         ERROR_OUT(-7910, done);
     }
 
     ret = wc_DhGenerateKeyPair(key2, &rng, priv2, &privSz2, pub2, &pubSz2);
 #if defined(WOLFSSL_ASYNC_CRYPT)
     ret = wc_AsyncWait(ret, key2.asyncDev, WC_ASYNC_FLAG_NONE);
 #endif
     if (ret != 0) {
         ERROR_OUT(-7911, done);
     }
 
     ret = wc_DhAgree(key, agree, &agreeSz, priv, privSz, pub2, pubSz2);
 #if defined(WOLFSSL_ASYNC_CRYPT)
     ret = wc_AsyncWait(ret, key.asyncDev, WC_ASYNC_FLAG_NONE);
 #endif
     if (ret != 0) {
         ERROR_OUT(-7912, done);
     }
 
     ret = wc_DhAgree(key2, agree2, &agreeSz2, priv2, privSz2, pub, pubSz);
 #if defined(WOLFSSL_ASYNC_CRYPT)
     ret = wc_AsyncWait(ret, key2.asyncDev, WC_ASYNC_FLAG_NONE);
 #endif
     if (ret != 0) {
         ERROR_OUT(-7913, done);
     }
 
     if (agreeSz != agreeSz2 || XMEMCMP(agree, agree2, agreeSz)) {
         ERROR_OUT(-7914, done);
     }
 
 #if defined(WOLFSSL_KEY_GEN) && !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
     if (wc_DhCheckPrivKey(NULL, NULL, 0) != BAD_FUNC_ARG)
         ERROR_OUT(-7915, done);
 
     if (wc_DhCheckPrivKey(key, priv, privSz) != 0)
         ERROR_OUT(-7916, done);
 
     if (wc_DhExportParamsRaw(NULL, NULL, NULL, NULL, NULL, NULL, NULL) != BAD_FUNC_ARG)
         ERROR_OUT(-7917, done);
     {
         word32 pSz, qSz, gSz;
         if (wc_DhExportParamsRaw(key, NULL, &pSz, NULL, &qSz, NULL, &gSz) != LENGTH_ONLY_E)
             ERROR_OUT(-7918, done);
     }
 #endif
 
     /* Test DH key import / export */
 #if defined(WOLFSSL_DH_EXTRA) && (!defined(HAVE_FIPS) || \
         (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2)))
     wc_FreeDhKey(key);
     ret = wc_InitDhKey_ex(key, HEAP_HINT, devId);
     if (ret != 0) {
         ERROR_OUT(-7949, done);
     }
 
 #if !defined(NO_ASN) && !defined(NO_FILESYSTEM)
     {
         XFILE file = XFOPEN(dhKeyFile, "rb");
         if (!file)
             ERROR_OUT(-7950, done);
         bytes = (word32)XFREAD(tmp, 1, DH_TEST_TMP_SIZE, file);
         XFCLOSE(file);
     }
 
     idx = 0;
     ret = wc_DhKeyDecode(tmp, &idx, key, bytes);
     if (ret != 0) {
         ERROR_OUT(-7951, done);
     }
 #endif
 
     privSz = DH_TEST_BUF_SIZE;
     pubSz = DH_TEST_BUF_SIZE;
     ret = wc_DhExportKeyPair(key, priv, &privSz, pub, &pubSz);
     if (ret != 0) {
         ERROR_OUT(-7952, done);
     }
     ret = wc_DhImportKeyPair(key2, priv, privSz, pub, pubSz);
     if (ret != 0) {
         ERROR_OUT(-7953, done);
     }
 #endif /* WOLFSSL_DH_EXTRA */
 
     ret = dh_generate_test(&rng);
     if (ret != 0)
         ERROR_OUT(-7954, done);
 
     ret = dh_fips_generate_test(&rng);
     if (ret != 0)
         ERROR_OUT(-7955, done);
 
 #if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
     ret = dh_test_check_pubvalue();
     if (ret != 0)
         ERROR_OUT(-7956, done);
 #endif
 
     /* Specialized code for key gen when using FFDHE-2048 and FFDHE-3072. */
     #ifdef HAVE_FFDHE_2048
     ret = dh_test_ffdhe(&rng, wc_Dh_ffdhe2048_Get());
     if (ret != 0)
         ERROR_OUT(-7957, done);
     #endif
     #ifdef HAVE_FFDHE_3072
     ret = dh_test_ffdhe(&rng, wc_Dh_ffdhe3072_Get());
     if (ret != 0)
         ERROR_OUT(-7958, done);
     #endif
 
     wc_FreeDhKey(key);
     keyInit = 0;
 
 #if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST) && \
     !defined(WOLFSSL_OLD_PRIME_CHECK)
     /* Test Check Key */
     ret = wc_DhSetCheckKey(key, dh_p, sizeof(dh_p), dh_g, sizeof(dh_g),
                            NULL, 0, 0, &rng);
     if (ret != 0)
         ERROR_OUT(-7959, done);
     keyInit = 1; /* DhSetCheckKey also initializes the key, free it */
 #endif
