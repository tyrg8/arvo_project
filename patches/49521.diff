commit 824d44b70542f2434135fe5d12b0cb71df1ef05c
Merge: 7b65a1f1c 9256d6aa7
Author: David Garske <david@wolfssl.com>
Date:   Wed Jul 27 20:44:46 2022 -0700

    Merge pull request #5412 from douzzer/20220726-multi-test-fixes
    
    20220726-multi-test-fixes

diff --git a/src/internal.c b/src/internal.c
index 7b28e0037..088161390 100644
--- a/src/internal.c
+++ b/src/internal.c
@@ -18086,1071 +18086,1071 @@ int ProcessReply(WOLFSSL* ssl)
 /* Process input requests. Return 0 is done, 1 is call again to complete, and
    negative number is error. If allowSocketErr is set, SOCKET_ERROR_E in
    ssl->error will be whitelisted. This is useful when the connection has been
    closed and the endpoint wants to check for an alert sent by the other end. */
 int ProcessReplyEx(WOLFSSL* ssl, int allowSocketErr)
 {
     int    ret = 0, type = internal_error, readSz;
     int    atomicUser = 0;
     word32 startIdx = 0;
 #if defined(WOLFSSL_DTLS)
     int    used;
 #endif
 
 #ifdef ATOMIC_USER
     if (ssl->ctx->DecryptVerifyCb)
         atomicUser = 1;
 #endif
 
     if (ssl->error != 0 && ssl->error != WANT_READ && ssl->error != WANT_WRITE
     #ifdef HAVE_SECURE_RENEGOTIATION
         && ssl->error != APP_DATA_READY
     #endif
     #ifdef WOLFSSL_ASYNC_CRYPT
         && ssl->error != WC_PENDING_E
     #endif
     #ifdef WOLFSSL_NONBLOCK_OCSP
         && ssl->error != OCSP_WANT_READ
     #endif
         && (allowSocketErr != 1 || ssl->error != SOCKET_ERROR_E)
     ) {
         WOLFSSL_MSG("ProcessReply retry in error state, not allowed");
         return ssl->error;
     }
 
 #if defined(WOLFSSL_DTLS) && defined(WOLFSSL_ASYNC_CRYPT)
     /* process any pending DTLS messages - this flow can happen with async */
     if (ssl->dtls_rx_msg_list != NULL) {
         word32 pendingMsg = ssl->dtls_rx_msg_list_sz;
         if(IsAtLeastTLSv1_3(ssl->version)) {
 #ifdef WOLFSSL_DTLS13
             ret = Dtls13ProcessBufferedMessages(ssl);
-#elif
+#else
             ret = NOT_COMPILED_IN;
 #endif /* WOLFSSL_DTLS13 */
         }
         else {
             ret = DtlsMsgDrain(ssl);
         }
         if (ret != 0) {
             WOLFSSL_ERROR(ret);
             return ret;
         }
         /* we processed some messages, return so connect/accept can make
            progress */
         if (ssl->dtls_rx_msg_list_sz != pendingMsg)
             return ret;
     }
 #endif
 
     ret = RetrySendAlert(ssl);
     if (ret != 0)
         return ret;
 
     for (;;) {
         switch (ssl->options.processReply) {
 
         /* in the WOLFSSL_SERVER case, get the first byte for detecting
          * old client hello */
         case doProcessInit:
 
             readSz = RECORD_HEADER_SZ;
 
         #ifdef WOLFSSL_DTLS
             if (ssl->options.dtls) {
                 readSz = DTLS_RECORD_HEADER_SZ;
 #ifdef WOLFSSL_DTLS13
                 if (ssl->options.tls1_3) {
                     /* dtls1.3 unified header can be as little as 2 bytes */
                     readSz = DTLS_UNIFIED_HEADER_MIN_SZ;
                 }
 #endif /* WOLFSSL_DTLS13 */
             }
         #endif
 
             /* get header or return error */
             if (!ssl->options.dtls) {
                 if ((ret = GetInputData(ssl, readSz)) < 0)
                     return ret;
             } else {
             #ifdef WOLFSSL_DTLS
                 /* read ahead may already have header */
                 used = ssl->buffers.inputBuffer.length -
                        ssl->buffers.inputBuffer.idx;
                 if (used < readSz) {
                     if ((ret = GetInputData(ssl, readSz)) < 0)
                         return ret;
                 }
             #endif
             }
 
 #ifdef OLD_HELLO_ALLOWED
 
             /* see if sending SSLv2 client hello */
             if ( ssl->options.side == WOLFSSL_SERVER_END &&
                  ssl->options.clientState == NULL_STATE &&
                  ssl->buffers.inputBuffer.buffer[ssl->buffers.inputBuffer.idx]
                          != handshake) {
                 byte b0, b1;
 
                 ssl->options.processReply = runProcessOldClientHello;
 
                 /* sanity checks before getting size at front */
                 if (ssl->buffers.inputBuffer.buffer[
                           ssl->buffers.inputBuffer.idx + OPAQUE16_LEN] != OLD_HELLO_ID) {
                     WOLFSSL_MSG("Not a valid old client hello");
                     return PARSE_ERROR;
                 }
 
                 if (ssl->buffers.inputBuffer.buffer[
                           ssl->buffers.inputBuffer.idx + OPAQUE24_LEN] != SSLv3_MAJOR &&
                     ssl->buffers.inputBuffer.buffer[
                           ssl->buffers.inputBuffer.idx + OPAQUE24_LEN] != DTLS_MAJOR) {
                     WOLFSSL_MSG("Not a valid version in old client hello");
                     return PARSE_ERROR;
                 }
 
                 /* how many bytes need ProcessOldClientHello */
                 b0 =
                 ssl->buffers.inputBuffer.buffer[ssl->buffers.inputBuffer.idx++];
                 b1 =
                 ssl->buffers.inputBuffer.buffer[ssl->buffers.inputBuffer.idx++];
                 ssl->curSize = (word16)(((b0 & 0x7f) << 8) | b1);
             }
             else {
                 ssl->options.processReply = getRecordLayerHeader;
                 continue;
             }
             FALL_THROUGH;
 
         /* in the WOLFSSL_SERVER case, run the old client hello */
         case runProcessOldClientHello:
 
             /* get sz bytes or return error */
             if (!ssl->options.dtls) {
                 if ((ret = GetInputData(ssl, ssl->curSize)) < 0)
                     return ret;
             } else {
             #ifdef WOLFSSL_DTLS
                 /* read ahead may already have */
                 used = ssl->buffers.inputBuffer.length -
                        ssl->buffers.inputBuffer.idx;
                 if (used < ssl->curSize)
                     if ((ret = GetInputData(ssl, ssl->curSize - used)) < 0)
                         return ret;
             #endif  /* WOLFSSL_DTLS */
             }
 
             ret = ProcessOldClientHello(ssl, ssl->buffers.inputBuffer.buffer,
                                         &ssl->buffers.inputBuffer.idx,
                                         ssl->buffers.inputBuffer.length -
                                         ssl->buffers.inputBuffer.idx,
                                         ssl->curSize);
             if (ret < 0)
                 return ret;
 
             else if (ssl->buffers.inputBuffer.idx ==
                      ssl->buffers.inputBuffer.length) {
                 ssl->options.processReply = doProcessInit;
                 return 0;
             }
 
 #endif  /* OLD_HELLO_ALLOWED */
             FALL_THROUGH;
 
         /* get the record layer header */
         case getRecordLayerHeader:
 
             /* DTLSv1.3 record numbers in the header are encrypted, and AAD
              * uses the unecrypted form. Because of this we need to modify the
              * header, decrypting the numbers inside
              * DtlsParseUnifiedRecordLayer(). This violates the const attribute
              * of the buffer parameter of GetRecordHeader() used here. */
             ret = GetRecordHeader(ssl, ssl->buffers.inputBuffer.buffer,
                                        &ssl->buffers.inputBuffer.idx,
                                        &ssl->curRL, &ssl->curSize);
 
 #ifdef WOLFSSL_DTLS
             if (ssl->options.dtls && ret == SEQUENCE_ERROR) {
                 WOLFSSL_MSG("Silently dropping out of order DTLS message");
                 ssl->options.processReply = doProcessInit;
                 ssl->buffers.inputBuffer.length = 0;
                 ssl->buffers.inputBuffer.idx = 0;
 #ifdef WOLFSSL_DTLS_DROP_STATS
                 ssl->replayDropCount++;
 #endif /* WOLFSSL_DTLS_DROP_STATS */
 
 #ifdef WOLFSSL_DTLS13
                 /* return to send ACKS and shortcut rtx timer */
                 if (IsAtLeastTLSv1_3(ssl->version)
                     && ssl->dtls13Rtx.sendAcks)
                     return 0;
 #endif /* WOLFSSL_DTLS13 */
 
                 continue;
             }
 #endif
             if (ret != 0)
                 return ret;
 
 #ifdef WOLFSSL_TLS13
             if (IsAtLeastTLSv1_3(ssl->version) && IsEncryptionOn(ssl, 0) &&
                                         ssl->curRL.type != application_data &&
                                         ssl->curRL.type != change_cipher_spec) {
                 SendAlert(ssl, alert_fatal, unexpected_message);
                 return PARSE_ERROR;
             }
 #endif
 
             ssl->options.processReply = getData;
             FALL_THROUGH;
 
         /* retrieve record layer data */
         case getData:
 
             /* get sz bytes or return error */
             if (!ssl->options.dtls) {
                 if ((ret = GetInputData(ssl, ssl->curSize)) < 0) {
 #ifdef WOLFSSL_EXTRA_ALERTS
                     if (ret != WANT_READ)
                         SendAlert(ssl, alert_fatal, bad_record_mac);
 #endif
                     return ret;
                 }
             }
             else {
 #ifdef WOLFSSL_DTLS
                 /* read ahead may already have */
                 used = ssl->buffers.inputBuffer.length -
                        ssl->buffers.inputBuffer.idx;
                 if (used < ssl->curSize)
                     if ((ret = GetInputData(ssl, ssl->curSize)) < 0)
                         return ret;
 #endif
             }
 
             if (IsEncryptionOn(ssl, 0)) {
 #if defined(WOLFSSL_TLS13) || defined(WOLFSSL_EXTRA_ALERTS)
                 int tooLong = 0;
 #endif
 
 #ifdef WOLFSSL_TLS13
                 if (IsAtLeastTLSv1_3(ssl->version)) {
                     tooLong  = ssl->curSize > MAX_TLS13_ENC_SZ;
                     tooLong |= ssl->curSize - ssl->specs.aead_mac_size >
                                                              MAX_TLS13_PLAIN_SZ;
                 }
 #endif
 #ifdef WOLFSSL_EXTRA_ALERTS
                 if (!IsAtLeastTLSv1_3(ssl->version))
                     tooLong = ssl->curSize > MAX_TLS_CIPHER_SZ;
 #endif
 #if defined(WOLFSSL_TLS13) || defined(WOLFSSL_EXTRA_ALERTS)
                 if (tooLong) {
                     WOLFSSL_MSG("Encrypted data too long");
                     SendAlert(ssl, alert_fatal, record_overflow);
                     return BUFFER_ERROR;
                 }
 #endif
             }
             ssl->keys.padSz = 0;
 
             ssl->options.processReply = verifyEncryptedMessage;
             startIdx = ssl->buffers.inputBuffer.idx;  /* in case > 1 msg per */
             FALL_THROUGH;
 
         /* verify digest of encrypted message */
         case verifyEncryptedMessage:
 #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
             if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
                                    !atomicUser && ssl->options.startedETMRead) {
                 ret = VerifyMacEnc(ssl, ssl->buffers.inputBuffer.buffer +
                                    ssl->buffers.inputBuffer.idx,
                                    ssl->curSize, ssl->curRL.type);
             #ifdef WOLFSSL_ASYNC_CRYPT
                 if (ret == WC_PENDING_E)
                     return ret;
             #endif
                 if (ret < 0) {
                     WOLFSSL_MSG("VerifyMacEnc failed");
                     WOLFSSL_ERROR(ret);
                 #ifdef WOLFSSL_DTLS
                     /* If in DTLS mode, if the decrypt fails for any
                      * reason, pretend the datagram never happened. */
                     if (ssl->options.dtls) {
                         ssl->options.processReply = doProcessInit;
                         ssl->buffers.inputBuffer.idx =
                                         ssl->buffers.inputBuffer.length;
                         #ifdef WOLFSSL_DTLS_DROP_STATS
                             ssl->macDropCount++;
                         #endif /* WOLFSSL_DTLS_DROP_STATS */
                     }
                 #endif /* WOLFSSL_DTLS */
                 #ifdef WOLFSSL_EXTRA_ALERTS
                     if (!ssl->options.dtls)
                         SendAlert(ssl, alert_fatal, bad_record_mac);
                 #endif
                     return DECRYPT_ERROR;
                 }
                 ssl->keys.encryptSz    = ssl->curSize;
             }
 #endif
             ssl->options.processReply = decryptMessage;
             FALL_THROUGH;
 
         /* decrypt message */
         case decryptMessage:
 
             if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
                                         (!IsAtLeastTLSv1_3(ssl->version) ||
                                          ssl->curRL.type != change_cipher_spec))
             {
                 bufferStatic* in = &ssl->buffers.inputBuffer;
 
                 ret = SanityCheckCipherText(ssl, ssl->curSize);
                 if (ret < 0) {
                 #ifdef WOLFSSL_EXTRA_ALERTS
                     SendAlert(ssl, alert_fatal, bad_record_mac);
                 #endif
                     return ret;
                 }
 
                 if (atomicUser) {
         #ifdef ATOMIC_USER
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead) {
                         ret = ssl->ctx->VerifyDecryptCb(ssl,
                                      in->buffer + in->idx, in->buffer + in->idx,
                                      ssl->curSize - MacSize(ssl),
                                      ssl->curRL.type, 1, &ssl->keys.padSz,
                                      ssl->DecryptVerifyCtx);
                     }
                     else
             #endif
                     {
                         ret = ssl->ctx->DecryptVerifyCb(ssl,
                                       in->buffer + in->idx,
                                       in->buffer + in->idx,
                                       ssl->curSize, ssl->curRL.type, 1,
                                       &ssl->keys.padSz, ssl->DecryptVerifyCtx);
                     }
         #endif /* ATOMIC_USER */
                 }
                 else {
                     if (!ssl->options.tls1_3) {
         #ifndef WOLFSSL_NO_TLS12
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead) {
                         word32 digestSz = MacSize(ssl);
                         ret = DecryptTls(ssl,
                                       in->buffer + in->idx,
                                       in->buffer + in->idx,
                                       ssl->curSize - (word16)digestSz);
                         if (ret == 0) {
                             byte invalid = 0;
                             byte padding = (byte)-1;
                             word32 i;
                             word32 off = in->idx + ssl->curSize - digestSz - 1;
 
                             /* Last of padding bytes - indicates length. */
                             ssl->keys.padSz = in->buffer[off];
                             /* Constant time checking of padding - don't leak
                              * the length of the data.
                              */
                             /* Compare max pad bytes or at most data + pad. */
                             for (i = 1; i < MAX_PAD_SIZE && off >= i; i++) {
                                 /* Mask on indicates this is expected to be a
                                  * padding byte.
                                  */
                                 padding &= ctMaskLTE(i, ssl->keys.padSz);
                                 /* When this is a padding byte and not equal
                                  * to length then mask is set.
                                  */
                                 invalid |= padding &
                                            ctMaskNotEq(in->buffer[off - i],
                                                        ssl->keys.padSz);
                             }
                             /* If mask is set then there was an error. */
                             if (invalid) {
                                 ret = DECRYPT_ERROR;
                             }
                             ssl->keys.padSz += 1;
                             ssl->keys.decryptedCur = 1;
                         }
                     }
                     else
             #endif
                     {
                         ret = DecryptTls(ssl,
                                       in->buffer + in->idx,
                                       in->buffer + in->idx,
                                       ssl->curSize);
                     }
         #else
                         ret = DECRYPT_ERROR;
         #endif
                     }
                     else
                     {
                 #ifdef WOLFSSL_TLS13
                         byte *aad = (byte*)&ssl->curRL;
                         word16 aad_size = RECORD_HEADER_SZ;
 #ifdef WOLFSSL_DTLS13
                         if (ssl->options.dtls) {
                             /* aad now points to the record header */
                             aad = ssl->dtls13CurRL;
                             aad_size = ssl->dtls13CurRlLength;
                         }
 #endif /* WOLFSSL_DTLS13 */
 
                         ret = DecryptTls13(ssl,
                                         in->buffer + in->idx,
                                         in->buffer + in->idx,
                                         ssl->curSize,
                                         aad, aad_size, 1);
                 #else
                         ret = DECRYPT_ERROR;
                 #endif /* WOLFSSL_TLS13 */
                     }
                     (void)in;
                 }
 
             #ifdef WOLFSSL_ASYNC_CRYPT
                 if (ret == WC_PENDING_E)
                     return ret;
             #endif
 
                 if (ret >= 0) {
             #ifndef WOLFSSL_NO_TLS12
                     /* handle success */
                 #ifndef WOLFSSL_AEAD_ONLY
                     if (ssl->options.tls1_1 && ssl->specs.cipher_type == block)
                         ssl->buffers.inputBuffer.idx += ssl->specs.block_size;
                 #endif
                     /* go past TLSv1.1 IV */
                     if (CipherHasExpIV(ssl))
                         ssl->buffers.inputBuffer.idx += AESGCM_EXP_IV_SZ;
             #endif
                 }
                 else {
                     WOLFSSL_MSG("Decrypt failed");
                     WOLFSSL_ERROR(ret);
 #ifdef WOLFSSL_DTLS13
                     if (ssl->options.tls1_3 && ssl->options.dtls) {
                         WOLFSSL_MSG("DTLS: Ignoring decrypted failed record");
                         ssl->options.processReply = doProcessInit;
                         ssl->buffers.inputBuffer.idx =
                             ssl->buffers.inputBuffer.length;
                         return 0;
                     }
 #endif /* WOLFSSL_DTLS13 */
                 #ifdef WOLFSSL_EARLY_DATA
                     if (ssl->options.tls1_3) {
                          if (ssl->options.side == WOLFSSL_SERVER_END &&
                                  ssl->earlyData != no_early_data &&
                                  ssl->options.clientState <
                                                      CLIENT_FINISHED_COMPLETE) {
                             ssl->earlyDataSz += ssl->curSize;
                             if (ssl->earlyDataSz <=
                                                   ssl->options.maxEarlyDataSz) {
                                 WOLFSSL_MSG("Ignoring EarlyData!");
                                 if (ssl->keys.peer_sequence_number_lo-- == 0)
                                     ssl->keys.peer_sequence_number_hi--;
                                 ssl->options.processReply = doProcessInit;
                                 ssl->buffers.inputBuffer.idx += ssl->curSize;
                                 if (ssl->buffers.inputBuffer.idx >
                                     ssl->buffers.inputBuffer.length)
                                     return BUFFER_E;
 
                                 return 0;
                             }
                             WOLFSSL_MSG("Too much EarlyData!");
                         }
                         SendAlert(ssl, alert_fatal, bad_record_mac);
                     }
                 #endif
                 #ifdef WOLFSSL_DTLS
                     /* If in DTLS mode, if the decrypt fails for any
                      * reason, pretend the datagram never happened. */
                     if (ssl->options.dtls) {
                         ssl->options.processReply = doProcessInit;
                         ssl->buffers.inputBuffer.idx =
                                         ssl->buffers.inputBuffer.length;
                         #ifdef WOLFSSL_DTLS_DROP_STATS
                             ssl->macDropCount++;
                         #endif /* WOLFSSL_DTLS_DROP_STATS */
                     }
                 #endif /* WOLFSSL_DTLS */
                     return DECRYPT_ERROR;
                 }
             }
 
             ssl->options.processReply = verifyMessage;
             FALL_THROUGH;
 
         /* verify digest of message */
         case verifyMessage:
 
             if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
                                         (!IsAtLeastTLSv1_3(ssl->version) ||
                                          ssl->curRL.type != change_cipher_spec))
             {
                 if (!atomicUser
 #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                                 && !ssl->options.startedETMRead
 #endif
                     ) {
                     ret = VerifyMac(ssl, ssl->buffers.inputBuffer.buffer +
                                     ssl->buffers.inputBuffer.idx,
                                     ssl->curSize, ssl->curRL.type,
                                     &ssl->keys.padSz);
                 #ifdef WOLFSSL_ASYNC_CRYPT
                     if (ret == WC_PENDING_E)
                         return ret;
                 #endif
                     if (ret < 0) {
                         WOLFSSL_MSG("VerifyMac failed");
                         WOLFSSL_ERROR(ret);
                     #ifdef WOLFSSL_DTLS
                         /* If in DTLS mode, if the decrypt fails for any
                          * reason, pretend the datagram never happened. */
                         if (ssl->options.dtls) {
                             ssl->options.processReply = doProcessInit;
                             ssl->buffers.inputBuffer.idx =
                                             ssl->buffers.inputBuffer.length;
                             #ifdef WOLFSSL_DTLS_DROP_STATS
                                 ssl->macDropCount++;
                             #endif /* WOLFSSL_DTLS_DROP_STATS */
                         }
                     #endif /* WOLFSSL_DTLS */
                     #ifdef WOLFSSL_EXTRA_ALERTS
                         if (!ssl->options.dtls)
                             SendAlert(ssl, alert_fatal, bad_record_mac);
                     #endif
                         return DECRYPT_ERROR;
                     }
                 }
 
                 ssl->keys.encryptSz    = ssl->curSize;
                 ssl->keys.decryptedCur = 1;
 #ifdef WOLFSSL_TLS13
                 if (ssl->options.tls1_3) {
                     /* end of plaintext */
                     word16 i = (word16)(ssl->buffers.inputBuffer.idx +
                                  ssl->curSize - ssl->specs.aead_mac_size);
 
                     if (i > ssl->buffers.inputBuffer.length) {
                         WOLFSSL_ERROR(BUFFER_ERROR);
                         return BUFFER_ERROR;
                     }
 
                     /* Remove padding from end of plain text. */
                     for (--i; i > ssl->buffers.inputBuffer.idx; i--) {
                         if (ssl->buffers.inputBuffer.buffer[i] != 0)
                             break;
                     }
 
                     /* Get the real content type from the end of the data. */
                     ssl->curRL.type = ssl->buffers.inputBuffer.buffer[i];
                     /* consider both contentType byte and MAC as padding */
                     ssl->keys.padSz = ssl->buffers.inputBuffer.idx
                         + ssl->curSize - i;
                 }
 #endif
             }
 
             ssl->options.processReply = runProcessingOneRecord;
             FALL_THROUGH;
 
         /* the record layer is here */
         case runProcessingOneRecord:
 #ifdef WOLFSSL_DTLS13
             if (ssl->options.dtls && IsAtLeastTLSv1_3(ssl->version)) {
 
                 if(!Dtls13CheckWindow(ssl)) {
                     /* drop packet */
                     WOLFSSL_MSG(
                             "Dropping DTLS record outside receiving window");
                     ssl->options.processReply = doProcessInit;
                     ssl->buffers.inputBuffer.idx += ssl->curSize;
                     if (ssl->buffers.inputBuffer.idx >
                             ssl->buffers.inputBuffer.length)
                         return BUFFER_E;
 
                     continue;
                 }
 
                 ret = Dtls13UpdateWindow(ssl);
                 if (ret != 1) {
                     WOLFSSL_ERROR(ret);
                     return ret;
                 }
 
                 ret = Dtls13RecordRecvd(ssl);
                 if (ret != 0) {
                     WOLFSSL_ERROR(ret);
                     return ret;
                 }
             }
 #endif /* WOLFSSL_DTLS13 */
             ssl->options.processReply = runProcessingOneMessage;
             FALL_THROUGH;
 
         case runProcessingOneMessage:
             /* can't process a message if we have no data.  */
             if (ssl->buffers.inputBuffer.idx
                     >= ssl->buffers.inputBuffer.length) {
                 return BUFFER_ERROR;
             }
        #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
             if (IsEncryptionOn(ssl, 0) && ssl->options.startedETMRead) {
                 /* For TLS v1.1 the block size and explcit IV are added to idx,
                  * so it needs to be included in this limit check */
                 if ((ssl->curSize - ssl->keys.padSz -
                         (ssl->buffers.inputBuffer.idx - startIdx) -
                         MacSize(ssl) > MAX_PLAINTEXT_SZ)
 #ifdef WOLFSSL_ASYNC_CRYPT
                         && ssl->buffers.inputBuffer.length !=
                                 ssl->buffers.inputBuffer.idx
 #endif
                                 ) {
                     WOLFSSL_MSG("Plaintext too long - Encrypt-Then-MAC");
             #if defined(WOLFSSL_EXTRA_ALERTS)
                     SendAlert(ssl, alert_fatal, record_overflow);
             #endif
                     return BUFFER_ERROR;
                 }
             }
             else
        #endif
                 /* TLS13 plaintext limit is checked earlier before decryption */
                 /* For TLS v1.1 the block size and explcit IV are added to idx,
                  * so it needs to be included in this limit check */
                 if (!IsAtLeastTLSv1_3(ssl->version)
                         && ssl->curSize - ssl->keys.padSz -
                             (ssl->buffers.inputBuffer.idx - startIdx)
                                 > MAX_PLAINTEXT_SZ
 #ifdef WOLFSSL_ASYNC_CRYPT
                         && ssl->buffers.inputBuffer.length !=
                                 ssl->buffers.inputBuffer.idx
 #endif
                                 ) {
                 WOLFSSL_MSG("Plaintext too long");
 #if defined(WOLFSSL_TLS13) || defined(WOLFSSL_EXTRA_ALERTS)
                 SendAlert(ssl, alert_fatal, record_overflow);
 #endif
                 return BUFFER_ERROR;
             }
 
 #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) && !IsAtLeastTLSv1_3(ssl->version)) {
                 _DtlsUpdateWindow(ssl);
             }
 #endif /* WOLFSSL_DTLS */
 
             WOLFSSL_MSG("received record layer msg");
 
             switch (ssl->curRL.type) {
                 case handshake :
                     WOLFSSL_MSG("got HANDSHAKE");
                     /* debugging in DoHandShakeMsg */
                     if (ssl->options.dtls) {
 #ifdef WOLFSSL_DTLS
                         if (!IsAtLeastTLSv1_3(ssl->version)) {
                                 ret = DoDtlsHandShakeMsg(ssl,
                                                          ssl->buffers.inputBuffer.buffer,
                                                          &ssl->buffers.inputBuffer.idx,
                                                          ssl->buffers.inputBuffer.length);
                         }
 #endif
 #ifdef WOLFSSL_DTLS13
                         if (IsAtLeastTLSv1_3(ssl->version)) {
                             ret = Dtls13HandshakeRecv(ssl,
                                 ssl->buffers.inputBuffer.buffer,
                                 &ssl->buffers.inputBuffer.idx,
                                 ssl->buffers.inputBuffer.length);
 #ifdef WOLFSSL_EARLY_DATA
                             if (ret == 0 &&
                                 ssl->options.side == WOLFSSL_SERVER_END &&
                                 ssl->earlyData > early_data_ext &&
                                 ssl->options.handShakeState == HANDSHAKE_DONE) {
 
                                 /* return so wolfSSL_read_early_data can return
                                    exit */
                                 ssl->earlyData = no_early_data;
                                 ssl->options.processReply = doProcessInit;
 
                                 return ZERO_RETURN;
                             }
 #endif /* WOLFSSL_EARLY_DATA */
 
                         }
 #endif /* WOLFSSL_DTLS13 */
                     }
                     else if (!IsAtLeastTLSv1_3(ssl->version)
 #if defined(WOLFSSL_TLS13) && !defined(WOLFSSL_NO_TLS12)
                             || !TLSv1_3_Capable(ssl)
 #endif
                             ) {
 #ifndef WOLFSSL_NO_TLS12
                         ret = DoHandShakeMsg(ssl,
                                             ssl->buffers.inputBuffer.buffer,
                                             &ssl->buffers.inputBuffer.idx,
                                             ssl->buffers.inputBuffer.length);
 #else
                         ret = BUFFER_ERROR;
 #endif
                     }
                     else {
 #ifdef WOLFSSL_TLS13
                         ssl->msgsReceived.got_change_cipher = 0;
                         ret = DoTls13HandShakeMsg(ssl,
                                             ssl->buffers.inputBuffer.buffer,
                                             &ssl->buffers.inputBuffer.idx,
                                             ssl->buffers.inputBuffer.length);
     #ifdef WOLFSSL_EARLY_DATA
                         if (ret != 0)
                             return ret;
                         if (ssl->options.side == WOLFSSL_SERVER_END &&
                                 ssl->earlyData > early_data_ext &&
                                 ssl->options.handShakeState == HANDSHAKE_DONE) {
                             ssl->earlyData = no_early_data;
                             ssl->options.processReply = doProcessInit;
                             return ZERO_RETURN;
                         }
     #endif
 #else
                         ret = BUFFER_ERROR;
 #endif
                     }
                     if (ret != 0
                             /* DoDtlsHandShakeMsg can return a WANT_WRITE when
                              * calling DtlsMsgPoolSend. This msg is done
                              * processing so let's move on. */
                         && (!ssl->options.dtls
                             || ret != WANT_WRITE)
 #ifdef WOLFSSL_ASYNC_CRYPT
                     /* In async case, on pending, move onto next message.
                      * Current message should have been DtlsMsgStore'ed and
                      * should be processed with DtlsMsgDrain */
                             && (!ssl->options.dtls
                                 || ret != WC_PENDING_E)
 #endif
                     ) {
                         WOLFSSL_ERROR(ret);
                         return ret;
                     }
                     break;
 
                 case change_cipher_spec:
                     WOLFSSL_MSG("got CHANGE CIPHER SPEC");
                     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
                         if (ssl->hsInfoOn)
                             AddPacketName(ssl, "ChangeCipher");
                         /* add record header back on info */
                         if (ssl->toInfoOn) {
                             AddPacketInfo(ssl, "ChangeCipher",
                                 change_cipher_spec,
                                 ssl->buffers.inputBuffer.buffer +
                                 ssl->buffers.inputBuffer.idx - RECORD_HEADER_SZ -
                                 (ssl->options.dtls ? DTLS_RECORD_EXTRA : 0),
                                 1 + RECORD_HEADER_SZ, READ_PROTO, ssl->heap);
                             #ifdef WOLFSSL_CALLBACKS
                             AddLateRecordHeader(&ssl->curRL, &ssl->timeoutInfo);
                             #endif
                         }
                     #endif
 
 #ifdef WOLFSSL_TLS13
                     if (IsAtLeastTLSv1_3(ssl->version)) {
                         word32 i = ssl->buffers.inputBuffer.idx;
                         if (ssl->options.handShakeState == HANDSHAKE_DONE) {
                             SendAlert(ssl, alert_fatal, unexpected_message);
                             return UNKNOWN_RECORD_TYPE;
                         }
                         if (ssl->curSize != 1 ||
                                       ssl->buffers.inputBuffer.buffer[i] != 1) {
                             SendAlert(ssl, alert_fatal, illegal_parameter);
                             return UNKNOWN_RECORD_TYPE;
                         }
                         ssl->buffers.inputBuffer.idx++;
                         if (!ssl->msgsReceived.got_change_cipher) {
                             ssl->msgsReceived.got_change_cipher = 1;
                         }
                         else {
                             SendAlert(ssl, alert_fatal, illegal_parameter);
                             return UNKNOWN_RECORD_TYPE;
                         }
                         break;
                     }
 #endif
 
 #ifndef WOLFSSL_NO_TLS12
                     if (ssl->buffers.inputBuffer.idx >=
                             ssl->buffers.inputBuffer.length ||
                             ssl->curSize < 1) {
                         WOLFSSL_MSG("ChangeCipher msg too short");
                         return LENGTH_ERROR;
                     }
                     if (ssl->buffers.inputBuffer.buffer[
                             ssl->buffers.inputBuffer.idx] != 1) {
                         WOLFSSL_MSG("ChangeCipher msg wrong value");
                         return LENGTH_ERROR;
                     }
 
                     if (IsEncryptionOn(ssl, 0) && ssl->options.handShakeDone) {
 #ifdef HAVE_AEAD
                         if (ssl->specs.cipher_type == aead) {
                             if (ssl->specs.bulk_cipher_algorithm != wolfssl_chacha)
                                 ssl->curSize -= AESGCM_EXP_IV_SZ;
                             ssl->buffers.inputBuffer.idx += ssl->specs.aead_mac_size;
                             ssl->curSize -= ssl->specs.aead_mac_size;
                         }
                         else
 #endif
                         {
                             ssl->buffers.inputBuffer.idx += ssl->keys.padSz;
                             ssl->curSize -= (word16)ssl->keys.padSz;
                             ssl->curSize -= ssl->specs.iv_size;
                         }
 
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                         if (ssl->options.startedETMRead) {
                             word32 digestSz = MacSize(ssl);
                             ssl->buffers.inputBuffer.idx += digestSz;
                             ssl->curSize -= (word16)digestSz;
                         }
             #endif
                     }
 
                     if (ssl->curSize != 1) {
                         WOLFSSL_MSG("Malicious or corrupted ChangeCipher msg");
                         return LENGTH_ERROR;
                     }
 
                     ssl->buffers.inputBuffer.idx++;
 
                     ret = SanityCheckMsgReceived(ssl, change_cipher_hs);
                     if (ret != 0) {
                         if (!ssl->options.dtls) {
                             return ret;
                         }
                         else {
                         #ifdef WOLFSSL_DTLS
                         /* Check for duplicate CCS message in DTLS mode.
                          * DTLS allows for duplicate messages, and it should be
                          * skipped. Also skip if out of order. */
                             if (ret != DUPLICATE_MSG_E && ret != OUT_OF_ORDER_E)
                                 return ret;
                             /* Reset error */
                             ret = 0;
                             break;
                         #endif /* WOLFSSL_DTLS */
                         }
                     }
 
                     ssl->keys.encryptionOn = 1;
 
                     /* setup decrypt keys for following messages */
                     /* XXX This might not be what we want to do when
                      * receiving a CCS with multicast. We update the
                      * key when the application updates them. */
                     if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)
                         return ret;
 
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     ssl->options.startedETMRead = ssl->options.encThenMac;
             #endif
 
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             WOLFSSL_DTLS_PEERSEQ* peerSeq = ssl->keys.peerSeq;
 #ifdef WOLFSSL_MULTICAST
                             if (ssl->options.haveMcast) {
                                 peerSeq += ssl->keys.curPeerId;
                                 peerSeq->highwaterMark = UpdateHighwaterMark(0,
                                         ssl->ctx->mcastFirstSeq,
                                         ssl->ctx->mcastSecondSeq,
                                         ssl->ctx->mcastMaxSeq);
                             }
 #endif
                             peerSeq->nextEpoch++;
                             peerSeq->prevSeq_lo = peerSeq->nextSeq_lo;
                             peerSeq->prevSeq_hi = peerSeq->nextSeq_hi;
                             peerSeq->nextSeq_lo = 0;
                             peerSeq->nextSeq_hi = 0;
                             XMEMCPY(peerSeq->prevWindow, peerSeq->window,
                                     DTLS_SEQ_SZ);
                             XMEMSET(peerSeq->window, 0, DTLS_SEQ_SZ);
                         }
                     #endif
 
                     #ifdef HAVE_LIBZ
                         if (ssl->options.usingCompression)
                             if ( (ret = InitStreams(ssl)) != 0)
                                 return ret;
                     #endif
                     ret = BuildFinished(ssl, &ssl->hsHashes->verifyHashes,
                                        ssl->options.side == WOLFSSL_CLIENT_END ?
                                        server : client);
                     if (ret != 0)
                         return ret;
 #endif /* !WOLFSSL_NO_TLS12 */
                     break;
 
                 case application_data:
                     WOLFSSL_MSG("got app DATA");
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls && ssl->options.dtlsHsRetain) {
                         #ifdef HAVE_SECURE_RENEGOTIATION
                             /*
                              * Only free HS resources when not in the process of a
                              * secure renegotiation and we have received APP DATA
                              * from the current epoch
                              */
                             if (!IsSCR(ssl) && (DtlsUseSCRKeys(ssl)
                                     || !DtlsSCRKeysSet(ssl))) {
                                 FreeHandshakeResources(ssl);
                                 ssl->options.dtlsHsRetain = 0;
                             }
                         #else
                             FreeHandshakeResources(ssl);
                             ssl->options.dtlsHsRetain = 0;
                         #endif
                         }
                     #endif
                     #ifdef WOLFSSL_TLS13
                         if (ssl->keys.keyUpdateRespond) {
                             WOLFSSL_MSG("No KeyUpdate from peer seen");
                             return SANITY_MSG_E;
                         }
                     #endif
                     if ((ret = DoApplicationData(ssl,
                                                 ssl->buffers.inputBuffer.buffer,
                                                 &ssl->buffers.inputBuffer.idx,
                                                               NO_SNIFF)) != 0) {
                         WOLFSSL_ERROR(ret);
                         return ret;
                     }
                     break;
 
                 case alert:
                     WOLFSSL_MSG("got ALERT!");
                     ret = DoAlert(ssl, ssl->buffers.inputBuffer.buffer,
                                   &ssl->buffers.inputBuffer.idx, &type);
                     if (ret == alert_fatal)
                         return FATAL_ERROR;
                     else if (ret < 0)
                         return ret;
 
                     /* catch warnings that are handled as errors */
                     if (type == close_notify) {
                         ssl->buffers.inputBuffer.idx =
                             ssl->buffers.inputBuffer.length;
                         ssl->options.processReply = doProcessInit;
                         return ssl->error = ZERO_RETURN;
                     }
 
                     if (type == decrypt_error)
                         return FATAL_ERROR;
 
                     /* Reset error if we got an alert level in ret */
                     if (ret > 0)
                         ret = 0;
                     break;
 
 #ifdef WOLFSSL_DTLS13
             case ack:
                 WOLFSSL_MSG("got ACK");
                 if (ssl->options.dtls && IsAtLeastTLSv1_3(ssl->version)) {
                     word32 processedSize = 0;
                     ret = DoDtls13Ack(ssl, ssl->buffers.inputBuffer.buffer +
                                              ssl->buffers.inputBuffer.idx,
                                              ssl->buffers.inputBuffer.length -
                                              ssl->buffers.inputBuffer.idx -
                                              ssl->keys.padSz, &processedSize);
                     ssl->buffers.inputBuffer.idx += processedSize;
                     ssl->buffers.inputBuffer.idx += ssl->keys.padSz;
                     break;
                 }
                 FALL_THROUGH;
 #endif /* WOLFSSL_DTLS13 */
                 default:
                     WOLFSSL_ERROR(UNKNOWN_RECORD_TYPE);
                     return UNKNOWN_RECORD_TYPE;
             }
 
             ssl->options.processReply = doProcessInit;
 
             /* input exhausted */
             if (ssl->buffers.inputBuffer.idx >= ssl->buffers.inputBuffer.length
 #ifdef WOLFSSL_DTLS
                 /* If app data was processed then return now to avoid
                  * dropping any app data. */
                 || (ssl->options.dtls && ssl->curRL.type == application_data)
 #endif
                 ) {
                 /* Shrink input buffer when we successfully finish record
                  * processing */
                 if (ret == 0 && ssl->buffers.inputBuffer.dynamicFlag)
                     ShrinkInputBuffer(ssl, NO_FORCED_FREE);
                 return ret;
             }
             /* more messages per record */
             else if ((ssl->buffers.inputBuffer.idx - startIdx) < ssl->curSize) {
                 WOLFSSL_MSG("More messages in record");
 
                 ssl->options.processReply = runProcessingOneMessage;
 
                 if (IsEncryptionOn(ssl, 0)) {
                     WOLFSSL_MSG("Bundled encrypted messages, remove middle pad");
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead) {
                         word32 digestSz = MacSize(ssl);
                         if (ssl->buffers.inputBuffer.idx >=
                                                    ssl->keys.padSz + digestSz) {
                             ssl->buffers.inputBuffer.idx -=
                                                      ssl->keys.padSz + digestSz;
                         }
                         else {
                             WOLFSSL_MSG("\tmiddle padding error");
                             return FATAL_ERROR;
                         }
                     }
                     else
              #endif
                     {
                         if (ssl->buffers.inputBuffer.idx >= ssl->keys.padSz) {
                             ssl->buffers.inputBuffer.idx -= ssl->keys.padSz;
                         }
                         else {
                             WOLFSSL_MSG("\tmiddle padding error");
                             return FATAL_ERROR;
                         }
                     }
                 }
             }
             /* more records */
             else {
                 WOLFSSL_MSG("More records in input");
             }
 #ifdef WOLFSSL_ASYNC_CRYPT
             /* We are setup to read next message/record but we had an error
              * (probably WC_PENDING_E) so return that so it can be handled
              * by higher layers. */
             if (ret != 0)
                 return ret;
 #endif
             /* It is safe to shrink the input buffer here now. local vars will
              * be reset to the new starting value. */
             if (ret == 0 && ssl->buffers.inputBuffer.dynamicFlag)
                 ShrinkInputBuffer(ssl, NO_FORCED_FREE);
             continue;
         default:
             WOLFSSL_MSG("Bad process input state, programming error");
             return INPUT_CASE_ERROR;
         }
     }
 }
 
 #if !defined(WOLFSSL_NO_TLS12) || !defined(NO_OLD_TLS) || \
              (defined(WOLFSSL_TLS13) && defined(WOLFSSL_TLS13_MIDDLEBOX_COMPAT))
@@ -23196,312 +23196,310 @@ ciphersuites introduced through the "bulk" ciphersuites.
 @return true on success, else false.
 */
 int SetCipherList(WOLFSSL_CTX* ctx, Suites* suites, const char* list)
 {
     int       ret           = 0;
     int       idx           = 0;
     int       haveRSAsig    = 0;
     int       haveECDSAsig  = 0;
     int       haveFalconSig = 0;
     int       haveAnon      = 0;
 #ifdef OPENSSL_EXTRA
     int       haveRSA       = 0;
     int       haveDH        = 0;
     int       haveECC       = 0;
     int       haveStaticRSA = 1; /* allowed by default if compiled in */
     int       haveStaticECC = 0;
     int       haveNull      = 1; /* allowed by default if compiled in */
     int       callInitSuites = 0;
     int       havePSK       = 0;
 #endif
     const int suiteSz       = GetCipherNamesSize();
     const char* next        = list;
 
     if (suites == NULL || list == NULL) {
         WOLFSSL_MSG("SetCipherList parameter error");
         return 0;
     }
 
     if (next[0] == 0 || XSTRCMP(next, "ALL") == 0 ||
         XSTRCMP(next, "DEFAULT") == 0 || XSTRCMP(next, "HIGH") == 0)
         return 1; /* wolfSSL default */
 
     do {
         const char* current = next;
         char   name[MAX_SUITE_NAME + 1];
         int    i;
         word32 length;
     #ifdef OPENSSL_EXTRA
         int    allowing = 1;
     #endif
 
         next = XSTRSTR(next, ":");
         length = MAX_SUITE_NAME;
         if (next != NULL) {
             word32 currLen = (word32)(next - current);
             if (length > currLen) {
                 length = currLen;
             }
         }
 
     #ifdef OPENSSL_EXTRA
         if (length > 1) {
             if (*current == '!') {
                 allowing = 0;
                 current++;
                 length--;
             }
         }
     #endif
 
         XSTRNCPY(name, current, length);
         name[(length == sizeof(name)) ? length - 1 : length] = 0;
 
     #ifdef OPENSSL_EXTRA
         if (XSTRCMP(name, "DEFAULT") == 0 || XSTRCMP(name, "ALL") == 0) {
             if (XSTRCMP(name, "ALL") == 0)
                 haveAnon = 1;
             else
                 haveAnon = 0;
         #ifdef HAVE_ANON
             ctx->haveAnon = haveAnon;
         #endif
             haveRSA = 1;
             haveDH = 1;
             haveECDSAsig = 1;
             haveECC = 1;
             haveStaticECC = 1;
             haveStaticRSA = 1;
             haveRSAsig = 1;
-            haveECDSAsig = 1;
             havePSK = 1;
             haveNull = 0;
 
             callInitSuites = 1;
             ret = 1;
             continue;
         }
 
         /* We don't have a way to disallow high bit sizes. Only disable unsafe
          * ciphersuites. */
         if (XSTRCMP(name, "HIGH") == 0 && allowing) {
             /* Disable static, anonymous, and null ciphers */
             haveAnon = 0;
         #ifdef HAVE_ANON
             ctx->haveAnon = 0;
         #endif
             haveRSA = 1;
             haveDH = 1;
             haveECDSAsig = 1;
             haveECC = 1;
             haveStaticECC = 0;
             haveStaticRSA = 0;
             haveRSAsig = 1;
-            haveECDSAsig = 1;
             havePSK = 1;
             haveNull = 0;
 
             callInitSuites = 1;
             ret = 1;
             continue;
         }
 
         if (XSTRCMP(name, "aNULL") == 0) {
             haveAnon = allowing;
         #ifdef HAVE_ANON
             ctx->haveAnon = allowing;
         #endif
             if (allowing) {
                 /* Allow RSA by default. */
                 if (!haveECC)
                     haveRSA = 1;
                 if (!haveECDSAsig)
                     haveRSAsig = 1;
                 callInitSuites = 1;
                 ret = 1;
             }
             continue;
         }
 
         if (XSTRCMP(name, "eNULL") == 0 || XSTRCMP(name, "NULL") == 0) {
             haveNull = allowing;
             if (allowing) {
                 /* Allow RSA by default. */
                 if (!haveECC)
                     haveRSA = 1;
                 if (!haveECDSAsig)
                     haveRSAsig = 1;
                 callInitSuites = 1;
                 ret = 1;
             }
             continue;
         }
 
         if (XSTRCMP(name, "kDH") == 0) {
             haveStaticECC = allowing;
             if (allowing) {
                 haveECC = 1;
                 haveECDSAsig = 1;
                 callInitSuites = 1;
                 ret = 1;
             }
             continue;
         }
 
         if (XSTRCMP(name, "kRSA") == 0 || XSTRCMP(name, "RSA") == 0) {
             haveStaticRSA = allowing;
             if (allowing) {
                 haveRSA = 1;
                 haveRSAsig = 1;
                 callInitSuites = 1;
                 ret = 1;
             }
             continue;
         }
 
         if (XSTRCMP(name, "PSK") == 0) {
             havePSK = allowing;
             haveRSAsig = 1;
             if (allowing) {
                 /* Allow RSA by default. */
                 if (!haveECC)
                     haveRSA = 1;
                 if (!haveECDSAsig)
                     haveRSAsig = 1;
                 callInitSuites = 1;
                 ret = 1;
             }
             continue;
         }
 
         if (XSTRCMP(name, "LOW") == 0 || XSTRCMP(name, "MEDIUM") == 0) {
             /* No way to limit or allow low bit sizes */
             if (allowing) {
                 /* Allow RSA by default */
                 haveRSA = 1;
                 haveRSAsig = 1;
                 callInitSuites = 1;
                 ret = 1;
             }
             continue;
         }
 
         if (XSTRCMP(name, "DSS") == 0) {
             /* No support for DSA ciphersuites */
             continue;
         }
 
         if (XSTRCMP(name, "EXP") == 0 || XSTRCMP(name, "EXPORT") == 0) {
             /* wolfSSL doesn't support "export" ciphers. We can skip this */
             continue;
         }
     #endif /* OPENSSL_EXTRA */
 
         for (i = 0; i < suiteSz; i++) {
             if (XSTRNCMP(name, cipher_names[i].name, sizeof(name)) == 0
             #ifndef NO_ERROR_STRINGS
                 || XSTRNCMP(name, cipher_names[i].name_iana, sizeof(name)) == 0
             #endif
              ) {
             #ifdef WOLFSSL_DTLS
                 /* don't allow stream ciphers with DTLS */
                 if (ctx->method->version.major == DTLS_MAJOR) {
                     if (XSTRSTR(name, "RC4"))
                     {
                         WOLFSSL_MSG("Stream ciphers not supported with DTLS");
                         continue;
                     }
 
                 }
             #endif /* WOLFSSL_DTLS */
 
                 if (idx + 1 >= WOLFSSL_MAX_SUITE_SZ) {
                     WOLFSSL_MSG("WOLFSSL_MAX_SUITE_SZ set too low");
                     return 0; /* suites buffer not large enough, error out */
                 }
 
                 suites->suites[idx++] = cipher_names[i].cipherSuite0;
                 suites->suites[idx++] = cipher_names[i].cipherSuite;
                 /* The suites are either ECDSA, RSA, PSK, or Anon. The RSA
                  * suites don't necessarily have RSA in the name. */
             #ifdef WOLFSSL_TLS13
                 if (cipher_names[i].cipherSuite0 == TLS13_BYTE ||
                          (cipher_names[i].cipherSuite0 == ECC_BYTE &&
                           (cipher_names[i].cipherSuite == TLS_SHA256_SHA256 ||
                            cipher_names[i].cipherSuite == TLS_SHA384_SHA384))) {
                 #ifndef NO_RSA
                     haveRSAsig = 1;
                 #endif
                 #if defined(HAVE_ECC) || defined(HAVE_ED25519) || \
                                                              defined(HAVE_ED448)
                     haveECDSAsig = 1;
                 #endif
                 #if defined(HAVE_PQC)
                     haveFalconSig = 1;
                 #endif
                 }
                 else
             #endif
             #if defined(HAVE_ECC) || defined(HAVE_ED25519) || \
                                                              defined(HAVE_ED448)
                 if ((haveECDSAsig == 0) && XSTRSTR(name, "ECDSA"))
                     haveECDSAsig = 1;
                 else
             #endif
             #ifdef HAVE_ANON
                 if (XSTRSTR(name, "ADH"))
                     haveAnon = 1;
                 else
             #endif
                 if (haveRSAsig == 0
                     #ifndef NO_PSK
                         && (XSTRSTR(name, "PSK") == NULL)
                     #endif
                    ) {
                     haveRSAsig = 1;
                 }
 
                 ret = 1; /* found at least one */
                 break;
             }
         }
     }
     while (next++); /* ++ needed to skip ':' */
 
     if (ret) {
         int keySz = 0;
     #ifndef NO_CERTS
         keySz = ctx->privateKeySz;
     #endif
     #ifdef OPENSSL_EXTRA
         if (callInitSuites) {
             byte tmp[WOLFSSL_MAX_SUITE_SZ];
             XMEMCPY(tmp, suites->suites, idx); /* Store copy */
             suites->setSuites = 0; /* Force InitSuites */
             suites->hashSigAlgoSz = 0; /* Force InitSuitesHashSigAlgo call
                                         * inside InitSuites */
             InitSuites(suites, ctx->method->version, keySz, (word16)haveRSA,
                        (word16)havePSK, (word16)haveDH, (word16)haveECDSAsig,
                        (word16)haveECC, (word16)haveStaticRSA,
                        (word16)haveStaticECC, (word16)haveFalconSig,
                        (word16)haveAnon, (word16)haveNull, ctx->method->side);
             /* Restore user ciphers ahead of defaults */
             XMEMMOVE(suites->suites + idx, suites->suites,
                     min(suites->suiteSz, WOLFSSL_MAX_SUITE_SZ-idx));
             suites->suiteSz += (word16)idx;
         }
         else
     #endif
         {
             suites->suiteSz   = (word16)idx;
             InitSuitesHashSigAlgo(suites, haveECDSAsig, haveRSAsig,
                                   haveFalconSig, haveAnon, 1, keySz);
         }
         suites->setSuites = 1;
     }
 
     (void)ctx;
 
     return ret;
 }
 
 #ifdef OPENSSL_EXTRA
diff --git a/src/pk.c b/src/pk.c
index 747f14ece..018f0f2ef 100644
--- a/src/pk.c
+++ b/src/pk.c
@@ -2623,34 +2623,34 @@ int wolfSSL_RSA_set_ex_data(WOLFSSL_RSA *rsa, int idx, void *data)
 #ifdef HAVE_EX_DATA_CLEANUP_HOOKS
 /* Set the extra data and cleanup callback against the RSA key at an index.
  *
  * wolfSSL API.
  *
  * @param [in, out] rsa     RSA key.
  * @param [in]      idx     Index set set extra data at.
  * @param [in]      data    Extra data of anonymous type.
  * @param [in]      freeCb  Callback function to free extra data.
  * @return 1 on success.
  * @return 0 on failure.
  */
 int wolfSSL_RSA_set_ex_data_with_cleanup(WOLFSSL_RSA *rsa, int idx, void *data,
     wolfSSL_ex_data_cleanup_routine_t freeCb)
 {
     WOLFSSL_ENTER("wolfSSL_RSA_set_ex_data_with_cleanup");
 
-    return (rsa == NULL) ? NULL :
+    return (rsa == NULL) ? 0 :
         wolfSSL_CRYPTO_set_ex_data_with_cleanup(&rsa->ex_data, idx, data,
             freeCb);
 }
 #endif /* HAVE_EX_DATA_CLEANUP_HOOKS */
 
 /*
  * RSA check key APIs
  */
 
 #ifdef WOLFSSL_RSA_KEY_CHECK
 /* Check that the RSA key is valid using wolfCrypt.
  *
  * @param [in] rsa  RSA key.
  * @return  1 on success.
  * @return  0 on failure.
  */
diff --git a/src/ssl.c b/src/ssl.c
index 1145f51e2..4d5e548f0 100644
--- a/src/ssl.c
+++ b/src/ssl.c
@@ -11635,1088 +11635,1095 @@ int wolfSSL_dtls_retransmit(WOLFSSL* ssl)
 /* Not an SSL function, return 0 for success, error code otherwise */
 /* Prereq: ssl's RNG needs to be initialized. */
 int wolfSSL_DTLS_SetCookieSecret(WOLFSSL* ssl,
                                  const byte* secret, word32 secretSz)
 {
     int ret = 0;
 
     WOLFSSL_ENTER("wolfSSL_DTLS_SetCookieSecret");
 
     if (ssl == NULL) {
         WOLFSSL_MSG("need a SSL object");
         return BAD_FUNC_ARG;
     }
 
     if (secret != NULL && secretSz == 0) {
         WOLFSSL_MSG("can't have a new secret without a size");
         return BAD_FUNC_ARG;
     }
 
     /* If secretSz is 0, use the default size. */
     if (secretSz == 0)
         secretSz = COOKIE_SECRET_SZ;
 
     if (secretSz != ssl->buffers.dtlsCookieSecret.length) {
         byte* newSecret;
 
         if (ssl->buffers.dtlsCookieSecret.buffer != NULL) {
             ForceZero(ssl->buffers.dtlsCookieSecret.buffer,
                       ssl->buffers.dtlsCookieSecret.length);
             XFREE(ssl->buffers.dtlsCookieSecret.buffer,
                   ssl->heap, DYNAMIC_TYPE_NONE);
         }
 
         newSecret = (byte*)XMALLOC(secretSz, ssl->heap,DYNAMIC_TYPE_COOKIE_PWD);
         if (newSecret == NULL) {
             ssl->buffers.dtlsCookieSecret.buffer = NULL;
             ssl->buffers.dtlsCookieSecret.length = 0;
             WOLFSSL_MSG("couldn't allocate new cookie secret");
             return MEMORY_ERROR;
         }
         ssl->buffers.dtlsCookieSecret.buffer = newSecret;
         ssl->buffers.dtlsCookieSecret.length = secretSz;
     #ifdef WOLFSSL_CHECK_MEM_ZERO
         wc_MemZero_Add("wolfSSL_DTLS_SetCookieSecret secret",
             ssl->buffers.dtlsCookieSecret.buffer,
             ssl->buffers.dtlsCookieSecret.length);
     #endif
     }
 
     /* If the supplied secret is NULL, randomly generate a new secret. */
     if (secret == NULL) {
         ret = wc_RNG_GenerateBlock(ssl->rng,
                              ssl->buffers.dtlsCookieSecret.buffer, secretSz);
     }
     else
         XMEMCPY(ssl->buffers.dtlsCookieSecret.buffer, secret, secretSz);
 
     WOLFSSL_LEAVE("wolfSSL_DTLS_SetCookieSecret", 0);
     return ret;
 }
 
 #endif /* WOLFSSL_DTLS && !NO_WOLFSSL_SERVER */
 
 
 /* EITHER SIDE METHODS */
 #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EITHER_SIDE)
     WOLFSSL_METHOD* wolfSSLv23_method(void)
     {
         return wolfSSLv23_method_ex(NULL);
     }
     WOLFSSL_METHOD* wolfSSLv23_method_ex(void* heap)
     {
         WOLFSSL_METHOD* m = NULL;
         WOLFSSL_ENTER("SSLv23_method");
     #if !defined(NO_WOLFSSL_CLIENT)
         m = wolfSSLv23_client_method_ex(heap);
     #elif !defined(NO_WOLFSSL_SERVER)
         m = wolfSSLv23_server_method_ex(heap);
     #else
         (void)heap;
     #endif
         if (m != NULL) {
             m->side = WOLFSSL_NEITHER_END;
         }
 
         return m;
     }
 
     #ifdef WOLFSSL_ALLOW_SSLV3
     WOLFSSL_METHOD* wolfSSLv3_method(void)
     {
         return wolfSSLv3_method_ex(NULL);
     }
     WOLFSSL_METHOD* wolfSSLv3_method_ex(void* heap)
     {
         WOLFSSL_METHOD* m = NULL;
         WOLFSSL_ENTER("SSLv3_method");
     #if !defined(NO_WOLFSSL_CLIENT)
         m = wolfSSLv3_client_method_ex(heap);
     #elif !defined(NO_WOLFSSL_SERVER)
         m = wolfSSLv3_server_method_ex(heap);
     #endif
         if (m != NULL) {
             m->side = WOLFSSL_NEITHER_END;
         }
 
         return m;
     }
     #endif
 #endif /* OPENSSL_EXTRA || WOLFSSL_EITHER_SIDE */
 
 /* client only parts */
 #ifndef NO_WOLFSSL_CLIENT
 
     #ifdef OPENSSL_EXTRA
     WOLFSSL_METHOD* wolfSSLv2_client_method(void)
     {
         WOLFSSL_STUB("wolfSSLv2_client_method");
         return NULL;
     }
     #endif
 
     #if defined(WOLFSSL_ALLOW_SSLV3) && !defined(NO_OLD_TLS)
     WOLFSSL_METHOD* wolfSSLv3_client_method(void)
     {
         return wolfSSLv3_client_method_ex(NULL);
     }
     WOLFSSL_METHOD* wolfSSLv3_client_method_ex(void* heap)
     {
         WOLFSSL_METHOD* method =
                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
                                                      heap, DYNAMIC_TYPE_METHOD);
         (void)heap;
         WOLFSSL_ENTER("SSLv3_client_method_ex");
         if (method)
             InitSSL_Method(method, MakeSSLv3());
         return method;
     }
     #endif /* WOLFSSL_ALLOW_SSLV3 && !NO_OLD_TLS */
 
 
     WOLFSSL_METHOD* wolfSSLv23_client_method(void)
     {
         return wolfSSLv23_client_method_ex(NULL);
     }
     WOLFSSL_METHOD* wolfSSLv23_client_method_ex(void* heap)
     {
         WOLFSSL_METHOD* method =
                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
                                                      heap, DYNAMIC_TYPE_METHOD);
         (void)heap;
         WOLFSSL_ENTER("SSLv23_client_method_ex");
         if (method) {
     #if !defined(NO_SHA256) || defined(WOLFSSL_SHA384) || defined(WOLFSSL_SHA512)
         #if defined(WOLFSSL_TLS13)
             InitSSL_Method(method, MakeTLSv1_3());
         #elif !defined(WOLFSSL_NO_TLS12)
             InitSSL_Method(method, MakeTLSv1_2());
         #elif !defined(NO_OLD_TLS)
             InitSSL_Method(method, MakeTLSv1_1());
         #endif
     #else
         #ifndef NO_OLD_TLS
             InitSSL_Method(method, MakeTLSv1_1());
         #endif
     #endif
     #if !defined(NO_OLD_TLS) || defined(WOLFSSL_TLS13)
             method->downgrade = 1;
     #endif
         }
         return method;
     }
 
     /* please see note at top of README if you get an error from connect */
     WOLFSSL_ABI
     int wolfSSL_connect(WOLFSSL* ssl)
     {
     #if !(defined(WOLFSSL_NO_TLS12) && defined(NO_OLD_TLS) && defined(WOLFSSL_TLS13))
         int neededState;
         byte advanceState;
     #endif
         int ret = 0;
 
         (void)ret;
 
         WOLFSSL_ENTER("SSL_connect()");
 
         #ifdef HAVE_ERRNO_H
             errno = 0;
         #endif
 
         if (ssl == NULL)
             return BAD_FUNC_ARG;
 
     #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EITHER_SIDE)
         if (ssl->options.side == WOLFSSL_NEITHER_END) {
             ssl->error = InitSSL_Side(ssl, WOLFSSL_CLIENT_END);
             if (ssl->error != WOLFSSL_SUCCESS) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             ssl->error = 0; /* expected to be zero here */
         }
 
     #ifdef OPENSSL_EXTRA
         if (ssl->CBIS != NULL) {
             ssl->CBIS(ssl, SSL_ST_CONNECT, WOLFSSL_SUCCESS);
             ssl->cbmode = SSL_CB_WRITE;
         }
     #endif
     #endif /* OPENSSL_EXTRA || WOLFSSL_EITHER_SIDE */
 
     #if defined(WOLFSSL_NO_TLS12) && defined(NO_OLD_TLS) && defined(WOLFSSL_TLS13)
         return wolfSSL_connect_TLSv13(ssl);
     #else
         #ifdef WOLFSSL_TLS13
         if (ssl->options.tls1_3)
             return wolfSSL_connect_TLSv13(ssl);
         #endif
 
 #ifdef WOLFSSL_WOLFSENTRY_HOOKS
-        if (ssl->ConnectFilter) {
+        if ((ssl->ConnectFilter != NULL) &&
+            (ssl->options.connectState == CONNECT_BEGIN)) {
             wolfSSL_netfilter_decision_t res;
             if ((ssl->ConnectFilter(ssl, ssl->ConnectFilter_arg, &res) ==
                  WOLFSSL_SUCCESS) &&
                 (res == WOLFSSL_NETFILTER_REJECT)) {
                 ssl->error = SOCKET_FILTERED_E;
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
         }
 #endif /* WOLFSSL_WOLFSENTRY_HOOKS */
 
         if (ssl->options.side != WOLFSSL_CLIENT_END) {
             ssl->error = SIDE_ERROR;
             WOLFSSL_ERROR(ssl->error);
             return WOLFSSL_FATAL_ERROR;
         }
 
         #ifdef WOLFSSL_DTLS
         if (ssl->version.major == DTLS_MAJOR) {
             ssl->options.dtls   = 1;
             ssl->options.tls    = 1;
             ssl->options.tls1_1 = 1;
         }
         #endif
 
         /* fragOffset is non-zero when sending fragments. On the last
          * fragment, fragOffset is zero again, and the state can be
          * advanced. */
         advanceState = ssl->fragOffset == 0 &&
             (ssl->options.connectState == CONNECT_BEGIN ||
              ssl->options.connectState == HELLO_AGAIN ||
              (ssl->options.connectState >= FIRST_REPLY_DONE &&
               ssl->options.connectState <= FIRST_REPLY_FOURTH));
 ;
 
 #ifdef WOLFSSL_DTLS13
         if (ssl->options.dtls && IsAtLeastTLSv1_3(ssl->version))
             advanceState = advanceState && !ssl->dtls13SendingAckOrRtx;
 #endif /* WOLFSSL_DTLS13 */
 
         if (ssl->buffers.outputBuffer.length > 0
         #ifdef WOLFSSL_ASYNC_CRYPT
             /* do not send buffered or advance state if last error was an
                 async pending operation */
             && ssl->error != WC_PENDING_E
         #endif
         ) {
             ret = SendBuffered(ssl);
             if (ret == 0) {
                 if (ssl->fragOffset == 0 && !ssl->options.buildingMsg) {
                     if (advanceState) {
                         ssl->options.connectState++;
                         WOLFSSL_MSG("connect state: "
                                     "Advanced from last buffered fragment send");
                     #ifdef WOLFSSL_ASYNC_IO
                         /* Cleanup async */
                         FreeAsyncCtx(ssl, 0);
                     #endif
                     }
                 }
                 else {
                     WOLFSSL_MSG("connect state: "
                                 "Not advanced, more fragments to send");
                 }
             }
             else {
                 ssl->error = ret;
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
         }
 
         ret = RetrySendAlert(ssl);
         if (ret != 0) {
             ssl->error = ret;
             WOLFSSL_ERROR(ssl->error);
             return WOLFSSL_FATAL_ERROR;
         }
 
         switch (ssl->options.connectState) {
 
         case CONNECT_BEGIN :
             /* always send client hello first */
             if ( (ssl->error = SendClientHello(ssl)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             ssl->options.connectState = CLIENT_HELLO_SENT;
             WOLFSSL_MSG("connect state: CLIENT_HELLO_SENT");
             FALL_THROUGH;
 
         case CLIENT_HELLO_SENT :
             neededState = ssl->options.resuming ? SERVER_FINISHED_COMPLETE :
                                           SERVER_HELLODONE_COMPLETE;
             #ifdef WOLFSSL_DTLS
                 /* In DTLS, when resuming, we can go straight to FINISHED,
                  * or do a cookie exchange and then skip to FINISHED, assume
                  * we need the cookie exchange first. */
                 if (IsDtlsNotSctpMode(ssl))
                     neededState = SERVER_HELLOVERIFYREQUEST_COMPLETE;
             #endif
             /* get response */
             while (ssl->options.serverState < neededState) {
                 #ifdef WOLFSSL_TLS13
                     if (ssl->options.tls1_3)
                         return wolfSSL_connect_TLSv13(ssl);
                 #endif
                 if ( (ssl->error = ProcessReply(ssl)) < 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
                 /* if resumption failed, reset needed state */
                 else if (neededState == SERVER_FINISHED_COMPLETE)
                     if (!ssl->options.resuming) {
                     #ifdef WOLFSSL_DTLS
                         if (IsDtlsNotSctpMode(ssl))
                             neededState = SERVER_HELLOVERIFYREQUEST_COMPLETE;
                         else
                     #endif
                             neededState = SERVER_HELLODONE_COMPLETE;
                     }
 #ifdef WOLFSSL_DTLS13
 
                 if (ssl->options.dtls && IsAtLeastTLSv1_3(ssl->version)
                     && ssl->dtls13Rtx.sendAcks == 1) {
                     ssl->dtls13Rtx.sendAcks = 0;
                     /* we aren't negotiated the version yet, so we aren't sure
                      * the other end can speak v1.3. On the other side we have
                      * received a unified records, assuming that the
                      * ServerHello got lost, we will send an empty ACK. In case
                      * the server is a DTLS with version less than 1.3, it
                      * should just ignore the message */
                     if ((ssl->error = SendDtls13Ack(ssl)) < 0) {
                         if (ssl->error == WANT_WRITE)
                             ssl->dtls13SendingAckOrRtx = 1;
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
 
 
 #endif /* WOLFSSL_DTLS13 */
             }
 
             ssl->options.connectState = HELLO_AGAIN;
             WOLFSSL_MSG("connect state: HELLO_AGAIN");
             FALL_THROUGH;
 
         case HELLO_AGAIN :
             if (ssl->options.certOnly)
                 return WOLFSSL_SUCCESS;
 
         #ifdef WOLFSSL_TLS13
             if (ssl->options.tls1_3)
                 return wolfSSL_connect_TLSv13(ssl);
         #endif
 
             #ifdef WOLFSSL_DTLS
             if (ssl->options.serverState ==
                     SERVER_HELLOVERIFYREQUEST_COMPLETE) {
                 if (IsDtlsNotSctpMode(ssl)) {
                     /* re-init hashes, exclude first hello and verify request */
                     if ((ssl->error = InitHandshakeHashes(ssl)) != 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                     if ( (ssl->error = SendClientHello(ssl)) != 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
             }
             #endif
 
             ssl->options.connectState = HELLO_AGAIN_REPLY;
             WOLFSSL_MSG("connect state: HELLO_AGAIN_REPLY");
             FALL_THROUGH;
 
         case HELLO_AGAIN_REPLY :
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     neededState = ssl->options.resuming ?
                            SERVER_FINISHED_COMPLETE : SERVER_HELLODONE_COMPLETE;
 
                     /* get response */
                     while (ssl->options.serverState < neededState) {
                         if ( (ssl->error = ProcessReply(ssl)) < 0) {
                             WOLFSSL_ERROR(ssl->error);
                             return WOLFSSL_FATAL_ERROR;
                         }
                         /* if resumption failed, reset needed state */
                         if (neededState == SERVER_FINISHED_COMPLETE) {
                             if (!ssl->options.resuming)
                                 neededState = SERVER_HELLODONE_COMPLETE;
                         }
                     }
                 }
             #endif
 
             ssl->options.connectState = FIRST_REPLY_DONE;
             WOLFSSL_MSG("connect state: FIRST_REPLY_DONE");
             FALL_THROUGH;
 
         case FIRST_REPLY_DONE :
             #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)
                 #ifdef WOLFSSL_TLS13
                     if (ssl->options.tls1_3)
                         return wolfSSL_connect_TLSv13(ssl);
                 #endif
                 if (ssl->options.sendVerify) {
                     if ( (ssl->error = SendCertificate(ssl)) != 0) {
                     #ifdef WOLFSSL_CHECK_ALERT_ON_ERR
                         ProcessReplyEx(ssl, 1); /* See if an alert was sent. */
                     #endif
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                     WOLFSSL_MSG("sent: certificate");
                 }
 
             #endif
             ssl->options.connectState = FIRST_REPLY_FIRST;
             WOLFSSL_MSG("connect state: FIRST_REPLY_FIRST");
             FALL_THROUGH;
 
         case FIRST_REPLY_FIRST :
         #ifdef WOLFSSL_TLS13
             if (ssl->options.tls1_3)
                 return wolfSSL_connect_TLSv13(ssl);
         #endif
             if (!ssl->options.resuming) {
                 if ( (ssl->error = SendClientKeyExchange(ssl)) != 0) {
                 #ifdef WOLFSSL_CHECK_ALERT_ON_ERR
                     ProcessReplyEx(ssl, 1); /* See if an alert was sent. */
                 #endif
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
                 WOLFSSL_MSG("sent: client key exchange");
             }
 
             ssl->options.connectState = FIRST_REPLY_SECOND;
             WOLFSSL_MSG("connect state: FIRST_REPLY_SECOND");
             FALL_THROUGH;
 
     #if !defined(WOLFSSL_NO_TLS12) || !defined(NO_OLD_TLS)
         case FIRST_REPLY_SECOND :
             /* CLIENT: Fail-safe for Server Authentication. */
             if (!ssl->options.peerAuthGood) {
                 WOLFSSL_MSG("Server authentication did not happen");
                 ssl->error = NO_PEER_VERIFY;
                 return WOLFSSL_FATAL_ERROR;
             }
 
             #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)
                 if (ssl->options.sendVerify) {
                     if ( (ssl->error = SendCertificateVerify(ssl)) != 0) {
                     #ifdef WOLFSSL_CHECK_ALERT_ON_ERR
                         ProcessReplyEx(ssl, 1); /* See if an alert was sent. */
                     #endif
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                     WOLFSSL_MSG("sent: certificate verify");
                 }
             #endif /* !NO_CERTS && !WOLFSSL_NO_CLIENT_AUTH */
             ssl->options.connectState = FIRST_REPLY_THIRD;
             WOLFSSL_MSG("connect state: FIRST_REPLY_THIRD");
             FALL_THROUGH;
 
         case FIRST_REPLY_THIRD :
             if ( (ssl->error = SendChangeCipher(ssl)) != 0) {
             #ifdef WOLFSSL_CHECK_ALERT_ON_ERR
                 ProcessReplyEx(ssl, 1); /* See if an alert was sent. */
             #endif
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             WOLFSSL_MSG("sent: change cipher spec");
             ssl->options.connectState = FIRST_REPLY_FOURTH;
             WOLFSSL_MSG("connect state: FIRST_REPLY_FOURTH");
             FALL_THROUGH;
 
         case FIRST_REPLY_FOURTH :
             if ( (ssl->error = SendFinished(ssl)) != 0) {
             #ifdef WOLFSSL_CHECK_ALERT_ON_ERR
                 ProcessReplyEx(ssl, 1); /* See if an alert was sent. */
             #endif
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             WOLFSSL_MSG("sent: finished");
             ssl->options.connectState = FINISHED_DONE;
             WOLFSSL_MSG("connect state: FINISHED_DONE");
             FALL_THROUGH;
 
 #ifdef WOLFSSL_DTLS13
         case WAIT_FINISHED_ACK:
             ssl->options.connectState = FINISHED_DONE;
             FALL_THROUGH;
 #endif /* WOLFSSL_DTLS13 */
 
         case FINISHED_DONE :
             /* get response */
             while (ssl->options.serverState < SERVER_FINISHED_COMPLETE)
                 if ( (ssl->error = ProcessReply(ssl)) < 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
 
             ssl->options.connectState = SECOND_REPLY_DONE;
             WOLFSSL_MSG("connect state: SECOND_REPLY_DONE");
             FALL_THROUGH;
 
         case SECOND_REPLY_DONE:
         #ifndef NO_HANDSHAKE_DONE_CB
             if (ssl->hsDoneCb) {
                 int cbret = ssl->hsDoneCb(ssl, ssl->hsDoneCtx);
                 if (cbret < 0) {
                     ssl->error = cbret;
                     WOLFSSL_MSG("HandShake Done Cb don't continue error");
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
         #endif /* NO_HANDSHAKE_DONE_CB */
 
             if (!ssl->options.dtls) {
                 if (!ssl->options.keepResources) {
                     FreeHandshakeResources(ssl);
                 }
             }
         #ifdef WOLFSSL_DTLS
             else {
                 ssl->options.dtlsHsRetain = 1;
             }
         #endif /* WOLFSSL_DTLS */
 
         #if defined(WOLFSSL_ASYNC_CRYPT) && defined(HAVE_SECURE_RENEGOTIATION)
             /* This may be necessary in async so that we don't try to
              * renegotiate again */
             if (ssl->secure_renegotiation && ssl->secure_renegotiation->startScr) {
                 ssl->secure_renegotiation->startScr = 0;
             }
         #endif /* WOLFSSL_ASYNC_CRYPT && HAVE_SECURE_RENEGOTIATION */
         #if defined(WOLFSSL_ASYNC_IO) && !defined(WOLFSSL_ASYNC_CRYPT)
             /* Free the remaining async context if not using it for crypto */
             FreeAsyncCtx(ssl, 1);
         #endif
 
             ssl->error = 0; /* clear the error */
 
             WOLFSSL_LEAVE("SSL_connect()", WOLFSSL_SUCCESS);
             return WOLFSSL_SUCCESS;
     #endif /* !WOLFSSL_NO_TLS12 || !NO_OLD_TLS */
 
         default:
             WOLFSSL_MSG("Unknown connect state ERROR");
             return WOLFSSL_FATAL_ERROR; /* unknown connect state */
         }
     #endif /* !WOLFSSL_NO_TLS12 || !NO_OLD_TLS || !WOLFSSL_TLS13 */
     }
 
 #endif /* NO_WOLFSSL_CLIENT */
 
 
 /* server only parts */
 #ifndef NO_WOLFSSL_SERVER
 
     #ifdef OPENSSL_EXTRA
     WOLFSSL_METHOD* wolfSSLv2_server_method(void)
     {
         WOLFSSL_STUB("wolfSSLv2_server_method");
         return 0;
     }
     #endif
 
     #if defined(WOLFSSL_ALLOW_SSLV3) && !defined(NO_OLD_TLS)
     WOLFSSL_METHOD* wolfSSLv3_server_method(void)
     {
         return wolfSSLv3_server_method_ex(NULL);
     }
     WOLFSSL_METHOD* wolfSSLv3_server_method_ex(void* heap)
     {
         WOLFSSL_METHOD* method =
                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
                                                      heap, DYNAMIC_TYPE_METHOD);
         (void)heap;
         WOLFSSL_ENTER("SSLv3_server_method_ex");
         if (method) {
             InitSSL_Method(method, MakeSSLv3());
             method->side = WOLFSSL_SERVER_END;
         }
         return method;
     }
     #endif /* WOLFSSL_ALLOW_SSLV3 && !NO_OLD_TLS */
 
     WOLFSSL_METHOD* wolfSSLv23_server_method(void)
     {
         return wolfSSLv23_server_method_ex(NULL);
     }
 
     WOLFSSL_METHOD* wolfSSLv23_server_method_ex(void* heap)
     {
         WOLFSSL_METHOD* method =
                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
                                                      heap, DYNAMIC_TYPE_METHOD);
         (void)heap;
         WOLFSSL_ENTER("SSLv23_server_method_ex");
         if (method) {
     #if !defined(NO_SHA256) || defined(WOLFSSL_SHA384) || defined(WOLFSSL_SHA512)
         #ifdef WOLFSSL_TLS13
             InitSSL_Method(method, MakeTLSv1_3());
         #elif !defined(WOLFSSL_NO_TLS12)
             InitSSL_Method(method, MakeTLSv1_2());
         #elif !defined(NO_OLD_TLS)
             InitSSL_Method(method, MakeTLSv1_1());
         #endif
     #else
         #ifndef NO_OLD_TLS
             InitSSL_Method(method, MakeTLSv1_1());
         #else
             #error Must have SHA256, SHA384 or SHA512 enabled for TLS 1.2
         #endif
     #endif
     #if !defined(NO_OLD_TLS) || defined(WOLFSSL_TLS13)
             method->downgrade = 1;
     #endif
             method->side      = WOLFSSL_SERVER_END;
         }
         return method;
     }
 
 
     WOLFSSL_ABI
     int wolfSSL_accept(WOLFSSL* ssl)
     {
 #if !(defined(WOLFSSL_NO_TLS12) && defined(NO_OLD_TLS) && defined(WOLFSSL_TLS13))
         word16 havePSK = 0;
         word16 haveAnon = 0;
         word16 haveMcast = 0;
 #endif
         int ret = 0;
 
         (void)ret;
 
         if (ssl == NULL)
             return WOLFSSL_FATAL_ERROR;
 
     #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EITHER_SIDE)
         if (ssl->options.side == WOLFSSL_NEITHER_END) {
             WOLFSSL_MSG("Setting WOLFSSL_SSL to be server side");
             ssl->error = InitSSL_Side(ssl, WOLFSSL_SERVER_END);
             if (ssl->error != WOLFSSL_SUCCESS) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             ssl->error = 0; /* expected to be zero here */
         }
     #endif /* OPENSSL_EXTRA || WOLFSSL_EITHER_SIDE */
 
 #if defined(WOLFSSL_NO_TLS12) && defined(NO_OLD_TLS) && defined(WOLFSSL_TLS13)
         return wolfSSL_accept_TLSv13(ssl);
 #else
     #ifdef WOLFSSL_TLS13
         if (ssl->options.tls1_3)
             return wolfSSL_accept_TLSv13(ssl);
     #endif
         WOLFSSL_ENTER("SSL_accept()");
 
 #ifdef WOLFSSL_WOLFSENTRY_HOOKS
-        if (ssl->AcceptFilter) {
+        if ((ssl->AcceptFilter != NULL) &&
+            ((ssl->options.acceptState == ACCEPT_BEGIN)
+#ifdef HAVE_SECURE_RENEGOTIATION
+             || (ssl->options.acceptState == ACCEPT_BEGIN_RENEG)
+#endif
+                ))
+        {
             wolfSSL_netfilter_decision_t res;
             if ((ssl->AcceptFilter(ssl, ssl->AcceptFilter_arg, &res) ==
                  WOLFSSL_SUCCESS) &&
                 (res == WOLFSSL_NETFILTER_REJECT)) {
                 ssl->error = SOCKET_FILTERED_E;
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
         }
 #endif /* WOLFSSL_WOLFSENTRY_HOOKS */
 
         #ifdef HAVE_ERRNO_H
             errno = 0;
         #endif
 
         #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
         #endif
         (void)havePSK;
 
         #ifdef HAVE_ANON
             haveAnon = ssl->options.haveAnon;
         #endif
         (void)haveAnon;
 
         #ifdef WOLFSSL_MULTICAST
             haveMcast = ssl->options.haveMcast;
         #endif
         (void)haveMcast;
 
         if (ssl->options.side != WOLFSSL_SERVER_END) {
             ssl->error = SIDE_ERROR;
             WOLFSSL_ERROR(ssl->error);
             return WOLFSSL_FATAL_ERROR;
         }
 
     #ifndef NO_CERTS
         /* in case used set_accept_state after init */
         if (!havePSK && !haveAnon && !haveMcast) {
         #ifdef OPENSSL_EXTRA
             if (ssl->ctx->certSetupCb != NULL) {
                 WOLFSSL_MSG("CertSetupCb set. server cert and "
                             "key not checked");
             }
             else
         #endif
             {
                 if (!ssl->buffers.certificate ||
                     !ssl->buffers.certificate->buffer) {
 
                     WOLFSSL_MSG("accept error: server cert required");
                     ssl->error = NO_PRIVATE_KEY;
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
 
                 if (!ssl->buffers.key || !ssl->buffers.key->buffer) {
                     /* allow no private key if using existing key */
                 #ifdef WOLF_PRIVATE_KEY_ID
                     if (ssl->devId != INVALID_DEVID
                     #ifdef HAVE_PK_CALLBACKS
                         || wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)
                     #endif
                     ) {
                         WOLFSSL_MSG("Allowing no server private key "
                                     "(external)");
                     }
                     else
                 #endif
                     {
                         WOLFSSL_MSG("accept error: server key required");
                         ssl->error = NO_PRIVATE_KEY;
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
             }
         }
     #endif
 
     #ifdef WOLFSSL_DTLS
         if (ssl->version.major == DTLS_MAJOR) {
             ssl->options.dtls   = 1;
             ssl->options.tls    = 1;
             ssl->options.tls1_1 = 1;
         }
     #endif
 
         if (ssl->buffers.outputBuffer.length > 0
         #ifdef WOLFSSL_ASYNC_CRYPT
             /* do not send buffered or advance state if last error was an
                 async pending operation */
             && ssl->error != WC_PENDING_E
         #endif
         ) {
             ret = SendBuffered(ssl);
             if (ret == 0) {
                 /* fragOffset is non-zero when sending fragments. On the last
                  * fragment, fragOffset is zero again, and the state can be
                  * advanced. */
                 if (ssl->fragOffset == 0 && !ssl->options.buildingMsg) {
                     if (ssl->options.acceptState == ACCEPT_FIRST_REPLY_DONE ||
                         ssl->options.acceptState == SERVER_HELLO_SENT ||
                         ssl->options.acceptState == CERT_SENT ||
                         ssl->options.acceptState == CERT_STATUS_SENT ||
                         ssl->options.acceptState == KEY_EXCHANGE_SENT ||
                         ssl->options.acceptState == CERT_REQ_SENT ||
                         ssl->options.acceptState == ACCEPT_SECOND_REPLY_DONE ||
                         ssl->options.acceptState == TICKET_SENT ||
                         ssl->options.acceptState == CHANGE_CIPHER_SENT) {
                         ssl->options.acceptState++;
                         WOLFSSL_MSG("accept state: "
                                     "Advanced from last buffered fragment send");
                     #ifdef WOLFSSL_ASYNC_IO
                         /* Cleanup async */
                         FreeAsyncCtx(ssl, 0);
                     #endif
                     }
                 }
                 else {
                     WOLFSSL_MSG("accept state: "
                                 "Not advanced, more fragments to send");
                 }
             }
             else {
                 ssl->error = ret;
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
         }
 
         ret = RetrySendAlert(ssl);
         if (ret != 0) {
             ssl->error = ret;
             WOLFSSL_ERROR(ssl->error);
             return WOLFSSL_FATAL_ERROR;
         }
 
         switch (ssl->options.acceptState) {
 
         case ACCEPT_BEGIN :
 #ifdef HAVE_SECURE_RENEGOTIATION
         case ACCEPT_BEGIN_RENEG:
 #endif
             /* get response */
             while (ssl->options.clientState < CLIENT_HELLO_COMPLETE)
                 if ( (ssl->error = ProcessReply(ssl)) < 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
 #ifdef WOLFSSL_TLS13
             ssl->options.acceptState = ACCEPT_CLIENT_HELLO_DONE;
             WOLFSSL_MSG("accept state ACCEPT_CLIENT_HELLO_DONE");
             FALL_THROUGH;
 
         case ACCEPT_CLIENT_HELLO_DONE :
             if (ssl->options.tls1_3) {
                 return wolfSSL_accept_TLSv13(ssl);
             }
 #endif
 
 #ifdef WOLFSSL_DTLS
             if (ssl->chGoodCb != NULL && !IsSCR(ssl)) {
                 int cbret = ssl->chGoodCb(ssl, ssl->chGoodCtx);
                 if (cbret < 0) {
                     ssl->error = cbret;
                     WOLFSSL_MSG("ClientHello Good Cb don't continue error");
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
 #endif
 
             ssl->options.acceptState = ACCEPT_FIRST_REPLY_DONE;
             WOLFSSL_MSG("accept state ACCEPT_FIRST_REPLY_DONE");
             FALL_THROUGH;
 
         case ACCEPT_FIRST_REPLY_DONE :
             if ( (ssl->error = SendServerHello(ssl)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             ssl->options.acceptState = SERVER_HELLO_SENT;
             WOLFSSL_MSG("accept state SERVER_HELLO_SENT");
             FALL_THROUGH;
 
         case SERVER_HELLO_SENT :
         #ifdef WOLFSSL_TLS13
             if (ssl->options.tls1_3) {
                 return wolfSSL_accept_TLSv13(ssl);
             }
         #endif
             #ifndef NO_CERTS
                 if (!ssl->options.resuming)
                     if ( (ssl->error = SendCertificate(ssl)) != 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
             #endif
             ssl->options.acceptState = CERT_SENT;
             WOLFSSL_MSG("accept state CERT_SENT");
             FALL_THROUGH;
 
         case CERT_SENT :
             #ifndef NO_CERTS
             if (!ssl->options.resuming)
                 if ( (ssl->error = SendCertificateStatus(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
             #endif
             ssl->options.acceptState = CERT_STATUS_SENT;
             WOLFSSL_MSG("accept state CERT_STATUS_SENT");
             FALL_THROUGH;
 
         case CERT_STATUS_SENT :
         #ifdef WOLFSSL_TLS13
             if (ssl->options.tls1_3) {
                 return wolfSSL_accept_TLSv13(ssl);
             }
         #endif
             if (!ssl->options.resuming)
                 if ( (ssl->error = SendServerKeyExchange(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
             ssl->options.acceptState = KEY_EXCHANGE_SENT;
             WOLFSSL_MSG("accept state KEY_EXCHANGE_SENT");
             FALL_THROUGH;
 
         case KEY_EXCHANGE_SENT :
             #ifndef NO_CERTS
                 if (!ssl->options.resuming) {
                     if (ssl->options.verifyPeer) {
                         if ( (ssl->error = SendCertificateRequest(ssl)) != 0) {
                             WOLFSSL_ERROR(ssl->error);
                             return WOLFSSL_FATAL_ERROR;
                         }
                     }
                     else {
                         /* SERVER: Peer auth good if not verifying client. */
                         ssl->options.peerAuthGood = 1;
                     }
                 }
             #endif
             ssl->options.acceptState = CERT_REQ_SENT;
             WOLFSSL_MSG("accept state CERT_REQ_SENT");
             FALL_THROUGH;
 
         case CERT_REQ_SENT :
             if (!ssl->options.resuming)
                 if ( (ssl->error = SendServerHelloDone(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
             ssl->options.acceptState = SERVER_HELLO_DONE;
             WOLFSSL_MSG("accept state SERVER_HELLO_DONE");
             FALL_THROUGH;
 
         case SERVER_HELLO_DONE :
             if (!ssl->options.resuming) {
                 while (ssl->options.clientState < CLIENT_FINISHED_COMPLETE)
                     if ( (ssl->error = ProcessReply(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
             }
             ssl->options.acceptState = ACCEPT_SECOND_REPLY_DONE;
             WOLFSSL_MSG("accept state  ACCEPT_SECOND_REPLY_DONE");
             FALL_THROUGH;
 
         case ACCEPT_SECOND_REPLY_DONE :
         #ifndef NO_CERTS
             /* SERVER: When not resuming and verifying peer but no certificate
              * received and not failing when not received then peer auth good.
              */
             if (!ssl->options.resuming && ssl->options.verifyPeer &&
                 !ssl->options.havePeerCert && !ssl->options.failNoCert) {
                 ssl->options.peerAuthGood = 1;
             }
         #endif /* !NO_CERTS  */
         #ifdef WOLFSSL_NO_CLIENT_AUTH
             if (!ssl->options.resuming) {
                 ssl->options.peerAuthGood = 1;
             }
         #endif
 
 #ifdef HAVE_SESSION_TICKET
             if (ssl->options.createTicket && !ssl->options.noTicketTls12) {
                 if ( (ssl->error = SendTicket(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
 #endif /* HAVE_SESSION_TICKET */
             ssl->options.acceptState = TICKET_SENT;
             WOLFSSL_MSG("accept state  TICKET_SENT");
             FALL_THROUGH;
 
         case TICKET_SENT:
             /* SERVER: Fail-safe for CLient Authentication. */
             if (!ssl->options.peerAuthGood) {
                 WOLFSSL_MSG("Client authentication did not happen");
                 return WOLFSSL_FATAL_ERROR;
             }
 
             if ( (ssl->error = SendChangeCipher(ssl)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             ssl->options.acceptState = CHANGE_CIPHER_SENT;
             WOLFSSL_MSG("accept state  CHANGE_CIPHER_SENT");
             FALL_THROUGH;
 
         case CHANGE_CIPHER_SENT :
             if ( (ssl->error = SendFinished(ssl)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
 
             ssl->options.acceptState = ACCEPT_FINISHED_DONE;
             WOLFSSL_MSG("accept state ACCEPT_FINISHED_DONE");
             FALL_THROUGH;
 
         case ACCEPT_FINISHED_DONE :
             if (ssl->options.resuming) {
                 while (ssl->options.clientState < CLIENT_FINISHED_COMPLETE) {
                     if ( (ssl->error = ProcessReply(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
             }
             ssl->options.acceptState = ACCEPT_THIRD_REPLY_DONE;
             WOLFSSL_MSG("accept state ACCEPT_THIRD_REPLY_DONE");
             FALL_THROUGH;
 
         case ACCEPT_THIRD_REPLY_DONE :
 #ifndef NO_HANDSHAKE_DONE_CB
             if (ssl->hsDoneCb) {
                 int cbret = ssl->hsDoneCb(ssl, ssl->hsDoneCtx);
                 if (cbret < 0) {
                     ssl->error = cbret;
                     WOLFSSL_MSG("HandShake Done Cb don't continue error");
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
 #endif /* NO_HANDSHAKE_DONE_CB */
 
             if (!ssl->options.dtls) {
                 if (!ssl->options.keepResources) {
                     FreeHandshakeResources(ssl);
                 }
             }
 #ifdef WOLFSSL_DTLS
             else {
                 ssl->options.dtlsHsRetain = 1;
             }
 #endif /* WOLFSSL_DTLS */
 
 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(HAVE_SECURE_RENEGOTIATION)
             /* This may be necessary in async so that we don't try to
              * renegotiate again */
             if (ssl->secure_renegotiation && ssl->secure_renegotiation->startScr) {
                 ssl->secure_renegotiation->startScr = 0;
             }
 #endif /* WOLFSSL_ASYNC_CRYPT && HAVE_SECURE_RENEGOTIATION */
 #if defined(WOLFSSL_ASYNC_IO) && !defined(WOLFSSL_ASYNC_CRYPT)
             /* Free the remaining async context if not using it for crypto */
             FreeAsyncCtx(ssl, 1);
 #endif
 
 #if defined(WOLFSSL_SESSION_EXPORT) && defined(WOLFSSL_DTLS)
             if (ssl->dtls_export) {
                 if ((ssl->error = wolfSSL_send_session(ssl)) != 0) {
                     WOLFSSL_MSG("Export DTLS session error");
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
 #endif
             ssl->error = 0; /* clear the error */
 
             WOLFSSL_LEAVE("SSL_accept()", WOLFSSL_SUCCESS);
             return WOLFSSL_SUCCESS;
 
         default :
             WOLFSSL_MSG("Unknown accept state ERROR");
             return WOLFSSL_FATAL_ERROR;
         }
 #endif /* !WOLFSSL_NO_TLS12 */
     }
 
 #endif /* NO_WOLFSSL_SERVER */
 
 #if defined(WOLFSSL_DTLS) && !defined(NO_WOLFSSL_SERVER)
diff --git a/src/tls13.c b/src/tls13.c
index 4c6592835..0632b0103 100644
--- a/src/tls13.c
+++ b/src/tls13.c
@@ -9720,385 +9720,387 @@ int DoTls13HandShakeMsg(WOLFSSL* ssl, byte* input, word32* inOutIdx,
 /* The client connecting to the server.
  * The protocol version is expecting to be TLS v1.3.
  * If the server downgrades, and older versions of the protocol are compiled
  * in, the client will fallback to wolfSSL_connect().
  * Please see note at top of README if you get an error from connect.
  *
  * ssl  The SSL/TLS object.
  * returns WOLFSSL_SUCCESS on successful handshake, WOLFSSL_FATAL_ERROR when
  * unrecoverable error occurs and 0 otherwise.
  * For more error information use wolfSSL_get_error().
  */
 int wolfSSL_connect_TLSv13(WOLFSSL* ssl)
 {
     int advanceState;
     int ret = 0;
 
     WOLFSSL_ENTER("wolfSSL_connect_TLSv13()");
 
     #ifdef HAVE_ERRNO_H
     errno = 0;
     #endif
 
     if (ssl->options.side != WOLFSSL_CLIENT_END) {
         ssl->error = SIDE_ERROR;
         WOLFSSL_ERROR(ssl->error);
         return WOLFSSL_FATAL_ERROR;
     }
 
 #ifdef WOLFSSL_WOLFSENTRY_HOOKS
-    if (ssl->ConnectFilter) {
+    if ((ssl->ConnectFilter != NULL) &&
+        (ssl->options.connectState == CONNECT_BEGIN))
+    {
         wolfSSL_netfilter_decision_t res;
         if ((ssl->ConnectFilter(ssl, ssl->ConnectFilter_arg, &res) ==
              WOLFSSL_SUCCESS) &&
             (res == WOLFSSL_NETFILTER_REJECT)) {
             ssl->error = SOCKET_FILTERED_E;
             WOLFSSL_ERROR(ssl->error);
             return WOLFSSL_FATAL_ERROR;
         }
     }
 #endif /* WOLFSSL_WOLFSENTRY_HOOKS */
 
     /* fragOffset is non-zero when sending fragments. On the last
      * fragment, fragOffset is zero again, and the state can be
      * advanced. Also, only advance from states in which we send data */
     advanceState = (ssl->options.connectState == CONNECT_BEGIN ||
             ssl->options.connectState == HELLO_AGAIN ||
             (ssl->options.connectState >= FIRST_REPLY_DONE &&
              ssl->options.connectState <= FIRST_REPLY_FOURTH));
 
 #ifdef WOLFSSL_DTLS13
     if (ssl->options.dtls)
         advanceState = advanceState && !ssl->dtls13SendingFragments
             && !ssl->dtls13SendingAckOrRtx;
 #endif /* WOLFSSL_DTLS13 */
 
     if (ssl->buffers.outputBuffer.length > 0
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* do not send buffered or advance state if last error was an
             async pending operation */
         && ssl->error != WC_PENDING_E
     #endif
     ) {
         if ((ssl->error = SendBuffered(ssl)) == 0) {
             if (ssl->fragOffset == 0 && !ssl->options.buildingMsg) {
                 if (advanceState) {
 #ifdef WOLFSSL_DTLS13
                     if (ssl->options.dtls && IsAtLeastTLSv1_3(ssl->version) &&
                         ssl->options.connectState == FIRST_REPLY_FOURTH) {
                     /* WAIT_FINISHED_ACK is a state added afterwards, but it
                        can't follow FIRST_REPLY_FOURTH in the enum order. Indeed
                        the value of the enum ConnectState is stored in
                        serialized session. This would make importing serialized
                        session from other wolfSSL version incompatible */
                         ssl->options.connectState = WAIT_FINISHED_ACK;
                     }
                     else
 #endif /* WOLFSSL_DTLS13 */
                     {
                         ssl->options.connectState++;
                     }
                     WOLFSSL_MSG("connect state: "
                                 "Advanced from last buffered fragment send");
 #ifdef WOLFSSL_ASYNC_IO
                     FreeAsyncCtx(ssl, 0);
 #endif
 
                 }
             }
             else {
                 WOLFSSL_MSG("connect state: "
                             "Not advanced, more fragments to send");
             }
 #ifdef WOLFSSL_DTLS13
             if (ssl->options.dtls)
                 ssl->dtls13SendingAckOrRtx =0;
 #endif /* WOLFSSL_DTLS13 */
 
         }
         else {
             ssl->error = ret;
             WOLFSSL_ERROR(ssl->error);
             return WOLFSSL_FATAL_ERROR;
         }
     }
 
     ret = RetrySendAlert(ssl);
     if (ret != 0) {
         ssl->error = ret;
         WOLFSSL_ERROR(ssl->error);
         return WOLFSSL_FATAL_ERROR;
     }
 
 #ifdef WOLFSSL_DTLS13
     if (ssl->options.dtls && ssl->dtls13SendingFragments) {
         if ((ssl->error = Dtls13FragmentsContinue(ssl)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
         }
 
         /* we sent all the fragments. Advance state. */
         ssl->options.connectState++;
     }
 #endif /* WOLFSSL_DTLS13 */
 
     switch (ssl->options.connectState) {
 
         case CONNECT_BEGIN:
             /* Always send client hello first. */
             if ((ssl->error = SendTls13ClientHello(ssl)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
 
             ssl->options.connectState = CLIENT_HELLO_SENT;
             WOLFSSL_MSG("connect state: CLIENT_HELLO_SENT");
     #ifdef WOLFSSL_EARLY_DATA
             if (ssl->earlyData != no_early_data) {
         #if defined(WOLFSSL_TLS13_MIDDLEBOX_COMPAT)
                 if (!ssl->options.dtls) {
                     if ((ssl->error = SendChangeCipher(ssl)) != 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                     ssl->options.sentChangeCipher = 1;
                 }
         #endif
             ssl->options.handShakeState = CLIENT_HELLO_COMPLETE;
             return WOLFSSL_SUCCESS;
             }
     #endif
             FALL_THROUGH;
 
         case CLIENT_HELLO_SENT:
             /* Get the response/s from the server. */
             while (ssl->options.serverState <
                                           SERVER_HELLO_RETRY_REQUEST_COMPLETE) {
                 if ((ssl->error = ProcessReply(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                 }
 
 #ifdef WOLFSSL_DTLS13
                 if (ssl->options.dtls) {
                     if ((ssl->error = Dtls13DoScheduledWork(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
 #endif /* WOLFSSL_DTLS13 */
             }
 
             if (!ssl->options.tls1_3) {
     #ifndef WOLFSSL_NO_TLS12
                 if (ssl->options.downgrade)
                     return wolfSSL_connect(ssl);
     #endif
                 WOLFSSL_MSG("Client using higher version, fatal error");
                 return VERSION_ERROR;
             }
 
             ssl->options.connectState = HELLO_AGAIN;
             WOLFSSL_MSG("connect state: HELLO_AGAIN");
             FALL_THROUGH;
 
         case HELLO_AGAIN:
             if (ssl->options.certOnly)
                 return WOLFSSL_SUCCESS;
 
             if (ssl->options.serverState ==
                                           SERVER_HELLO_RETRY_REQUEST_COMPLETE) {
         #if defined(WOLFSSL_TLS13_MIDDLEBOX_COMPAT)
                 if (!ssl->options.dtls && !ssl->options.sentChangeCipher) {
                     if ((ssl->error = SendChangeCipher(ssl)) != 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                     ssl->options.sentChangeCipher = 1;
                 }
         #endif
                 /* Try again with different security parameters. */
                 if ((ssl->error = SendTls13ClientHello(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
 
             ssl->options.connectState = HELLO_AGAIN_REPLY;
             WOLFSSL_MSG("connect state: HELLO_AGAIN_REPLY");
             FALL_THROUGH;
 
         case HELLO_AGAIN_REPLY:
             /* Get the response/s from the server. */
             while (ssl->options.serverState < SERVER_FINISHED_COMPLETE) {
                 if ((ssl->error = ProcessReply(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                 }
 
 #ifdef WOLFSSL_DTLS13
                 if (ssl->options.dtls) {
                     if ((ssl->error = Dtls13DoScheduledWork(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
 #endif /* WOLFSSL_DTLS13 */
             }
 
             ssl->options.connectState = FIRST_REPLY_DONE;
             WOLFSSL_MSG("connect state: FIRST_REPLY_DONE");
             FALL_THROUGH;
 
         case FIRST_REPLY_DONE:
         #ifdef WOLFSSL_EARLY_DATA
             if (!ssl->options.dtls && ssl->earlyData != no_early_data) {
                 if ((ssl->error = SendTls13EndOfEarlyData(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
                 WOLFSSL_MSG("sent: end_of_early_data");
             }
         #endif
 
             ssl->options.connectState = FIRST_REPLY_FIRST;
             WOLFSSL_MSG("connect state: FIRST_REPLY_FIRST");
             FALL_THROUGH;
 
         case FIRST_REPLY_FIRST:
         #if defined(WOLFSSL_TLS13_MIDDLEBOX_COMPAT)
             if (!ssl->options.sentChangeCipher && !ssl->options.dtls) {
                 if ((ssl->error = SendChangeCipher(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
                 ssl->options.sentChangeCipher = 1;
             }
         #endif
 
             ssl->options.connectState = FIRST_REPLY_SECOND;
             WOLFSSL_MSG("connect state: FIRST_REPLY_SECOND");
             FALL_THROUGH;
 
         case FIRST_REPLY_SECOND:
             /* CLIENT: check peer authentication. */
             if (!ssl->options.peerAuthGood) {
                 WOLFSSL_MSG("Server authentication did not happen");
                 return WOLFSSL_FATAL_ERROR;
             }
         #ifndef NO_CERTS
             if (!ssl->options.resuming && ssl->options.sendVerify) {
                 ssl->error = SendTls13Certificate(ssl);
                 if (ssl->error != 0) {
                 #ifdef WOLFSSL_CHECK_ALERT_ON_ERR
                     ProcessReplyEx(ssl, 1); /* See if an alert was sent. */
                 #endif
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
                 WOLFSSL_MSG("sent: certificate");
             }
         #endif
 
             ssl->options.connectState = FIRST_REPLY_THIRD;
             WOLFSSL_MSG("connect state: FIRST_REPLY_THIRD");
             FALL_THROUGH;
 
         case FIRST_REPLY_THIRD:
         #if (!defined(NO_CERTS) && (!defined(NO_RSA) || defined(HAVE_ECC) || \
              defined(HAVE_ED25519) || defined(HAVE_ED448) || \
              defined(HAVE_PQC))) && (!defined(NO_WOLFSSL_SERVER) || \
              !defined(WOLFSSL_NO_CLIENT_AUTH))
             if (!ssl->options.resuming && ssl->options.sendVerify) {
                 ssl->error = SendTls13CertificateVerify(ssl);
                 if (ssl->error != 0) {
                 #ifdef WOLFSSL_CHECK_ALERT_ON_ERR
                     ProcessReplyEx(ssl, 1); /* See if an alert was sent. */
                 #endif
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
                 WOLFSSL_MSG("sent: certificate verify");
             }
         #endif
 
             ssl->options.connectState = FIRST_REPLY_FOURTH;
             WOLFSSL_MSG("connect state: FIRST_REPLY_FOURTH");
             FALL_THROUGH;
 
         case FIRST_REPLY_FOURTH:
             if ((ssl->error = SendTls13Finished(ssl)) != 0) {
             #ifdef WOLFSSL_CHECK_ALERT_ON_ERR
                 ProcessReplyEx(ssl, 1); /* See if an alert was sent. */
             #endif
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             WOLFSSL_MSG("sent: finished");
 
 #ifdef WOLFSSL_DTLS13
             ssl->options.connectState = WAIT_FINISHED_ACK;
             WOLFSSL_MSG("connect state: WAIT_FINISHED_ACK");
             FALL_THROUGH;
 
         case WAIT_FINISHED_ACK:
             if (ssl->options.dtls) {
                 while (ssl->options.serverState != SERVER_FINISHED_ACKED) {
                     if ((ssl->error = ProcessReply(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
 
                     if ((ssl->error = Dtls13DoScheduledWork(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
             }
 #endif /* WOLFSSL_DTLS13 */
             ssl->options.connectState = FINISHED_DONE;
             WOLFSSL_MSG("connect state: FINISHED_DONE");
             FALL_THROUGH;
 
         case FINISHED_DONE:
         #ifndef NO_HANDSHAKE_DONE_CB
             if (ssl->hsDoneCb != NULL) {
                 int cbret = ssl->hsDoneCb(ssl, ssl->hsDoneCtx);
                 if (cbret < 0) {
                     ssl->error = cbret;
                     WOLFSSL_MSG("HandShake Done Cb don't continue error");
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
         #endif /* NO_HANDSHAKE_DONE_CB */
 
             if (!ssl->options.keepResources) {
                 FreeHandshakeResources(ssl);
             }
         #if defined(WOLFSSL_ASYNC_IO) && !defined(WOLFSSL_ASYNC_CRYPT)
             /* Free the remaining async context if not using it for crypto */
             FreeAsyncCtx(ssl, 1);
         #endif
 
             ssl->error = 0; /* clear the error */
 
             WOLFSSL_LEAVE("wolfSSL_connect_TLSv13()", WOLFSSL_SUCCESS);
             return WOLFSSL_SUCCESS;
 
         default:
             WOLFSSL_MSG("Unknown connect state ERROR");
             return WOLFSSL_FATAL_ERROR; /* unknown connect state */
     }
 }
 #endif
 
 #if defined(WOLFSSL_SEND_HRR_COOKIE)
 /* Send a cookie with the HelloRetryRequest to avoid storing state.
  *
  * ssl       SSL/TLS object.
  * secret    Secret to use when generating integrity check for cookie.
  *           A value of NULL indicates to generate a new random secret.
  * secretSz  Size of secret data in bytes.
  *           Use a value of 0 to indicate use of default size.
  * returns BAD_FUNC_ARG when ssl is NULL or not using TLS v1.3, SIDE_ERROR when
  * called on a client; WOLFSSL_SUCCESS on success and otherwise failure.
  */
@@ -10746,534 +10748,540 @@ const char* wolfSSL_get_cipher_name_by_hash(WOLFSSL* ssl, const char* hash)
 #ifndef NO_WOLFSSL_SERVER
 /* The server accepting a connection from a client.
  * The protocol version is expecting to be TLS v1.3.
  * If the client downgrades, and older versions of the protocol are compiled
  * in, the server will fallback to wolfSSL_accept().
  * Please see note at top of README if you get an error from accept.
  *
  * ssl  The SSL/TLS object.
  * returns WOLFSSL_SUCCESS on successful handshake, WOLFSSL_FATAL_ERROR when
  * unrecoverable error occurs and 0 otherwise.
  * For more error information use wolfSSL_get_error().
  */
 int wolfSSL_accept_TLSv13(WOLFSSL* ssl)
 {
 #if !defined(NO_CERTS) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))
     word16 havePSK = 0;
 #endif
     int advanceState;
     int ret = 0;
 
     WOLFSSL_ENTER("SSL_accept_TLSv13()");
 
 
 #ifdef HAVE_ERRNO_H
     errno = 0;
 #endif
 
 #if !defined(NO_CERTS) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))
     havePSK = ssl->options.havePSK;
 #endif
 
     if (ssl->options.side != WOLFSSL_SERVER_END) {
         ssl->error = SIDE_ERROR;
         WOLFSSL_ERROR(ssl->error);
         return WOLFSSL_FATAL_ERROR;
     }
 
 #ifdef WOLFSSL_WOLFSENTRY_HOOKS
-    if (ssl->AcceptFilter) {
+    if ((ssl->AcceptFilter != NULL) &&
+            ((ssl->options.acceptState == TLS13_ACCEPT_BEGIN)
+#ifdef HAVE_SECURE_RENEGOTIATION
+             || (ssl->options.acceptState == TLS13_ACCEPT_BEGIN_RENEG)
+#endif
+                ))
+    {
         wolfSSL_netfilter_decision_t res;
         if ((ssl->AcceptFilter(ssl, ssl->AcceptFilter_arg, &res) ==
              WOLFSSL_SUCCESS) &&
             (res == WOLFSSL_NETFILTER_REJECT)) {
             ssl->error = SOCKET_FILTERED_E;
             WOLFSSL_ERROR(ssl->error);
             return WOLFSSL_FATAL_ERROR;
         }
     }
 #endif /* WOLFSSL_WOLFSENTRY_HOOKS */
 
 #ifndef NO_CERTS
 #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
     if (!havePSK)
 #endif
     {
     #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA) || \
         defined(WOLFSSL_NGINX) || defined (WOLFSSL_HAPROXY)
         if (ssl->ctx->certSetupCb != NULL) {
             WOLFSSL_MSG("CertSetupCb set. server cert and "
                         "key not checked");
         }
         else
     #endif
         {
             if (!ssl->buffers.certificate ||
                 !ssl->buffers.certificate->buffer) {
 
                 WOLFSSL_MSG("accept error: server cert required");
                 ssl->error = NO_PRIVATE_KEY;
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
 
             if (!ssl->buffers.key || !ssl->buffers.key->buffer) {
                 /* allow no private key if using existing key */
             #ifdef WOLF_PRIVATE_KEY_ID
                 if (ssl->devId != INVALID_DEVID
                 #ifdef HAVE_PK_CALLBACKS
                     || wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)
                 #endif
                 ) {
                     WOLFSSL_MSG("Allowing no server private key (external)");
                 }
                 else
             #endif
                 {
                     WOLFSSL_MSG("accept error: server key required");
                     ssl->error = NO_PRIVATE_KEY;
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
         }
     }
 #endif /* NO_CERTS */
 
     if (ssl->buffers.outputBuffer.length > 0
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* do not send buffered or advance state if last error was an
             async pending operation */
         && ssl->error != WC_PENDING_E
     #endif
     ) {
 
         /* fragOffset is non-zero when sending fragments. On the last
          * fragment, fragOffset is zero again, and the state can be
          * advanced. */
         advanceState =
             (ssl->options.acceptState == TLS13_ACCEPT_CLIENT_HELLO_DONE ||
                 ssl->options.acceptState ==
                     TLS13_ACCEPT_HELLO_RETRY_REQUEST_DONE ||
                 ssl->options.acceptState == TLS13_ACCEPT_SECOND_REPLY_DONE ||
                 ssl->options.acceptState == TLS13_SERVER_HELLO_SENT ||
                 ssl->options.acceptState == TLS13_ACCEPT_THIRD_REPLY_DONE ||
                 ssl->options.acceptState == TLS13_SERVER_EXTENSIONS_SENT ||
                 ssl->options.acceptState == TLS13_CERT_REQ_SENT ||
                 ssl->options.acceptState == TLS13_CERT_SENT ||
                 ssl->options.acceptState == TLS13_CERT_VERIFY_SENT ||
                 ssl->options.acceptState == TLS13_ACCEPT_FINISHED_SENT ||
                 ssl->options.acceptState == TLS13_ACCEPT_FINISHED_DONE);
 
 #ifdef WOLFSSL_DTLS13
         if (ssl->options.dtls)
             advanceState = advanceState && !ssl->dtls13SendingFragments
                 && !ssl->dtls13SendingAckOrRtx;
 #endif /* WOLFSSL_DTLS13 */
 
         if ((ssl->error = SendBuffered(ssl)) == 0) {
             if (ssl->fragOffset == 0 && !ssl->options.buildingMsg) {
                 if (advanceState) {
                     ssl->options.acceptState++;
                     WOLFSSL_MSG("accept state: "
                                 "Advanced from last buffered fragment send");
 #ifdef WOLFSSL_ASYNC_IO
                     FreeAsyncCtx(ssl, 0);
 #endif
                 }
             }
             else {
                 WOLFSSL_MSG("accept state: "
                             "Not advanced, more fragments to send");
             }
 
 #ifdef WOLFSSL_DTLS13
             if (ssl->options.dtls)
                 ssl->dtls13SendingAckOrRtx = 0;
 #endif /* WOLFSSL_DTLS13 */
 
         }
         else {
             ssl->error = ret;
             WOLFSSL_ERROR(ssl->error);
             return WOLFSSL_FATAL_ERROR;
         }
     }
 
     ret = RetrySendAlert(ssl);
     if (ret != 0) {
         ssl->error = ret;
         WOLFSSL_ERROR(ssl->error);
         return WOLFSSL_FATAL_ERROR;
     }
 #ifdef WOLFSSL_DTLS13
     if (ssl->options.dtls && ssl->dtls13SendingFragments) {
         if ((ssl->error = Dtls13FragmentsContinue(ssl)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
         }
 
         /* we sent all the fragments. Advance state. */
         ssl->options.acceptState++;
     }
 #endif /* WOLFSSL_DTLS13 */
 
     switch (ssl->options.acceptState) {
 
 #ifdef HAVE_SECURE_RENEGOTIATION
         case TLS13_ACCEPT_BEGIN_RENEG:
 #endif
         case TLS13_ACCEPT_BEGIN :
             /* get client_hello */
             while (ssl->options.clientState < CLIENT_HELLO_COMPLETE) {
                 if ((ssl->error = ProcessReply(ssl)) < 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
 
 #ifdef WOLFSSL_DTLS13
                 if (ssl->options.dtls) {
                     if ((ssl->error = Dtls13DoScheduledWork(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
 #endif /* WOLFSSL_DTLS13 */
 
             }
 
             ssl->options.acceptState = TLS13_ACCEPT_CLIENT_HELLO_DONE;
             WOLFSSL_MSG("accept state ACCEPT_CLIENT_HELLO_DONE");
             if (!IsAtLeastTLSv1_3(ssl->version))
                 return wolfSSL_accept(ssl);
             FALL_THROUGH;
 
         case TLS13_ACCEPT_CLIENT_HELLO_DONE :
             if (ssl->options.serverState ==
                                           SERVER_HELLO_RETRY_REQUEST_COMPLETE) {
                 if ((ssl->error = SendTls13ServerHello(ssl,
                                                    hello_retry_request)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
 #ifdef WOLFSSL_DTLS13
                 if (ssl->options.dtls && wolfSSL_dtls_get_using_nonblock(ssl)) {
                     /* Reset the state so that we can statelessly await the
                      * ClientHello that contains the cookie. Return a WANT_READ
                      * to the user so that we don't drop UDP messages in the
                      * network callbacks. */
 
                     /* Reset DTLS window */
                     w64Zero(&ssl->dtls13Epochs[0].nextSeqNumber);
                     w64Zero(&ssl->dtls13Epochs[0].nextPeerSeqNumber);
                     XMEMSET(ssl->dtls13Epochs[0].window, 0,
                             sizeof(ssl->dtls13Epochs[0].window));
 
                     ssl->keys.dtls_expected_peer_handshake_number = 0;
                     ssl->keys.dtls_handshake_number = 0;
 
                     ssl->msgsReceived.got_client_hello = 0;
 #ifdef WOLFSSL_SEND_HRR_COOKIE
                     /* Remove cookie so that it will get computed again */
                     TLSX_Remove(&ssl->extensions, TLSX_COOKIE, ssl->heap);
 #endif
 
                     /* Reset states */
                     ssl->options.serverState = NULL_STATE;
                     ssl->options.clientState = NULL_STATE;
                     ssl->options.connectState = CONNECT_BEGIN;
                     ssl->options.acceptState  = ACCEPT_BEGIN;
                     ssl->options.handShakeState  = NULL_STATE;
 
                     ssl->error = WANT_READ;
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
 #endif /* WOLFSSL_DTLS13 */
             }
 
             ssl->options.acceptState = TLS13_ACCEPT_HELLO_RETRY_REQUEST_DONE;
             WOLFSSL_MSG("accept state ACCEPT_HELLO_RETRY_REQUEST_DONE");
             FALL_THROUGH;
 
         case TLS13_ACCEPT_HELLO_RETRY_REQUEST_DONE :
     #ifdef WOLFSSL_TLS13_MIDDLEBOX_COMPAT
             if (!ssl->options.dtls && ssl->options.serverState ==
                                           SERVER_HELLO_RETRY_REQUEST_COMPLETE) {
                 if ((ssl->error = SendChangeCipher(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
                 ssl->options.sentChangeCipher = 1;
                 ssl->options.serverState = SERVER_HELLO_RETRY_REQUEST_COMPLETE;
             }
     #endif
             ssl->options.acceptState = TLS13_ACCEPT_FIRST_REPLY_DONE;
             WOLFSSL_MSG("accept state ACCEPT_FIRST_REPLY_DONE");
             FALL_THROUGH;
 
         case TLS13_ACCEPT_FIRST_REPLY_DONE :
             if (ssl->options.serverState ==
                                           SERVER_HELLO_RETRY_REQUEST_COMPLETE) {
                 ssl->options.clientState = CLIENT_HELLO_RETRY;
                 while (ssl->options.clientState < CLIENT_HELLO_COMPLETE) {
                     if ((ssl->error = ProcessReply(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
 
 #ifdef WOLFSSL_DTLS13
                 if (ssl->options.dtls) {
                     if ((ssl->error = Dtls13DoScheduledWork(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
 #endif /* WOLFSSL_DTLS13 */
 
                 }
             }
 
 #ifdef WOLFSSL_DTLS
             if (ssl->chGoodCb != NULL) {
                 int cbret = ssl->chGoodCb(ssl, ssl->chGoodCtx);
                 if (cbret < 0) {
                     ssl->error = cbret;
                     WOLFSSL_MSG("ClientHello Good Cb don't continue error");
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
 #endif
 
             ssl->options.acceptState = TLS13_ACCEPT_SECOND_REPLY_DONE;
             WOLFSSL_MSG("accept state ACCEPT_SECOND_REPLY_DONE");
             FALL_THROUGH;
 
         case TLS13_ACCEPT_SECOND_REPLY_DONE :
             if ((ssl->error = SendTls13ServerHello(ssl, server_hello)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             ssl->options.acceptState = TLS13_SERVER_HELLO_SENT;
             WOLFSSL_MSG("accept state SERVER_HELLO_SENT");
             FALL_THROUGH;
 
         case TLS13_SERVER_HELLO_SENT :
     #if defined(WOLFSSL_TLS13_MIDDLEBOX_COMPAT)
             if (!ssl->options.dtls
                           && !ssl->options.sentChangeCipher && !ssl->options.dtls) {
                 if ((ssl->error = SendChangeCipher(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
                 ssl->options.sentChangeCipher = 1;
             }
     #endif
 
             ssl->options.acceptState = TLS13_ACCEPT_THIRD_REPLY_DONE;
             WOLFSSL_MSG("accept state ACCEPT_THIRD_REPLY_DONE");
             FALL_THROUGH;
 
         case TLS13_ACCEPT_THIRD_REPLY_DONE :
 #ifdef HAVE_SUPPORTED_CURVES
             if (!ssl->options.noPskDheKe) {
                 ssl->error = TLSX_KeyShare_DeriveSecret(ssl);
                 if (ssl->error != 0)
                     return WOLFSSL_FATAL_ERROR;
             }
 #endif
 
             if ((ssl->error = SendTls13EncryptedExtensions(ssl)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
             ssl->options.acceptState = TLS13_SERVER_EXTENSIONS_SENT;
             WOLFSSL_MSG("accept state SERVER_EXTENSIONS_SENT");
             FALL_THROUGH;
 
         case TLS13_SERVER_EXTENSIONS_SENT :
 #ifndef NO_CERTS
             if (!ssl->options.resuming) {
                 if (ssl->options.verifyPeer
     #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
                     && !ssl->options.verifyPostHandshake
     #endif
                    ) {
                     ssl->error = SendTls13CertificateRequest(ssl, NULL, 0);
                     if (ssl->error != 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
                 else {
                     /* SERVER: Peer auth good if not verifying client. */
                     ssl->options.peerAuthGood = 1;
                 }
             }
 #endif
             ssl->options.acceptState = TLS13_CERT_REQ_SENT;
             WOLFSSL_MSG("accept state CERT_REQ_SENT");
             FALL_THROUGH;
 
         case TLS13_CERT_REQ_SENT :
 #ifndef NO_CERTS
             if (!ssl->options.resuming && ssl->options.sendVerify) {
                 if ((ssl->error = SendTls13Certificate(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
 #endif
             ssl->options.acceptState = TLS13_CERT_SENT;
             WOLFSSL_MSG("accept state CERT_SENT");
             FALL_THROUGH;
 
         case TLS13_CERT_SENT :
 #if !defined(NO_CERTS) && (!defined(NO_RSA) || defined(HAVE_ECC) || \
      defined(HAVE_ED25519) || defined(HAVE_ED448) || defined(HAVE_PQC))
             if (!ssl->options.resuming && ssl->options.sendVerify) {
                 if ((ssl->error = SendTls13CertificateVerify(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
 #endif
             ssl->options.acceptState = TLS13_CERT_VERIFY_SENT;
             WOLFSSL_MSG("accept state CERT_VERIFY_SENT");
             FALL_THROUGH;
 
         case TLS13_CERT_VERIFY_SENT :
             if ((ssl->error = SendTls13Finished(ssl)) != 0) {
                 WOLFSSL_ERROR(ssl->error);
                 return WOLFSSL_FATAL_ERROR;
             }
 
             ssl->options.acceptState = TLS13_ACCEPT_FINISHED_SENT;
             WOLFSSL_MSG("accept state ACCEPT_FINISHED_SENT");
 #ifdef WOLFSSL_EARLY_DATA
             if (ssl->earlyData != no_early_data) {
                 ssl->options.handShakeState = SERVER_FINISHED_COMPLETE;
                 return WOLFSSL_SUCCESS;
             }
 #endif
             FALL_THROUGH;
 
         case TLS13_ACCEPT_FINISHED_SENT :
 #ifdef HAVE_SESSION_TICKET
     #ifdef WOLFSSL_TLS13_TICKET_BEFORE_FINISHED
             if (!ssl->options.verifyPeer && !ssl->options.noTicketTls13 &&
                                                 ssl->ctx->ticketEncCb != NULL) {
                 if ((ssl->error = SendTls13NewSessionTicket(ssl)) != 0) {
                     WOLFSSL_ERROR(ssl->error);
                     return WOLFSSL_FATAL_ERROR;
                 }
                 ssl->options.ticketsSent = 1;
             }
     #endif
 #endif /* HAVE_SESSION_TICKET */
             ssl->options.acceptState = TLS13_PRE_TICKET_SENT;
             WOLFSSL_MSG("accept state  TICKET_SENT");
             FALL_THROUGH;
 
         case TLS13_PRE_TICKET_SENT :
             while (ssl->options.clientState < CLIENT_FINISHED_COMPLETE) {
                 if ( (ssl->error = ProcessReply(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
 
 #ifdef WOLFSSL_DTLS13
                 if (ssl->options.dtls) {
                     if ((ssl->error = Dtls13DoScheduledWork(ssl)) < 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
 #endif /* WOLFSSL_DTLS13 */
             }
 
             ssl->options.acceptState = TLS13_ACCEPT_FINISHED_DONE;
             WOLFSSL_MSG("accept state ACCEPT_FINISHED_DONE");
             FALL_THROUGH;
 
         case TLS13_ACCEPT_FINISHED_DONE :
             /* SERVER: When not resuming and verifying peer but no certificate
              * received and not failing when not received then peer auth good.
              */
             if (!ssl->options.resuming && ssl->options.verifyPeer &&
         #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
                 !ssl->options.verifyPostHandshake &&
         #endif
                 !ssl->options.havePeerCert && !ssl->options.failNoCert) {
                 ssl->options.peerAuthGood = 1;
             }
             /* SERVER: check peer authentication. */
             if (!ssl->options.peerAuthGood) {
                 WOLFSSL_MSG("Client authentication did not happen");
                 return WOLFSSL_FATAL_ERROR;
             }
 #ifdef HAVE_SESSION_TICKET
             while (ssl->options.ticketsSent < ssl->options.maxTicketTls13) {
                 if (!ssl->options.noTicketTls13 && ssl->ctx->ticketEncCb
                         != NULL) {
                     if ((ssl->error = SendTls13NewSessionTicket(ssl)) != 0) {
                         WOLFSSL_ERROR(ssl->error);
                         return WOLFSSL_FATAL_ERROR;
                     }
                 }
                 ssl->options.ticketsSent++;
 
                 /* only one session ticket is sent on session resumption */
                 if (ssl->options.resuming) {
                     break;
                 }
             }
 #endif /* HAVE_SESSION_TICKET */
             ssl->options.acceptState = TLS13_TICKET_SENT;
             WOLFSSL_MSG("accept state TICKET_SENT");
             FALL_THROUGH;
 
         case TLS13_TICKET_SENT :
 #ifndef NO_HANDSHAKE_DONE_CB
             if (ssl->hsDoneCb) {
                 int cbret = ssl->hsDoneCb(ssl, ssl->hsDoneCtx);
                 if (cbret < 0) {
                     ssl->error = cbret;
                     WOLFSSL_MSG("HandShake Done Cb don't continue error");
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
 #endif /* NO_HANDSHAKE_DONE_CB */
 
             if (!ssl->options.keepResources) {
                 FreeHandshakeResources(ssl);
             }
 
 #if defined(WOLFSSL_ASYNC_IO) && !defined(WOLFSSL_ASYNC_CRYPT)
             /* Free the remaining async context if not using it for crypto */
             FreeAsyncCtx(ssl, 1);
 #endif
 
             ssl->error = 0; /* clear the error */
 
             WOLFSSL_LEAVE("SSL_accept()", WOLFSSL_SUCCESS);
             return WOLFSSL_SUCCESS;
 
         default :
             WOLFSSL_MSG("Unknown accept state ERROR");
             return WOLFSSL_FATAL_ERROR;
     }
 }
 #endif
 
 #if !defined(NO_WOLFSSL_SERVER) && defined(HAVE_SESSION_TICKET)
 /* Server sends a session ticket to the peer.
  *
  * RFC 8446, section 4.6.1, para 1.
  *
  * ssl  The SSL/TLS object.
  * returns BAD_FUNC_ARG when ssl is NULL, or not using TLS v1.3,
  *         SIDE_ERROR when not a server,
  *         NOT_READY_ERROR when handshake not complete,
  *         WOLFSSL_FATAL_ERROR when creating or sending message fails, and
  *         WOLFSSL_SUCCESS on success.
  */
