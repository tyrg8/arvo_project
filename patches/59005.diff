commit 237a86901c13c0238cbd3ab07255abb90ea04dc3
Author: Amit Khandekar <amit.khandekar@oracle.com>
Date:   Wed May 3 16:38:11 2023 +0200

    WL#15426: Implement SHOW PARSE_TREE [2/3, prep]
    
    Preparatory patch: Add position parameter for parse tree node
    constructors. Position info will be later used for generating the SQL
    clause to be displayed as a json "text" field in each of the json
    parse tree nodes.
    
    Make the @$ parameter mandatory for all classes derived from
    Parse_tree_node. This prevents accidental absence of position info
    when someone adds a new grammar related PT_* class for a new
    production. For this, replaced the default Parse_tree_node constructor
    with one taking a single 'pos' parameter of type POS.
    
    While at it, fix some existing clang-tidy issues which were showing up
    for lines changed by this patch. Most of them were
    cppcoreguidelines-pro-type-member-init.
    
    Change-Id: I8277fcdd2209851783eefc4cb7bc286032879a2a

diff --git a/mysql-test/r/parser.result b/mysql-test/r/parser.result
index 034b83b2709..de453b9bd20 100644
--- a/mysql-test/r/parser.result
+++ b/mysql-test/r/parser.result
@@ -2471,14 +2471,14 @@ x VARCHAR(10)
 COLLATE ascii_bin
 COLLATE ascii_bin
 );
-ERROR 42000: Multiple COLLATE clauses near 'ascii_bin
+ERROR 42000: Multiple COLLATE clauses near 'COLLATE ascii_bin
 )' at line 4
 CREATE TABLE t2 (
 x VARCHAR(10)
 COLLATE ascii_bin
 COLLATE ascii_general_ci
 );
-ERROR 42000: Multiple COLLATE clauses near 'ascii_general_ci
+ERROR 42000: Multiple COLLATE clauses near 'COLLATE ascii_general_ci
 )' at line 4
 CREATE TABLE t3 (
 x VARCHAR(10)
@@ -2486,7 +2486,7 @@ COLLATE ascii_bin
 NOT NULL
 COLLATE ascii_bin
 );
-ERROR 42000: Multiple COLLATE clauses near 'ascii_bin
+ERROR 42000: Multiple COLLATE clauses near 'COLLATE ascii_bin
 )' at line 5
 CREATE TABLE t3 (
 x VARCHAR(10)
@@ -2504,8 +2504,8 @@ GENERATED ALWAYS AS(NULL)
 COLLATE ascii_bin
 COLLATE ascii_bin
 );
-ERROR 42000: Multiple COLLATE clauses near 'ascii_bin
+ERROR 42000: Multiple COLLATE clauses near 'COLLATE ascii_bin
 )' at line 5
 #
 # Bug#28961997: REMOVE PARENTHESES INFORMATION FROM AST
 #
diff --git a/sql/dd/info_schema/show_query_builder.cc b/sql/dd/info_schema/show_query_builder.cc
index 51063372f78..44dd6b89cc8 100644
--- a/sql/dd/info_schema/show_query_builder.cc
+++ b/sql/dd/info_schema/show_query_builder.cc
@@ -62,14 +62,14 @@ Select_lex_builder::Select_lex_builder(const POS *pc, THD *thd)
 bool Select_lex_builder::add_to_select_item_list(Item *expr) {
   // Prepare list if not exist.
   if (!m_select_item_list) {
-    m_select_item_list = new (m_thd->mem_root) PT_select_item_list();
+    m_select_item_list = new (m_thd->mem_root) PT_select_item_list(*m_pos);
 
     if (m_select_item_list == nullptr) return true;
   }
 
   m_select_item_list->push_back(expr);
 
   return false;
 }
 
 // Add item representing star in "SELECT '*' ...".
@@ -118,47 +118,48 @@ bool Select_lex_builder::add_select_expr(Item *select_list_item,
 /**
   Add item representing a FROM clause table as,
   @code
   SELECT ... FROM <schema_name>.<table_name> ...
   @endcode
 */
 bool Select_lex_builder::add_from_item(const LEX_CSTRING &schema_name,
                                        const LEX_CSTRING &table_name) {
   /*
     make_table_list() might alter the database and table name
     strings. Create copies and leave the original values
     unaltered.
   */
 
   /* ... schame_name ... */
   LEX_CSTRING tmp_db_name;
   if (lex_string_strmake(m_thd->mem_root, &tmp_db_name, schema_name.str,
                          schema_name.length))
     return true;
 
   /* ... <table_name> ... */
   LEX_CSTRING tmp_table_name;
   if (lex_string_strmake(m_thd->mem_root, &tmp_table_name, table_name.str,
                          table_name.length))
     return true;
 
   /* ... schame_name.<table_name> ... */
   Table_ident *table_ident =
       new (m_thd->mem_root) Table_ident(tmp_db_name, tmp_table_name);
   if (table_ident == nullptr) return true;
 
   /* ... FROM schame_name.<table_name> ... */
-  PT_table_factor_table_ident *table_factor = new (m_thd->mem_root)
-      PT_table_factor_table_ident(table_ident, nullptr, NULL_CSTR, nullptr);
+  PT_table_factor_table_ident *table_factor =
+      new (m_thd->mem_root) PT_table_factor_table_ident(
+          *m_pos, table_ident, nullptr, NULL_CSTR, nullptr);
   if (table_factor == nullptr) return true;
 
   if (m_table_reference_list.push_back(table_factor)) return true;
 
   return false;
 }
 
 /**
   Add item representing a FROM clause table as,
   @code
   SELECT ... FROM <sub query or derived table> ...
   @endcode
  */
@@ -248,82 +249,82 @@ bool Select_lex_builder::add_condition(Item *a) {
 // Add a ORDER BY clause field to Select_lex_builder.
 bool Select_lex_builder::add_order_by(const LEX_CSTRING &field_name) {
   /* ... ORDER BY <field_name> ASC... */
   if (!m_order_by_list) {
-    m_order_by_list = new (m_thd->mem_root) PT_order_list();
+    m_order_by_list = new (m_thd->mem_root) PT_order_list(*m_pos);
     if (m_order_by_list == nullptr) return true;
   }
 
   /* ... FIELD_NAME ... */
   PTI_simple_ident_ident *ident_field =
       new (m_thd->mem_root) PTI_simple_ident_ident(*m_pos, field_name);
   if (ident_field == nullptr) return true;
 
   PT_order_expr *expression =
-      new (m_thd->mem_root) PT_order_expr(ident_field, ORDER_ASC);
+      new (m_thd->mem_root) PT_order_expr(*m_pos, ident_field, ORDER_ASC);
   m_order_by_list->push_back(expression);
 
   return expression == nullptr;
 }
 
 /**
   This function build ParseTree node that represents this
   Select_lex_builder as sub-query.
 */
 PT_derived_table *Select_lex_builder::prepare_derived_table(
     const LEX_CSTRING &table_alias) {
-  PT_query_primary *query_specification =
-      new (m_thd->mem_root) PT_query_specification(
-          options, m_select_item_list, m_table_reference_list, m_where_clause);
+  PT_query_primary *query_specification = new (m_thd->mem_root)
+      PT_query_specification(*m_pos, options, m_select_item_list,
+                             m_table_reference_list, m_where_clause);
 
   if (query_specification == nullptr) return nullptr;
 
   PT_query_expression *query_expression =
-      new (m_thd->mem_root) PT_query_expression(query_specification);
+      new (m_thd->mem_root) PT_query_expression(*m_pos, query_specification);
   if (query_expression == nullptr) return nullptr;
 
   PT_subquery *sub_query =
       new (m_thd->mem_root) PT_subquery(*m_pos, query_expression);
   if (sub_query == nullptr) return nullptr;
 
   Create_col_name_list column_names;
   column_names.init(m_thd->mem_root);
   PT_derived_table *derived_table = new (m_thd->mem_root)
-      PT_derived_table(false, sub_query, table_alias, &column_names);
+      PT_derived_table(*m_pos, false, sub_query, table_alias, &column_names);
 
   return derived_table;
 }
 
 /**
   Prepare a Query_block using all the information information
   added to this Select_lex_builder.
 */
 Query_block *Select_lex_builder::prepare_query_block() {
-  PT_query_specification *query_specification =
-      new (m_thd->mem_root) PT_query_specification(
-          options, m_select_item_list, m_table_reference_list, m_where_clause);
+  PT_query_specification *query_specification = new (m_thd->mem_root)
+      PT_query_specification(*m_pos, options, m_select_item_list,
+                             m_table_reference_list, m_where_clause);
   if (query_specification == nullptr) return nullptr;
 
   PT_order *pt_order_by = nullptr;
   if (m_order_by_list) {
-    pt_order_by = new (m_thd->mem_root) PT_order(m_order_by_list);
+    pt_order_by = new (m_thd->mem_root) PT_order(*m_pos, m_order_by_list);
     if (pt_order_by == nullptr) return nullptr;
   }
 
   PT_query_expression *query_expression = new (m_thd->mem_root)
-      PT_query_expression(query_specification, pt_order_by, nullptr);
+      PT_query_expression(*m_pos, query_specification, pt_order_by, nullptr);
   if (query_expression == nullptr) return nullptr;
 
   LEX *lex = m_thd->lex;
   Query_block *current_query_block = lex->current_query_block();
 
   lex->sql_command = SQLCOM_SELECT;
   Parse_context pc(m_thd, current_query_block);
   if (m_thd->is_error()) return nullptr;
 
   if (query_expression->contextualize(&pc)) return nullptr;
   if (pc.finalize_query_expression()) return nullptr;
   return current_query_block;
 }
 
 }  // namespace info_schema
 }  // namespace dd
diff --git a/sql/item.cc b/sql/item.cc
index 57931106ef0..72e8cb4fba6 100644
--- a/sql/item.cc
+++ b/sql/item.cc
@@ -137,76 +137,79 @@ void item_init(void) {
 }
 
 Item::Item()
-    : next_free(nullptr),
+    : super(POS()),
+      next_free(nullptr),
       str_value(),
       collation(&my_charset_bin, DERIVATION_COERCIBLE),
       item_name(),
       orig_name(),
       max_length(0),
       marker(MARKER_NONE),
       cmp_context(INVALID_RESULT),
       is_parser_item(false),
       is_expensive_cache(-1),
       m_data_type(MYSQL_TYPE_INVALID),
       fixed(false),
       decimals(0),
       m_nullable(false),
       null_value(false),
       unsigned_flag(false),
       m_is_window_function(false),
       m_accum_properties(0) {
 #ifndef NDEBUG
   contextualized = true;
 #endif  // NDEBUG
 
   // Put item into global list so that we can free all items at end
   current_thd->add_item(this);
 }
 
 Item::Item(THD *thd, const Item *item)
-    : next_free(nullptr),
+    : super(POS()),
+      next_free(nullptr),
       str_value(item->str_value),
       collation(item->collation),
       item_name(item->item_name),
       orig_name(item->orig_name),
       max_length(item->max_length),
       marker(MARKER_NONE),
       cmp_context(item->cmp_context),
       is_parser_item(false),
       is_expensive_cache(-1),
       m_data_type(item->data_type()),
       fixed(item->fixed),
       decimals(item->decimals),
       m_nullable(item->m_nullable),
       null_value(item->null_value),
       unsigned_flag(item->unsigned_flag),
       m_is_window_function(item->m_is_window_function),
       m_accum_properties(item->m_accum_properties) {
 #ifndef NDEBUG
   assert(item->contextualized);
   contextualized = true;
 #endif  // NDEBUG
 
   // Add item to global list
   thd->add_item(this);
 }
 
-Item::Item(const POS &)
-    : next_free(nullptr),
+Item::Item(const POS &pos)
+    : super(pos),
+      next_free(nullptr),
       str_value(),
       collation(&my_charset_bin, DERIVATION_COERCIBLE),
       item_name(),
       orig_name(),
       max_length(0),
       marker(MARKER_NONE),
       cmp_context(INVALID_RESULT),
       is_parser_item(true),
       is_expensive_cache(-1),
       m_data_type(MYSQL_TYPE_INVALID),
       fixed(false),
       decimals(0),
       m_nullable(false),
       null_value(false),
       unsigned_flag(false),
       m_is_window_function(false),
       m_accum_properties(0) {}
diff --git a/sql/item_create.cc b/sql/item_create.cc
index 7efb08664e4..b1918e9d4f6 100644
--- a/sql/item_create.cc
+++ b/sql/item_create.cc
@@ -129,17 +129,17 @@ namespace {
   @see Function_factory::create_func()
 */
 constexpr auto MAX_ARGLIST_SIZE =
-    std::numeric_limits<decltype(PT_item_list().elements())>::max();
+    std::numeric_limits<decltype(PT_item_list(POS()).elements())>::max();
 
 /**
   Instantiates a function class with the list of arguments.
 
   @tparam Function_class The class that implements the function. Does not need
   to inherit Item_func.
 
   @tparam Min_argc The minimum number of arguments. Not used in this
   general case.
 
   @tparam Max_argc The maximum number of arguments. Not used in this
   general case.
 */
diff --git a/sql/item_xmlfunc.cc b/sql/item_xmlfunc.cc
index 47fbae50ee6..ba7332baa78 100644
--- a/sql/item_xmlfunc.cc
+++ b/sql/item_xmlfunc.cc
@@ -388,28 +388,28 @@ class Item_xpath_cast_number : public Item_real_func {
 /*
   Context cache, for predicate
 */
 class Item_nodeset_context_cache : public Item_nodeset_func {
   bool m_is_empty;
   uint32 m_num;
-  uint32 m_pos;
+  uint32 m_position;
   size_t m_size;
 
  public:
   Item_nodeset_context_cache(const ParsedXML &pxml_arg, const CHARSET_INFO *cs)
       : Item_nodeset_func(pxml_arg, cs),
         m_is_empty(true),
         m_num(0),
-        m_pos(0),
+        m_position(0),
         m_size(0) {}
   void val_nodeset(XPathFilter *nodeset) const override {
     nodeset->clear();
     if (!m_is_empty)
-      nodeset->push_back({m_num, m_pos, static_cast<uint>(m_size)});
+      nodeset->push_back({m_num, m_position, static_cast<uint>(m_size)});
   }
   void set_element(uint32 num, uint32 pos, size_t size) {
     m_num = num;
-    m_pos = pos;
+    m_position = pos;
     m_size = size;
     m_is_empty = false;
   }
 };
diff --git a/sql/parse_location.h b/sql/parse_location.h
index a46c12cd9cf..1e5d12ea84f 100644
--- a/sql/parse_location.h
+++ b/sql/parse_location.h
@@ -28,14 +28,14 @@
 /**
   Helper class for the MY_SQL_PARSER_LTYPE
 */
 struct Symbol_location {
-  const char *start;  // token start
-  const char *end;    // the 1st byte after the token
+  const char *start = nullptr;  // token start
+  const char *end = nullptr;    // the 1st byte after the token
 
   bool is_empty() const { return length() == 0; }
   size_t length() const { return static_cast<size_t>(end - start); }
 };
 
 /**
   Bison "location" class
 */
diff --git a/sql/parse_tree_column_attrs.h b/sql/parse_tree_column_attrs.h
index 309b65955bd..41fdca126fb 100644
--- a/sql/parse_tree_column_attrs.h
+++ b/sql/parse_tree_column_attrs.h
@@ -82,551 +82,578 @@ struct Column_parse_context : public Parse_context {
   @ingroup ptn_column_attrs ptn_gcol_attrs
 */
 class PT_column_attr_base : public Parse_tree_node_tmpl<Column_parse_context> {
  protected:
-  PT_column_attr_base() = default;
+  explicit PT_column_attr_base(const POS &pos)
+      : Parse_tree_node_tmpl<Column_parse_context>(pos) {}
 
  public:
   typedef decltype(Alter_info::flags) alter_info_flags_t;
 
   virtual void apply_type_flags(ulong *) const {}
   virtual void apply_alter_info_flags(ulonglong *) const {}
   virtual void apply_comment(LEX_CSTRING *) const {}
   virtual void apply_default_value(Item **) const {}
   virtual void apply_gen_default_value(Value_generator **) {}
   virtual void apply_on_update_value(Item **) const {}
   virtual void apply_srid_modifier(std::optional<gis::srid_t> *) const {}
   virtual bool apply_collation(Column_parse_context *,
                                const CHARSET_INFO **to [[maybe_unused]],
                                bool *has_explicit_collation
                                [[maybe_unused]]) const {
     return false;
   }
   virtual bool add_check_constraints(
       Sql_check_constraint_spec_list *check_const_list [[maybe_unused]]) {
     return false;
   }
 
   /**
     Check for the [NOT] ENFORCED characteristic.
 
     @returns true  if the [NOT] ENFORCED follows the CHECK(...) clause,
              false otherwise.
   */
   virtual bool has_constraint_enforcement() const { return false; }
 
   /**
     Check if constraint is enforced.
     Method must be called only when has_constraint_enforcement() is true (i.e
     when [NOT] ENFORCED follows the CHECK(...) clause).
 
     @returns true  if constraint is enforced.
              false otherwise.
   */
   virtual bool is_constraint_enforced() const { return false; }
 
   /**
     Update the ENFORCED/NOT ENFORCED state of the CHECK constraint.
 
     @param   enforced     true if ENFORCED, false if NOT ENFORCED.
 
     @returns false if success, true if error (e.g. if [NOT] ENFORCED follows
              something other than the CHECK clause.)
   */
   virtual bool set_constraint_enforcement(bool enforced [[maybe_unused]]) {
     return true;  // error
   }
 };
 
 /**
   Node for the @SQL{NULL} column attribute
 
   @ingroup ptn_column_attrs
 */
 class PT_null_column_attr : public PT_column_attr_base {
  public:
+  explicit PT_null_column_attr(const POS &pos) : PT_column_attr_base(pos) {}
   void apply_type_flags(ulong *type_flags) const override {
     *type_flags &= ~NOT_NULL_FLAG;
     *type_flags |= EXPLICIT_NULL_FLAG;
   }
 };
 
 /**
   Node for the @SQL{NOT NULL} column attribute
 
   @ingroup ptn_column_attrs
 */
 class PT_not_null_column_attr : public PT_column_attr_base {
+ public:
+  explicit PT_not_null_column_attr(const POS &pos) : PT_column_attr_base(pos) {}
   void apply_type_flags(ulong *type_flags) const override {
     *type_flags |= NOT_NULL_FLAG;
   }
 };
 
 /**
   Node for the @SQL{NOT SECONDARY} column attribute
 
   @ingroup ptn_column_attrs
 */
 class PT_secondary_column_attr : public PT_column_attr_base {
  public:
+  explicit PT_secondary_column_attr(const POS &pos)
+      : PT_column_attr_base(pos) {}
   void apply_type_flags(unsigned long *type_flags) const override {
     *type_flags |= NOT_SECONDARY_FLAG;
   }
 };
 
 /**
   Node for the @SQL{UNIQUE [KEY]} column attribute
 
   @ingroup ptn_column_attrs
 */
 class PT_unique_key_column_attr : public PT_column_attr_base {
  public:
+  explicit PT_unique_key_column_attr(const POS &pos)
+      : PT_column_attr_base(pos) {}
+
   void apply_type_flags(ulong *type_flags) const override {
     *type_flags |= UNIQUE_FLAG;
   }
 
   void apply_alter_info_flags(ulonglong *flags) const override {
     *flags |= Alter_info::ALTER_ADD_INDEX;
   }
 };
 
 /**
   Node for the @SQL{PRIMARY [KEY]} column attribute
 
   @ingroup ptn_column_attrs
 */
 class PT_primary_key_column_attr : public PT_column_attr_base {
  public:
+  explicit PT_primary_key_column_attr(const POS &pos)
+      : PT_column_attr_base(pos) {}
+
   void apply_type_flags(ulong *type_flags) const override {
     *type_flags |= PRI_KEY_FLAG | NOT_NULL_FLAG;
   }
 
   void apply_alter_info_flags(ulonglong *flags) const override {
     *flags |= Alter_info::ALTER_ADD_INDEX;
   }
 };
 
 /**
   Node for the @SQL{[CONSTRAINT [symbol]] CHECK '(' expr ')'} column attribute.
 
   @ingroup ptn_column_attrs
 */
 class PT_check_constraint_column_attr : public PT_column_attr_base {
   typedef PT_column_attr_base super;
   Sql_check_constraint_spec col_cc_spec;
 
  public:
-  explicit PT_check_constraint_column_attr(LEX_STRING &name, Item *expr) {
+  explicit PT_check_constraint_column_attr(const POS &pos, LEX_STRING &name,
+                                           Item *expr)
+      : super(pos) {
     col_cc_spec.name = name;
     col_cc_spec.check_expr = expr;
   }
 
   bool set_constraint_enforcement(bool enforced) override {
     col_cc_spec.is_enforced = enforced;
     return false;
   }
 
   void apply_alter_info_flags(ulonglong *flags) const override {
     *flags |= Alter_info::ADD_CHECK_CONSTRAINT;
   }
 
   bool add_check_constraints(
       Sql_check_constraint_spec_list *check_const_list) override {
     assert(check_const_list != nullptr);
     return (check_const_list->push_back(&col_cc_spec));
   }
 
   bool do_contextualize(Column_parse_context *pc) override {
     return (super::do_contextualize(pc) ||
             col_cc_spec.check_expr->itemize(pc, &col_cc_spec.check_expr));
   }
 };
 
 /**
   Node for the @SQL{[NOT] ENFORCED} column attribute.
 
   @ingroup ptn_column_attrs
 */
 class PT_constraint_enforcement_attr : public PT_column_attr_base {
  public:
-  explicit PT_constraint_enforcement_attr(bool enforced)
-      : m_enforced(enforced) {}
+  explicit PT_constraint_enforcement_attr(const POS &pos, bool enforced)
+      : PT_column_attr_base(pos), m_enforced(enforced) {}
 
   bool has_constraint_enforcement() const override { return true; }
 
   bool is_constraint_enforced() const override { return m_enforced; }
 
  private:
   const bool m_enforced;
 };
 
 /**
   Node for the @SQL{COMMENT @<comment@>} column attribute
 
   @ingroup ptn_column_attrs
 */
 class PT_comment_column_attr : public PT_column_attr_base {
   const LEX_CSTRING comment;
 
  public:
-  explicit PT_comment_column_attr(const LEX_CSTRING &comment)
-      : comment(comment) {}
+  explicit PT_comment_column_attr(const POS &pos, const LEX_CSTRING &comment)
+      : PT_column_attr_base(pos), comment(comment) {}
 
   void apply_comment(LEX_CSTRING *to) const override { *to = comment; }
 };
 
 /**
   Node for the @SQL{COLLATE @<collation@>} column attribute
 
   @ingroup ptn_column_attrs
 */
 class PT_collate_column_attr : public PT_column_attr_base {
  public:
   explicit PT_collate_column_attr(const POS &pos, const CHARSET_INFO *collation)
-      : m_pos(pos), m_collation(collation) {
+      : PT_column_attr_base(pos), m_collation(collation) {
     assert(m_collation != nullptr);
   }
 
   bool apply_collation(Column_parse_context *pc, const CHARSET_INFO **to,
                        bool *has_explicit_collation) const override {
     if (*has_explicit_collation) {
       pc->thd->syntax_error_at(m_pos, ER_INVALID_MULTIPLE_CLAUSES, "COLLATE");
       return true;
     }
     *has_explicit_collation = true;
     return merge_charset_and_collation(*to, m_collation, to);
   }
 
  private:
-  const POS m_pos;
   const CHARSET_INFO *const m_collation;
 };
 
 // Specific to non-generated columns only:
 
 /**
   Node for the @SQL{DEFAULT @<expression@>} column attribute
 
   @ingroup ptn_not_gcol_attr
 */
 class PT_default_column_attr : public PT_column_attr_base {
   typedef PT_column_attr_base super;
 
   Item *item;
 
  public:
-  explicit PT_default_column_attr(Item *item) : item(item) {}
+  explicit PT_default_column_attr(const POS &pos, Item *item)
+      : super(pos), item(item) {}
   void apply_default_value(Item **value) const override { *value = item; }
 
   bool do_contextualize(Column_parse_context *pc) override {
     if (pc->is_generated) {
       my_error(ER_WRONG_USAGE, MYF(0), "DEFAULT", "generated column");
       return true;
     }
     return super::do_contextualize(pc) || item->itemize(pc, &item);
   }
   void apply_type_flags(ulong *type_flags) const override {
     if (item->type() == Item::NULL_ITEM) *type_flags |= EXPLICIT_NULL_FLAG;
   }
 };
 
 /**
   Node for the @SQL{UPDATE NOW[([@<precision@>])]} column attribute
 
   @ingroup ptn_not_gcol_attr
 */
 class PT_on_update_column_attr : public PT_column_attr_base {
   typedef PT_column_attr_base super;
 
   const uint8 precision;
-  Item *item;
+  Item *item = nullptr;
 
  public:
-  explicit PT_on_update_column_attr(uint8 precision) : precision(precision) {}
+  explicit PT_on_update_column_attr(const POS &pos, uint8 precision)
+      : super(pos), precision(precision) {}
   void apply_on_update_value(Item **value) const override { *value = item; }
 
   bool do_contextualize(Column_parse_context *pc) override {
     if (pc->is_generated) {
       my_error(ER_WRONG_USAGE, MYF(0), "ON UPDATE", "generated column");
       return true;
     }
     if (super::do_contextualize(pc)) return true;
 
     item = new (pc->thd->mem_root) Item_func_now_local(precision);
     return item == nullptr;
   }
 };
 
 /**
   Node for the @SQL{AUTO_INCREMENT} column attribute
 
   @ingroup ptn_not_gcol_attr
 */
 class PT_auto_increment_column_attr : public PT_column_attr_base {
   typedef PT_column_attr_base super;
 
  public:
+  explicit PT_auto_increment_column_attr(const POS &pos)
+      : PT_column_attr_base(pos) {}
+
   void apply_type_flags(ulong *type_flags) const override {
     *type_flags |= AUTO_INCREMENT_FLAG | NOT_NULL_FLAG;
   }
   bool do_contextualize(Column_parse_context *pc) override {
     if (pc->is_generated) {
       my_error(ER_WRONG_USAGE, MYF(0), "AUTO_INCREMENT", "generated column");
       return true;
     }
     return super::do_contextualize(pc);
   }
 };
 
 /**
   Node for the @SQL{SERIAL DEFAULT VALUE} column attribute
 
   @ingroup ptn_not_gcol_attr
 */
 class PT_serial_default_value_column_attr : public PT_column_attr_base {
   typedef PT_column_attr_base super;
 
  public:
+  explicit PT_serial_default_value_column_attr(const POS &pos) : super(pos) {}
+
   void apply_type_flags(ulong *type_flags) const override {
     *type_flags |= AUTO_INCREMENT_FLAG | NOT_NULL_FLAG | UNIQUE_FLAG;
   }
   void apply_alter_info_flags(ulonglong *flags) const override {
     *flags |= Alter_info::ALTER_ADD_INDEX;
   }
   bool do_contextualize(Column_parse_context *pc) override {
     if (pc->is_generated) {
       my_error(ER_WRONG_USAGE, MYF(0), "SERIAL DEFAULT VALUE",
                "generated column");
       return true;
     }
     return super::do_contextualize(pc);
   }
 };
 
 /**
   Node for the @SQL{COLUMN_FORMAT @<DEFAULT|FIXED|DYNAMIC@>} column attribute
 
   @ingroup ptn_not_gcol_attr
 */
 class PT_column_format_column_attr : public PT_column_attr_base {
   typedef PT_column_attr_base super;
 
   column_format_type format;
 
  public:
-  explicit PT_column_format_column_attr(column_format_type format)
-      : format(format) {}
+  explicit PT_column_format_column_attr(const POS &pos,
+                                        column_format_type format)
+      : super(pos), format(format) {}
 
   void apply_type_flags(ulong *type_flags) const override {
     *type_flags &= ~(FIELD_FLAGS_COLUMN_FORMAT_MASK);
     *type_flags |= format << FIELD_FLAGS_COLUMN_FORMAT;
   }
   bool do_contextualize(Column_parse_context *pc) override {
     if (pc->is_generated) {
       my_error(ER_WRONG_USAGE, MYF(0), "COLUMN_FORMAT", "generated column");
       return true;
     }
     return super::do_contextualize(pc);
   }
 };
 
 /**
   Node for the @SQL{STORAGE @<DEFAULT|DISK|MEMORY@>} column attribute
 
   @ingroup ptn_not_gcol_attr
 */
 class PT_storage_media_column_attr : public PT_column_attr_base {
   typedef PT_column_attr_base super;
 
   ha_storage_media media;
 
  public:
-  explicit PT_storage_media_column_attr(ha_storage_media media)
-      : media(media) {}
+  explicit PT_storage_media_column_attr(const POS &pos, ha_storage_media media)
+      : super(pos), media(media) {}
 
   void apply_type_flags(ulong *type_flags) const override {
     *type_flags &= ~(FIELD_FLAGS_STORAGE_MEDIA_MASK);
     *type_flags |= media << FIELD_FLAGS_STORAGE_MEDIA;
   }
   bool do_contextualize(Column_parse_context *pc) override {
     if (pc->is_generated) {
       my_error(ER_WRONG_USAGE, MYF(0), "STORAGE", "generated column");
       return true;
     }
     return super::do_contextualize(pc);
   }
 };
 
 /// Node for the SRID column attribute
 class PT_srid_column_attr : public PT_column_attr_base {
   typedef PT_column_attr_base super;
 
   gis::srid_t m_srid;
 
  public:
-  explicit PT_srid_column_attr(gis::srid_t srid) : m_srid(srid) {}
+  explicit PT_srid_column_attr(const POS &pos, gis::srid_t srid)
+      : super(pos), m_srid(srid) {}
 
   void apply_srid_modifier(std::optional<gis::srid_t> *srid) const override {
     *srid = m_srid;
   }
 };
 
 /// Node for the generated default value, column attribute
 class PT_generated_default_val_column_attr : public PT_column_attr_base {
   typedef PT_column_attr_base super;
 
  public:
-  PT_generated_default_val_column_attr(Item *expr) {
+  explicit PT_generated_default_val_column_attr(const POS &pos, Item *expr)
+      : super(pos) {
     m_default_value_expression.expr_item = expr;
     m_default_value_expression.set_field_stored(true);
   }
 
   void apply_gen_default_value(
       Value_generator **default_value_expression) override {
     *default_value_expression = &m_default_value_expression;
   }
 
   bool do_contextualize(Column_parse_context *pc) override {
     // GC and default value expressions are mutually exclusive and thus only
     // one is allowed to be present on the same column definition.
     if (pc->is_generated) {
       my_error(ER_WRONG_USAGE, MYF(0), "DEFAULT", "generated column");
       return true;
     }
     Parse_context expr_pc(pc->thd, pc->select);
     return super::do_contextualize(pc) ||
            m_default_value_expression.expr_item->itemize(
                &expr_pc, &m_default_value_expression.expr_item);
   }
 
  private:
   Value_generator m_default_value_expression;
 };
 
 /**
   Node for the @SQL{VISIBLE|INVISIBLE} column attribute
 
   @ingroup ptn_column_attrs
 */
 class PT_column_visibility_attr : public PT_column_attr_base {
+  typedef PT_column_attr_base super;
+
  public:
-  explicit PT_column_visibility_attr(bool is_visible)
-      : m_is_visible(is_visible) {}
+  explicit PT_column_visibility_attr(const POS &pos, bool is_visible)
+      : super(pos), m_is_visible(is_visible) {}
   void apply_type_flags(unsigned long *type_flags) const override {
     *type_flags &= ~FIELD_IS_INVISIBLE;
     if (!m_is_visible) *type_flags |= FIELD_IS_INVISIBLE;
   }
 
  private:
   const bool m_is_visible;
 };
 
 // Type nodes:
 
 /**
   Base class for all column type nodes
 
   @ingroup ptn_column_types
 */
 class PT_type : public Parse_tree_node {
  public:
   const enum_field_types type;
 
  protected:
-  explicit PT_type(enum_field_types type) : type(type) {}
+  explicit PT_type(const POS &pos, enum_field_types type)
+      : Parse_tree_node(pos), type(type) {}
 
  public:
   virtual ulong get_type_flags() const { return 0; }
   virtual const char *get_length() const { return nullptr; }
   virtual const char *get_dec() const { return nullptr; }
   virtual const CHARSET_INFO *get_charset() const { return nullptr; }
   virtual uint get_uint_geom_type() const { return 0; }
   virtual List<String> *get_interval_list() const { return nullptr; }
   virtual bool is_serial_type() const { return false; }
 };
 
 /**
   Node for numeric types
 
   Type list:
   * NUMERIC, REAL, DOUBLE, DECIMAL and FIXED,
   * INTEGER, INT, INT1, INT2, INT3, INT4, TINYINT, SMALLINT, MEDIUMINT and
     BIGINT.
 
   @ingroup ptn_column_types
 */
 class PT_numeric_type : public PT_type {
   const char *length;
   const char *dec;
   ulong options;
 
   using Parent_type = std::remove_const<decltype(PT_type::type)>::type;
 
  public:
-  PT_numeric_type(THD *thd, Numeric_type type_arg, const char *length,
-                  const char *dec, ulong options)
-      : PT_type(static_cast<Parent_type>(type_arg)),
+  PT_numeric_type(const POS &pos, THD *thd, Numeric_type type_arg,
+                  const char *length, const char *dec, ulong options)
+      : PT_type(pos, static_cast<Parent_type>(type_arg)),
         length(length),
         dec(dec),
         options(options) {
     assert((options & ~(UNSIGNED_FLAG | ZEROFILL_FLAG)) == 0);
 
     if (type_arg != Numeric_type::DECIMAL && dec != nullptr) {
       push_warning(thd, Sql_condition::SL_WARNING,
                    ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
                    ER_THD(thd, ER_WARN_DEPRECATED_FLOAT_DIGITS));
     }
     if (options & UNSIGNED_FLAG) {
       push_warning(thd, Sql_condition::SL_WARNING,
                    ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
                    ER_THD(thd, ER_WARN_DEPRECATED_FLOAT_UNSIGNED));
     }
   }
-  PT_numeric_type(THD *thd, Int_type type_arg, const char *length,
-                  ulong options)
-      : PT_type(static_cast<enum_field_types>(type_arg)),
+  PT_numeric_type(const POS &pos, THD *thd, Int_type type_arg,
+                  const char *length, ulong options)
+      : PT_type(pos, static_cast<enum_field_types>(type_arg)),
         length(length),
         dec(nullptr),
         options(options) {
     assert((options & ~(UNSIGNED_FLAG | ZEROFILL_FLAG)) == 0);
 
     if (length != nullptr) {
       push_warning(thd, Sql_condition::SL_WARNING,
                    ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
                    ER_THD(thd, ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH));
     }
   }
 
   ulong get_type_flags() const override {
     return (options & ZEROFILL_FLAG) ? (options | UNSIGNED_FLAG) : options;
   }
   const char *get_length() const override { return length; }
   const char *get_dec() const override { return dec; }
 };
 
 /**
   Node for the BIT type
 
   @ingroup ptn_column_types
 */
 class PT_bit_type : public PT_type {
   const char *length;
 
  public:
-  PT_bit_type() : PT_type(MYSQL_TYPE_BIT), length("1") {}
-  explicit PT_bit_type(const char *length)
-      : PT_type(MYSQL_TYPE_BIT), length(length) {}
+  explicit PT_bit_type(const POS &pos)
+      : PT_type(pos, MYSQL_TYPE_BIT), length("1") {}
+  explicit PT_bit_type(const POS &pos, const char *length)
+      : PT_type(pos, MYSQL_TYPE_BIT), length(length) {}
 
   const char *get_length() const override { return length; }
 };
 
 /**
   Node for the BOOL/BOOLEAN type
 
   @ingroup ptn_column_types
 */
 class PT_boolean_type : public PT_type {
  public:
-  PT_boolean_type() : PT_type(MYSQL_TYPE_TINY) {}
+  explicit PT_boolean_type(const POS &pos) : PT_type(pos, MYSQL_TYPE_TINY) {}
   const char *get_length() const override { return "1"; }
 };
 
@@ -639,25 +666,25 @@ enum class Char_type : ulong {
 class PT_char_type : public PT_type {
   const char *length;
   const CHARSET_INFO *charset;
   const bool force_binary;
 
   using Parent_type = std::remove_const<decltype(PT_type::type)>::type;
 
  public:
-  PT_char_type(Char_type char_type, const char *length,
+  PT_char_type(const POS &pos, Char_type char_type, const char *length,
                const CHARSET_INFO *charset, bool force_binary = false)
-      : PT_type(static_cast<Parent_type>(char_type)),
+      : PT_type(pos, static_cast<Parent_type>(char_type)),
         length(length),
         charset(charset),
         force_binary(force_binary) {
     assert(charset == nullptr || !force_binary);
   }
-  PT_char_type(Char_type char_type, const CHARSET_INFO *charset,
+  PT_char_type(const POS &pos, Char_type char_type, const CHARSET_INFO *charset,
                bool force_binary = false)
-      : PT_char_type(char_type, "1", charset, force_binary) {}
+      : PT_char_type(pos, char_type, "1", charset, force_binary) {}
   ulong get_type_flags() const override {
     return force_binary ? BINCMP_FLAG : 0;
   }
   const char *get_length() const override { return length; }
   const CHARSET_INFO *get_charset() const override { return charset; }
 };
@@ -677,52 +704,52 @@ enum class Blob_type {
   @ingroup ptn_column_types
 */
 class PT_blob_type : public PT_type {
   const char *length;
   const CHARSET_INFO *charset;
   const bool force_binary;
 
   using Parent_type = std::remove_const<decltype(PT_type::type)>::type;
 
  public:
-  PT_blob_type(Blob_type blob_type, const CHARSET_INFO *charset,
+  PT_blob_type(const POS &pos, Blob_type blob_type, const CHARSET_INFO *charset,
                bool force_binary = false)
-      : PT_type(static_cast<Parent_type>(blob_type)),
+      : PT_type(pos, static_cast<Parent_type>(blob_type)),
         length(nullptr),
         charset(charset),
         force_binary(force_binary) {
     assert(charset == nullptr || !force_binary);
   }
-  explicit PT_blob_type(const char *length)
-      : PT_type(MYSQL_TYPE_BLOB),
+  explicit PT_blob_type(const POS &pos, const char *length)
+      : PT_type(pos, MYSQL_TYPE_BLOB),
         length(length),
         charset(&my_charset_bin),
         force_binary(false) {}
 
   ulong get_type_flags() const override {
     return force_binary ? BINCMP_FLAG : 0;
   }
   const CHARSET_INFO *get_charset() const override { return charset; }
   const char *get_length() const override { return length; }
 };
 
 /**
   Node for the YEAR type
 
   @ingroup ptn_column_types
 */
 class PT_year_type : public PT_type {
  public:
-  PT_year_type() : PT_type(MYSQL_TYPE_YEAR) {}
+  explicit PT_year_type(const POS &pos) : PT_type(pos, MYSQL_TYPE_YEAR) {}
 };
 
 /**
   Node for the DATE type
 
   @ingroup ptn_column_types
 */
 class PT_date_type : public PT_type {
  public:
-  PT_date_type() : PT_type(MYSQL_TYPE_DATE) {}
+  explicit PT_date_type(const POS &pos) : PT_type(pos, MYSQL_TYPE_DATE) {}
 };
 
 enum class Time_type : ulong {
@@ -736,71 +763,71 @@ enum class Time_type : ulong {
   @ingroup ptn_column_types
 */
 class PT_time_type : public PT_type {
   const char *dec;
 
   using Parent_type = std::remove_const<decltype(PT_type::type)>::type;
 
  public:
-  PT_time_type(Time_type time_type, const char *dec)
-      : PT_type(static_cast<Parent_type>(time_type)), dec(dec) {}
+  PT_time_type(const POS &pos, Time_type time_type, const char *dec)
+      : PT_type(pos, static_cast<Parent_type>(time_type)), dec(dec) {}
 
   const char *get_dec() const override { return dec; }
 };
 
 /**
   Node for the TIMESTAMP type
 
   @ingroup ptn_column_types
 */
 class PT_timestamp_type : public PT_type {
   typedef PT_type super;
 
   const char *dec;
   ulong type_flags;
 
  public:
-  explicit PT_timestamp_type(const char *dec)
-      : super(MYSQL_TYPE_TIMESTAMP2), dec(dec), type_flags(0) {}
+  explicit PT_timestamp_type(const POS &pos, const char *dec)
+      : super(pos, MYSQL_TYPE_TIMESTAMP2), dec(dec), type_flags(0) {}
 
   const char *get_dec() const override { return dec; }
   ulong get_type_flags() const override { return type_flags; }
 
   bool do_contextualize(Parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
     /*
       TIMESTAMP fields are NOT NULL by default, unless the variable
       explicit_defaults_for_timestamp is true.
     */
     if (!pc->thd->variables.explicit_defaults_for_timestamp)
       type_flags = NOT_NULL_FLAG;
     /*
       To flag the current statement as dependent for binary
       logging on the session var. Extra copying to Lex is
       done in case prepared stmt.
     */
     pc->thd->lex->binlog_need_explicit_defaults_ts =
         pc->thd->binlog_need_explicit_defaults_ts = true;
 
     return false;
   }
 };
 
 /**
   Node for spatial types
 
   Types: GEOMETRY, GEOMCOLLECTION/GEOMETRYCOLLECTION, POINT, MULTIPOINT,
          LINESTRING, MULTILINESTRING, POLYGON, MULTIPOLYGON
 
   @ingroup ptn_column_types
 */
 class PT_spacial_type : public PT_type {
   Field::geometry_type geo_type;
 
  public:
-  explicit PT_spacial_type(Field::geometry_type geo_type)
-      : PT_type(MYSQL_TYPE_GEOMETRY), geo_type(geo_type) {}
+  explicit PT_spacial_type(const POS &pos, Field::geometry_type geo_type)
+      : PT_type(pos, MYSQL_TYPE_GEOMETRY), geo_type(geo_type) {}
 
   const CHARSET_INFO *get_charset() const override { return &my_charset_bin; }
   uint get_uint_geom_type() const override { return geo_type; }
   const char *get_length() const override { return nullptr; }
 };
@@ -811,29 +838,29 @@ template <Enum_type enum_type>
 class PT_enum_type_tmpl : public PT_type {
   List<String> *const interval_list;
   const CHARSET_INFO *charset;
   const bool force_binary;
 
   using Parent_type = std::remove_const<decltype(PT_type::type)>::type;
 
  public:
-  PT_enum_type_tmpl(List<String> *interval_list, const CHARSET_INFO *charset,
-                    bool force_binary)
-      : PT_type(static_cast<Parent_type>(enum_type)),
+  PT_enum_type_tmpl(const POS &pos, List<String> *interval_list,
+                    const CHARSET_INFO *charset, bool force_binary)
+      : PT_type(pos, static_cast<Parent_type>(enum_type)),
         interval_list(interval_list),
         charset(charset),
         force_binary(force_binary) {
     assert(charset == nullptr || !force_binary);
   }
 
   const CHARSET_INFO *get_charset() const override { return charset; }
   ulong get_type_flags() const override {
     return force_binary ? BINCMP_FLAG : 0;
   }
   List<String> *get_interval_list() const override { return interval_list; }
 };
 
 /**
   Node for the ENUM type
 
   @ingroup ptn_column_types
 */
@@ -848,173 +875,166 @@ typedef PT_enum_type_tmpl<Enum_type::SET> PT_set_type;
 
 class PT_serial_type : public PT_type {
  public:
-  PT_serial_type() : PT_type(MYSQL_TYPE_LONGLONG) {}
+  explicit PT_serial_type(const POS &pos) : PT_type(pos, MYSQL_TYPE_LONGLONG) {}
 
   ulong get_type_flags() const override {
     return AUTO_INCREMENT_FLAG | NOT_NULL_FLAG | UNSIGNED_FLAG | UNIQUE_FLAG;
   }
   bool is_serial_type() const override { return true; }
 };
 
 /**
   Node for the JSON type
 
   @ingroup ptn_column_types
 */
 class PT_json_type : public PT_type {
  public:
-  PT_json_type() : PT_type(MYSQL_TYPE_JSON) {}
+  explicit PT_json_type(const POS &pos) : PT_type(pos, MYSQL_TYPE_JSON) {}
   const CHARSET_INFO *get_charset() const override { return &my_charset_bin; }
 };
 
 /**
   Base class for both generated and regular column definitions
 
   @ingroup ptn_create_table
 */
 class PT_field_def_base : public Parse_tree_node {
   typedef Parse_tree_node super;
   typedef decltype(Alter_info::flags) alter_info_flags_t;
 
  public:
-  enum_field_types type;
-  ulong type_flags;
-  const char *length;
-  const char *dec;
-  const CHARSET_INFO *charset;
-  bool has_explicit_collation;
-  uint uint_geom_type;
-  List<String> *interval_list;
-  alter_info_flags_t alter_info_flags;
-  LEX_CSTRING comment;
-  Item *default_value;
-  Item *on_update_value;
-  Value_generator *gcol_info;
+  enum_field_types type = MYSQL_TYPE_INVALID;
+  ulong type_flags = 0;
+  const char *length = nullptr;
+  const char *dec = nullptr;
+  const CHARSET_INFO *charset = nullptr;
+  bool has_explicit_collation = false;
+  uint uint_geom_type = 0;
+  List<String> *interval_list = nullptr;
+  alter_info_flags_t alter_info_flags = 0;
+  LEX_CSTRING comment = EMPTY_CSTR;
+  Item *default_value = nullptr;
+  Item *on_update_value = nullptr;
+  Value_generator *gcol_info = nullptr;
   /// Holds the expression to generate default values
-  Value_generator *default_val_info;
-  std::optional<gis::srid_t> m_srid;
+  Value_generator *default_val_info = nullptr;
+  std::optional<gis::srid_t> m_srid{};
   // List of column check constraint's specification.
-  Sql_check_constraint_spec_list *check_const_spec_list{nullptr};
+  Sql_check_constraint_spec_list *check_const_spec_list = nullptr;
 
  protected:
   PT_type *type_node;
 
-  explicit PT_field_def_base(PT_type *type_node)
-      : has_explicit_collation(false),
-        alter_info_flags(0),
-        comment(EMPTY_CSTR),
-        default_value(nullptr),
-        on_update_value(nullptr),
-        gcol_info(nullptr),
-        default_val_info(nullptr),
-        type_node(type_node) {}
+  explicit PT_field_def_base(const POS &pos, PT_type *type_node)
+      : super(pos), type_node(type_node) {}
 
  public:
   bool do_contextualize(Parse_context *pc) override {
     if (super::do_contextualize(pc) || type_node->contextualize(pc))
       return true;
 
     type = type_node->type;
     type_flags = type_node->get_type_flags();
     length = type_node->get_length();
     dec = type_node->get_dec();
     charset = type_node->get_charset();
     uint_geom_type = type_node->get_uint_geom_type();
     interval_list = type_node->get_interval_list();
     check_const_spec_list = new (pc->thd->mem_root)
         Sql_check_constraint_spec_list(pc->thd->mem_root);
     if (check_const_spec_list == nullptr) return true;  // OOM
     return false;
   }
 
  protected:
   template <class T>
   bool contextualize_attrs(Column_parse_context *pc,
                            Mem_root_array<T *> *attrs) {
     if (attrs != nullptr) {
       for (auto attr : *attrs) {
         if (attr->contextualize(pc)) return true;
         attr->apply_type_flags(&type_flags);
         attr->apply_alter_info_flags(&alter_info_flags);
         attr->apply_comment(&comment);
         attr->apply_default_value(&default_value);
         attr->apply_gen_default_value(&default_val_info);
         attr->apply_on_update_value(&on_update_value);
         attr->apply_srid_modifier(&m_srid);
         if (attr->apply_collation(pc, &charset, &has_explicit_collation))
           return true;
         if (attr->add_check_constraints(check_const_spec_list)) return true;
       }
     }
     return false;
   }
 };
 
 /**
   Base class for regular (non-generated) column definition nodes
 
   @ingroup ptn_create_table
 */
 class PT_field_def : public PT_field_def_base {
   typedef PT_field_def_base super;
 
   Mem_root_array<PT_column_attr_base *> *opt_attrs;
 
  public:
-  PT_field_def(PT_type *type_node_arg,
+  PT_field_def(const POS &pos, PT_type *type_node_arg,
                Mem_root_array<PT_column_attr_base *> *opt_attrs)
-      : super(type_node_arg), opt_attrs(opt_attrs) {}
+      : super(pos, type_node_arg), opt_attrs(opt_attrs) {}
 
   bool do_contextualize(Parse_context *pc_arg) override {
     Column_parse_context pc(pc_arg->thd, pc_arg->select, false);
     if (super::do_contextualize(&pc) || contextualize_attrs(&pc, opt_attrs))
       return true;
 
     move_cf_appliers(pc_arg, &pc);
     return false;
   }
 };
 
 /**
   Base class for generated column definition nodes
 
   @ingroup ptn_create_table
 */
 class PT_generated_field_def : public PT_field_def_base {
   typedef PT_field_def_base super;
 
   const Virtual_or_stored virtual_or_stored;
   Item *expr;
   Mem_root_array<PT_column_attr_base *> *opt_attrs;
 
  public:
-  PT_generated_field_def(PT_type *type_node_arg, Item *expr,
+  PT_generated_field_def(const POS &pos, PT_type *type_node_arg, Item *expr,
                          Virtual_or_stored virtual_or_stored,
                          Mem_root_array<PT_column_attr_base *> *opt_attrs)
-      : super(type_node_arg),
+      : super(pos, type_node_arg),
         virtual_or_stored(virtual_or_stored),
         expr(expr),
         opt_attrs(opt_attrs) {}
 
   bool do_contextualize(Parse_context *pc_arg) override {
     Column_parse_context pc(pc_arg->thd, pc_arg->select, true);
     if (super::do_contextualize(&pc) || contextualize_attrs(&pc, opt_attrs) ||
         expr->itemize(&pc, &expr))
       return true;
 
     // column of type serial cannot be generated
     if (type_node->is_serial_type()) {
       my_error(ER_WRONG_USAGE, MYF(0), "SERIAL", "generated column");
       return true;
     }
 
     gcol_info = new (pc.mem_root) Value_generator;
     if (gcol_info == nullptr) return true;  // OOM
     gcol_info->expr_item = expr;
     if (virtual_or_stored == Virtual_or_stored::STORED)
       gcol_info->set_field_stored(true);
     gcol_info->set_field_type(type);
 
     return false;
   }
 };
diff --git a/sql/parse_tree_helpers.h b/sql/parse_tree_helpers.h
index 084a9df836f..b7b3251698c 100644
--- a/sql/parse_tree_helpers.h
+++ b/sql/parse_tree_helpers.h
@@ -100,64 +100,66 @@ class Parse_tree_item : public Item {
 /**
   Wrapper class for an Item list head, used to allocate Item lists in the parser
   in a context-independent way
 */
 class PT_item_list : public Parse_tree_node {
   typedef Parse_tree_node super;
 
  public:
-  PT_item_list() : value(*THR_MALLOC) {}
+  explicit PT_item_list(const POS &pos) : super(pos), value(*THR_MALLOC) {}
+  explicit PT_item_list(const POS &start_pos, const POS &end_pos)
+      : super(start_pos, end_pos), value(*THR_MALLOC) {}
 
   mem_root_deque<Item *> value;
 
   bool do_contextualize(Parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
     for (Item *&item : value) {
       if (item->itemize(pc, &item)) return true;
     }
     return false;
   }
 
   bool is_empty() const { return value.empty(); }
   uint elements() const { return value.size(); }
 
   bool push_back(Item *item) {
     /*
      Item may be NULL in case of OOM: just ignore it and check thd->is_error()
      in the caller code.
     */
     if (item == nullptr) return true;
     value.push_back(item);
     return false;
   }
 
   bool push_front(Item *item) {
     /*
      Item may be NULL in case of OOM: just ignore it and check thd->is_error()
      in the caller code.
     */
     if (item == nullptr) return true;
     value.push_front(item);
     return false;
   }
 
   Item *pop_front() {
     assert(!is_empty());
     Item *ret = value.front();
     value.pop_front();
     return ret;
   }
 
   Item *operator[](uint index) const { return value[index]; }
 };
 
 /**
   Contextualize a Mem_root_array of parse tree nodes of the type PTN
 
   @tparam Context       Parse context.
   @tparam Array         Array of parse tree nodes.
 
   @param[in,out] pc     Parse context.
   @param[in,out] array  Array of nodes to contextualize.
 
   @return false on success.
 */
diff --git a/sql/parse_tree_hints.h b/sql/parse_tree_hints.h
index af31844f1a4..69b823a73b8 100644
--- a/sql/parse_tree_hints.h
+++ b/sql/parse_tree_hints.h
@@ -52,44 +52,46 @@ typedef Mem_root_array_YY<Hint_param_table> Hint_param_table_list;
 /**
   The class is a base class for representation of the
   different types of the hints. For the complex hints
   it is also used as a container for additional arguments.
 */
 class PT_hint : public Parse_tree_node {
   opt_hints_enum hint_type;  // Hint type
   bool state;                // true if hints is on, false otherwise
  public:
   PT_hint(opt_hints_enum hint_type_arg, bool switch_state_arg)
-      : hint_type(hint_type_arg), state(switch_state_arg) {}
+      : Parse_tree_node(POS()) /* TODO: handle position in hints */,
+        hint_type(hint_type_arg),
+        state(switch_state_arg) {}
 
   opt_hints_enum type() const { return hint_type; }
   bool switch_on() const { return state; }
   /**
     Print warning issuing in processing of the hint.
 
     @param thd             Pointer to THD object
     @param err_code        Error code
     @param qb_name_arg     QB name
     @param table_name_arg  table name
     @param key_name_arg    key name
     @param hint            Pointer to hint object
   */
   virtual void print_warn(THD *thd, uint err_code,
                           const LEX_CSTRING *qb_name_arg,
                           LEX_CSTRING *table_name_arg,
                           LEX_CSTRING *key_name_arg, PT_hint *hint) const;
   /**
     Append additional hint arguments.
 
     @param thd             Pointer to THD object
     @param str             Pointer to String object
   */
   virtual void append_args(const THD *thd [[maybe_unused]],
                            String *str [[maybe_unused]]) const {}
   bool supports_view() {
     /*
       Only index hints are supported to be used in views.
       Other hints can be added separately.
     */
     return (type() >= INDEX_HINT_ENUM && type() <= ORDER_INDEX_HINT_ENUM);
   }
 };
@@ -97,26 +99,27 @@ class PT_hint : public Parse_tree_node {
 class PT_hint_list : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   Mem_root_array<PT_hint *> hints;
 
  public:
-  explicit PT_hint_list(MEM_ROOT *mem_root) : hints(mem_root) {}
+  explicit PT_hint_list(MEM_ROOT *mem_root)
+      : super(POS()) /* TODO: handle position of hints */, hints(mem_root) {}
 
   /**
     Function handles list of the hints we get after
     parse procedure. It also creates query block hint
     object(Opt_hints_qb) if it does not exists.
 
     @param pc   Pointer to Parse_context object
 
     @return  true in case of error,
              false otherwise
   */
   bool do_contextualize(Parse_context *pc) override;
 
   bool push_back(PT_hint *hint) { return hints.push_back(hint); }
 };
 
 /**
   Parse tree hint object for query block level hints.
 */
diff --git a/sql/parse_tree_node_base.h b/sql/parse_tree_node_base.h
index 5bac8f875b7..ef64fa875c8 100644
--- a/sql/parse_tree_node_base.h
+++ b/sql/parse_tree_node_base.h
@@ -138,103 +138,111 @@ template <typename Context>
 class Parse_tree_node_tmpl {
   friend class Item;  // for direct access to the "contextualized" field
 
   Parse_tree_node_tmpl(const Parse_tree_node_tmpl &);  // undefined
   void operator=(const Parse_tree_node_tmpl &);        // undefined
 
 #ifndef NDEBUG
  private:
-  bool contextualized;  // true if the node object is contextualized
-#endif                  // NDEBUG
+  bool contextualized = false;  // true if the node object is contextualized
+#endif                          // NDEBUG
 
  public:
   typedef Context context_t;
+  POS m_pos;
 
   static void *operator new(size_t size, MEM_ROOT *mem_root,
                             const std::nothrow_t &arg
                             [[maybe_unused]] = std::nothrow) noexcept {
     return mem_root->Alloc(size);
   }
   static void operator delete(void *ptr [[maybe_unused]],
                               size_t size [[maybe_unused]]) {
     TRASH(ptr, size);
   }
   static void operator delete(void *, MEM_ROOT *,
                               const std::nothrow_t &) noexcept {}
 
  protected:
-  Parse_tree_node_tmpl() {
-#ifndef NDEBUG
-    contextualized = false;
-#endif  // NDEBUG
+  Parse_tree_node_tmpl() = delete;
+
+  explicit Parse_tree_node_tmpl(const POS &pos) : m_pos(pos) {}
+
+  explicit Parse_tree_node_tmpl(const POS &start_pos, const POS &end_pos) {
+    // Range of this item list should be from first character position of
+    // start_pos to the last character position of end_pos.
+    m_pos.cpp.start = start_pos.cpp.start;
+    m_pos.cpp.end = end_pos.cpp.end;
+    m_pos.raw.start = start_pos.raw.start;
+    m_pos.raw.end = end_pos.raw.end;
   }
 
   /**
     Do all context-sensitive things and mark the node as contextualized
 
     @param      pc      current parse context
 
     @retval     false   success
     @retval     true    syntax/OOM/etc error
   */
   virtual bool do_contextualize(Context *pc) {
     uchar dummy;
     if (check_stack_overrun(pc->thd, STACK_MIN_SIZE, &dummy)) return true;
 
 #ifndef NDEBUG
     assert(!contextualized);
     contextualized = true;
 #endif  // NDEBUG
 
     return false;
   }
 
  public:
   virtual ~Parse_tree_node_tmpl() = default;
 
 #ifndef NDEBUG
   bool is_contextualized() const { return contextualized; }
 #endif  // NDEBUG
 
   // Derived classes should not override this. If needed, they should override
   // do_contextualize().
   virtual bool contextualize(Context *pc) final {
     // Json parse tree related things to be done pre-do_contextualize().
     if (do_contextualize(pc)) return true;
     // Json parse tree related things to be done post-do_contextualize().
     return false;
   }
 
   /**
     syntax_error() function replacement for deferred reporting of syntax
     errors
 
     @param      pc      Current parse context.
     @param      pos     Location of the error in lexical scanner buffers.
   */
   void error(Context *pc, const POS &pos) const {
     pc->thd->syntax_error_at(pos);
   }
 
   /**
     syntax_error() function replacement for deferred reporting of syntax
     errors
 
     @param      pc      Current parse context.
     @param      pos     Location of the error in lexical scanner buffers.
     @param      msg     Error message.
   */
   void error(Context *pc, const POS &pos, const char *msg) const {
     pc->thd->syntax_error_at(pos, "%s", msg);
   }
 
   /**
     syntax_error() function replacement for deferred reporting of syntax
     errors
 
     @param      pc      Current parse context.
     @param      pos     Location of the error in lexical scanner buffers.
     @param      format  Error message format string with optional argument list.
   */
   void errorf(Context *pc, const POS &pos, const char *format, ...) const
       MY_ATTRIBUTE((format(printf, 4, 5)));
 };
diff --git a/sql/parse_tree_nodes.cc b/sql/parse_tree_nodes.cc
index 4121327a4be..d3019e4fb2b 100644
--- a/sql/parse_tree_nodes.cc
+++ b/sql/parse_tree_nodes.cc
@@ -203,15 +203,15 @@ bool PT_option_value_no_option_type_charset::do_contextualize(
 bool PT_option_value_no_option_type_names::do_contextualize(Parse_context *pc) {
   if (super::do_contextualize(pc)) return true;
 
   THD *thd = pc->thd;
   LEX *lex = thd->lex;
   sp_pcontext *pctx = lex->get_sp_current_parsing_ctx();
   LEX_CSTRING names = {STRING_WITH_LEN("names")};
 
   if (pctx && pctx->find_variable(names.str, names.length, false))
     my_error(ER_SP_BAD_VAR_SHADOW, MYF(0), names.str);
   else
-    error(pc, pos);
+    error(pc, m_error_pos);
 
   return true;  // always fails with an error
 }
@@ -668,13 +668,16 @@ bool PT_option_value_no_option_type_password::do_contextualize(
   return false;
 }
 
-PT_key_part_specification::PT_key_part_specification(Item *expression,
+PT_key_part_specification::PT_key_part_specification(const POS &pos,
+                                                     Item *expression,
                                                      enum_order order)
-    : m_expression(expression), m_order(order) {}
+    : super(pos), m_expression(expression), m_order(order) {}
 
 PT_key_part_specification::PT_key_part_specification(
-    const LEX_CSTRING &column_name, enum_order order, int prefix_length)
-    : m_expression(nullptr),
+    const POS &pos, const LEX_CSTRING &column_name, enum_order order,
+    int prefix_length)
+    : super(pos),
+      m_expression(nullptr),
       m_order(order),
       m_column_name(column_name),
       m_prefix_length(prefix_length) {}
@@ -1313,12 +1316,14 @@ bool PT_table_factor_function::do_contextualize(Parse_context *pc) {
   return false;
 }
 
-PT_derived_table::PT_derived_table(bool lateral, PT_subquery *subquery,
+PT_derived_table::PT_derived_table(const POS &pos, bool lateral,
+                                   PT_subquery *subquery,
                                    const LEX_CSTRING &table_alias,
                                    Create_col_name_list *column_names)
-    : m_lateral(lateral),
+    : super(pos),
+      m_lateral(lateral),
       m_subquery(subquery),
       m_table_alias(table_alias.str),
       column_names(*column_names) {
   m_subquery->m_is_derived_table = true;
 }
@@ -1915,18 +1920,19 @@ bool PT_with_list::push_back(PT_common_table_expr *el) {
 }
 
 PT_common_table_expr::PT_common_table_expr(
-    const LEX_STRING &name, const LEX_STRING &subq_text, uint subq_text_offs,
-    PT_subquery *subq_node, const Create_col_name_list *column_names,
-    MEM_ROOT *mem_root)
-    : m_name(name),
+    const POS &pos, const LEX_STRING &name, const LEX_STRING &subq_text,
+    uint subq_text_offs, PT_subquery *subq_node,
+    const Create_col_name_list *column_names, MEM_ROOT *mem_root)
+    : super(pos),
+      m_name(name),
       m_subq_text(subq_text),
       m_subq_text_offset(subq_text_offs),
       m_subq_node(subq_node),
       m_column_names(*column_names),
       m_postparse(mem_root) {
   if (lower_case_table_names && m_name.length) {
     // Lowercase name, as in Query_block::add_table_to_list()
     m_name.length = my_casedn_str(files_charset_info, m_name.str);
   }
   m_postparse.name = m_name;
 }
@@ -3372,8 +3378,8 @@ Item *PT_border::build_addop(Item_cache *order_expr, bool prec, bool asc,
 }
 
 PT_json_table_column_for_ordinality::PT_json_table_column_for_ordinality(
-    LEX_STRING name)
-    : m_name(name.str) {}
+    const POS &pos, LEX_STRING name)
+    : super(pos), m_name(name.str) {}
 
 PT_json_table_column_for_ordinality::~PT_json_table_column_for_ordinality() =
     default;
@@ -3389,9 +3395,10 @@ bool PT_json_table_column_for_ordinality::do_contextualize(Parse_context *pc) {
 }
 
 PT_json_table_column_with_path::PT_json_table_column_with_path(
-    unique_ptr_destroy_only<Json_table_column> column, LEX_STRING name,
-    PT_type *type, const CHARSET_INFO *collation)
-    : m_column(std::move(column)),
+    const POS &pos, unique_ptr_destroy_only<Json_table_column> column,
+    LEX_STRING name, PT_type *type, const CHARSET_INFO *collation)
+    : super(pos),
+      m_column(std::move(column)),
       m_name(name.str),
       m_type(type),
       m_collation(collation) {}
@@ -3733,41 +3740,41 @@ bool PT_table_locking_clause::raise_error(int error) {
 bool PT_set_scoped_system_variable::do_contextualize(Parse_context *pc) {
   if (super::do_contextualize(pc) || itemize_safe(pc, &m_opt_expr)) {
     return true;
   }
 
   // Remove deprecation warning when FULL is used as keyword.
   THD *thd = pc->thd;
   if (thd->get_stmt_da()->has_sql_condition(ER_WARN_DEPRECATED_IDENT)) {
     thd->get_stmt_da()->reset_condition_info(thd);
   }
 
   const bool is_1d_name = m_opt_prefix.str == nullptr;
 
   /*
     Reject transition variable names in the syntax:
 
         {"GLOBAL" | "SESSION" | "PERSIST" | ...} {"NEW" | "OLD"} "."  <name>
   */
   if (is_any_transition_variable_prefix(*pc, m_opt_prefix)) {
-    error(pc, m_pos);
+    error(pc, m_varpos);
     return true;
   }
 
   /*
     Reject SP variable names in the syntax:
 
         {"GLOBAL" | "SESSION" | ...} <SP variable name>
 
     Note: we also reject overload system variable names here too.
     TODO: most likely this reject is fine, since such a use case is confusing,
           OTOH this is also probable that a rejection of overloaded system
           variables is too strict, so a warning may be a better alternative.
   */
   if (is_1d_name && find_sp_variable(*pc, m_name) != nullptr) {
-    error(pc, m_pos);
+    error(pc, m_varpos);
     return true;
   }
 
   return add_system_variable_assignment(pc->thd, m_opt_prefix, m_name,
                                         pc->thd->lex->option_type, m_opt_expr);
 }
@@ -4103,46 +4110,46 @@ bool PT_query_expression::do_contextualize(Parse_context *pc) {
 bool PT_subquery::do_contextualize(Parse_context *pc) {
   if (super::do_contextualize(pc)) return true;
 
   LEX *lex = pc->thd->lex;
   if (!lex->expr_allows_subselect || lex->sql_command == SQLCOM_PURGE) {
-    error(pc, pos);
+    error(pc, m_pos);
     return true;
   }
 
   // Create a Query_expression and Query_block for the subquery's query
   // expression.
   Query_block *child = lex->new_query(pc->select);
   if (child == nullptr) return true;
 
   Parse_context inner_pc(pc->thd, child);
   inner_pc.m_stack.push_back(QueryLevel(pc->mem_root, SC_SUBQUERY));
 
   if (m_is_derived_table) child->linkage = DERIVED_TABLE_TYPE;
 
   if (qe->contextualize(&inner_pc)) return true;
 
   if (qe->has_into_clause()) {
     my_error(ER_MISPLACED_INTO, MYF(0));
     return true;
   }
 
   query_block = inner_pc.select->master_query_expression()->first_query_block();
   if (inner_pc.finalize_query_expression()) return true;
   inner_pc.m_stack.pop_back();
   assert(inner_pc.m_stack.size() == 0);
 
   lex->pop_context();
   pc->select->n_child_sum_items += child->n_sum_items;
 
   /*
     A subquery (and all the subsequent query blocks in a UNION) can add
     columns to an outer query block. Reserve space for them.
   */
   for (Query_block *temp = child; temp != nullptr;
        temp = temp->next_query_block()) {
     pc->select->select_n_where_fields += temp->select_n_where_fields;
     pc->select->select_n_having_items += temp->select_n_having_items;
   }
 
   return false;
 }
@@ -4332,12 +4339,12 @@ Sql_cmd *PT_set_role::make_cmd(THD *thd) {
 }
 
 LEX_USER *PT_role_or_privilege::get_user(THD *thd) {
-  thd->syntax_error_at(pos, "Illegal authorization identifier");
+  thd->syntax_error_at(m_errpos, "Illegal authorization identifier");
   return nullptr;
 }
 
 Privilege *PT_role_or_privilege::get_privilege(THD *thd) {
-  thd->syntax_error_at(pos, "Illegal privilege identifier");
+  thd->syntax_error_at(m_errpos, "Illegal privilege identifier");
   return nullptr;
 }
 
@@ -4631,22 +4638,22 @@ template <class ATTRIBUTE, class BASE>
 class PT_attribute : public BASE {
   ATTRIBUTE m_attr;
   using CFP = bool (*)(ATTRIBUTE, typename BASE::context_t *);
   CFP m_cfp;
 
  public:
-  PT_attribute(ATTRIBUTE a, CFP cfp) : m_attr{a}, m_cfp{cfp} {}
+  PT_attribute(ATTRIBUTE a, CFP cfp) : BASE(POS()), m_attr{a}, m_cfp{cfp} {}
   bool do_contextualize(typename BASE::context_t *pc) override {
     return BASE::do_contextualize(pc) || m_cfp(m_attr, pc);
   }
 };
 
 /**
    Factory function which instantiates PT_attribute with suitable
    parameters, allocates on the provided mem_root, and returns the
    appropriate base pointer.
 
    @param mem_root Memory arena.
    @param attr     Attribute value from parser.
 
    @return PT_alter_tablespace_option_base* to PT_attribute object.
  */
@@ -4806,22 +4813,22 @@ PT_base_index_option *make_index_secondary_engine_attribute(MEM_ROOT *mem_root,
 }
 
 PT_install_component::PT_install_component(
-    THD *thd, const Mem_root_array_YY<LEX_STRING> urns,
+    const POS &pos, THD *thd, const Mem_root_array_YY<LEX_STRING> urns,
     List<PT_install_component_set_element> *set_elements)
-    : m_urns(urns), m_set_elements(set_elements) {
+    : Parse_tree_root(pos), m_urns(urns), m_set_elements(set_elements) {
   const char *prefix = "file://component_";
   const auto prefix_len = sizeof("file://component_") - 1;
 
   if (m_urns.size() == 1 &&
       !thd->charset()->coll->strnncoll(
           thd->charset(), pointer_cast<const uchar *>(m_urns[0].str),
           m_urns[0].length, pointer_cast<const uchar *>(prefix), prefix_len,
           true)) {
     for (auto &elt : *m_set_elements) {
       if (elt.name.prefix.length == 0) {
         elt.name.prefix.str = m_urns[0].str + prefix_len;
         elt.name.prefix.length = m_urns[0].length - prefix_len;
       }
     }
   }
 }
diff --git a/sql/parse_tree_nodes.h b/sql/parse_tree_nodes.h
index fd3bfee593f..0c74b4f100a 100644
--- a/sql/parse_tree_nodes.h
+++ b/sql/parse_tree_nodes.h
@@ -157,24 +157,28 @@ bool contextualize_nodes(Mem_root_array_YY<Node_type *> nodes,
   @ingroup ptn_stmt
 */
 class Parse_tree_root {
   Parse_tree_root(const Parse_tree_root &) = delete;
   void operator=(const Parse_tree_root &) = delete;
 
  protected:
-  virtual ~Parse_tree_root() = default;
   Parse_tree_root() = default;
+  explicit Parse_tree_root(const POS &pos) : m_pos(pos) {}
+  virtual ~Parse_tree_root() = default;
 
  public:
+  /// Textual location of a token just parsed.
+  POS m_pos;
+
   virtual Sql_cmd *make_cmd(THD *thd) = 0;
 };
 
 class PT_table_ddl_stmt_base : public Parse_tree_root {
  public:
-  explicit PT_table_ddl_stmt_base(MEM_ROOT *mem_root)
-      : m_alter_info(mem_root) {}
+  explicit PT_table_ddl_stmt_base(const POS &pos, MEM_ROOT *mem_root)
+      : Parse_tree_root(pos), m_alter_info(mem_root) {}
 
   ~PT_table_ddl_stmt_base() override = 0;  // force abstract class
 
  protected:
   Alter_info m_alter_info;
 };
@@ -202,11 +206,11 @@ typedef Parse_tree_node_tmpl<Table_ddl_parse_context> Table_ddl_node;
 class PT_order_expr : public Parse_tree_node, public ORDER {
   typedef Parse_tree_node super;
 
  public:
-  PT_order_expr(Item *item_arg, enum_order dir) {
+  PT_order_expr(const POS &pos, Item *item_arg, enum_order dir) : super(pos) {
     item_initial = item_arg;
     direction = (dir == ORDER_DESC) ? ORDER_DESC : ORDER_ASC;
   }
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -214,21 +218,23 @@ class PT_order_expr : public Parse_tree_node, public ORDER {
 class PT_order_list : public Parse_tree_node {
   typedef Parse_tree_node super;
 
  public:
   SQL_I_List<ORDER> value;
 
  public:
+  explicit PT_order_list(const POS &pos) : super(pos) {}
+
   bool do_contextualize(Parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
     for (ORDER *o = value.first; o != nullptr; o = o->next) {
       if (static_cast<PT_order_expr *>(o)->contextualize(pc)) return true;
     }
     return false;
   }
 
   void push_back(PT_order_expr *order) {
     order->used_alias = false;
     order->used = 0;
     value.link_in_list(order, &order->next);
   }
 };
@@ -236,145 +242,152 @@ class PT_order_list : public Parse_tree_node {
 class PT_gorder_list : public PT_order_list {
   typedef PT_order_list super;
 
  public:
+  explicit PT_gorder_list(const POS &pos) : super(pos) {}
+
   bool do_contextualize(Parse_context *pc) override {
     return super::do_contextualize(pc);
   }
 };
 
 /**
   Represents an element of the WITH list:
   WITH [...], [...] SELECT ...,
          ^  or  ^
   i.e. a Common Table Expression (CTE, or Query Name in SQL99 terms).
 */
 class PT_common_table_expr : public Parse_tree_node {
   typedef Parse_tree_node super;
 
  public:
-  explicit PT_common_table_expr(const LEX_STRING &name,
+  explicit PT_common_table_expr(const POS &pos, const LEX_STRING &name,
                                 const LEX_STRING &subq_text,
                                 uint subq_text_offset, PT_subquery *sn,
                                 const Create_col_name_list *column_names,
                                 MEM_ROOT *mem_root);
 
   /// The name after AS
   const LEX_STRING &name() const { return m_name; }
   /**
     @param      thd  Thread handler
     @param[out] node PT_subquery
     @returns a PT_subquery to attach to a table reference for this CTE
   */
   bool make_subquery_node(THD *thd, PT_subquery **node);
   /**
     @param tl  Table reference to match
     @param in_self  If this is a recursive reference
     @param[out]  found Is set to true/false if matches or not
     @returns true if error
   */
   bool match_table_ref(Table_ref *tl, bool in_self, bool *found);
   /**
     @returns true if 'other' is the same instance as 'this'
   */
   bool is(const Common_table_expr *other) const {
     return other == &m_postparse;
   }
   void print(const THD *thd, String *str, enum_query_type query_type);
 
  private:
   LEX_STRING m_name;
   /// Raw text of query expression (including parentheses)
   const LEX_STRING m_subq_text;
   /**
     Offset in bytes of m_subq_text in original statement which had the WITH
     clause.
   */
   uint m_subq_text_offset;
   /// Parsed version of subq_text
   PT_subquery *const m_subq_node;
   /// List of explicitly specified column names; if empty, no list.
   const Create_col_name_list m_column_names;
   /**
     A Table_ref representing a CTE needs access to the WITH list
     element it derives from. However, in order to:
     - limit the members which Table_ref can access
     - avoid including this header file everywhere Table_ref needs to
     access these members, these members are relocated into a separate inferior
     object whose declaration is in table.h, like that of Table_ref. It's
     the "postparse" part. Table_ref accesses this inferior object only.
   */
   Common_table_expr m_postparse;
 
   friend bool Query_expression::clear_correlated_query_blocks();
 };
 
 /**
    Represents the WITH list.
    WITH [...], [...] SELECT ...,
         ^^^^^^^^^^^^
 */
 class PT_with_list : public Parse_tree_node {
   typedef Parse_tree_node super;
 
  public:
+  /// @param pos Position of this clause in the SQL statement.
   /// @param mem_root where interior objects are allocated
-  explicit PT_with_list(MEM_ROOT *mem_root) : m_elements(mem_root) {}
+  explicit PT_with_list(const POS &pos, MEM_ROOT *mem_root)
+      : super(pos), m_elements(mem_root) {}
   bool push_back(PT_common_table_expr *el);
   const Mem_root_array<PT_common_table_expr *> &elements() const {
     return m_elements;
   }
 
  private:
   Mem_root_array<PT_common_table_expr *> m_elements;
 };
 
 /**
   Represents the WITH clause:
   WITH [...], [...] SELECT ...,
   ^^^^^^^^^^^^^^^^^
 */
 class PT_with_clause : public Parse_tree_node {
   typedef Parse_tree_node super;
 
  public:
-  PT_with_clause(const PT_with_list *l, bool r)
-      : m_list(l), m_recursive(r), m_most_inner_in_parsing(nullptr) {}
+  PT_with_clause(const POS &pos, const PT_with_list *l, bool r)
+      : super(pos),
+        m_list(l),
+        m_recursive(r),
+        m_most_inner_in_parsing(nullptr) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
   /**
     Looks up a table reference into the list of CTEs.
     @param      tl    Table reference to look up
     @param[out] found Is set to true/false if found or not
     @returns true if error
   */
   bool lookup(Table_ref *tl, PT_common_table_expr **found);
   /**
     Call this to record in the WITH clause that we are contextualizing the
     CTE definition inserted in table reference 'tl'.
     @returns information which the caller must provide to
     leave_parsing_definition().
   */
   const Table_ref *enter_parsing_definition(Table_ref *tl) {
     auto old = m_most_inner_in_parsing;
     m_most_inner_in_parsing = tl;
     return old;
   }
   void leave_parsing_definition(const Table_ref *old) {
     m_most_inner_in_parsing = old;
   }
   void print(const THD *thd, String *str, enum_query_type query_type);
 
  private:
   /// All CTEs of this clause
   const PT_with_list *const m_list;
   /// True if the user has specified the RECURSIVE keyword.
   const bool m_recursive;
   /**
     The innermost CTE reference which we're parsing at the
     moment. Used to detect forward references, loops and recursiveness.
   */
   const Table_ref *m_most_inner_in_parsing;
 
   friend bool Query_expression::clear_correlated_query_blocks();
 };
@@ -382,19 +395,21 @@ class PT_with_clause : public Parse_tree_node {
 class PT_select_item_list : public PT_item_list {
   typedef PT_item_list super;
 
  public:
+  explicit PT_select_item_list(const POS &pos) : super(pos) {}
+
   bool do_contextualize(Parse_context *pc) override;
 };
 
 class PT_limit_clause : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   Limit_options limit_options;
 
  public:
-  PT_limit_clause(const Limit_options &limit_options_arg)
-      : limit_options(limit_options_arg) {}
+  PT_limit_clause(const POS &pos, const Limit_options &limit_options_arg)
+      : super(pos), limit_options(limit_options_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
   friend class PT_query_expression;
 };
@@ -404,19 +419,21 @@ class PT_joined_table;
 
 class PT_table_reference : public Parse_tree_node {
  public:
-  Table_ref *m_table_ref;
+  explicit PT_table_reference(const POS &pos) : Parse_tree_node(pos) {}
+
+  Table_ref *m_table_ref{nullptr};
 
   /**
     Lets us build a parse tree top-down, which is necessary due to the
     context-dependent nature of the join syntax. This function adds
     the @<table_ref@> cross join as the left-most leaf in this join tree
     rooted at this node.
 
     @todo: comment on non-join PT_table_reference objects
 
     @param cj This @<table ref@> will be added if it represents a cross join.
 
     @return The new top-level join.
   */
   virtual PT_joined_table *add_cross_join(PT_cross_join *cj);
 };
@@ -424,25 +441,29 @@ class PT_table_reference : public Parse_tree_node {
 class PT_table_factor_table_ident : public PT_table_reference {
   typedef PT_table_reference super;
 
   Table_ident *table_ident;
   List<String> *opt_use_partition;
   const char *const opt_table_alias;
   List<Index_hint> *opt_key_definition;
 
  public:
-  PT_table_factor_table_ident(Table_ident *table_ident_arg,
+  PT_table_factor_table_ident(const POS &pos, Table_ident *table_ident_arg,
                               List<String> *opt_use_partition_arg,
                               const LEX_CSTRING &opt_table_alias_arg,
                               List<Index_hint> *opt_key_definition_arg)
-      : table_ident(table_ident_arg),
+      : super(pos),
+        table_ident(table_ident_arg),
         opt_use_partition(opt_use_partition_arg),
         opt_table_alias(opt_table_alias_arg.str),
         opt_key_definition(opt_key_definition_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
 
 class PT_json_table_column : public Parse_tree_node {
+ protected:
+  explicit PT_json_table_column(const POS &pos) : Parse_tree_node(pos) {}
+
  public:
   virtual Json_table_column *get_column() = 0;
 };
@@ -450,20 +471,21 @@ class PT_json_table_column : public Parse_tree_node {
 class PT_table_factor_function : public PT_table_reference {
   typedef PT_table_reference super;
 
  public:
-  PT_table_factor_function(Item *expr, Item *path,
+  PT_table_factor_function(const POS &pos, Item *expr, Item *path,
                            Mem_root_array<PT_json_table_column *> *nested_cols,
                            const LEX_STRING &table_alias)
-      : m_expr(expr),
+      : super(pos),
+        m_expr(expr),
         m_path(path),
         m_nested_columns(nested_cols),
         m_table_alias(table_alias) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
  private:
   Item *m_expr;
   Item *m_path;
   Mem_root_array<PT_json_table_column *> *m_nested_columns;
   const LEX_STRING m_table_alias;
 };
@@ -471,12 +493,12 @@ class PT_table_factor_function : public PT_table_reference {
 class PT_table_reference_list_parens : public PT_table_reference {
   typedef PT_table_reference super;
 
   Mem_root_array_YY<PT_table_reference *> table_list;
 
  public:
   explicit PT_table_reference_list_parens(
-      const Mem_root_array_YY<PT_table_reference *> table_list)
-      : table_list(table_list) {}
+      const POS &pos, const Mem_root_array_YY<PT_table_reference *> table_list)
+      : super(pos), table_list(table_list) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -484,17 +506,17 @@ class PT_table_reference_list_parens : public PT_table_reference {
 class PT_derived_table : public PT_table_reference {
   typedef PT_table_reference super;
 
  public:
-  PT_derived_table(bool lateral, PT_subquery *subquery,
+  PT_derived_table(const POS &pos, bool lateral, PT_subquery *subquery,
                    const LEX_CSTRING &table_alias,
                    Create_col_name_list *column_names);
 
   bool do_contextualize(Parse_context *pc) override;
 
  private:
   bool m_lateral;
   PT_subquery *m_subquery;
   const char *const m_table_alias;
   /// List of explicitly specified column names; if empty, no list.
   const Create_col_name_list column_names;
 };
@@ -502,12 +524,12 @@ class PT_derived_table : public PT_table_reference {
 class PT_table_factor_joined_table : public PT_table_reference {
   typedef PT_table_reference super;
 
  public:
-  PT_table_factor_joined_table(PT_joined_table *joined_table)
-      : m_joined_table(joined_table) {}
+  PT_table_factor_joined_table(const POS &pos, PT_joined_table *joined_table)
+      : super(pos), m_joined_table(joined_table) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
  private:
   PT_joined_table *m_joined_table;
 };
@@ -515,53 +537,55 @@ class PT_table_factor_joined_table : public PT_table_reference {
 class PT_joined_table : public PT_table_reference {
   typedef PT_table_reference super;
 
  protected:
   PT_table_reference *m_left_pt_table;
   POS m_join_pos;
   PT_joined_table_type m_type;
   PT_table_reference *m_right_pt_table;
 
   Table_ref *m_left_table_ref{nullptr};
   Table_ref *m_right_table_ref{nullptr};
 
  public:
-  PT_joined_table(PT_table_reference *tab1_node_arg, const POS &join_pos_arg,
-                  PT_joined_table_type type, PT_table_reference *tab2_node_arg)
-      : m_left_pt_table(tab1_node_arg),
+  PT_joined_table(const POS &pos, PT_table_reference *tab1_node_arg,
+                  const POS &join_pos_arg, PT_joined_table_type type,
+                  PT_table_reference *tab2_node_arg)
+      : super(pos),
+        m_left_pt_table(tab1_node_arg),
         m_join_pos(join_pos_arg),
         m_type(type),
         m_right_pt_table(tab2_node_arg) {
     static_assert(is_single_bit(JTT_INNER), "not a single bit");
     static_assert(is_single_bit(JTT_STRAIGHT), "not a single bit");
     static_assert(is_single_bit(JTT_NATURAL), "not a single bit");
     static_assert(is_single_bit(JTT_LEFT), "not a single bit");
     static_assert(is_single_bit(JTT_RIGHT), "not a single bit");
 
     assert(type == JTT_INNER || type == JTT_STRAIGHT_INNER ||
            type == JTT_NATURAL_INNER || type == JTT_NATURAL_LEFT ||
            type == JTT_NATURAL_RIGHT || type == JTT_LEFT || type == JTT_RIGHT);
   }
 
   /**
     Adds the cross join to this join operation. The cross join is nested as
     the table reference on the left-hand side.
   */
   PT_joined_table *add_cross_join(PT_cross_join *cj) override {
     m_left_pt_table = m_left_pt_table->add_cross_join(cj);
     return this;
   }
 
   /// Adds the table reference as the right-hand side of this join.
   void add_rhs(PT_table_reference *table) {
     assert(m_right_pt_table == nullptr);
     m_right_pt_table = table;
   }
 
   bool do_contextualize(Parse_context *pc) override;
 
   /// This class is being inherited, it should thus be abstract.
   ~PT_joined_table() override = 0;
 
  protected:
   bool contextualize_tabs(Parse_context *pc);
 };
@@ -571,11 +595,12 @@ inline PT_joined_table::~PT_joined_table() = default;
 class PT_cross_join : public PT_joined_table {
   typedef PT_joined_table super;
 
  public:
-  PT_cross_join(PT_table_reference *tab1_node_arg, const POS &join_pos_arg,
-                PT_joined_table_type Type_arg,
+  PT_cross_join(const POS &pos, PT_table_reference *tab1_node_arg,
+                const POS &join_pos_arg, PT_joined_table_type Type_arg,
                 PT_table_reference *tab2_node_arg)
-      : PT_joined_table(tab1_node_arg, join_pos_arg, Type_arg, tab2_node_arg) {}
+      : PT_joined_table(pos, tab1_node_arg, join_pos_arg, Type_arg,
+                        tab2_node_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -583,12 +608,13 @@ class PT_cross_join : public PT_joined_table {
 class PT_joined_table_on : public PT_joined_table {
   typedef PT_joined_table super;
   Item *on;
 
  public:
-  PT_joined_table_on(PT_table_reference *tab1_node_arg, const POS &join_pos_arg,
-                     PT_joined_table_type type,
+  PT_joined_table_on(const POS &pos, PT_table_reference *tab1_node_arg,
+                     const POS &join_pos_arg, PT_joined_table_type type,
                      PT_table_reference *tab2_node_arg, Item *on_arg)
-      : super(tab1_node_arg, join_pos_arg, type, tab2_node_arg), on(on_arg) {}
+      : super(pos, tab1_node_arg, join_pos_arg, type, tab2_node_arg),
+        on(on_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -596,21 +622,21 @@ class PT_joined_table_on : public PT_joined_table {
 class PT_joined_table_using : public PT_joined_table {
   typedef PT_joined_table super;
   List<String> *using_fields;
 
  public:
-  PT_joined_table_using(PT_table_reference *tab1_node_arg,
+  PT_joined_table_using(const POS &pos, PT_table_reference *tab1_node_arg,
                         const POS &join_pos_arg, PT_joined_table_type type,
                         PT_table_reference *tab2_node_arg,
                         List<String> *using_fields_arg)
-      : super(tab1_node_arg, join_pos_arg, type, tab2_node_arg),
+      : super(pos, tab1_node_arg, join_pos_arg, type, tab2_node_arg),
         using_fields(using_fields_arg) {}
 
   /// A PT_joined_table_using without a list of columns denotes a natural join.
-  PT_joined_table_using(PT_table_reference *tab1_node_arg,
+  PT_joined_table_using(const POS &pos, PT_table_reference *tab1_node_arg,
                         const POS &join_pos_arg, PT_joined_table_type type,
                         PT_table_reference *tab2_node_arg)
-      : PT_joined_table_using(tab1_node_arg, join_pos_arg, type, tab2_node_arg,
-                              nullptr) {}
+      : PT_joined_table_using(pos, tab1_node_arg, join_pos_arg, type,
+                              tab2_node_arg, nullptr) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -618,12 +644,12 @@ class PT_joined_table_using : public PT_joined_table {
 class PT_group : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   PT_order_list *group_list;
   olap_type olap;
 
  public:
-  PT_group(PT_order_list *group_list_arg, olap_type olap_arg)
-      : group_list(group_list_arg), olap(olap_arg) {}
+  PT_group(const POS &pos, PT_order_list *group_list_arg, olap_type olap_arg)
+      : super(pos), group_list(group_list_arg), olap(olap_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -631,41 +657,44 @@ class PT_group : public Parse_tree_node {
 class PT_order : public Parse_tree_node {
   typedef Parse_tree_node super;
 
  public:
   PT_order_list *order_list;
-  explicit PT_order(PT_order_list *order_list_arg)
-      : order_list(order_list_arg) {}
+  explicit PT_order(const POS &pos, PT_order_list *order_list_arg)
+      : super(pos), order_list(order_list_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
 
 class PT_locking_clause : public Parse_tree_node {
  public:
-  PT_locking_clause(Lock_strength strength, Locked_row_action action)
-      : m_lock_strength(strength), m_locked_row_action(action) {}
+  PT_locking_clause(const POS &pos, Lock_strength strength,
+                    Locked_row_action action)
+      : Parse_tree_node(pos),
+        m_lock_strength(strength),
+        m_locked_row_action(action) {}
 
   bool do_contextualize(Parse_context *pc) final;
 
   virtual bool set_lock_for_tables(Parse_context *pc) = 0;
 
   Locked_row_action action() const { return m_locked_row_action; }
 
  protected:
   Lock_descriptor get_lock_descriptor() const {
     thr_lock_type lock_type = TL_IGNORE;
     switch (m_lock_strength) {
       case Lock_strength::UPDATE:
         lock_type = TL_WRITE;
         break;
       case Lock_strength::SHARE:
         lock_type = TL_READ_WITH_SHARED_LOCKS;
         break;
     }
 
     return {lock_type, static_cast<thr_locked_row_action>(action())};
   }
 
  private:
   Lock_strength m_lock_strength;
   Locked_row_action m_locked_row_action;
 };
@@ -673,9 +702,9 @@ class PT_locking_clause : public Parse_tree_node {
 class PT_query_block_locking_clause : public PT_locking_clause {
  public:
   explicit PT_query_block_locking_clause(
-      Lock_strength strength,
+      const POS &pos, Lock_strength strength,
       Locked_row_action action = Locked_row_action::WAIT)
-      : PT_locking_clause(strength, action) {}
+      : PT_locking_clause(pos, strength, action) {}
 
   bool set_lock_for_tables(Parse_context *pc) override;
 };
@@ -683,94 +712,97 @@ class PT_query_block_locking_clause : public PT_locking_clause {
 class PT_table_locking_clause : public PT_locking_clause {
  public:
   typedef Mem_root_array_YY<Table_ident *> Table_ident_list;
 
-  PT_table_locking_clause(Lock_strength strength,
+  PT_table_locking_clause(const POS &pos, Lock_strength strength,
                           Mem_root_array_YY<Table_ident *> tables,
                           Locked_row_action action)
-      : PT_locking_clause(strength, action), m_tables(tables) {}
+      : PT_locking_clause(pos, strength, action), m_tables(tables) {}
 
   bool set_lock_for_tables(Parse_context *pc) override;
 
  private:
   /// @todo Move this function to Table_ident?
   void print_table_ident(const THD *thd, const Table_ident *ident, String *s);
 
   bool raise_error(THD *thd, const Table_ident *name, int error);
 
   bool raise_error(int error);
 
   Table_ident_list m_tables;
 };
 
 class PT_locking_clause_list : public Parse_tree_node {
  public:
-  PT_locking_clause_list(MEM_ROOT *mem_root) {
+  PT_locking_clause_list(const POS &pos, MEM_ROOT *mem_root)
+      : Parse_tree_node(pos) {
     m_locking_clauses.init(mem_root);
   }
 
   bool push_back(PT_locking_clause *locking_clause) {
     return m_locking_clauses.push_back(locking_clause);
   }
 
   bool do_contextualize(Parse_context *pc) override {
     for (auto locking_clause : m_locking_clauses)
       if (locking_clause->contextualize(pc)) return true;
     return false;
   }
 
  private:
-  Mem_root_array_YY<PT_locking_clause *> m_locking_clauses;
+  Mem_root_array_YY<PT_locking_clause *> m_locking_clauses{};
 };
 
 class PT_query_expression_body : public Parse_tree_node {
  public:
+  explicit PT_query_expression_body(const POS &pos) : Parse_tree_node(pos) {}
+
   virtual bool is_set_operation() const = 0;
 
   /**
     True if this query expression can absorb an extraneous order by/limit
     clause. The `ORDER BY`/`LIMIT` syntax is mostly consistestent, i.e. a
     trailing clause may not refer to the tables in the `<query primary>`, with
     one glaring exception:
 
         (...( SELECT ... )...) ORDER BY ...
 
     If the nested query expression doesn't contain `ORDER BY`, the statement
     is interpreted as if the `ORDER BY` was absorbed by the innermost query
     expression, i.e.:
 
         (...( SELECT ... ORDER BY ... )...)
 
     There is no rewriting of the parse tree nor AST happening here, the
     transformation is done by the contextualizer (see
     PT_query_expression::contextualize_order_and_limit), which interprets the
     parse tree, and builds the AST according to this interpretation. This
     interpretation is governed by the following rule: An `ORDER BY` can be
     absorbed if none the nested query expressions contains an `ORDER BY` *or*
     `LIMIT`. The rule is complex, so here are some examples for illustration:
 
     In these cases the `ORDER BY` *is* absorbed:
 
         ( SELECT * FROM t1 ) ORDER BY t1.a;
         (( SELECT * FROM t1 )) ORDER BY t1.a;
 
     In these cases the ORDER BY is *not* absorbed:
 
         ( SELECT * FROM t1 ORDER BY 1 ) ORDER BY t1.a;
         (( SELECT * FROM t1 ) ORDER BY 1 ) ORDER BY t1.a;
         ( SELECT * FROM t1 LIMIT 1 ) ORDER BY t1.a;
         (( SELECT * FROM t1 ) LIMIT 1 ) ORDER BY t1.a;
 
     The same happens with `LIMIT`, obviously, but the optimizer is freeer to
     choose when to apply the limit, and there are name no resolution issues
     involved.
 
     @param order  True if the outer query block has the ORDER BY clause.
     @param limit  True if the outer query block has the LIMIT clause.
   */
   virtual bool can_absorb_order_and_limit(bool order, bool limit) const = 0;
   virtual bool has_into_clause() const = 0;
   virtual bool has_trailing_into_clause() const = 0;
 
   virtual bool is_table_value_constructor() const = 0;
   virtual PT_insert_values_list *get_row_value_list() const = 0;
 };
@@ -778,43 +810,51 @@ class PT_query_expression_body : public Parse_tree_node {
 class PT_set_scoped_system_variable : public Parse_tree_node {
   typedef Parse_tree_node super;
 
  public:
-  PT_set_scoped_system_variable(const POS &pos, const LEX_CSTRING &opt_prefix,
+  PT_set_scoped_system_variable(const POS &pos, const POS &var_pos,
+                                const LEX_CSTRING &opt_prefix,
                                 const LEX_CSTRING &name, Item *opt_expr)
-      : m_pos{pos},
+      : super(pos),
+        m_varpos(var_pos),
         m_opt_prefix{opt_prefix},
         m_name{name},
         m_opt_expr{opt_expr} {}
 
   bool do_contextualize(Parse_context *pc) override;
 
  private:
-  const POS m_pos;
+  const POS m_varpos;
   const LEX_CSTRING m_opt_prefix;
   const LEX_CSTRING m_name;
   Item *m_opt_expr;
 };
 
-class PT_option_value_no_option_type : public Parse_tree_node {};
+class PT_option_value_no_option_type : public Parse_tree_node {
+ protected:
+  explicit PT_option_value_no_option_type(const POS &pos)
+      : Parse_tree_node(pos) {}
+};
 
 class PT_set_variable : public PT_option_value_no_option_type {
   typedef PT_option_value_no_option_type super;
 
  public:
-  PT_set_variable(const POS &pos, const LEX_CSTRING &opt_prefix,
-                  const LEX_CSTRING &name, const POS &expr_pos, Item *opt_expr)
-      : m_pos{pos},
+  PT_set_variable(const POS &pos, const POS &varpos,
+                  const LEX_CSTRING &opt_prefix, const LEX_CSTRING &name,
+                  const POS &expr_pos, Item *opt_expr)
+      : super{pos},
+        m_varpos{varpos},
         m_opt_prefix{opt_prefix},
         m_name{name},
         m_expr_pos{expr_pos},
         m_opt_expr{opt_expr} {}
 
   bool do_contextualize(Parse_context *pc) override;
 
  private:
-  const POS m_pos;
+  const POS m_varpos;
   const LEX_CSTRING m_opt_prefix;
   const LEX_CSTRING m_name;
   const POS m_expr_pos;
   Item *m_opt_expr;
 };
@@ -822,14 +862,15 @@ class PT_set_variable : public PT_option_value_no_option_type {
 class PT_option_value_no_option_type_user_var
     : public PT_option_value_no_option_type {
   typedef PT_option_value_no_option_type super;
 
   LEX_STRING name;
   Item *expr;
 
  public:
-  PT_option_value_no_option_type_user_var(const LEX_STRING &name_arg,
+  PT_option_value_no_option_type_user_var(const POS &pos,
+                                          const LEX_STRING &name_arg,
                                           Item *expr_arg)
-      : name(name_arg), expr(expr_arg) {}
+      : super(pos), name(name_arg), expr(expr_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -837,22 +878,23 @@ class PT_option_value_no_option_type_user_var
 class PT_set_system_variable : public PT_option_value_no_option_type {
   typedef PT_option_value_no_option_type super;
 
  public:
-  PT_set_system_variable(enum_var_type scope, const POS &name_pos,
-                         const LEX_CSTRING &opt_prefix, const LEX_CSTRING &name,
-                         Item *opt_expr)
-      : m_scope{scope},
+  PT_set_system_variable(const POS &pos, enum_var_type scope,
+                         const POS &name_pos, const LEX_CSTRING &opt_prefix,
+                         const LEX_CSTRING &name, Item *opt_expr)
+      : super(pos),
+        m_scope{scope},
         m_name_pos{name_pos},
         m_opt_prefix{opt_prefix},
         m_name{name},
         m_opt_expr{opt_expr} {}
 
   bool do_contextualize(Parse_context *pc) override;
 
  private:
   const enum_var_type m_scope;
   const POS m_name_pos;
   const LEX_CSTRING m_opt_prefix;
   const LEX_CSTRING m_name;
   Item *m_opt_expr;
 };
@@ -860,12 +902,13 @@ class PT_set_system_variable : public PT_option_value_no_option_type {
 class PT_option_value_no_option_type_charset
     : public PT_option_value_no_option_type {
   typedef PT_option_value_no_option_type super;
 
   const CHARSET_INFO *opt_charset;
 
  public:
-  PT_option_value_no_option_type_charset(const CHARSET_INFO *opt_charset_arg)
-      : opt_charset(opt_charset_arg) {}
+  PT_option_value_no_option_type_charset(const POS &pos,
+                                         const CHARSET_INFO *opt_charset_arg)
+      : super(pos), opt_charset(opt_charset_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -873,11 +916,13 @@ class PT_option_value_no_option_type_charset
 class PT_option_value_no_option_type_names
     : public PT_option_value_no_option_type {
   typedef PT_option_value_no_option_type super;
 
-  POS pos;
+  POS m_error_pos;
 
  public:
-  explicit PT_option_value_no_option_type_names(const POS &pos) : pos(pos) {}
+  explicit PT_option_value_no_option_type_names(const POS &pos,
+                                                const POS &error_pos)
+      : super(pos), m_error_pos(error_pos) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -885,40 +930,47 @@ class PT_option_value_no_option_type_names
 class PT_set_names : public PT_option_value_no_option_type {
   typedef PT_option_value_no_option_type super;
 
   const CHARSET_INFO *opt_charset;
   const CHARSET_INFO *opt_collation;
 
  public:
-  PT_set_names(const CHARSET_INFO *opt_charset_arg,
+  PT_set_names(const POS &pos, const CHARSET_INFO *opt_charset_arg,
                const CHARSET_INFO *opt_collation_arg)
-      : opt_charset(opt_charset_arg), opt_collation(opt_collation_arg) {}
+      : super(pos),
+        opt_charset(opt_charset_arg),
+        opt_collation(opt_collation_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
 
-class PT_start_option_value_list : public Parse_tree_node {};
+class PT_start_option_value_list : public Parse_tree_node {
+ protected:
+  explicit PT_start_option_value_list(const POS &pos) : Parse_tree_node(pos) {}
+};
 
 class PT_option_value_no_option_type_password
     : public PT_start_option_value_list {
   typedef PT_start_option_value_list super;
 
   const char *password;
   const char *current_password;
   bool retain_current_password;
   bool random_password_generator;
   POS expr_pos;
 
  public:
-  PT_option_value_no_option_type_password(const char *password_arg,
+  PT_option_value_no_option_type_password(const POS &pos,
+                                          const char *password_arg,
                                           const char *current_password_arg,
                                           bool retain_current,
                                           bool random_password,
                                           const POS &expr_pos_arg)
-      : password(password_arg),
+      : super(pos),
+        password(password_arg),
         current_password(current_password_arg),
         retain_current_password(retain_current),
         random_password_generator(random_password),
         expr_pos(expr_pos_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -926,27 +978,26 @@ class PT_option_value_no_option_type_password
 class PT_option_value_no_option_type_password_for
     : public PT_start_option_value_list {
   typedef PT_start_option_value_list super;
 
   LEX_USER *user;
   const char *password;
   const char *current_password;
   bool retain_current_password;
   bool random_password_generator;
   POS expr_pos;
 
  public:
-  PT_option_value_no_option_type_password_for(LEX_USER *user_arg,
-                                              const char *password_arg,
-                                              const char *current_password_arg,
-                                              bool retain_current,
-                                              bool random_pass,
-                                              const POS &expr_pos_arg)
-      : user(user_arg),
+  PT_option_value_no_option_type_password_for(
+      const POS &pos, LEX_USER *user_arg, const char *password_arg,
+      const char *current_password_arg, bool retain_current, bool random_pass,
+      const POS &expr_pos_arg)
+      : super(pos),
+        user(user_arg),
         password(password_arg),
         current_password(current_password_arg),
         retain_current_password(retain_current),
         random_password_generator(random_pass),
         expr_pos(expr_pos_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -954,13 +1005,13 @@ class PT_option_value_no_option_type_password_for
 class PT_option_value_type : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   enum_var_type type;
   PT_set_scoped_system_variable *value;
 
  public:
-  PT_option_value_type(enum_var_type type_arg,
+  PT_option_value_type(const POS &pos, enum_var_type type_arg,
                        PT_set_scoped_system_variable *value_arg)
-      : type(type_arg), value(value_arg) {}
+      : super(pos), type(type_arg), value(value_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -968,17 +1019,18 @@ class PT_option_value_type : public Parse_tree_node {
 class PT_option_value_list_head : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   POS delimiter_pos;
   Parse_tree_node *value;
   POS value_pos;
 
  public:
-  PT_option_value_list_head(const POS &delimiter_pos_arg,
+  PT_option_value_list_head(const POS &pos, const POS &delimiter_pos_arg,
                             Parse_tree_node *value_arg,
                             const POS &value_pos_arg)
-      : delimiter_pos(delimiter_pos_arg),
+      : super(pos),
+        delimiter_pos(delimiter_pos_arg),
         value(value_arg),
         value_pos(value_pos_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -986,17 +1038,17 @@ class PT_option_value_list_head : public Parse_tree_node {
 class PT_option_value_list : public PT_option_value_list_head {
   typedef PT_option_value_list_head super;
 
   PT_option_value_list_head *head;
 
  public:
-  PT_option_value_list(PT_option_value_list_head *head_arg,
+  PT_option_value_list(const POS &pos, PT_option_value_list_head *head_arg,
                        const POS &delimiter_pos_arg, Parse_tree_node *tail,
                        const POS &tail_pos)
-      : super(delimiter_pos_arg, tail, tail_pos), head(head_arg) {}
+      : super(pos, delimiter_pos_arg, tail, tail_pos), head(head_arg) {}
 
   bool do_contextualize(Parse_context *pc) override {
     uchar dummy;
     if (check_stack_overrun(pc->thd, STACK_MIN_SIZE, &dummy)) return true;
     return head->contextualize(pc) || super::do_contextualize(pc);
   }
 };
@@ -1004,15 +1056,16 @@ class PT_option_value_list : public PT_option_value_list_head {
 class PT_start_option_value_list_no_type : public PT_start_option_value_list {
   typedef PT_start_option_value_list super;
 
   PT_option_value_no_option_type *head;
   POS head_pos;
   PT_option_value_list_head *tail;
 
  public:
-  PT_start_option_value_list_no_type(PT_option_value_no_option_type *head_arg,
+  PT_start_option_value_list_no_type(const POS &pos,
+                                     PT_option_value_no_option_type *head_arg,
                                      const POS &head_pos_arg,
                                      PT_option_value_list_head *tail_arg)
-      : head(head_arg), head_pos(head_pos_arg), tail(tail_arg) {}
+      : super(pos), head(head_arg), head_pos(head_pos_arg), tail(tail_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -1020,12 +1073,13 @@ class PT_start_option_value_list_no_type : public PT_start_option_value_list {
 class PT_transaction_characteristic : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   const char *name;
   int32 value;
 
  public:
-  PT_transaction_characteristic(const char *name_arg, int32 value_arg)
-      : name(name_arg), value(value_arg) {}
+  PT_transaction_characteristic(const POS &pos, const char *name_arg,
+                                int32 value_arg)
+      : super(pos), name(name_arg), value(value_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -1033,32 +1087,33 @@ class PT_transaction_characteristic : public Parse_tree_node {
 class PT_transaction_access_mode : public PT_transaction_characteristic {
   typedef PT_transaction_characteristic super;
 
  public:
-  explicit PT_transaction_access_mode(bool is_read_only)
-      : super("transaction_read_only", (int32)is_read_only) {}
+  explicit PT_transaction_access_mode(const POS &pos, bool is_read_only)
+      : super(pos, "transaction_read_only", (int32)is_read_only) {}
 };
 
 class PT_isolation_level : public PT_transaction_characteristic {
   typedef PT_transaction_characteristic super;
 
  public:
-  explicit PT_isolation_level(enum_tx_isolation level)
-      : super("transaction_isolation", (int32)level) {}
+  explicit PT_isolation_level(const POS &pos, enum_tx_isolation level)
+      : super(pos, "transaction_isolation", (int32)level) {}
 };
 
 class PT_transaction_characteristics : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   PT_transaction_characteristic *head;
   PT_transaction_characteristic *opt_tail;
 
  public:
-  PT_transaction_characteristics(PT_transaction_characteristic *head_arg,
+  PT_transaction_characteristics(const POS &pos,
+                                 PT_transaction_characteristic *head_arg,
                                  PT_transaction_characteristic *opt_tail_arg)
-      : head(head_arg), opt_tail(opt_tail_arg) {}
+      : super(pos), head(head_arg), opt_tail(opt_tail_arg) {}
 
   bool do_contextualize(Parse_context *pc) override {
     return (super::do_contextualize(pc) || head->contextualize(pc) ||
             (opt_tail != nullptr && opt_tail->contextualize(pc)));
   }
 };
@@ -1066,35 +1121,44 @@ class PT_transaction_characteristics : public Parse_tree_node {
 class PT_start_option_value_list_transaction
     : public PT_start_option_value_list {
   typedef PT_start_option_value_list super;
 
   PT_transaction_characteristics *characteristics;
   POS end_pos;
 
  public:
   PT_start_option_value_list_transaction(
-      PT_transaction_characteristics *characteristics_arg,
+      const POS &pos, PT_transaction_characteristics *characteristics_arg,
       const POS &end_pos_arg)
-      : characteristics(characteristics_arg), end_pos(end_pos_arg) {}
+      : super(pos),
+        characteristics(characteristics_arg),
+        end_pos(end_pos_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
 
 class PT_start_option_value_list_following_option_type
-    : public Parse_tree_node {};
+    : public Parse_tree_node {
+ protected:
+  explicit PT_start_option_value_list_following_option_type(const POS &pos)
+      : Parse_tree_node(pos) {}
+};
 
 class PT_start_option_value_list_following_option_type_eq
     : public PT_start_option_value_list_following_option_type {
   typedef PT_start_option_value_list_following_option_type super;
 
   PT_set_scoped_system_variable *head;
   POS head_pos;
   PT_option_value_list_head *opt_tail;
 
  public:
   PT_start_option_value_list_following_option_type_eq(
-      PT_set_scoped_system_variable *head_arg, const POS &head_pos_arg,
-      PT_option_value_list_head *opt_tail_arg)
-      : head(head_arg), head_pos(head_pos_arg), opt_tail(opt_tail_arg) {}
+      const POS &pos, PT_set_scoped_system_variable *head_arg,
+      const POS &head_pos_arg, PT_option_value_list_head *opt_tail_arg)
+      : super(pos),
+        head(head_arg),
+        head_pos(head_pos_arg),
+        opt_tail(opt_tail_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -1102,16 +1166,17 @@ class PT_start_option_value_list_following_option_type_eq
 class PT_start_option_value_list_following_option_type_transaction
     : public PT_start_option_value_list_following_option_type {
   typedef PT_start_option_value_list_following_option_type super;
 
   PT_transaction_characteristics *characteristics;
   POS characteristics_pos;
 
  public:
   PT_start_option_value_list_following_option_type_transaction(
-      PT_transaction_characteristics *characteristics_arg,
+      const POS &pos, PT_transaction_characteristics *characteristics_arg,
       const POS &characteristics_pos_arg)
-      : characteristics(characteristics_arg),
+      : super(pos),
+        characteristics(characteristics_arg),
         characteristics_pos(characteristics_pos_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -1119,14 +1184,14 @@ class PT_start_option_value_list_following_option_type_transaction
 class PT_start_option_value_list_type : public PT_start_option_value_list {
   typedef PT_start_option_value_list super;
 
   enum_var_type type;
   PT_start_option_value_list_following_option_type *list;
 
  public:
   PT_start_option_value_list_type(
-      enum_var_type type_arg,
+      const POS &pos, enum_var_type type_arg,
       PT_start_option_value_list_following_option_type *list_arg)
-      : type(type_arg), list(list_arg) {}
+      : super(pos), type(type_arg), list(list_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -1134,23 +1199,23 @@ class PT_start_option_value_list_type : public PT_start_option_value_list {
 class PT_set : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   POS set_pos;
   PT_start_option_value_list *list;
 
  public:
-  PT_set(const POS &set_pos_arg, PT_start_option_value_list *list_arg)
-      : set_pos(set_pos_arg), list(list_arg) {}
+  PT_set(const POS &pos, const POS &set_pos_arg,
+         PT_start_option_value_list *list_arg)
+      : super(pos), set_pos(set_pos_arg), list(list_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
 
 class PT_into_destination : public Parse_tree_node {
   typedef Parse_tree_node super;
-  POS m_pos;
 
  protected:
-  PT_into_destination(const POS &pos) : m_pos(pos) {}
+  explicit PT_into_destination(const POS &pos) : super(pos) {}
 
  public:
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -1191,12 +1256,13 @@ class PT_into_destination_dumpfile final : public PT_into_destination {
 class PT_select_var : public Parse_tree_node {
  public:
   const LEX_STRING name;
 
-  explicit PT_select_var(const LEX_STRING &name_arg) : name(name_arg) {}
+  explicit PT_select_var(const POS &pos, const LEX_STRING &name_arg)
+      : Parse_tree_node(pos), name(name_arg) {}
 
   virtual bool is_local() const { return false; }
   virtual uint get_offset() const {
     assert(0);
     return 0;
   }
 };
@@ -1204,21 +1270,22 @@ class PT_select_var : public Parse_tree_node {
 class PT_select_sp_var : public PT_select_var {
   typedef PT_select_var super;
 
-  uint offset;
+  uint offset = 0;
 
 #ifndef NDEBUG
   /*
     Routine to which this Item_splocal belongs. Used for checking if correct
     runtime context is used for variable handling.
   */
-  sp_head *sp;
+  sp_head *sp = nullptr;
 #endif
 
  public:
-  PT_select_sp_var(const LEX_STRING &name_arg) : super(name_arg) {}
+  PT_select_sp_var(const POS &pos, const LEX_STRING &name_arg)
+      : super(pos, name_arg) {}
 
   bool is_local() const override { return true; }
   uint get_offset() const override { return offset; }
 
   bool do_contextualize(Parse_context *pc) override;
 };
@@ -1239,187 +1306,203 @@ class PT_select_var_list : public PT_into_destination {
 /**
   Parse tree node for a single of a window extent's borders,
   cf. \<window frame extent\> in SQL 2003.
 */
 class PT_border : public Parse_tree_node {
   friend class Window;
   Item *m_value{nullptr};  ///< only relevant iff m_border_type == WBT_VALUE_*
  public:
   enum_window_border_type m_border_type;
   const bool m_date_time;
-  interval_type m_int_type;
+  interval_type m_int_type = INTERVAL_LAST;  // clang-tidy needs initialization.
 
   ///< For unbounded border
-  PT_border(enum_window_border_type type)
-      : m_border_type(type), m_date_time(false) {
+  PT_border(const POS &pos, enum_window_border_type type)
+      : Parse_tree_node(pos), m_border_type(type), m_date_time(false) {
     assert(type != WBT_VALUE_PRECEDING && type != WBT_VALUE_FOLLOWING);
   }
 
   ///< For bounded non-temporal border, e.g. 2 PRECEDING: 'value' is 2.
-  PT_border(enum_window_border_type type, Item *value)
-      : m_value(value), m_border_type(type), m_date_time(false) {}
+  PT_border(const POS &pos, enum_window_border_type type, Item *value)
+      : Parse_tree_node(pos),
+        m_value(value),
+        m_border_type(type),
+        m_date_time(false) {}
 
   ///< For bounded INTERVAL 2 DAYS, 'value' is 2, int_type is DAYS.
-  PT_border(enum_window_border_type type, Item *value, interval_type int_type)
-      : m_value(value),
+  PT_border(const POS &pos, enum_window_border_type type, Item *value,
+            interval_type int_type)
+      : Parse_tree_node(pos),
+        m_value(value),
         m_border_type(type),
         m_date_time(true),
         m_int_type(int_type) {}
 
   ///< @returns the '2' in '2 PRECEDING' or 'INTERVAL 2 DAYS PRECEDING'
   Item *border() const { return m_value; }
   /// Need such low-level access so that fix_fields updates the right pointer
   Item **border_ptr() { return &m_value; }
 
   /**
     @returns Addition operator for computation of frames, nullptr if error.
     @param  order_expr  Expression to add to/subtract from
     @param  prec    true if PRECEDING
     @param  asc     true if ASC
     @param  window  only used for error generation
   */
   Item *build_addop(Item_cache *order_expr, bool prec, bool asc,
                     const Window *window);
 };
 
 /**
   Parse tree node for one or both of a window extent's borders, cf.
   \<window frame extent\> in SQL 2003.
 */
 class PT_borders : public Parse_tree_node {
-  PT_border *m_borders[2];
+  PT_border *m_borders[2]{};
   friend class PT_frame;
 
  public:
   /**
     Constructor.
 
     Frames of the form "frame_start no_frame_end" are translated during
     parsing to "BETWEEN frame_start AND CURRENT ROW". So both 'start' and
     'end' are non-nullptr.
   */
-  PT_borders(PT_border *start, PT_border *end) {
+  PT_borders(const POS &pos, PT_border *start, PT_border *end)
+      : Parse_tree_node(pos) {
     m_borders[0] = start;
     m_borders[1] = end;
   }
 };
 
 /**
   Parse tree node for a window frame's exclusions, cf. the
   \<window frame exclusion\> clause in SQL 2003.
 */
 class PT_exclusion : public Parse_tree_node {
   enum_window_frame_exclusion m_exclusion;
 
  public:
-  PT_exclusion(enum_window_frame_exclusion e) : m_exclusion(e) {}
+  PT_exclusion(const POS &pos, enum_window_frame_exclusion e)
+      : Parse_tree_node(pos), m_exclusion(e) {}
   // enum_window_frame_exclusion exclusion() { return m_exclusion; }
 };
 
 /**
   Parse tree node for a window's frame, cf. the \<window frame clause\>
   in SQL 2003.
 */
 class PT_frame : public Parse_tree_node {
  public:
   enum_window_frame_unit m_query_expression;
 
   PT_border *m_from;
   PT_border *m_to;
 
   PT_exclusion *m_exclusion;
 
   /// If true, this is an artificial frame, not specified by the user
   bool m_originally_absent = false;
 
-  PT_frame(enum_window_frame_unit unit, PT_borders *from_to,
+  PT_frame(const POS &pos, enum_window_frame_unit unit, PT_borders *from_to,
            PT_exclusion *exclusion)
-      : m_query_expression(unit),
+      : Parse_tree_node(pos),
+        m_query_expression(unit),
         m_from(from_to->m_borders[0]),
         m_to(from_to->m_borders[1]),
         m_exclusion(exclusion) {}
 };
 
-class PT_query_primary : public PT_query_expression_body {};
+class PT_query_primary : public PT_query_expression_body {
+ protected:
+  explicit PT_query_primary(const POS &pos) : PT_query_expression_body(pos) {}
+};
 
 class PT_query_specification : public PT_query_primary {
   typedef PT_query_primary super;
 
   PT_hint_list *opt_hints;
   Query_options options;
   PT_item_list *item_list;
   PT_into_destination *opt_into1;
   const bool m_is_from_clause_implicit;
   Mem_root_array_YY<PT_table_reference *> from_clause;  // empty list for DUAL
   Item *opt_where_clause;
   PT_group *opt_group_clause;
   Item *opt_having_clause;
   PT_window_list *opt_window_clause;
 
  public:
   PT_query_specification(
-      PT_hint_list *opt_hints_arg, const Query_options &options_arg,
-      PT_item_list *item_list_arg, PT_into_destination *opt_into1_arg,
+      const POS &pos, PT_hint_list *opt_hints_arg,
+      const Query_options &options_arg, PT_item_list *item_list_arg,
+      PT_into_destination *opt_into1_arg,
       const Mem_root_array_YY<PT_table_reference *> &from_clause_arg,
       Item *opt_where_clause_arg, PT_group *opt_group_clause_arg,
       Item *opt_having_clause_arg, PT_window_list *opt_window_clause_arg,
       bool implicit_from_clause)
-      : opt_hints(opt_hints_arg),
+      : super(pos),
+        opt_hints(opt_hints_arg),
         options(options_arg),
         item_list(item_list_arg),
         opt_into1(opt_into1_arg),
         m_is_from_clause_implicit{implicit_from_clause},
         from_clause(from_clause_arg),
         opt_where_clause(opt_where_clause_arg),
         opt_group_clause(opt_group_clause_arg),
         opt_having_clause(opt_having_clause_arg),
         opt_window_clause(opt_window_clause_arg) {
     assert(implicit_from_clause ? from_clause.empty() : true);
   }
 
   PT_query_specification(
-      const Query_options &options_arg, PT_item_list *item_list_arg,
+      const POS &pos, const Query_options &options_arg,
+      PT_item_list *item_list_arg,
       const Mem_root_array_YY<PT_table_reference *> &from_clause_arg,
       Item *opt_where_clause_arg)
-      : opt_hints(nullptr),
+      : super(pos),
+        opt_hints(nullptr),
         options(options_arg),
         item_list(item_list_arg),
         opt_into1(nullptr),
         m_is_from_clause_implicit{true},
         from_clause(from_clause_arg),
         opt_where_clause(opt_where_clause_arg),
         opt_group_clause(nullptr),
         opt_having_clause(nullptr),
         opt_window_clause(nullptr) {}
 
-  PT_query_specification(const Query_options &options_arg,
+  PT_query_specification(const POS &pos, const Query_options &options_arg,
                          PT_item_list *item_list_arg)
-      : opt_hints(nullptr),
+      : super(pos),
+        opt_hints(nullptr),
         options(options_arg),
         item_list(item_list_arg),
         opt_into1(nullptr),
         m_is_from_clause_implicit{false},
         from_clause{},
         opt_where_clause(nullptr),
         opt_group_clause(nullptr),
         opt_having_clause(nullptr),
         opt_window_clause(nullptr) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
   bool has_into_clause() const override { return opt_into1 != nullptr; }
   bool has_trailing_into_clause() const override {
     return (has_into_clause() && is_implicit_from_clause() &&
             opt_where_clause == nullptr && opt_group_clause == nullptr &&
             opt_having_clause == nullptr && opt_window_clause == nullptr);
   }
 
   bool is_set_operation() const override { return false; }
 
   bool can_absorb_order_and_limit(bool, bool) const override { return true; }
 
   bool is_table_value_constructor() const override { return false; }
   PT_insert_values_list *get_row_value_list() const override { return nullptr; }
 
  private:
   bool is_implicit_from_clause() const { return m_is_from_clause_implicit; }
 };
@@ -1427,24 +1510,25 @@ class PT_query_specification : public PT_query_primary {
 class PT_table_value_constructor : public PT_query_primary {
   typedef PT_query_primary super;
 
   PT_insert_values_list *const row_value_list;
 
  public:
-  explicit PT_table_value_constructor(PT_insert_values_list *row_value_list_arg)
-      : row_value_list(row_value_list_arg) {}
+  explicit PT_table_value_constructor(const POS &pos,
+                                      PT_insert_values_list *row_value_list_arg)
+      : super(pos), row_value_list(row_value_list_arg) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
   bool has_into_clause() const override { return false; }
   bool has_trailing_into_clause() const override { return false; }
 
   bool is_set_operation() const override { return false; }
 
   bool can_absorb_order_and_limit(bool, bool) const override { return true; }
 
   bool is_table_value_constructor() const override { return true; }
 
   PT_insert_values_list *get_row_value_list() const override {
     return row_value_list;
   }
 };
@@ -1452,154 +1536,158 @@ class PT_table_value_constructor : public PT_query_primary {
 class PT_explicit_table : public PT_query_specification {
   using super = PT_query_specification;
 
  public:
   PT_explicit_table(
-      const Query_options &options_arg, PT_item_list *item_list_arg,
+      const POS &pos, const Query_options &options_arg,
+      PT_item_list *item_list_arg,
       const Mem_root_array_YY<PT_table_reference *> &from_clause_arg)
-      : super(options_arg, item_list_arg, from_clause_arg, nullptr) {}
+      : super(pos, options_arg, item_list_arg, from_clause_arg, nullptr) {}
 };
 
 class PT_query_expression final : public PT_query_expression_body {
  public:
-  PT_query_expression(PT_with_clause *with_clause,
+  PT_query_expression(const POS &pos, PT_with_clause *with_clause,
                       PT_query_expression_body *body, PT_order *order,
                       PT_limit_clause *limit)
-      : m_body(body),
+      : PT_query_expression_body(pos),
+        m_body(body),
         m_order(order),
         m_limit(limit),
         m_with_clause(with_clause) {}
 
-  PT_query_expression(PT_query_expression_body *body, PT_order *order,
-                      PT_limit_clause *limit)
-      : PT_query_expression(nullptr, body, order, limit) {}
+  PT_query_expression(const POS &pos, PT_query_expression_body *body,
+                      PT_order *order, PT_limit_clause *limit)
+      : PT_query_expression(pos, nullptr, body, order, limit) {}
 
-  explicit PT_query_expression(PT_query_expression_body *body)
-      : PT_query_expression(body, nullptr, nullptr) {}
+  explicit PT_query_expression(const POS &pos, PT_query_expression_body *body)
+      : PT_query_expression(pos, body, nullptr, nullptr) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
   bool is_set_operation() const override { return m_body->is_set_operation(); }
 
   bool has_into_clause() const override { return m_body->has_into_clause(); }
   bool has_trailing_into_clause() const override {
     return (m_body->has_trailing_into_clause() && m_order == nullptr &&
             m_limit == nullptr);
   }
 
   bool can_absorb_order_and_limit(bool order, bool limit) const override {
     if (m_body->is_set_operation()) {
       return false;
     }
     if (m_order == nullptr && m_limit == nullptr) {
       /*
         It is safe to push ORDER and/or LIMIT down in:
 
           (SELECT ...<no order or limit clauses>) ORDER BY ... LIMIT ...;
           (SELECT ...<no order or limit clauses>) ORDER BY ...;
           (SELECT ...<no order or limit clauses>)              LIMIT ...;
       */
       return true;
     }
     if (m_limit != nullptr && !order && limit) {
       /*
         In MySQL, it is ok(*) to push LIMIT down in:
 
           (SELECT ... [ORDER BY ...] LIMIT a) LIMIT b;
 
         *) MySQL doesn't follow the standard when overwriting `LIMIT a` with
            `LIMIT b` if a < b.  Moreover, the result of:
 
              (SELECT ... ORDER BY order1 LIMIT a) ORDER BY order1 LIMIT b; (1)
 
            can diverge from:
 
              (SELECT ... ORDER BY order1 LIMIT a) LIMIT b;                  (2)
 
            since the example (1) never overwrites `LIMIT a` with `LIMIT b`,
            while the example (2) does overwrite.
 
            TODO: add a warning, deprecate and replace this behavior with the
                  standard one.
       */
       return true;
     }
     if (m_order != nullptr && m_limit == nullptr && !order && limit) {
       /*
         Allow pushdown of LIMIT into body with ORDER BY, e.g
 
           (SELECT ... ORDER BY order1) LIMIT a;
       */
       return true;
     }
     return false;
   }
 
   bool is_table_value_constructor() const override {
     return m_body->is_table_value_constructor();
   }
 
   PT_insert_values_list *get_row_value_list() const override {
     return m_body->get_row_value_list();
   }
 
  private:
   /**
     Contextualizes the order and limit clauses, re-interpreting them according
     to the rules. If the `<query expression body>` can absorb the clauses,
     they are simply contextualized into the current Query_block. If not, we
     have to create the "fake" Query_block unless there is one already
     (Query_expression::new_set_operation_query() is known to do this.)
 
     @see PT_query_expression::can_absorb_order_and_limit()
   */
   bool contextualize_order_and_limit(Parse_context *pc);
 
   PT_query_expression_body *m_body;
   PT_order *m_order;
   PT_limit_clause *m_limit;
   PT_with_clause *m_with_clause;
 };
 
 /*
   After the removal of the `... <locking_clause> <into_clause>` syntax
   PT_locking will disappear.
 */
 class PT_locking final : public PT_query_expression_body {
   using super = PT_query_expression_body;
 
  public:
-  PT_locking(PT_query_expression_body *qe,
+  PT_locking(const POS &pos, PT_query_expression_body *qe,
              PT_locking_clause_list *locking_clauses)
-      : m_query_expression{qe}, m_locking_clauses{locking_clauses} {}
+      : super(pos),
+        m_query_expression{qe},
+        m_locking_clauses{locking_clauses} {}
 
   bool do_contextualize(Parse_context *pc) override {
     return (super::do_contextualize(pc) ||
             m_query_expression->contextualize(pc) ||
             m_locking_clauses->contextualize(pc));
   }
 
   bool is_set_operation() const override {
     return m_query_expression->is_set_operation();
   }
 
   bool has_into_clause() const override {
     return m_query_expression->has_into_clause();
   }
   bool has_trailing_into_clause() const override { return false; }
 
   bool can_absorb_order_and_limit(bool order, bool limit) const override {
     return m_query_expression->can_absorb_order_and_limit(order, limit);
   }
 
   bool is_table_value_constructor() const override {
     return m_query_expression->is_table_value_constructor();
   }
 
   PT_insert_values_list *get_row_value_list() const override {
     return m_query_expression->get_row_value_list();
   }
 
  private:
   PT_query_expression_body *const m_query_expression;
   PT_locking_clause_list *const m_locking_clauses;
 };
@@ -1607,20 +1695,19 @@ class PT_locking final : public PT_query_expression_body {
 class PT_subquery : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   PT_query_expression_body *qe;
-  POS pos;
   Query_block *query_block;
 
  public:
   bool m_is_derived_table;
 
-  PT_subquery(POS p, PT_query_expression_body *query_expression)
-      : qe(query_expression),
-        pos(p),
+  PT_subquery(const POS &pos, PT_query_expression_body *query_expression)
+      : super(pos),
+        qe(query_expression),
         query_block(nullptr),
         m_is_derived_table(false) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
   Query_block *value() { return query_block; }
 };
@@ -1628,38 +1715,39 @@ class PT_subquery : public Parse_tree_node {
 class PT_set_operation : public PT_query_expression_body {
   using super = PT_query_expression_body;
 
  public:
-  PT_set_operation(PT_query_expression_body *lhs, bool is_distinct,
-                   PT_query_expression_body *rhs,
+  PT_set_operation(const POS &pos, PT_query_expression_body *lhs,
+                   bool is_distinct, PT_query_expression_body *rhs,
                    bool is_rhs_in_parentheses = false)
-      : m_lhs(lhs),
+      : super(pos),
+        m_lhs(lhs),
         m_is_distinct(is_distinct),
         m_rhs(rhs),
         m_is_rhs_in_parentheses{is_rhs_in_parentheses} {}
 
   void merge_descendants(Parse_context *pc, Query_term_set_op *setop,
                          QueryLevel &ql);
   bool is_set_operation() const override { return true; }
 
   bool has_into_clause() const override {
     return m_lhs->has_into_clause() || m_rhs->has_into_clause();
   }
   bool has_trailing_into_clause() const override {
     return !m_is_rhs_in_parentheses && m_rhs->has_trailing_into_clause();
   }
 
   bool can_absorb_order_and_limit(bool, bool) const override { return false; }
 
   bool is_table_value_constructor() const override { return false; }
   PT_insert_values_list *get_row_value_list() const override { return nullptr; }
 
  protected:
   bool contextualize_setop(Parse_context *pc, Query_term_type setop_type,
                            Surrounding_context context);
   PT_query_expression_body *m_lhs;
   bool m_is_distinct;
   PT_query_expression_body *m_rhs;
-  PT_into_destination *m_into;
+  PT_into_destination *m_into{nullptr};
   const bool m_is_rhs_in_parentheses;
 };
 
@@ -1690,146 +1778,161 @@ class PT_intersect : public PT_set_operation {
 class PT_select_stmt : public Parse_tree_root {
   typedef Parse_tree_root super;
 
  public:
   /**
+    @param pos Position of this clause in the SQL statement.
     @param qe The query expression.
     @param sql_command The type of SQL command.
   */
-  PT_select_stmt(enum_sql_command sql_command, PT_query_expression_body *qe)
-      : m_sql_command(sql_command),
+  PT_select_stmt(const POS &pos, enum_sql_command sql_command,
+                 PT_query_expression_body *qe)
+      : super(pos),
+        m_sql_command(sql_command),
         m_qe(qe),
         m_into(nullptr),
         m_has_trailing_locking_clauses{false} {}
 
   /**
     Creates a SELECT command. Only SELECT commands can have into.
 
+    @param pos                          Position of this clause in the SQL
+                                        statement.
     @param qe                           The query expression.
     @param into                         The own INTO destination.
     @param has_trailing_locking_clauses True if there are locking clauses (like
                                         `FOR UPDATE`) at the end of the
                                         statement.
   */
-  explicit PT_select_stmt(PT_query_expression_body *qe,
+  explicit PT_select_stmt(const POS &pos, PT_query_expression_body *qe,
                           PT_into_destination *into = nullptr,
                           bool has_trailing_locking_clauses = false)
-      : m_sql_command{SQLCOM_SELECT},
+      : super(pos),
+        m_sql_command{SQLCOM_SELECT},
         m_qe{qe},
         m_into{into},
         m_has_trailing_locking_clauses{has_trailing_locking_clauses} {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   enum_sql_command m_sql_command;
   PT_query_expression_body *m_qe;
   PT_into_destination *m_into;
   const bool m_has_trailing_locking_clauses;
 };
 
 /**
   Top-level node for the DELETE statement
 
   @ingroup ptn_stmt
 */
 class PT_delete final : public Parse_tree_root {
+  typedef Parse_tree_root super;
+
  private:
   PT_with_clause *m_with_clause;
   PT_hint_list *opt_hints;
   const int opt_delete_options;
   Table_ident *table_ident;
   const char *const opt_table_alias;
-  Mem_root_array_YY<Table_ident *> table_list;
+  Mem_root_array_YY<Table_ident *> table_list{};
   List<String> *opt_use_partition;
-  Mem_root_array_YY<PT_table_reference *> join_table_list;
+  Mem_root_array_YY<PT_table_reference *> join_table_list{};
   Item *opt_where_clause;
   PT_order *opt_order_clause;
   Item *opt_delete_limit_clause;
   SQL_I_List<Table_ref> delete_tables;
 
  public:
   // single-table DELETE node constructor:
-  PT_delete(PT_with_clause *with_clause_arg, PT_hint_list *opt_hints_arg,
-            int opt_delete_options_arg, Table_ident *table_ident_arg,
+  PT_delete(const POS &pos, PT_with_clause *with_clause_arg,
+            PT_hint_list *opt_hints_arg, int opt_delete_options_arg,
+            Table_ident *table_ident_arg,
             const LEX_CSTRING &opt_table_alias_arg,
             List<String> *opt_use_partition_arg, Item *opt_where_clause_arg,
             PT_order *opt_order_clause_arg, Item *opt_delete_limit_clause_arg)
-      : m_with_clause(with_clause_arg),
+      : super(pos),
+        m_with_clause(with_clause_arg),
         opt_hints(opt_hints_arg),
         opt_delete_options(opt_delete_options_arg),
         table_ident(table_ident_arg),
         opt_table_alias(opt_table_alias_arg.str),
         opt_use_partition(opt_use_partition_arg),
         opt_where_clause(opt_where_clause_arg),
         opt_order_clause(opt_order_clause_arg),
         opt_delete_limit_clause(opt_delete_limit_clause_arg) {
     table_list.init_empty_const();
     join_table_list.init_empty_const();
   }
 
   // multi-table DELETE node constructor:
-  PT_delete(PT_with_clause *with_clause_arg, PT_hint_list *opt_hints_arg,
-            int opt_delete_options_arg,
+  PT_delete(const POS &pos, PT_with_clause *with_clause_arg,
+            PT_hint_list *opt_hints_arg, int opt_delete_options_arg,
             const Mem_root_array_YY<Table_ident *> &table_list_arg,
             const Mem_root_array_YY<PT_table_reference *> &join_table_list_arg,
             Item *opt_where_clause_arg)
-      : m_with_clause(with_clause_arg),
+      : super(pos),
+        m_with_clause(with_clause_arg),
         opt_hints(opt_hints_arg),
         opt_delete_options(opt_delete_options_arg),
         table_ident(nullptr),
         opt_table_alias(nullptr),
         table_list(table_list_arg),
         opt_use_partition(nullptr),
         join_table_list(join_table_list_arg),
         opt_where_clause(opt_where_clause_arg),
         opt_order_clause(nullptr),
         opt_delete_limit_clause(nullptr) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   bool is_multitable() const {
     assert((table_ident != nullptr) ^ (table_list.size() > 0));
     return table_ident == nullptr;
   }
 
   bool add_table(Parse_context *pc, Table_ident *table);
 };
 
 /**
   Top-level node for the UPDATE statement
 
   @ingroup ptn_stmt
 */
 class PT_update : public Parse_tree_root {
+  typedef Parse_tree_root super;
+
   PT_with_clause *m_with_clause;
   PT_hint_list *opt_hints;
   thr_lock_type opt_low_priority;
   bool opt_ignore;
   Mem_root_array_YY<PT_table_reference *> join_table_list;
   PT_item_list *column_list;
   PT_item_list *value_list;
   Item *opt_where_clause;
   PT_order *opt_order_clause;
   Item *opt_limit_clause;
 
  public:
-  PT_update(PT_with_clause *with_clause_arg, PT_hint_list *opt_hints_arg,
-            thr_lock_type opt_low_priority_arg, bool opt_ignore_arg,
+  PT_update(const POS &pos, PT_with_clause *with_clause_arg,
+            PT_hint_list *opt_hints_arg, thr_lock_type opt_low_priority_arg,
+            bool opt_ignore_arg,
             const Mem_root_array_YY<PT_table_reference *> &join_table_list_arg,
             PT_item_list *column_list_arg, PT_item_list *value_list_arg,
             Item *opt_where_clause_arg, PT_order *opt_order_clause_arg,
             Item *opt_limit_clause_arg)
-      : m_with_clause(with_clause_arg),
+      : super(pos),
+        m_with_clause(with_clause_arg),
         opt_hints(opt_hints_arg),
         opt_low_priority(opt_low_priority_arg),
         opt_ignore(opt_ignore_arg),
         join_table_list(join_table_list_arg),
         column_list(column_list_arg),
         value_list(value_list_arg),
         opt_where_clause(opt_where_clause_arg),
         opt_order_clause(opt_order_clause_arg),
         opt_limit_clause(opt_limit_clause_arg) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
@@ -1837,83 +1940,87 @@ class PT_update : public Parse_tree_root {
 class PT_insert_values_list : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   mem_root_deque<List_item *> many_values;
 
  public:
-  explicit PT_insert_values_list(MEM_ROOT *mem_root) : many_values(mem_root) {}
+  explicit PT_insert_values_list(const POS &pos, MEM_ROOT *mem_root)
+      : super(pos), many_values(mem_root) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
   bool push_back(mem_root_deque<Item *> *x) {
     many_values.push_back(x);
     return false;
   }
 
   virtual mem_root_deque<List_item *> &get_many_values() {
     assert(is_contextualized());
     return many_values;
   }
 };
 
 /**
   Top-level node for the INSERT statement
 
   @ingroup ptn_stmt
 */
 class PT_insert final : public Parse_tree_root {
+  typedef Parse_tree_root super;
+
   const bool is_replace;
   PT_hint_list *opt_hints;
   const thr_lock_type lock_option;
   const bool ignore;
   Table_ident *const table_ident;
   List<String> *const opt_use_partition;
   PT_item_list *const column_list;
   PT_insert_values_list *row_value_list;
   PT_query_expression_body *insert_query_expression;
   const char *const opt_values_table_alias;
   Create_col_name_list *const opt_values_column_list;
   PT_item_list *const opt_on_duplicate_column_list;
   PT_item_list *const opt_on_duplicate_value_list;
 
  public:
-  PT_insert(bool is_replace_arg, PT_hint_list *opt_hints_arg,
+  PT_insert(const POS &pos, bool is_replace_arg, PT_hint_list *opt_hints_arg,
             thr_lock_type lock_option_arg, bool ignore_arg,
             Table_ident *table_ident_arg, List<String> *opt_use_partition_arg,
             PT_item_list *column_list_arg,
             PT_insert_values_list *row_value_list_arg,
             PT_query_expression_body *insert_query_expression_arg,
             const LEX_CSTRING &opt_values_table_alias_arg,
             Create_col_name_list *opt_values_column_list_arg,
             PT_item_list *opt_on_duplicate_column_list_arg,
             PT_item_list *opt_on_duplicate_value_list_arg)
-      : is_replace(is_replace_arg),
+      : super(pos),
+        is_replace(is_replace_arg),
         opt_hints(opt_hints_arg),
         lock_option(lock_option_arg),
         ignore(ignore_arg),
         table_ident(table_ident_arg),
         opt_use_partition(opt_use_partition_arg),
         column_list(column_list_arg),
         row_value_list(row_value_list_arg),
         insert_query_expression(insert_query_expression_arg),
         opt_values_table_alias(opt_values_table_alias_arg.str),
         opt_values_column_list(opt_values_column_list_arg),
         opt_on_duplicate_column_list(opt_on_duplicate_column_list_arg),
         opt_on_duplicate_value_list(opt_on_duplicate_value_list_arg) {
     // REPLACE statement can't have IGNORE flag:
     assert(!is_replace || !ignore);
     // REPLACE statement can't have ON DUPLICATE KEY UPDATE clause:
     assert(!is_replace || opt_on_duplicate_column_list == nullptr);
     // INSERT/REPLACE ... SELECT can't have VALUES clause:
     assert((row_value_list != nullptr) ^ (insert_query_expression != nullptr));
     // ON DUPLICATE KEY UPDATE: column and value arrays must have same sizes:
     assert((opt_on_duplicate_column_list == nullptr &&
             opt_on_duplicate_value_list == nullptr) ||
            (opt_on_duplicate_column_list->elements() ==
             opt_on_duplicate_value_list->elements()));
   }
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   bool has_query_block() const { return insert_query_expression != nullptr; }
 };
@@ -1921,16 +2028,19 @@ class PT_insert final : public Parse_tree_root {
 class PT_call final : public Parse_tree_root {
   sp_name *proc_name;
   PT_item_list *opt_expr_list;
 
  public:
-  PT_call(sp_name *proc_name_arg, PT_item_list *opt_expr_list_arg)
-      : proc_name(proc_name_arg), opt_expr_list(opt_expr_list_arg) {}
+  PT_call(const POS &pos, sp_name *proc_name_arg,
+          PT_item_list *opt_expr_list_arg)
+      : Parse_tree_root(pos),
+        proc_name(proc_name_arg),
+        opt_expr_list(opt_expr_list_arg) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 /**
   Top-level node for the SHUTDOWN statement
 
   @ingroup ptn_stmt
 */
@@ -1947,230 +2057,238 @@ class PT_shutdown final : public Parse_tree_root {
   @ingroup ptn_stmt
 */
 class PT_create_srs final : public Parse_tree_root {
   /// The SQL command object.
   Sql_cmd_create_srs sql_cmd;
   /// Whether OR REPLACE is specified.
   bool m_or_replace;
   /// Whether IF NOT EXISTS is specified.
   bool m_if_not_exists;
   /// SRID of the SRS to create.
   ///
   /// The range is larger than that of gis::srid_t, so it must be
   /// verified to be less than the uint32 maximum value.
   unsigned long long m_srid;
   /// All attributes except SRID.
   const Sql_cmd_srs_attributes m_attributes;
 
   /// Check if a UTF-8 string contains control characters.
   ///
   /// @note This function only checks single byte control characters (U+0000 to
   /// U+001F, and U+007F). There are some control characters at U+0080 to U+00A0
   /// that are not detected by this function.
   ///
   /// @param str The string.
   /// @param length Length of the string.
   ///
   /// @retval false The string contains no control characters.
   /// @retval true The string contains at least one control character.
   bool contains_control_char(char *str, size_t length) {
     for (size_t pos = 0; pos < length; pos++) {
       if (std::iscntrl(str[pos])) return true;
     }
     return false;
   }
 
  public:
-  PT_create_srs(unsigned long long srid,
+  PT_create_srs(const POS &pos, unsigned long long srid,
                 const Sql_cmd_srs_attributes &attributes, bool or_replace,
                 bool if_not_exists)
-      : m_or_replace(or_replace),
+      : Parse_tree_root(pos),
+        m_or_replace(or_replace),
         m_if_not_exists(if_not_exists),
         m_srid(srid),
         m_attributes(attributes) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 /**
   Top-level node for the DROP SPATIAL REFERENCE SYSTEM statement.
 
   @ingroup ptn_stmt
 */
 class PT_drop_srs final : public Parse_tree_root {
   /// The SQL command object.
   Sql_cmd_drop_srs sql_cmd;
   /// SRID of the SRS to drop.
   ///
   /// The range is larger than that of gis::srid_t, so it must be
   /// verified to be less than the uint32 maximum value.
   unsigned long long m_srid;
 
  public:
-  PT_drop_srs(unsigned long long srid, bool if_exists)
-      : sql_cmd(srid, if_exists), m_srid(srid) {}
+  PT_drop_srs(const POS &pos, unsigned long long srid, bool if_exists)
+      : Parse_tree_root(pos), sql_cmd(srid, if_exists), m_srid(srid) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 /**
   Top-level node for the ALTER INSTANCE statement
 
   @ingroup ptn_stmt
 */
 class PT_alter_instance final : public Parse_tree_root {
   Sql_cmd_alter_instance sql_cmd;
 
  public:
   explicit PT_alter_instance(
-      enum alter_instance_action_enum alter_instance_action,
+      const POS &pos, enum alter_instance_action_enum alter_instance_action,
       const LEX_CSTRING &channel)
-      : sql_cmd(alter_instance_action, channel) {}
+      : Parse_tree_root(pos), sql_cmd(alter_instance_action, channel) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 /**
   A template-free base class for index options that we can predeclare in
   sql_lex.h
 */
-class PT_base_index_option : public Table_ddl_node {};
+class PT_base_index_option : public Table_ddl_node {
+ protected:
+  explicit PT_base_index_option(const POS &pos) : Table_ddl_node(pos) {}
+};
 
 /**
   A key part specification.
 
   This can either be a "normal" key part (a key part that points to a column),
   or this can be a functional key part (a key part that points to an
   expression).
 */
 class PT_key_part_specification : public Parse_tree_node {
   typedef Parse_tree_node super;
 
  public:
   /**
     Constructor for a functional key part.
 
+    @param pos Position of this clause in the SQL statement.
     @param expression The expression to index.
     @param order The direction of the index.
   */
-  PT_key_part_specification(Item *expression, enum_order order);
+  PT_key_part_specification(const POS &pos, Item *expression, enum_order order);
 
   /**
     Constructor for a "normal" key part. That is a key part that points to a
     column and not an expression.
 
+    @param pos Position of this clause in the SQL statement.
     @param column_name The column name that this key part points to.
     @param order The direction of the index.
     @param prefix_length How many bytes or characters this key part should
            index, or zero if it should index the entire column.
   */
-  PT_key_part_specification(const LEX_CSTRING &column_name, enum_order order,
-                            int prefix_length);
+  PT_key_part_specification(const POS &pos, const LEX_CSTRING &column_name,
+                            enum_order order, int prefix_length);
 
   /**
     Contextualize this key part specification. This will also call itemize on
     the indexed expression if this is a functional key part.
 
     @param pc The parse context
 
     @retval true on error
     @retval false on success
   */
   bool do_contextualize(Parse_context *pc) override;
 
   /**
     Get the indexed expression. The caller must ensure that has_expression()
     returns true before calling this.
 
     @returns The indexed expression
   */
   Item *get_expression() const {
     assert(has_expression());
     return m_expression;
   }
 
   /**
     @returns The direction of the index: ORDER_ASC, ORDER_DESC or
              ORDER_NOT_RELEVANT in case the user didn't explicitly specify a
              direction.
   */
   enum_order get_order() const { return m_order; }
 
   /**
     @retval true if the user explicitly specified a direction (asc/desc).
     @retval false if the user didn't explicitly specify a direction.
   */
   bool is_explicit() const { return get_order() != ORDER_NOT_RELEVANT; }
 
   /**
     @retval true if the key part contains an expression (and thus is a
             functional key part).
     @retval false if the key part doesn't contain an expression.
   */
   bool has_expression() const { return m_expression != nullptr; }
 
   /**
     Get the column that this key part points to. This is only valid if this
     key part isn't a functional index. The caller must thus check the return
     value of has_expression() before calling this function.
 
     @returns The column that this key part points to.
   */
   LEX_CSTRING get_column_name() const {
     assert(!has_expression());
     return m_column_name;
   }
 
   /**
     @returns The number of bytes that this key part should index. If the column
              this key part points to is a non-binary column, this is the number
              of characters. Returns zero if the entire column should be indexed.
   */
   int get_prefix_length() const { return m_prefix_length; }
 
  private:
   /**
     The indexed expression in case this is a functional key part. Only valid if
     has_expression() returns true.
   */
   Item *m_expression;
 
   /// The direction of the index.
   enum_order m_order;
 
   /// The name of the column that this key part indexes.
-  LEX_CSTRING m_column_name;
+  LEX_CSTRING m_column_name{};
 
   /**
     If this is greater than zero, it represents how many bytes of the column
     that is indexed. Note that for non-binary columns (VARCHAR, TEXT etc), this
     is the number of characters.
   */
-  int m_prefix_length;
+  int m_prefix_length = 0;
 };
 
 /**
   A template for options that set a single `<alter option>` value in
   thd->lex->key_create_info.
 
   @tparam Option_type The data type of the option.
   @tparam Property Pointer-to-member for the option of KEY_CREATE_INFO.
 */
 template <typename Option_type, Option_type KEY_CREATE_INFO::*Property>
 class PT_index_option : public PT_base_index_option {
  public:
+  /// @param pos Position of this clause in the SQL statement.
   /// @param option_value The value of the option.
-  PT_index_option(Option_type option_value) : m_option_value(option_value) {}
+  PT_index_option(const POS &pos, Option_type option_value)
+      : PT_base_index_option(pos), m_option_value(option_value) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     pc->key_create_info->*Property = m_option_value;
     return false;
   }
 
  private:
   Option_type m_option_value;
 };
 
 /**
   A template for options that set a single property in a KEY_CREATE_INFO, and
   also records if the option was explicitly set.
 */
@@ -2178,15 +2296,15 @@ template <typename Option_type, Option_type KEY_CREATE_INFO::*Property,
           bool KEY_CREATE_INFO::*Property_is_explicit>
 class PT_traceable_index_option : public PT_base_index_option {
  public:
-  PT_traceable_index_option(Option_type option_value)
-      : m_option_value(option_value) {}
+  PT_traceable_index_option(const POS &pos, Option_type option_value)
+      : PT_base_index_option(pos), m_option_value(option_value) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     pc->key_create_info->*Property = m_option_value;
     pc->key_create_info->*Property_is_explicit = true;
     return false;
   }
 
  private:
   Option_type m_option_value;
 };
@@ -2213,65 +2331,73 @@ typedef PT_traceable_index_option<ha_key_alg, &KEY_CREATE_INFO::algorithm,
 
 class PT_create_index_stmt final : public PT_table_ddl_stmt_base {
  public:
-  PT_create_index_stmt(MEM_ROOT *mem_root, keytype type_par,
+  PT_create_index_stmt(const POS &pos, MEM_ROOT *mem_root, keytype type_par,
                        const LEX_STRING &name_arg, PT_base_index_option *type,
                        Table_ident *table_ident,
                        List<PT_key_part_specification> *cols,
                        Index_options options,
                        Alter_info::enum_alter_table_algorithm algo,
                        Alter_info::enum_alter_table_lock lock)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_keytype(type_par),
         m_name(name_arg),
         m_type(type),
         m_table_ident(table_ident),
         m_columns(cols),
         m_options(options),
         m_algo(algo),
         m_lock(lock) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   keytype m_keytype;
   LEX_STRING m_name;
   PT_base_index_option *m_type;
   Table_ident *m_table_ident;
   List<PT_key_part_specification> *m_columns;
   Index_options m_options;
   const Alter_info::enum_alter_table_algorithm m_algo;
   const Alter_info::enum_alter_table_lock m_lock;
 };
 
 /**
   Base class for column/constraint definitions in CREATE %TABLE
 
   @ingroup ptn_create_table_stuff
 */
-class PT_table_element : public Table_ddl_node {};
+class PT_table_element : public Table_ddl_node {
+ protected:
+  explicit PT_table_element(const POS &pos) : Table_ddl_node(pos) {}
+};
 
-class PT_table_constraint_def : public PT_table_element {};
+class PT_table_constraint_def : public PT_table_element {
+ protected:
+  explicit PT_table_constraint_def(const POS &pos) : PT_table_element(pos) {}
+};
 
 class PT_inline_index_definition : public PT_table_constraint_def {
   typedef PT_table_constraint_def super;
 
  public:
-  PT_inline_index_definition(keytype type_par, const LEX_STRING &name_arg,
+  PT_inline_index_definition(const POS &pos, keytype type_par,
+                             const LEX_STRING &name_arg,
                              PT_base_index_option *type,
                              List<PT_key_part_specification> *cols,
                              Index_options options)
-      : m_keytype(type_par),
+      : super(pos),
+        m_keytype(type_par),
         m_name(name_arg),
         m_type(type),
         m_columns(cols),
         m_options(options) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   keytype m_keytype;
   const LEX_STRING m_name;
   PT_base_index_option *m_type;
   List<PT_key_part_specification> *m_columns;
   Index_options m_options;
 };
@@ -2279,44 +2405,48 @@ class PT_inline_index_definition : public PT_table_constraint_def {
 class PT_foreign_key_definition : public PT_table_constraint_def {
   typedef PT_table_constraint_def super;
 
  public:
-  PT_foreign_key_definition(const LEX_STRING &constraint_name,
+  PT_foreign_key_definition(const POS &pos, const LEX_STRING &constraint_name,
                             const LEX_STRING &key_name,
                             List<PT_key_part_specification> *columns,
                             Table_ident *referenced_table,
                             List<Key_part_spec> *ref_list,
                             fk_match_opt fk_match_option,
                             fk_option fk_update_opt, fk_option fk_delete_opt)
-      : m_constraint_name(constraint_name),
+      : super(pos),
+        m_constraint_name(constraint_name),
         m_key_name(key_name),
         m_columns(columns),
         m_referenced_table(referenced_table),
         m_ref_list(ref_list),
         m_fk_match_option(fk_match_option),
         m_fk_update_opt(fk_update_opt),
         m_fk_delete_opt(fk_delete_opt) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   const LEX_STRING m_constraint_name;
   const LEX_STRING m_key_name;
   List<PT_key_part_specification> *m_columns;
   Table_ident *m_referenced_table;
   List<Key_part_spec> *m_ref_list;
   fk_match_opt m_fk_match_option;
   fk_option m_fk_update_opt;
   fk_option m_fk_delete_opt;
 };
 
 /**
   Common base class for CREATE TABLE and ALTER TABLE option nodes
 
   @ingroup ptn_create_or_alter_table_options
 */
 class PT_ddl_table_option : public Table_ddl_node {
+ protected:
+  explicit PT_ddl_table_option(const POS &pos) : Table_ddl_node(pos) {}
+
  public:
   ~PT_ddl_table_option() override = 0;  // Force abstract class declaration
 
   virtual bool is_rename_table() const { return false; }
 };
@@ -2329,14 +2459,17 @@ inline PT_ddl_table_option::~PT_ddl_table_option() = default;
   @ingroup ptn_create_or_alter_table_options
 */
 class PT_create_table_option : public PT_ddl_table_option {
   typedef PT_ddl_table_option super;
 
+ protected:
+  explicit PT_create_table_option(const POS &pos) : super(pos) {}
+
  public:
   ~PT_create_table_option() override = 0;  // Force abstract class declaration
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
     pc->alter_info->flags |= Alter_info::ALTER_OPTIONS;
     return false;
   }
 };
@@ -2351,24 +2484,25 @@ template <typename Option_type, Option_type HA_CREATE_INFO::*Property,
           uint64_t Property_flag>
 class PT_traceable_create_table_option : public PT_create_table_option {
   typedef PT_create_table_option super;
 
   const Option_type value;
 
  public:
-  explicit PT_traceable_create_table_option(Option_type value) : value(value) {}
+  explicit PT_traceable_create_table_option(const POS &pos, Option_type value)
+      : super(pos), value(value) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
     pc->create_info->*Property = value;
     pc->create_info->used_fields |= Property_flag;
     return false;
   }
 };
 
 #define TYPE_AND_REF(x) decltype(x), &x
 
 /**
   Node for the @SQL{MAX_ROWS [=] @B{@<integer@>}} table option
 
   @ingroup ptn_create_or_alter_table_options
 */
@@ -2488,41 +2622,41 @@ template <ulong Property_flag, table_options_t Default, table_options_t Yes,
           table_options_t No>
 class PT_ternary_create_table_option : public PT_create_table_option {
   typedef PT_create_table_option super;
 
   const Ternary_option value;
 
  public:
-  explicit PT_ternary_create_table_option(Ternary_option value)
-      : value(value) {}
+  explicit PT_ternary_create_table_option(const POS &pos, Ternary_option value)
+      : super(pos), value(value) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
     pc->create_info->table_options &= ~(Yes | No);
     switch (value) {
       case Ternary_option::ON:
         pc->create_info->table_options |= Yes;
         break;
       case Ternary_option::OFF:
         pc->create_info->table_options |= No;
         break;
       case Ternary_option::DEFAULT:
         break;
       default:
         assert(false);
     }
     pc->create_info->used_fields |= Property_flag;
     return false;
   }
 };
 
 /**
   Node for the @SQL{PACK_KEYS [=] @B{1|0|DEFAULT}} table option
 
   @ingroup ptn_create_or_alter_table_options
 
   PACK_KEYS | Constructor parameter
   ----------|----------------------
   1         | Ternary_option::ON
   0         | Ternary_option::OFF
   DEFAULT   | Ternary_option::DEFAULT
 */
@@ -2557,27 +2691,28 @@ template <ulong Property_flag, table_options_t Yes, table_options_t No>
 class PT_bool_create_table_option : public PT_create_table_option {
   typedef PT_create_table_option super;
 
   const bool value;
 
  public:
-  explicit PT_bool_create_table_option(bool value) : value(value) {}
+  explicit PT_bool_create_table_option(const POS &pos, bool value)
+      : super(pos), value(value) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
     pc->create_info->table_options &= ~(Yes | No);
     pc->create_info->table_options |= value ? Yes : No;
     pc->create_info->used_fields |= Property_flag;
     return false;
   }
 };
 
 /**
   Node for the @SQL{CHECKSUM|TABLE_CHECKSUM [=] @B{0|@<not 0@>}} table option
 
   @ingroup ptn_create_or_alter_table_options
 
   TABLE_CHECKSUM | Constructor parameter
   ---------------|----------------------
   0              | false
   not 0          | true
 */
@@ -2608,89 +2743,97 @@ typedef PT_bool_create_table_option<HA_CREATE_USED_DELAY_KEY_WRITE,  // flag
   @ingroup ptn_create_or_alter_table_options
 */
 class PT_create_table_engine_option : public PT_create_table_option {
   typedef PT_create_table_option super;
 
   const LEX_CSTRING engine;
 
  public:
   /**
+    @param pos          Position of this clause in the SQL statement.
     @param engine       Storage engine name.
   */
-  explicit PT_create_table_engine_option(const LEX_CSTRING &engine)
-      : engine(engine) {}
+  explicit PT_create_table_engine_option(const POS &pos,
+                                         const LEX_CSTRING &engine)
+      : super(pos), engine(engine) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{SECONDARY_ENGINE [=] @B{@<identifier@>|@<string@>|NULL}}
   table option.
 
   @ingroup ptn_create_or_alter_table_options
 */
 class PT_create_table_secondary_engine_option : public PT_create_table_option {
   using super = PT_create_table_option;
 
  public:
-  explicit PT_create_table_secondary_engine_option() = default;
+  explicit PT_create_table_secondary_engine_option(const POS &pos)
+      : super(pos) {}
   explicit PT_create_table_secondary_engine_option(
-      const LEX_CSTRING &secondary_engine)
-      : m_secondary_engine(secondary_engine) {}
+      const POS &pos, const LEX_CSTRING &secondary_engine)
+      : super(pos), m_secondary_engine(secondary_engine) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   const LEX_CSTRING m_secondary_engine{nullptr, 0};
 };
 
 /**
   Node for the @SQL{STATS_AUTO_RECALC [=] @B{@<0|1|DEFAULT@>})} table option
 
   @ingroup ptn_create_or_alter_table_options
 */
 class PT_create_stats_auto_recalc_option : public PT_create_table_option {
   typedef PT_create_table_option super;
 
   const Ternary_option value;
 
  public:
   /**
+    @param pos Position of this clause in the SQL statement.
     @param value
       STATS_AUTO_RECALC | value
       ------------------|----------------------
       1                 | Ternary_option::ON
       0                 | Ternary_option::OFF
       DEFAULT           | Ternary_option::DEFAULT
   */
-  PT_create_stats_auto_recalc_option(Ternary_option value) : value(value) {}
+  PT_create_stats_auto_recalc_option(const POS &pos, Ternary_option value)
+      : super(pos), value(value) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{STATS_SAMPLE_PAGES [=] @B{@<integer@>|DEFAULT}} table option
 
   @ingroup ptn_create_or_alter_table_options
 */
 class PT_create_stats_stable_pages : public PT_create_table_option {
   typedef PT_create_table_option super;
   typedef decltype(HA_CREATE_INFO::stats_sample_pages) value_t;
 
   const value_t value;
 
  public:
   /**
     Constructor for implicit number of pages
 
+    @param pos         Position of this clause in the SQL statement.
     @param value       Number of pages, 1@<=N@<=65535.
   */
-  explicit PT_create_stats_stable_pages(value_t value) : value(value) {
+  explicit PT_create_stats_stable_pages(const POS &pos, value_t value)
+      : super(pos), value(value) {
     assert(value != 0 && value <= 0xFFFF);
   }
   /**
     Constructor for the DEFAULT number of pages
   */
-  PT_create_stats_stable_pages() : value(0) {}  // DEFAULT
+  explicit PT_create_stats_stable_pages(const POS &pos)
+      : super(pos), value(0) {}  // DEFAULT
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 };
@@ -2698,11 +2841,12 @@ class PT_create_stats_stable_pages : public PT_create_table_option {
 class PT_create_union_option : public PT_create_table_option {
   typedef PT_create_table_option super;
 
   const Mem_root_array<Table_ident *> *tables;
 
  public:
-  explicit PT_create_union_option(const Mem_root_array<Table_ident *> *tables)
-      : tables(tables) {}
+  explicit PT_create_union_option(const POS &pos,
+                                  const Mem_root_array<Table_ident *> *tables)
+      : super(pos), tables(tables) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 };
@@ -2710,14 +2854,15 @@ class PT_create_union_option : public PT_create_table_option {
 class PT_create_storage_option : public PT_create_table_option {
   typedef PT_create_table_option super;
 
   const ha_storage_media value;
 
  public:
-  explicit PT_create_storage_option(ha_storage_media value) : value(value) {}
+  explicit PT_create_storage_option(const POS &pos, ha_storage_media value)
+      : super(pos), value(value) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
     pc->create_info->storage_media = value;
     return false;
   }
 };
@@ -2725,13 +2870,14 @@ class PT_create_storage_option : public PT_create_table_option {
 class PT_create_table_default_charset : public PT_create_table_option {
   typedef PT_create_table_option super;
 
   const CHARSET_INFO *value;
 
  public:
-  explicit PT_create_table_default_charset(const CHARSET_INFO *value)
-      : value(value) {
+  explicit PT_create_table_default_charset(const POS &pos,
+                                           const CHARSET_INFO *value)
+      : super(pos), value(value) {
     assert(value != nullptr);
   }
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 };
@@ -2739,13 +2885,14 @@ class PT_create_table_default_charset : public PT_create_table_option {
 class PT_create_table_default_collation : public PT_create_table_option {
   typedef PT_create_table_option super;
 
   const CHARSET_INFO *value;
 
  public:
-  explicit PT_create_table_default_collation(const CHARSET_INFO *value)
-      : value(value) {
+  explicit PT_create_table_default_collation(const POS &pos,
+                                             const CHARSET_INFO *value)
+      : super(pos), value(value) {
     assert(value != nullptr);
   }
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 };
@@ -2753,14 +2900,16 @@ class PT_create_table_default_collation : public PT_create_table_option {
 class PT_check_constraint final : public PT_table_constraint_def {
   typedef PT_table_constraint_def super;
   Sql_check_constraint_spec cc_spec;
 
  public:
-  explicit PT_check_constraint(LEX_STRING &name, Item *expr, bool is_enforced) {
+  explicit PT_check_constraint(const POS &pos, LEX_STRING &name, Item *expr,
+                               bool is_enforced)
+      : super(pos) {
     cc_spec.name = name;
     cc_spec.check_expr = expr;
     cc_spec.is_enforced = is_enforced;
   }
   void set_column_name(const LEX_STRING &name) { cc_spec.column_name = name; }
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 };
@@ -2768,98 +2917,103 @@ class PT_check_constraint final : public PT_table_constraint_def {
 class PT_column_def : public PT_table_element {
   typedef PT_table_element super;
 
   const LEX_STRING field_ident;
   PT_field_def_base *field_def;
   // Currently we ignore that constraint in the executor.
   PT_table_constraint_def *opt_column_constraint;
 
   const char *opt_place;
 
  public:
-  PT_column_def(const LEX_STRING &field_ident, PT_field_def_base *field_def,
+  PT_column_def(const POS &pos, const LEX_STRING &field_ident,
+                PT_field_def_base *field_def,
                 PT_table_constraint_def *opt_column_constraint,
                 const char *opt_place = nullptr)
-      : field_ident(field_ident),
+      : super(pos),
+        field_ident(field_ident),
         field_def(field_def),
         opt_column_constraint(opt_column_constraint),
         opt_place(opt_place) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 };
 
 /**
   Top-level node for the CREATE %TABLE statement
 
   @ingroup ptn_create_table
 */
 class PT_create_table_stmt final : public PT_table_ddl_stmt_base {
   bool is_temporary;
   bool only_if_not_exists;
   Table_ident *table_name;
   const Mem_root_array<PT_table_element *> *opt_table_element_list;
   const Mem_root_array<PT_create_table_option *> *opt_create_table_options;
   PT_partition *opt_partitioning;
   On_duplicate on_duplicate;
   PT_query_expression_body *opt_query_expression;
   Table_ident *opt_like_clause;
 
   HA_CREATE_INFO m_create_info;
 
  public:
   /**
+    @param pos                        Position of this clause in the SQL
+                                      statement.
     @param mem_root                   MEM_ROOT to use for allocation
     @param is_temporary               True if @SQL{CREATE @B{TEMPORARY} %TABLE}
     @param only_if_not_exists  True if @SQL{CREATE %TABLE ... @B{IF NOT EXISTS}}
     @param table_name                 @SQL{CREATE %TABLE ... @B{@<table name@>}}
     @param opt_table_element_list     NULL or a list of table column and
                                       constraint definitions.
     @param opt_create_table_options   NULL or a list of
                                       @ref ptn_create_or_alter_table_options
                                       "table options".
     @param opt_partitioning           NULL or the @SQL{PARTITION BY} clause.
     @param on_duplicate               DUPLICATE, IGNORE or fail with an error
                                       on data duplication errors (relevant
                                       for @SQL{CREATE TABLE ... SELECT}
                                       statements).
     @param opt_query_expression       NULL or the @SQL{@B{SELECT}} clause.
   */
   PT_create_table_stmt(
-      MEM_ROOT *mem_root, bool is_temporary, bool only_if_not_exists,
-      Table_ident *table_name,
+      const POS &pos, MEM_ROOT *mem_root, bool is_temporary,
+      bool only_if_not_exists, Table_ident *table_name,
       const Mem_root_array<PT_table_element *> *opt_table_element_list,
       const Mem_root_array<PT_create_table_option *> *opt_create_table_options,
       PT_partition *opt_partitioning, On_duplicate on_duplicate,
       PT_query_expression_body *opt_query_expression)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         is_temporary(is_temporary),
         only_if_not_exists(only_if_not_exists),
         table_name(table_name),
         opt_table_element_list(opt_table_element_list),
         opt_create_table_options(opt_create_table_options),
         opt_partitioning(opt_partitioning),
         on_duplicate(on_duplicate),
         opt_query_expression(opt_query_expression),
         opt_like_clause(nullptr) {}
   /**
+    @param pos                Position of this clause in the SQL statement.
     @param mem_root           MEM_ROOT to use for allocation
     @param is_temporary       True if @SQL{CREATE @B{TEMPORARY} %TABLE}.
     @param only_if_not_exists True if @SQL{CREATE %TABLE ... @B{IF NOT EXISTS}}.
     @param table_name         @SQL{CREATE %TABLE ... @B{@<table name@>}}.
     @param opt_like_clause    NULL or the @SQL{@B{LIKE @<table name@>}} clause.
   */
-  PT_create_table_stmt(MEM_ROOT *mem_root, bool is_temporary,
+  PT_create_table_stmt(const POS &pos, MEM_ROOT *mem_root, bool is_temporary,
                        bool only_if_not_exists, Table_ident *table_name,
                        Table_ident *opt_like_clause)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         is_temporary(is_temporary),
         only_if_not_exists(only_if_not_exists),
         table_name(table_name),
         opt_table_element_list(nullptr),
         opt_create_table_options(nullptr),
         opt_partitioning(nullptr),
         on_duplicate(On_duplicate::ERROR),
         opt_query_expression(nullptr),
         opt_like_clause(opt_like_clause) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
@@ -2867,9 +3021,10 @@ class PT_create_table_stmt final : public PT_table_ddl_stmt_base {
 class PT_create_role final : public Parse_tree_root {
   Sql_cmd_create_role sql_cmd;
 
  public:
-  PT_create_role(bool if_not_exists, const List<LEX_USER> *roles)
-      : sql_cmd(if_not_exists, roles) {}
+  PT_create_role(const POS &pos, bool if_not_exists,
+                 const List<LEX_USER> *roles)
+      : Parse_tree_root(pos), sql_cmd(if_not_exists, roles) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
@@ -2877,9 +3032,10 @@ class PT_create_role final : public Parse_tree_root {
 class PT_drop_role final : public Parse_tree_root {
   Sql_cmd_drop_role sql_cmd;
 
  public:
-  explicit PT_drop_role(bool ignore_errors, const List<LEX_USER> *roles)
-      : sql_cmd(ignore_errors, roles) {}
+  explicit PT_drop_role(const POS &pos, bool ignore_errors,
+                        const List<LEX_USER> *roles)
+      : Parse_tree_root(pos), sql_cmd(ignore_errors, roles) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
@@ -2887,18 +3043,19 @@ class PT_drop_role final : public Parse_tree_root {
 class PT_set_role : public Parse_tree_root {
   Sql_cmd_set_role sql_cmd;
 
  public:
-  explicit PT_set_role(role_enum role_type,
+  explicit PT_set_role(const POS &pos, role_enum role_type,
                        const List<LEX_USER> *opt_except_roles = nullptr)
-      : sql_cmd(role_type, opt_except_roles) {
+      : Parse_tree_root(pos), sql_cmd(role_type, opt_except_roles) {
     assert(role_type == role_enum::ROLE_ALL || opt_except_roles == nullptr);
   }
-  explicit PT_set_role(const List<LEX_USER> *roles) : sql_cmd(roles) {}
+  explicit PT_set_role(const POS &pos, const List<LEX_USER> *roles)
+      : Parse_tree_root(pos), sql_cmd(roles) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 /**
   This class is used for representing both static and dynamic privileges on
   global as well as table and column level.
 */
@@ -2930,10 +3087,11 @@ struct Dynamic_privilege : public Privilege {
 
 class PT_role_or_privilege : public Parse_tree_node {
  private:
-  POS pos;
+  POS m_errpos;
 
  public:
-  explicit PT_role_or_privilege(const POS &pos) : pos(pos) {}
+  explicit PT_role_or_privilege(const POS &pos, const POS &errpos)
+      : Parse_tree_node(pos), m_errpos(errpos) {}
   virtual LEX_USER *get_user(THD *thd);
   virtual Privilege *get_privilege(THD *thd);
 };
@@ -2941,11 +3099,11 @@ class PT_role_or_privilege : public Parse_tree_node {
 class PT_role_at_host final : public PT_role_or_privilege {
   LEX_STRING role;
   LEX_STRING host;
 
  public:
-  PT_role_at_host(const POS &pos, const LEX_STRING &role,
+  PT_role_at_host(const POS &pos, const POS &errpos, const LEX_STRING &role,
                   const LEX_STRING &host)
-      : PT_role_or_privilege(pos), role(role), host(host) {}
+      : PT_role_or_privilege(pos, errpos), role(role), host(host) {}
 
   LEX_USER *get_user(THD *thd) override;
 };
@@ -2953,10 +3111,11 @@ class PT_role_at_host final : public PT_role_or_privilege {
 class PT_role_or_dynamic_privilege final : public PT_role_or_privilege {
   LEX_STRING ident;
 
  public:
-  PT_role_or_dynamic_privilege(const POS &pos, const LEX_STRING &ident)
-      : PT_role_or_privilege(pos), ident(ident) {}
+  PT_role_or_dynamic_privilege(const POS &pos, const POS &errpos,
+                               const LEX_STRING &ident)
+      : PT_role_or_privilege(pos, errpos), ident(ident) {}
 
   LEX_USER *get_user(THD *thd) override;
   Privilege *get_privilege(THD *thd) override;
 };
@@ -2964,11 +3123,11 @@ class PT_role_or_dynamic_privilege final : public PT_role_or_privilege {
 class PT_static_privilege final : public PT_role_or_privilege {
   const uint grant;
   const Mem_root_array<LEX_CSTRING> *columns;
 
  public:
-  PT_static_privilege(const POS &pos, uint grant,
+  PT_static_privilege(const POS &pos, const POS &errpos, uint grant,
                       const Mem_root_array<LEX_CSTRING> *columns = nullptr)
-      : PT_role_or_privilege(pos), grant(grant), columns(columns) {}
+      : PT_role_or_privilege(pos, errpos), grant(grant), columns(columns) {}
 
   Privilege *get_privilege(THD *thd) override;
 };
@@ -2976,9 +3135,10 @@ class PT_static_privilege final : public PT_role_or_privilege {
 class PT_dynamic_privilege final : public PT_role_or_privilege {
   LEX_STRING ident;
 
  public:
-  PT_dynamic_privilege(const POS &pos, const LEX_STRING &ident)
-      : PT_role_or_privilege(pos), ident(ident) {}
+  PT_dynamic_privilege(const POS &pos, const POS &errpos,
+                       const LEX_STRING &ident)
+      : PT_role_or_privilege(pos, errpos), ident(ident) {}
 
   Privilege *get_privilege(THD *thd) override;
 };
@@ -2986,12 +3146,16 @@ class PT_dynamic_privilege final : public PT_role_or_privilege {
 class PT_grant_roles final : public Parse_tree_root {
   const Mem_root_array<PT_role_or_privilege *> *roles;
   const List<LEX_USER> *users;
   const bool with_admin_option;
 
  public:
-  PT_grant_roles(const Mem_root_array<PT_role_or_privilege *> *roles,
+  PT_grant_roles(const POS &pos,
+                 const Mem_root_array<PT_role_or_privilege *> *roles,
                  const List<LEX_USER> *users, bool with_admin_option)
-      : roles(roles), users(users), with_admin_option(with_admin_option) {}
+      : Parse_tree_root(pos),
+        roles(roles),
+        users(users),
+        with_admin_option(with_admin_option) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
@@ -2999,11 +3163,11 @@ class PT_grant_roles final : public Parse_tree_root {
 class PT_revoke_roles final : public Parse_tree_root {
   const Mem_root_array<PT_role_or_privilege *> *roles;
   const List<LEX_USER> *users;
 
  public:
-  PT_revoke_roles(Mem_root_array<PT_role_or_privilege *> *roles,
+  PT_revoke_roles(const POS &pos, Mem_root_array<PT_role_or_privilege *> *roles,
                   const List<LEX_USER> *users)
-      : roles(roles), users(users) {}
+      : Parse_tree_root(pos), roles(roles), users(users) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
@@ -3011,13 +3175,14 @@ class PT_revoke_roles final : public Parse_tree_root {
 class PT_alter_user_default_role final : public Parse_tree_root {
   Sql_cmd_alter_user_default_role sql_cmd;
 
  public:
-  PT_alter_user_default_role(bool if_exists, const List<LEX_USER> *users,
+  PT_alter_user_default_role(const POS &pos, bool if_exists,
+                             const List<LEX_USER> *users,
                              const List<LEX_USER> *roles,
                              const role_enum role_type)
-      : sql_cmd(if_exists, users, roles, role_type) {}
+      : Parse_tree_root(pos), sql_cmd(if_exists, users, roles, role_type) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 /// Base class for Parse tree nodes of SHOW statements
@@ -3025,12 +3190,10 @@ class PT_alter_user_default_role final : public Parse_tree_root {
 class PT_show_base : public Parse_tree_root {
  protected:
   PT_show_base(const POS &pos, enum_sql_command sql_command)
-      : m_pos(pos), m_sql_command(sql_command) {}
+      : Parse_tree_root(pos), m_sql_command(sql_command) {}
 
-  /// Textual location of a token just parsed.
-  POS m_pos;
   /// SQL command
   enum_sql_command m_sql_command;
 };
 
 /// Base class for Parse tree nodes of SHOW statements with LIKE/WHERE parameter
@@ -3771,26 +3934,27 @@ class PT_show_warnings final : public PT_show_base {
 class PT_alter_table_action : public PT_ddl_table_option {
   typedef PT_ddl_table_option super;
 
  protected:
-  explicit PT_alter_table_action(Alter_info::Alter_info_flag flag)
-      : flag(flag) {}
+  explicit PT_alter_table_action(const POS &pos,
+                                 Alter_info::Alter_info_flag flag)
+      : super(pos), flag(flag) {}
 
  public:
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  protected:
   /**
     A routine used by the parser to decide whether we are specifying a full
     partitioning or if only partitions to add or to reorganize.
 
     @retval  true    ALTER TABLE ADD/REORGANIZE PARTITION.
     @retval  false   Something else.
   */
   bool is_add_or_reorganize_partition() const {
     return (flag == Alter_info::ALTER_ADD_PARTITION ||
             flag == Alter_info::ALTER_REORGANIZE_PARTITION);
   }
 
  public:
   const Alter_info::Alter_info_flag flag;
 };
@@ -3798,40 +3962,40 @@ class PT_alter_table_action : public PT_ddl_table_option {
 class PT_alter_table_add_column final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_add_column(const LEX_STRING &field_ident,
+  PT_alter_table_add_column(const POS &pos, const LEX_STRING &field_ident,
                             PT_field_def_base *field_def,
                             PT_table_constraint_def *opt_column_constraint,
                             const char *opt_place)
-      : super(Alter_info::ALTER_ADD_COLUMN),
-        m_column_def(field_ident, field_def, opt_column_constraint, opt_place) {
-  }
+      : super(pos, Alter_info::ALTER_ADD_COLUMN),
+        m_column_def(POS(), field_ident, field_def, opt_column_constraint,
+                     opt_place) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     return super::do_contextualize(pc) || m_column_def.contextualize(pc);
   }
 
  private:
-  PT_column_def m_column_def;
+  PT_column_def m_column_def;  // TODO: Position is not set.
 };
 
 class PT_alter_table_add_columns final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
   explicit PT_alter_table_add_columns(
-      const Mem_root_array<PT_table_element *> *columns)
-      : super(Alter_info::ALTER_ADD_COLUMN), m_columns(columns) {}
+      const POS &pos, const Mem_root_array<PT_table_element *> *columns)
+      : super(pos, Alter_info::ALTER_ADD_COLUMN), m_columns(columns) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
 
     for (auto *column : *m_columns)
       if (column->contextualize(pc)) return true;
 
     return false;
   }
 
  private:
   const Mem_root_array<PT_table_element *> *m_columns;
 };
@@ -3839,14 +4003,15 @@ class PT_alter_table_add_columns final : public PT_alter_table_action {
 class PT_alter_table_add_constraint final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  explicit PT_alter_table_add_constraint(PT_table_constraint_def *constraint)
-      : super(Alter_info::ALTER_ADD_INDEX), m_constraint(constraint) {}
+  explicit PT_alter_table_add_constraint(const POS &pos,
+                                         PT_table_constraint_def *constraint)
+      : super(pos, Alter_info::ALTER_ADD_INDEX), m_constraint(constraint) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     return super::do_contextualize(pc) || m_constraint->contextualize(pc);
   }
 
  private:
   PT_table_constraint_def *m_constraint;
 };
@@ -3854,27 +4019,27 @@ class PT_alter_table_add_constraint final : public PT_alter_table_action {
 class PT_alter_table_change_column final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_change_column(const LEX_STRING &old_name,
+  PT_alter_table_change_column(const POS &pos, const LEX_STRING &old_name,
                                const LEX_STRING &new_name,
                                PT_field_def_base *field_def,
                                const char *opt_place)
-      : super(Alter_info::ALTER_CHANGE_COLUMN),
+      : super(pos, Alter_info::ALTER_CHANGE_COLUMN),
         m_old_name(old_name),
         m_new_name(new_name),
         m_field_def(field_def),
         m_opt_place(opt_place) {}
 
-  PT_alter_table_change_column(const LEX_STRING &name,
+  PT_alter_table_change_column(const POS &pos, const LEX_STRING &name,
                                PT_field_def_base *field_def,
                                const char *opt_place)
-      : PT_alter_table_change_column(name, name, field_def, opt_place) {}
+      : PT_alter_table_change_column(pos, name, name, field_def, opt_place) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   const LEX_STRING m_old_name;
   const LEX_STRING m_new_name;
   PT_field_def_base *m_field_def;
   const char *m_opt_place;
 };
@@ -3882,82 +4047,84 @@ class PT_alter_table_change_column final : public PT_alter_table_action {
 class PT_alter_table_drop : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  protected:
-  PT_alter_table_drop(Alter_drop::drop_type drop_type,
+  PT_alter_table_drop(const POS &pos, Alter_drop::drop_type drop_type,
                       Alter_info::Alter_info_flag alter_info_flag,
                       const char *name)
-      : super(alter_info_flag), m_alter_drop(drop_type, name) {}
+      : super(pos, alter_info_flag), m_alter_drop(drop_type, name) {}
 
  public:
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     return (super::do_contextualize(pc) ||
             pc->alter_info->drop_list.push_back(&m_alter_drop));
   }
 
  private:
   Alter_drop m_alter_drop;
 };
 
 class PT_alter_table_drop_column final : public PT_alter_table_drop {
  public:
-  explicit PT_alter_table_drop_column(const char *name)
-      : PT_alter_table_drop(Alter_drop::COLUMN, Alter_info::ALTER_DROP_COLUMN,
-                            name) {}
+  explicit PT_alter_table_drop_column(const POS &pos, const char *name)
+      : PT_alter_table_drop(pos, Alter_drop::COLUMN,
+                            Alter_info::ALTER_DROP_COLUMN, name) {}
 };
 
 class PT_alter_table_drop_foreign_key final : public PT_alter_table_drop {
  public:
-  explicit PT_alter_table_drop_foreign_key(const char *name)
-      : PT_alter_table_drop(Alter_drop::FOREIGN_KEY,
+  explicit PT_alter_table_drop_foreign_key(const POS &pos, const char *name)
+      : PT_alter_table_drop(pos, Alter_drop::FOREIGN_KEY,
                             Alter_info::DROP_FOREIGN_KEY, name) {}
 };
 
 class PT_alter_table_drop_key final : public PT_alter_table_drop {
  public:
-  explicit PT_alter_table_drop_key(const char *name)
-      : PT_alter_table_drop(Alter_drop::KEY, Alter_info::ALTER_DROP_INDEX,
+  explicit PT_alter_table_drop_key(const POS &pos, const char *name)
+      : PT_alter_table_drop(pos, Alter_drop::KEY, Alter_info::ALTER_DROP_INDEX,
                             name) {}
 };
 
 class PT_alter_table_drop_check_constraint final : public PT_alter_table_drop {
  public:
-  explicit PT_alter_table_drop_check_constraint(const char *name)
-      : PT_alter_table_drop(Alter_drop::CHECK_CONSTRAINT,
+  explicit PT_alter_table_drop_check_constraint(const POS &pos,
+                                                const char *name)
+      : PT_alter_table_drop(pos, Alter_drop::CHECK_CONSTRAINT,
                             Alter_info::DROP_CHECK_CONSTRAINT, name) {}
 };
 
 class PT_alter_table_drop_constraint final : public PT_alter_table_drop {
  public:
-  explicit PT_alter_table_drop_constraint(const char *name)
-      : PT_alter_table_drop(Alter_drop::ANY_CONSTRAINT,
+  explicit PT_alter_table_drop_constraint(const POS &pos, const char *name)
+      : PT_alter_table_drop(pos, Alter_drop::ANY_CONSTRAINT,
                             Alter_info::DROP_ANY_CONSTRAINT, name) {}
 };
 
 class PT_alter_table_enforce_constraint : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  protected:
   PT_alter_table_enforce_constraint(
-      Alter_constraint_enforcement::Type alter_type,
+      const POS &pos, Alter_constraint_enforcement::Type alter_type,
       Alter_info::Alter_info_flag alter_info_flag, const char *name,
       bool is_enforced)
-      : super(alter_info_flag),
+      : super(pos, alter_info_flag),
         m_constraint_enforcement(alter_type, name, is_enforced) {}
 
  public:
-  explicit PT_alter_table_enforce_constraint(const char *name, bool is_enforced)
-      : super(is_enforced ? Alter_info::ENFORCE_ANY_CONSTRAINT
-                          : Alter_info::SUSPEND_ANY_CONSTRAINT),
+  explicit PT_alter_table_enforce_constraint(const POS &pos, const char *name,
+                                             bool is_enforced)
+      : super(pos, is_enforced ? Alter_info::ENFORCE_ANY_CONSTRAINT
+                               : Alter_info::SUSPEND_ANY_CONSTRAINT),
         m_constraint_enforcement(
             Alter_constraint_enforcement::Type::ANY_CONSTRAINT, name,
             is_enforced) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     return (super::do_contextualize(pc) ||
             pc->alter_info->alter_constraint_enforcement_list.push_back(
                 &m_constraint_enforcement));
   }
 
  private:
   Alter_constraint_enforcement m_constraint_enforcement;
 };
@@ -3965,11 +4132,12 @@ class PT_alter_table_enforce_constraint : public PT_alter_table_action {
 class PT_alter_table_enforce_check_constraint final
     : public PT_alter_table_enforce_constraint {
  public:
-  explicit PT_alter_table_enforce_check_constraint(const char *name,
+  explicit PT_alter_table_enforce_check_constraint(const POS &pos,
+                                                   const char *name,
                                                    bool is_enforced)
       : PT_alter_table_enforce_constraint(
-            Alter_constraint_enforcement::Type::CHECK_CONSTRAINT,
+            pos, Alter_constraint_enforcement::Type::CHECK_CONSTRAINT,
             is_enforced ? Alter_info::ENFORCE_CHECK_CONSTRAINT
                         : Alter_info::SUSPEND_CHECK_CONSTRAINT,
             name, is_enforced) {}
 };
@@ -3977,16 +4145,16 @@ class PT_alter_table_enforce_check_constraint final
 class PT_alter_table_enable_keys final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  explicit PT_alter_table_enable_keys(bool enable)
-      : super(Alter_info::ALTER_KEYS_ONOFF), m_enable(enable) {}
+  explicit PT_alter_table_enable_keys(const POS &pos, bool enable)
+      : super(pos, Alter_info::ALTER_KEYS_ONOFF), m_enable(enable) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     pc->alter_info->keys_onoff =
         m_enable ? Alter_info::ENABLE : Alter_info::DISABLE;
     return super::do_contextualize(pc);
   }
 
  private:
   bool m_enable;
 };
@@ -3994,15 +4162,16 @@ class PT_alter_table_enable_keys final : public PT_alter_table_action {
 class PT_alter_table_set_default final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_set_default(const char *col_name, Item *opt_default_expr)
-      : super(Alter_info::ALTER_CHANGE_COLUMN_DEFAULT),
+  PT_alter_table_set_default(const POS &pos, const char *col_name,
+                             Item *opt_default_expr)
+      : super(pos, Alter_info::ALTER_CHANGE_COLUMN_DEFAULT),
         m_name(col_name),
         m_expr(opt_default_expr) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   const char *m_name;
   Item *m_expr;
 };
@@ -4010,16 +4179,17 @@ class PT_alter_table_set_default final : public PT_alter_table_action {
 class PT_alter_table_column_visibility final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_column_visibility(const char *col_name, bool is_visible)
-      : super(Alter_info::ALTER_COLUMN_VISIBILITY),
+  PT_alter_table_column_visibility(const POS &pos, const char *col_name,
+                                   bool is_visible)
+      : super(pos, Alter_info::ALTER_COLUMN_VISIBILITY),
         m_alter_column(col_name, is_visible) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     return (super::do_contextualize(pc) ||
             pc->alter_info->alter_list.push_back(&m_alter_column));
   }
 
  private:
   Alter_column m_alter_column;
 };
@@ -4027,17 +4197,17 @@ class PT_alter_table_column_visibility final : public PT_alter_table_action {
 class PT_alter_table_index_visible final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_index_visible(const char *name, bool visible)
-      : super(Alter_info::ALTER_INDEX_VISIBILITY),
+  PT_alter_table_index_visible(const POS &pos, const char *name, bool visible)
+      : super(pos, Alter_info::ALTER_INDEX_VISIBILITY),
         m_alter_index_visibility(name, visible) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     return (super::do_contextualize(pc) ||
             pc->alter_info->alter_index_visibility_list.push_back(
                 &m_alter_index_visibility));
   }
 
  private:
   Alter_index_visibility m_alter_index_visibility;
 };
@@ -4045,14 +4215,14 @@ class PT_alter_table_index_visible final : public PT_alter_table_action {
 class PT_alter_table_rename final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  explicit PT_alter_table_rename(const Table_ident *ident)
-      : super(Alter_info::ALTER_RENAME), m_ident(ident) {}
+  explicit PT_alter_table_rename(const POS &pos, const Table_ident *ident)
+      : super(pos, Alter_info::ALTER_RENAME), m_ident(ident) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   bool is_rename_table() const override { return true; }
 
  private:
   const Table_ident *const m_ident;
 };
@@ -4060,15 +4230,15 @@ class PT_alter_table_rename final : public PT_alter_table_action {
 class PT_alter_table_rename_key final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_rename_key(const char *from, const char *to)
-      : super(Alter_info::ALTER_RENAME_INDEX), m_rename_key(from, to) {}
+  PT_alter_table_rename_key(const POS &pos, const char *from, const char *to)
+      : super(pos, Alter_info::ALTER_RENAME_INDEX), m_rename_key(from, to) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     return super::do_contextualize(pc) ||
            pc->alter_info->alter_rename_key_list.push_back(&m_rename_key);
   }
 
  private:
   Alter_rename_key m_rename_key;
 };
@@ -4076,15 +4246,16 @@ class PT_alter_table_rename_key final : public PT_alter_table_action {
 class PT_alter_table_rename_column final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_rename_column(const char *from, const char *to)
-      : super(Alter_info::ALTER_CHANGE_COLUMN), m_rename_column(from, to) {}
+  PT_alter_table_rename_column(const POS &pos, const char *from, const char *to)
+      : super(pos, Alter_info::ALTER_CHANGE_COLUMN),
+        m_rename_column(from, to) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     return super::do_contextualize(pc) ||
            pc->alter_info->alter_list.push_back(&m_rename_column);
   }
 
  private:
   Alter_column m_rename_column;
 };
@@ -4092,16 +4263,16 @@ class PT_alter_table_rename_column final : public PT_alter_table_action {
 class PT_alter_table_convert_to_charset final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_convert_to_charset(const CHARSET_INFO *charset,
+  PT_alter_table_convert_to_charset(const POS &pos, const CHARSET_INFO *charset,
                                     const CHARSET_INFO *opt_collation)
-      : super(Alter_info::ALTER_OPTIONS),
+      : super(pos, Alter_info::ALTER_OPTIONS),
         m_charset(charset),
         m_collation(opt_collation) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   const CHARSET_INFO *const m_charset;
   const CHARSET_INFO *const m_collation;
 };
@@ -4109,19 +4280,20 @@ class PT_alter_table_convert_to_charset final : public PT_alter_table_action {
 class PT_alter_table_force final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_force() : super(Alter_info::ALTER_RECREATE) {}
+  explicit PT_alter_table_force(const POS &pos)
+      : super(pos, Alter_info::ALTER_RECREATE) {}
 };
 
 class PT_alter_table_order final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  explicit PT_alter_table_order(PT_order_list *order)
-      : super(Alter_info::ALTER_ORDER), m_order(order) {}
+  explicit PT_alter_table_order(const POS &pos, PT_order_list *order)
+      : super(pos, Alter_info::ALTER_ORDER), m_order(order) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   PT_order_list *const m_order;
 };
@@ -4129,12 +4301,12 @@ class PT_alter_table_order final : public PT_alter_table_action {
 class PT_alter_table_partition_by final : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  explicit PT_alter_table_partition_by(PT_partition *partition)
-      : super(Alter_info::ALTER_PARTITION), m_partition(partition) {}
+  explicit PT_alter_table_partition_by(const POS &pos, PT_partition *partition)
+      : super(pos, Alter_info::ALTER_PARTITION), m_partition(partition) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   PT_partition *const m_partition;
 };
@@ -4142,83 +4314,85 @@ class PT_alter_table_partition_by final : public PT_alter_table_action {
 class PT_alter_table_remove_partitioning : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
  public:
-  PT_alter_table_remove_partitioning()
-      : super(Alter_info::ALTER_REMOVE_PARTITIONING) {}
+  explicit PT_alter_table_remove_partitioning(const POS &pos)
+      : super(pos, Alter_info::ALTER_REMOVE_PARTITIONING) {}
 };
 
 class PT_alter_table_standalone_action : public PT_alter_table_action {
   typedef PT_alter_table_action super;
 
   friend class PT_alter_table_standalone_stmt;  // to access make_cmd()
 
  protected:
-  PT_alter_table_standalone_action(Alter_info::Alter_info_flag alter_info_flag)
-      : super(alter_info_flag) {}
+  PT_alter_table_standalone_action(const POS &pos,
+                                   Alter_info::Alter_info_flag alter_info_flag)
+      : super(pos, alter_info_flag) {}
 
  private:
   virtual Sql_cmd *make_cmd(Table_ddl_parse_context *pc) = 0;
 };
 
 /**
   Node for the @SQL{ALTER TABLE ADD PARTITION} statement
 
   @ingroup ptn_alter_table
 */
 class PT_alter_table_add_partition : public PT_alter_table_standalone_action {
   typedef PT_alter_table_standalone_action super;
 
  public:
-  explicit PT_alter_table_add_partition(bool no_write_to_binlog)
-      : super(Alter_info::ALTER_ADD_PARTITION),
+  explicit PT_alter_table_add_partition(const POS &pos, bool no_write_to_binlog)
+      : super(pos, Alter_info::ALTER_ADD_PARTITION),
         m_no_write_to_binlog(no_write_to_binlog) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) final {
     return new (pc->mem_root) Sql_cmd_alter_table(pc->alter_info);
   }
 
  protected:
   partition_info m_part_info;
 
  private:
   const bool m_no_write_to_binlog;
 };
 
 /**
   Node for the @SQL{ALTER TABLE ADD PARTITION (@<partition list@>)} statement
 
   @ingroup ptn_alter_table
 */
 class PT_alter_table_add_partition_def_list final
     : public PT_alter_table_add_partition {
   typedef PT_alter_table_add_partition super;
 
  public:
   PT_alter_table_add_partition_def_list(
-      bool no_write_to_binlog,
+      const POS &pos, bool no_write_to_binlog,
       const Mem_root_array<PT_part_definition *> *def_list)
-      : super(no_write_to_binlog), m_def_list(def_list) {}
+      : super(pos, no_write_to_binlog), m_def_list(def_list) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   const Mem_root_array<PT_part_definition *> *m_def_list;
 };
 
 /**
   Node for the @SQL{ALTER TABLE ADD PARTITION PARTITIONS (@<n>@)} statement
 
   @ingroup ptn_alter_table
 */
 class PT_alter_table_add_partition_num final
     : public PT_alter_table_add_partition {
   typedef PT_alter_table_add_partition super;
 
  public:
-  PT_alter_table_add_partition_num(bool no_write_to_binlog, uint num_parts)
-      : super(no_write_to_binlog) {
+  PT_alter_table_add_partition_num(const POS &pos, bool no_write_to_binlog,
+                                   uint num_parts)
+      : super(pos, no_write_to_binlog) {
     m_part_info.num_parts = num_parts;
   }
 };
@@ -4226,17 +4400,19 @@ class PT_alter_table_add_partition_num final
 class PT_alter_table_drop_partition final
     : public PT_alter_table_standalone_action {
   typedef PT_alter_table_standalone_action super;
 
  public:
-  explicit PT_alter_table_drop_partition(const List<String> &partitions)
-      : super(Alter_info::ALTER_DROP_PARTITION), m_partitions(partitions) {}
+  explicit PT_alter_table_drop_partition(const POS &pos,
+                                         const List<String> &partitions)
+      : super(pos, Alter_info::ALTER_DROP_PARTITION),
+        m_partitions(partitions) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) final {
     return new (pc->mem_root) Sql_cmd_alter_table(pc->alter_info);
   }
 
  private:
   const List<String> m_partitions;
 };
@@ -4244,22 +4420,22 @@ class PT_alter_table_drop_partition final
 class PT_alter_table_partition_list_or_all
     : public PT_alter_table_standalone_action {
   typedef PT_alter_table_standalone_action super;
 
  public:
   explicit PT_alter_table_partition_list_or_all(
-      Alter_info::Alter_info_flag alter_info_flag,
+      const POS &pos, Alter_info::Alter_info_flag alter_info_flag,
       const List<String> *opt_partition_list)
-      : super(alter_info_flag), m_opt_partition_list(opt_partition_list) {}
+      : super(pos, alter_info_flag), m_opt_partition_list(opt_partition_list) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override {
     assert(pc->alter_info->partition_names.is_empty());
     if (m_opt_partition_list == nullptr)
       pc->alter_info->flags |= Alter_info::ALTER_ALL_PARTITION;
     else
       pc->alter_info->partition_names = *m_opt_partition_list;
     return super::do_contextualize(pc);
   }
 
  private:
   const List<String> *m_opt_partition_list;
 };
@@ -4267,19 +4443,19 @@ class PT_alter_table_partition_list_or_all
 class PT_alter_table_rebuild_partition final
     : public PT_alter_table_partition_list_or_all {
   typedef PT_alter_table_partition_list_or_all super;
 
  public:
-  PT_alter_table_rebuild_partition(bool no_write_to_binlog,
+  PT_alter_table_rebuild_partition(const POS &pos, bool no_write_to_binlog,
                                    const List<String> *opt_partition_list)
-      : super(Alter_info::ALTER_REBUILD_PARTITION, opt_partition_list),
+      : super(pos, Alter_info::ALTER_REBUILD_PARTITION, opt_partition_list),
         m_no_write_to_binlog(no_write_to_binlog) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_alter_table(pc->alter_info);
   }
 
  private:
   const bool m_no_write_to_binlog;
 };
@@ -4287,20 +4463,20 @@ class PT_alter_table_rebuild_partition final
 class PT_alter_table_optimize_partition final
     : public PT_alter_table_partition_list_or_all {
   typedef PT_alter_table_partition_list_or_all super;
 
  public:
-  PT_alter_table_optimize_partition(bool no_write_to_binlog,
+  PT_alter_table_optimize_partition(const POS &pos, bool no_write_to_binlog,
                                     const List<String> *opt_partition_list)
-      : super(Alter_info::ALTER_ADMIN_PARTITION, opt_partition_list),
+      : super(pos, Alter_info::ALTER_ADMIN_PARTITION, opt_partition_list),
         m_no_write_to_binlog(no_write_to_binlog) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root)
         Sql_cmd_alter_table_optimize_partition(pc->alter_info);
   }
 
  private:
   const bool m_no_write_to_binlog;
 };
@@ -4308,19 +4484,19 @@ class PT_alter_table_optimize_partition final
 class PT_alter_table_analyze_partition
     : public PT_alter_table_partition_list_or_all {
   typedef PT_alter_table_partition_list_or_all super;
 
  public:
-  PT_alter_table_analyze_partition(bool no_write_to_binlog,
+  PT_alter_table_analyze_partition(const POS &pos, bool no_write_to_binlog,
                                    const List<String> *opt_partition_list)
-      : super(Alter_info::ALTER_ADMIN_PARTITION, opt_partition_list),
+      : super(pos, Alter_info::ALTER_ADMIN_PARTITION, opt_partition_list),
         m_no_write_to_binlog(no_write_to_binlog) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root)
         Sql_cmd_alter_table_analyze_partition(pc->thd, pc->alter_info);
   }
 
  private:
   const bool m_no_write_to_binlog;
 };
@@ -4328,22 +4504,23 @@ class PT_alter_table_analyze_partition
 class PT_alter_table_check_partition
     : public PT_alter_table_partition_list_or_all {
   typedef PT_alter_table_partition_list_or_all super;
 
  public:
-  PT_alter_table_check_partition(const List<String> *opt_partition_list,
+  PT_alter_table_check_partition(const POS &pos,
+                                 const List<String> *opt_partition_list,
                                  uint flags, uint sql_flags)
-      : super(Alter_info::ALTER_ADMIN_PARTITION, opt_partition_list),
+      : super(pos, Alter_info::ALTER_ADMIN_PARTITION, opt_partition_list),
         m_flags(flags),
         m_sql_flags(sql_flags) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root)
         Sql_cmd_alter_table_check_partition(pc->alter_info);
   }
 
  private:
   uint m_flags;
   uint m_sql_flags;
 };
@@ -4351,25 +4528,25 @@ class PT_alter_table_check_partition
 class PT_alter_table_repair_partition
     : public PT_alter_table_partition_list_or_all {
   typedef PT_alter_table_partition_list_or_all super;
 
  public:
-  PT_alter_table_repair_partition(bool no_write_to_binlog,
+  PT_alter_table_repair_partition(const POS &pos, bool no_write_to_binlog,
                                   const List<String> *opt_partition_list,
                                   uint flags, uint sql_flags)
-      : super(Alter_info::ALTER_ADMIN_PARTITION, opt_partition_list),
+      : super(pos, Alter_info::ALTER_ADMIN_PARTITION, opt_partition_list),
         m_no_write_to_binlog(no_write_to_binlog),
         m_flags(flags),
         m_sql_flags(sql_flags) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root)
         Sql_cmd_alter_table_repair_partition(pc->alter_info);
   }
 
  private:
   const bool m_no_write_to_binlog;
   uint m_flags;
   uint m_sql_flags;
 };
@@ -4377,20 +4554,21 @@ class PT_alter_table_repair_partition
 class PT_alter_table_coalesce_partition final
     : public PT_alter_table_standalone_action {
   typedef PT_alter_table_standalone_action super;
 
  public:
-  PT_alter_table_coalesce_partition(bool no_write_to_binlog, uint num_parts)
-      : super(Alter_info::ALTER_COALESCE_PARTITION),
+  PT_alter_table_coalesce_partition(const POS &pos, bool no_write_to_binlog,
+                                    uint num_parts)
+      : super(pos, Alter_info::ALTER_COALESCE_PARTITION),
         m_no_write_to_binlog(no_write_to_binlog),
         m_num_parts(num_parts) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_alter_table(pc->alter_info);
   }
 
  private:
   const bool m_no_write_to_binlog;
   const uint m_num_parts;
 };
@@ -4398,19 +4576,20 @@ class PT_alter_table_coalesce_partition final
 class PT_alter_table_truncate_partition
     : public PT_alter_table_partition_list_or_all {
   typedef PT_alter_table_partition_list_or_all super;
 
  public:
   explicit PT_alter_table_truncate_partition(
-      const List<String> *opt_partition_list)
-      : super(static_cast<Alter_info::Alter_info_flag>(
+      const POS &pos, const List<String> *opt_partition_list)
+      : super(pos,
+              static_cast<Alter_info::Alter_info_flag>(
                   Alter_info::ALTER_ADMIN_PARTITION |
                   Alter_info::ALTER_TRUNCATE_PARTITION),
               opt_partition_list) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root)
         Sql_cmd_alter_table_truncate_partition(pc->alter_info);
   }
 };
@@ -4418,19 +4597,20 @@ class PT_alter_table_truncate_partition
 class PT_alter_table_reorganize_partition final
     : public PT_alter_table_standalone_action {
   typedef PT_alter_table_standalone_action super;
 
  public:
-  explicit PT_alter_table_reorganize_partition(bool no_write_to_binlog)
-      : super(Alter_info::ALTER_TABLE_REORG),
+  explicit PT_alter_table_reorganize_partition(const POS &pos,
+                                               bool no_write_to_binlog)
+      : super(pos, Alter_info::ALTER_TABLE_REORG),
         m_no_write_to_binlog(no_write_to_binlog) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_alter_table(pc->alter_info);
   }
 
  private:
   const bool m_no_write_to_binlog;
   partition_info m_partition_info;
 };
@@ -4438,25 +4618,26 @@ class PT_alter_table_reorganize_partition final
 class PT_alter_table_reorganize_partition_into final
     : public PT_alter_table_standalone_action {
   typedef PT_alter_table_standalone_action super;
 
  public:
   explicit PT_alter_table_reorganize_partition_into(
-      bool no_write_to_binlog, const List<String> &partition_names,
+      const POS &pos, bool no_write_to_binlog,
+      const List<String> &partition_names,
       const Mem_root_array<PT_part_definition *> *into)
-      : super(Alter_info::ALTER_REORGANIZE_PARTITION),
+      : super(pos, Alter_info::ALTER_REORGANIZE_PARTITION),
         m_no_write_to_binlog(no_write_to_binlog),
         m_partition_names(partition_names),
         m_into(into) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_alter_table(pc->alter_info);
   }
 
  private:
   const bool m_no_write_to_binlog;
   const List<String> m_partition_names;
   const Mem_root_array<PT_part_definition *> *m_into;
   partition_info m_partition_info;
 };
@@ -4464,25 +4645,26 @@ class PT_alter_table_reorganize_partition_into final
 class PT_alter_table_exchange_partition final
     : public PT_alter_table_standalone_action {
   typedef PT_alter_table_standalone_action super;
 
  public:
-  PT_alter_table_exchange_partition(const LEX_STRING &partition_name,
+  PT_alter_table_exchange_partition(const POS &pos,
+                                    const LEX_STRING &partition_name,
                                     Table_ident *table_name,
                                     Alter_info::enum_with_validation validation)
-      : super(Alter_info::ALTER_EXCHANGE_PARTITION),
+      : super(pos, Alter_info::ALTER_EXCHANGE_PARTITION),
         m_partition_name(partition_name),
         m_table_name(table_name),
         m_validation(validation) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root)
         Sql_cmd_alter_table_exchange_partition(pc->alter_info);
   }
 
  private:
   const LEX_STRING m_partition_name;
   Table_ident *m_table_name;
   const Alter_info::enum_with_validation m_validation;
 };
@@ -4490,12 +4672,12 @@ class PT_alter_table_exchange_partition final
 class PT_alter_table_secondary_load final
     : public PT_alter_table_standalone_action {
   using super = PT_alter_table_standalone_action;
 
  public:
-  explicit PT_alter_table_secondary_load()
-      : super(Alter_info::ALTER_SECONDARY_LOAD) {}
+  explicit PT_alter_table_secondary_load(const POS &pos)
+      : super(pos, Alter_info::ALTER_SECONDARY_LOAD) {}
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_secondary_load_unload(pc->alter_info);
   }
 };
@@ -4503,12 +4685,12 @@ class PT_alter_table_secondary_load final
 class PT_alter_table_secondary_unload final
     : public PT_alter_table_standalone_action {
   using super = PT_alter_table_standalone_action;
 
  public:
-  explicit PT_alter_table_secondary_unload()
-      : super(Alter_info::ALTER_SECONDARY_UNLOAD) {}
+  explicit PT_alter_table_secondary_unload(const POS &pos)
+      : super(pos, Alter_info::ALTER_SECONDARY_UNLOAD) {}
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_secondary_load_unload(pc->alter_info);
   }
 };
@@ -4516,13 +4698,13 @@ class PT_alter_table_secondary_unload final
 class PT_alter_table_discard_partition_tablespace final
     : public PT_alter_table_partition_list_or_all {
   typedef PT_alter_table_partition_list_or_all super;
 
  public:
   explicit PT_alter_table_discard_partition_tablespace(
-      const List<String> *opt_partition_list)
-      : super(Alter_info::ALTER_DISCARD_TABLESPACE, opt_partition_list) {}
+      const POS &pos, const List<String> *opt_partition_list)
+      : super(pos, Alter_info::ALTER_DISCARD_TABLESPACE, opt_partition_list) {}
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_discard_import_tablespace(pc->alter_info);
   }
 };
@@ -4530,13 +4712,13 @@ class PT_alter_table_discard_partition_tablespace final
 class PT_alter_table_import_partition_tablespace final
     : public PT_alter_table_partition_list_or_all {
   typedef PT_alter_table_partition_list_or_all super;
 
  public:
   explicit PT_alter_table_import_partition_tablespace(
-      const List<String> *opt_partition_list)
-      : super(Alter_info::ALTER_IMPORT_TABLESPACE, opt_partition_list) {}
+      const POS &pos, const List<String> *opt_partition_list)
+      : super(pos, Alter_info::ALTER_IMPORT_TABLESPACE, opt_partition_list) {}
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_discard_import_tablespace(pc->alter_info);
   }
 };
@@ -4544,12 +4726,12 @@ class PT_alter_table_import_partition_tablespace final
 class PT_alter_table_discard_tablespace final
     : public PT_alter_table_standalone_action {
   typedef PT_alter_table_standalone_action super;
 
  public:
-  PT_alter_table_discard_tablespace()
-      : super(Alter_info::ALTER_DISCARD_TABLESPACE) {}
+  explicit PT_alter_table_discard_tablespace(const POS &pos)
+      : super(pos, Alter_info::ALTER_DISCARD_TABLESPACE) {}
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_discard_import_tablespace(pc->alter_info);
   }
 };
@@ -4557,12 +4739,12 @@ class PT_alter_table_discard_tablespace final
 class PT_alter_table_import_tablespace final
     : public PT_alter_table_standalone_action {
   typedef PT_alter_table_standalone_action super;
 
  public:
-  PT_alter_table_import_tablespace()
-      : super(Alter_info::ALTER_IMPORT_TABLESPACE) {}
+  explicit PT_alter_table_import_tablespace(const POS &pos)
+      : super(pos, Alter_info::ALTER_IMPORT_TABLESPACE) {}
 
   Sql_cmd *make_cmd(Table_ddl_parse_context *pc) override {
     return new (pc->mem_root) Sql_cmd_discard_import_tablespace(pc->alter_info);
   }
 };
@@ -4570,26 +4752,26 @@ class PT_alter_table_import_tablespace final
 class PT_alter_table_stmt final : public PT_table_ddl_stmt_base {
  public:
   explicit PT_alter_table_stmt(
-      MEM_ROOT *mem_root, Table_ident *table_name,
+      const POS &pos, MEM_ROOT *mem_root, Table_ident *table_name,
       Mem_root_array<PT_ddl_table_option *> *opt_actions,
       Alter_info::enum_alter_table_algorithm algo,
       Alter_info::enum_alter_table_lock lock,
       Alter_info::enum_with_validation validation)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_table_name(table_name),
         m_opt_actions(opt_actions),
         m_algo(algo),
         m_lock(lock),
         m_validation(validation) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Table_ident *const m_table_name;
   Mem_root_array<PT_ddl_table_option *> *const m_opt_actions;
   const Alter_info::enum_alter_table_algorithm m_algo;
   const Alter_info::enum_alter_table_lock m_lock;
   const Alter_info::enum_with_validation m_validation;
 
   HA_CREATE_INFO m_create_info;
 };
@@ -4597,141 +4779,145 @@ class PT_alter_table_stmt final : public PT_table_ddl_stmt_base {
 class PT_alter_table_standalone_stmt final : public PT_table_ddl_stmt_base {
  public:
   explicit PT_alter_table_standalone_stmt(
-      MEM_ROOT *mem_root, Table_ident *table_name,
+      const POS &pos, MEM_ROOT *mem_root, Table_ident *table_name,
       PT_alter_table_standalone_action *action,
       Alter_info::enum_alter_table_algorithm algo,
       Alter_info::enum_alter_table_lock lock,
       Alter_info::enum_with_validation validation)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_table_name(table_name),
         m_action(action),
         m_algo(algo),
         m_lock(lock),
         m_validation(validation) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Table_ident *const m_table_name;
   PT_alter_table_standalone_action *const m_action;
   const Alter_info::enum_alter_table_algorithm m_algo;
   const Alter_info::enum_alter_table_lock m_lock;
   const Alter_info::enum_with_validation m_validation;
 
   HA_CREATE_INFO m_create_info;
 };
 
 class PT_repair_table_stmt final : public PT_table_ddl_stmt_base {
  public:
-  PT_repair_table_stmt(MEM_ROOT *mem_root, bool no_write_to_binlog,
+  PT_repair_table_stmt(const POS &pos, MEM_ROOT *mem_root,
+                       bool no_write_to_binlog,
                        Mem_root_array<Table_ident *> *table_list,
                        decltype(HA_CHECK_OPT::flags) flags,
                        decltype(HA_CHECK_OPT::sql_flags) sql_flags)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_no_write_to_binlog(no_write_to_binlog),
         m_table_list(table_list),
         m_flags(flags),
         m_sql_flags(sql_flags) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   bool m_no_write_to_binlog;
   Mem_root_array<Table_ident *> *m_table_list;
   decltype(HA_CHECK_OPT::flags) m_flags;
   decltype(HA_CHECK_OPT::sql_flags) m_sql_flags;
 };
 
 class PT_analyze_table_stmt final : public PT_table_ddl_stmt_base {
  public:
-  PT_analyze_table_stmt(MEM_ROOT *mem_root, bool no_write_to_binlog,
+  PT_analyze_table_stmt(const POS &pos, MEM_ROOT *mem_root,
+                        bool no_write_to_binlog,
                         Mem_root_array<Table_ident *> *table_list,
                         Sql_cmd_analyze_table::Histogram_command command,
                         int num_buckets, List<String> *columns, LEX_STRING data)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_no_write_to_binlog(no_write_to_binlog),
         m_table_list(table_list),
         m_command(command),
         m_num_buckets(num_buckets),
         m_columns(columns),
         m_data{data} {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   const bool m_no_write_to_binlog;
   const Mem_root_array<Table_ident *> *m_table_list;
   const Sql_cmd_analyze_table::Histogram_command m_command;
   const int m_num_buckets;
   List<String> *m_columns;
   const LEX_STRING m_data;
 };
 
 class PT_check_table_stmt final : public PT_table_ddl_stmt_base {
  public:
-  PT_check_table_stmt(MEM_ROOT *mem_root,
+  PT_check_table_stmt(const POS &pos, MEM_ROOT *mem_root,
                       Mem_root_array<Table_ident *> *table_list,
                       decltype(HA_CHECK_OPT::flags) flags,
                       decltype(HA_CHECK_OPT::sql_flags) sql_flags)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_table_list(table_list),
         m_flags(flags),
         m_sql_flags(sql_flags) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Mem_root_array<Table_ident *> *m_table_list;
   decltype(HA_CHECK_OPT::flags) m_flags;
   decltype(HA_CHECK_OPT::sql_flags) m_sql_flags;
 };
 
 class PT_optimize_table_stmt final : public PT_table_ddl_stmt_base {
  public:
-  PT_optimize_table_stmt(MEM_ROOT *mem_root, bool no_write_to_binlog,
+  PT_optimize_table_stmt(const POS &pos, MEM_ROOT *mem_root,
+                         bool no_write_to_binlog,
                          Mem_root_array<Table_ident *> *table_list)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_no_write_to_binlog(no_write_to_binlog),
         m_table_list(table_list) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
   bool m_no_write_to_binlog;
   Mem_root_array<Table_ident *> *m_table_list;
 };
 
 class PT_drop_index_stmt final : public PT_table_ddl_stmt_base {
  public:
-  PT_drop_index_stmt(MEM_ROOT *mem_root, const char *index_name,
+  PT_drop_index_stmt(const POS &pos, MEM_ROOT *mem_root, const char *index_name,
                      Table_ident *table,
                      Alter_info::enum_alter_table_algorithm algo,
                      Alter_info::enum_alter_table_lock lock)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_index_name(index_name),
         m_table(table),
         m_algo(algo),
         m_lock(lock),
         m_alter_drop(Alter_drop::KEY, m_index_name) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   const char *m_index_name;
   Table_ident *m_table;
   Alter_info::enum_alter_table_algorithm m_algo;
   Alter_info::enum_alter_table_lock m_lock;
 
   Alter_drop m_alter_drop;
 };
 
 class PT_truncate_table_stmt final : public Parse_tree_root {
  public:
-  explicit PT_truncate_table_stmt(Table_ident *table) : m_table(table) {}
+  explicit PT_truncate_table_stmt(const POS &pos, Table_ident *table)
+      : Parse_tree_root(pos), m_table(table) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Table_ident *m_table;
 
   Sql_cmd_truncate_table m_cmd_truncate_table;
 };
@@ -4739,13 +4925,14 @@ class PT_truncate_table_stmt final : public Parse_tree_root {
 class PT_assign_to_keycache final : public Table_ddl_node {
   typedef Table_ddl_node super;
 
  public:
-  PT_assign_to_keycache(Table_ident *table, List<Index_hint> *index_hints)
-      : m_table(table), m_index_hints(index_hints) {}
+  PT_assign_to_keycache(const POS &pos, Table_ident *table,
+                        List<Index_hint> *index_hints)
+      : super(pos), m_table(table), m_index_hints(index_hints) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   Table_ident *m_table;
   List<Index_hint> *m_index_hints;
 };
@@ -4753,49 +4940,50 @@ class PT_assign_to_keycache final : public Table_ddl_node {
 class PT_adm_partition final : public Table_ddl_node {
   typedef Table_ddl_node super;
 
  public:
-  explicit PT_adm_partition(List<String> *opt_partitions)
-      : m_opt_partitions(opt_partitions) {}
+  explicit PT_adm_partition(const POS &pos, List<String> *opt_partitions)
+      : super(pos), m_opt_partitions(opt_partitions) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   List<String> *m_opt_partitions;
 };
 
 class PT_cache_index_stmt final : public PT_table_ddl_stmt_base {
  public:
-  PT_cache_index_stmt(MEM_ROOT *mem_root,
+  PT_cache_index_stmt(const POS &pos, MEM_ROOT *mem_root,
                       Mem_root_array<PT_assign_to_keycache *> *tbl_index_lists,
                       LEX_CSTRING key_cache_name)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_tbl_index_lists(tbl_index_lists),
         m_key_cache_name(key_cache_name) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Mem_root_array<PT_assign_to_keycache *> *m_tbl_index_lists;
   const LEX_CSTRING m_key_cache_name;
 };
 
 class PT_cache_index_partitions_stmt : public PT_table_ddl_stmt_base {
  public:
-  PT_cache_index_partitions_stmt(MEM_ROOT *mem_root, Table_ident *table,
+  PT_cache_index_partitions_stmt(const POS &pos, MEM_ROOT *mem_root,
+                                 Table_ident *table,
                                  PT_adm_partition *partitions,
                                  List<Index_hint> *opt_key_usage_list,
                                  LEX_CSTRING key_cache_name)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_table(table),
         m_partitions(partitions),
         m_opt_key_usage_list(opt_key_usage_list),
         m_key_cache_name(key_cache_name) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Table_ident *m_table;
   PT_adm_partition *m_partitions;
   List<Index_hint> *m_opt_key_usage_list;
   const LEX_CSTRING m_key_cache_name;
 };
@@ -4803,50 +4991,52 @@ class PT_cache_index_partitions_stmt : public PT_table_ddl_stmt_base {
 class PT_preload_keys final : public Table_ddl_node {
   typedef Table_ddl_node super;
 
  public:
-  PT_preload_keys(Table_ident *table, List<Index_hint> *opt_cache_key_list,
-                  bool ignore_leaves)
-      : m_table(table),
+  PT_preload_keys(const POS &pos, Table_ident *table,
+                  List<Index_hint> *opt_cache_key_list, bool ignore_leaves)
+      : super(pos),
+        m_table(table),
         m_opt_cache_key_list(opt_cache_key_list),
         m_ignore_leaves(ignore_leaves) {}
 
   bool do_contextualize(Table_ddl_parse_context *pc) override;
 
  private:
   Table_ident *m_table;
   List<Index_hint> *m_opt_cache_key_list;
   bool m_ignore_leaves;
 };
 
 class PT_load_index_partitions_stmt final : public PT_table_ddl_stmt_base {
  public:
-  PT_load_index_partitions_stmt(MEM_ROOT *mem_root, Table_ident *table,
+  PT_load_index_partitions_stmt(const POS &pos, MEM_ROOT *mem_root,
+                                Table_ident *table,
                                 PT_adm_partition *partitions,
                                 List<Index_hint> *opt_cache_key_list,
                                 bool ignore_leaves)
-      : PT_table_ddl_stmt_base(mem_root),
+      : PT_table_ddl_stmt_base(pos, mem_root),
         m_table(table),
         m_partitions(partitions),
         m_opt_cache_key_list(opt_cache_key_list),
         m_ignore_leaves(ignore_leaves) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Table_ident *m_table;
   PT_adm_partition *m_partitions;
   List<Index_hint> *m_opt_cache_key_list;
   bool m_ignore_leaves;
 };
 
 class PT_load_index_stmt final : public PT_table_ddl_stmt_base {
  public:
-  PT_load_index_stmt(MEM_ROOT *mem_root,
+  PT_load_index_stmt(const POS &pos, MEM_ROOT *mem_root,
                      Mem_root_array<PT_preload_keys *> *preload_list)
-      : PT_table_ddl_stmt_base(mem_root), m_preload_list(preload_list) {}
+      : PT_table_ddl_stmt_base(pos, mem_root), m_preload_list(preload_list) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Mem_root_array<PT_preload_keys *> *m_preload_list;
 };
@@ -4854,13 +5044,13 @@ class PT_load_index_stmt final : public PT_table_ddl_stmt_base {
 class PT_json_table_column_for_ordinality final : public PT_json_table_column {
   typedef PT_json_table_column super;
 
  public:
-  explicit PT_json_table_column_for_ordinality(LEX_STRING name);
+  explicit PT_json_table_column_for_ordinality(const POS &pos, LEX_STRING name);
   ~PT_json_table_column_for_ordinality() override;
   bool do_contextualize(Parse_context *pc) override;
   Json_table_column *get_column() override { return m_column.get(); }
 
  private:
   unique_ptr_destroy_only<Json_table_column> m_column;
   const char *m_name;
 };
@@ -4868,19 +5058,19 @@ class PT_json_table_column_for_ordinality final : public PT_json_table_column {
 class PT_json_table_column_with_path final : public PT_json_table_column {
   typedef PT_json_table_column super;
 
  public:
   PT_json_table_column_with_path(
-      unique_ptr_destroy_only<Json_table_column> column, LEX_STRING name,
-      PT_type *type, const CHARSET_INFO *collation);
+      const POS &pos, unique_ptr_destroy_only<Json_table_column> column,
+      LEX_STRING name, PT_type *type, const CHARSET_INFO *collation);
   ~PT_json_table_column_with_path() override;
 
   bool do_contextualize(Parse_context *pc) override;
 
   Json_table_column *get_column() override { return m_column.get(); }
 
  private:
   unique_ptr_destroy_only<Json_table_column> m_column;
   const char *m_name;
   PT_type *m_type;
   const CHARSET_INFO *m_collation;
 };
@@ -4888,18 +5078,19 @@ class PT_json_table_column_with_path final : public PT_json_table_column {
 class PT_json_table_column_with_nested_path final
     : public PT_json_table_column {
   typedef PT_json_table_column super;
 
  public:
   PT_json_table_column_with_nested_path(
-      Item *path, Mem_root_array<PT_json_table_column *> *nested_cols)
-      : m_path(path), m_nested_columns(nested_cols) {}
+      const POS &pos, Item *path,
+      Mem_root_array<PT_json_table_column *> *nested_cols)
+      : super(pos), m_path(path), m_nested_columns(nested_cols) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
   Json_table_column *get_column() override { return m_column; }
 
  private:
   Item *m_path;
   const Mem_root_array<PT_json_table_column *> *m_nested_columns;
   Json_table_column *m_column{nullptr};
 };
@@ -4918,16 +5109,17 @@ template <typename Option_type, Option_type Tablespace_options::*Option>
 class PT_alter_tablespace_option final
     : public PT_alter_tablespace_option_base /* purecov: inspected */
 {
   typedef PT_alter_tablespace_option_base super;
 
  public:
-  explicit PT_alter_tablespace_option(Option_type value) : m_value(value) {}
+  explicit PT_alter_tablespace_option(const POS &pos, Option_type value)
+      : super(pos), m_value(value) {}
 
   bool do_contextualize(Alter_tablespace_parse_context *pc) override {
     pc->*Option = m_value;
     return super::do_contextualize(pc);
   }
 
  private:
   const Option_type m_value;
 };
@@ -4971,15 +5163,16 @@ typedef PT_alter_tablespace_option<decltype(Tablespace_options::encryption),
 class PT_alter_tablespace_option_nodegroup final
     : public PT_alter_tablespace_option_base /* purecov: inspected */
 {
   typedef PT_alter_tablespace_option_base super;
   typedef decltype(Tablespace_options::nodegroup_id) option_type;
 
  public:
-  explicit PT_alter_tablespace_option_nodegroup(option_type nodegroup_id)
-      : m_nodegroup_id(nodegroup_id) {}
+  explicit PT_alter_tablespace_option_nodegroup(const POS &pos,
+                                                option_type nodegroup_id)
+      : super(pos), m_nodegroup_id(nodegroup_id) {}
 
   bool do_contextualize(Alter_tablespace_parse_context *pc) override;
 
  private:
   const option_type m_nodegroup_id;
 };
@@ -4987,25 +5180,26 @@ class PT_alter_tablespace_option_nodegroup final
 class PT_alter_tablespace_option_comment final
     : public PT_alter_tablespace_option_base /* purecov: inspected */
 {
   typedef PT_alter_tablespace_option_base super;
   typedef decltype(Tablespace_options::ts_comment) option_type;
 
  public:
-  explicit PT_alter_tablespace_option_comment(option_type comment)
-      : m_comment(comment) {}
+  explicit PT_alter_tablespace_option_comment(const POS &pos,
+                                              option_type comment)
+      : super(pos), m_comment(comment) {}
 
   bool do_contextualize(Alter_tablespace_parse_context *pc) override {
     if (super::do_contextualize(pc))
       return true; /* purecov: inspected */  // OOM
 
     if (pc->ts_comment.str) {
       my_error(ER_FILEGROUP_OPTION_ONLY_ONCE, MYF(0), "COMMENT");
       return true;
     }
     pc->ts_comment = m_comment;
     return false;
   }
 
  private:
   const option_type m_comment;
 };
@@ -5013,25 +5207,26 @@ class PT_alter_tablespace_option_comment final
 class PT_alter_tablespace_option_engine final
     : public PT_alter_tablespace_option_base /* purecov: inspected */
 {
   typedef PT_alter_tablespace_option_base super;
   typedef decltype(Tablespace_options::engine_name) option_type;
 
  public:
-  explicit PT_alter_tablespace_option_engine(option_type engine_name)
-      : m_engine_name(engine_name) {}
+  explicit PT_alter_tablespace_option_engine(const POS &pos,
+                                             option_type engine_name)
+      : super(pos), m_engine_name(engine_name) {}
 
   bool do_contextualize(Alter_tablespace_parse_context *pc) override {
     if (super::do_contextualize(pc))
       return true; /* purecov: inspected */  // OOM
 
     if (pc->engine_name.str) {
       my_error(ER_FILEGROUP_OPTION_ONLY_ONCE, MYF(0), "STORAGE ENGINE");
       return true;
     }
     pc->engine_name = m_engine_name;
     return false;
   }
 
  private:
   const option_type m_engine_name;
 };
@@ -5039,30 +5234,30 @@ class PT_alter_tablespace_option_engine final
 class PT_alter_tablespace_option_file_block_size final
     : public PT_alter_tablespace_option_base /* purecov: inspected */
 {
   typedef PT_alter_tablespace_option_base super;
   typedef decltype(Tablespace_options::file_block_size) option_type;
 
  public:
   explicit PT_alter_tablespace_option_file_block_size(
-      option_type file_block_size)
-      : m_file_block_size(file_block_size) {}
+      const POS &pos, option_type file_block_size)
+      : super(pos), m_file_block_size(file_block_size) {}
 
   bool do_contextualize(Alter_tablespace_parse_context *pc) override {
     if (super::do_contextualize(pc))
       return true; /* purecov: inspected */  // OOM
 
     if (pc->file_block_size != 0) {
       my_error(ER_FILEGROUP_OPTION_ONLY_ONCE, MYF(0), "FILE_BLOCK_SIZE");
       return true;
     }
     pc->file_block_size = m_file_block_size;
     return false;
   }
 
  private:
   const option_type m_file_block_size;
 };
 
 /**
   Parse tree node for CREATE RESOURCE GROUP statement.
 */
@@ -5070,19 +5265,20 @@ class PT_alter_tablespace_option_file_block_size final
 class PT_create_resource_group final : public Parse_tree_root {
   resourcegroups::Sql_cmd_create_resource_group sql_cmd;
   const bool has_priority;
 
  public:
   PT_create_resource_group(
-      const LEX_CSTRING &name, const resourcegroups::Type type,
+      const POS &pos, const LEX_CSTRING &name, const resourcegroups::Type type,
       const Mem_root_array<resourcegroups::Range> *cpu_list,
       const Value_or_default<int> &opt_priority, bool enabled)
-      : sql_cmd(name, type, cpu_list,
+      : Parse_tree_root(pos),
+        sql_cmd(name, type, cpu_list,
                 opt_priority.is_default ? 0 : opt_priority.value, enabled),
         has_priority(!opt_priority.is_default) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 /**
   Parse tree node for ALTER RESOURCE GROUP statement.
 */
@@ -5090,19 +5286,20 @@ class PT_create_resource_group final : public Parse_tree_root {
 class PT_alter_resource_group final : public Parse_tree_root {
   resourcegroups::Sql_cmd_alter_resource_group sql_cmd;
 
  public:
-  PT_alter_resource_group(const LEX_CSTRING &name,
+  PT_alter_resource_group(const POS &pos, const LEX_CSTRING &name,
                           const Mem_root_array<resourcegroups::Range> *cpu_list,
                           const Value_or_default<int> &opt_priority,
                           const Value_or_default<bool> &enable, bool force)
-      : sql_cmd(name, cpu_list,
+      : Parse_tree_root(pos),
+        sql_cmd(name, cpu_list,
                 opt_priority.is_default ? 0 : opt_priority.value,
                 enable.is_default ? false : enable.value, force,
                 !enable.is_default) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 /**
   Parse tree node for DROP RESOURCE GROUP statement.
 */
@@ -5110,13 +5307,14 @@ class PT_alter_resource_group final : public Parse_tree_root {
 class PT_drop_resource_group final : public Parse_tree_root {
   resourcegroups::Sql_cmd_drop_resource_group sql_cmd;
 
  public:
-  PT_drop_resource_group(const LEX_CSTRING &resource_group_name, bool force)
-      : sql_cmd(resource_group_name, force) {}
+  PT_drop_resource_group(const POS &pos, const LEX_CSTRING &resource_group_name,
+                         bool force)
+      : Parse_tree_root(pos), sql_cmd(resource_group_name, force) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 /**
   Parse tree node for SET RESOURCE GROUP statement.
 */
@@ -5124,81 +5322,83 @@ class PT_drop_resource_group final : public Parse_tree_root {
 class PT_set_resource_group final : public Parse_tree_root {
   resourcegroups::Sql_cmd_set_resource_group sql_cmd;
 
  public:
-  PT_set_resource_group(const LEX_CSTRING &name,
+  PT_set_resource_group(const POS &pos, const LEX_CSTRING &name,
                         Mem_root_array<ulonglong> *thread_id_list)
-      : sql_cmd(name, thread_id_list) {}
+      : Parse_tree_root(pos), sql_cmd(name, thread_id_list) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 };
 
 class PT_explain_for_connection final : public Parse_tree_root {
  public:
-  explicit PT_explain_for_connection(my_thread_id thread_id)
-      : m_cmd(thread_id) {}
+  explicit PT_explain_for_connection(const POS &pos, my_thread_id thread_id)
+      : Parse_tree_root(pos), m_cmd(thread_id) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Sql_cmd_explain_other_thread m_cmd;
 };
 
 class PT_explain : public Parse_tree_root {
  public:
-  PT_explain(Explain_format_type format, bool is_analyze,
+  PT_explain(const POS &pos, Explain_format_type format, bool is_analyze,
              bool is_explicit_format, Parse_tree_root *explainable_stmt,
              std::optional<std::string_view> explain_into_variable_name)
-      : m_format(format),
+      : Parse_tree_root(pos),
+        m_format(format),
         m_analyze(is_analyze),
         m_explicit_format(is_explicit_format),
         m_explainable_stmt(explainable_stmt),
         m_explain_into_variable_name(explain_into_variable_name) {}
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   const Explain_format_type m_format;
   const bool m_analyze;
   const bool m_explicit_format;
   Parse_tree_root *const m_explainable_stmt;
   std::optional<std::string_view> m_explain_into_variable_name;
 };
 
 class PT_load_table final : public Parse_tree_root {
  public:
-  PT_load_table(enum_filetype filetype, thr_lock_type lock_type,
+  PT_load_table(const POS &pos, enum_filetype filetype, thr_lock_type lock_type,
                 bool is_local_file, enum_source_type, const LEX_STRING filename,
                 ulong, bool, On_duplicate on_duplicate, Table_ident *table,
                 List<String> *opt_partitions, const CHARSET_INFO *opt_charset,
                 String *opt_xml_rows_identified_by,
                 const Field_separators &opt_field_separators,
                 const Line_separators &opt_line_separators,
                 ulong opt_ignore_lines, PT_item_list *opt_fields_or_vars,
                 PT_item_list *opt_set_fields, PT_item_list *opt_set_exprs,
                 List<String> *opt_set_expr_strings, bool)
-      : m_cmd(filetype, is_local_file, filename, on_duplicate, table,
+      : Parse_tree_root(pos),
+        m_cmd(filetype, is_local_file, filename, on_duplicate, table,
               opt_partitions, opt_charset, opt_xml_rows_identified_by,
               opt_field_separators, opt_line_separators, opt_ignore_lines,
               opt_fields_or_vars ? &opt_fields_or_vars->value : nullptr,
               opt_set_fields ? &opt_set_fields->value : nullptr,
               opt_set_exprs ? &opt_set_exprs->value : nullptr,
               opt_set_expr_strings),
         m_lock_type(lock_type) {
     assert((opt_set_fields == nullptr) ^ (opt_set_exprs != nullptr));
     assert(opt_set_fields == nullptr ||
            opt_set_fields->value.size() == opt_set_exprs->value.size());
   }
 
   Sql_cmd *make_cmd(THD *thd) override;
 
  private:
   Sql_cmd_load_table m_cmd;
 
   const thr_lock_type m_lock_type;
 };
 
 /**
   Top-level node for the SHUTDOWN statement
 
   @ingroup ptn_stmt
 */
@@ -5214,10 +5414,11 @@ class PT_restart_server final : public Parse_tree_root {
 class PT_install_component final : public Parse_tree_root {
  private:
   Mem_root_array_YY<LEX_STRING> m_urns;
   List<PT_install_component_set_element> *m_set_elements;
 
  public:
-  PT_install_component(THD *thd, const Mem_root_array_YY<LEX_STRING> urns,
+  PT_install_component(const POS &pos, THD *thd,
+                       Mem_root_array_YY<LEX_STRING> urns,
                        List<PT_install_component_set_element> *set_elements);
   Sql_cmd *make_cmd(THD *thd) override;
 };
diff --git a/sql/parse_tree_partitions.cc b/sql/parse_tree_partitions.cc
index b68ad2250d0..6cfdbab0643 100644
--- a/sql/parse_tree_partitions.cc
+++ b/sql/parse_tree_partitions.cc
@@ -52,51 +52,51 @@ Partition_parse_context::Partition_parse_context(
 bool PT_subpartition::do_contextualize(Partition_parse_context *pc) {
   partition_info *const part_info = pc->part_info;
 
   if (part_info->use_default_subpartitions &&
       part_info->partitions.elements >= 2) {
     /*
       create table t1 (a int)
       partition by list (a) subpartition by hash (a)
       (partition p0 values in (1),
        partition p1 values in (2) subpartition sp11);
       causes us to arrive since we are on the second
       partition, but still use_default_subpartitions
       is set. When we come here we're processing at least
       the second partition (the current partition processed
       have already been put into the partitions list.
     */
-    error(pc, pos, ER_THD(pc->thd, ER_PARTITION_WRONG_NO_SUBPART_ERROR));
+    error(pc, m_errpos, ER_THD(pc->thd, ER_PARTITION_WRONG_NO_SUBPART_ERROR));
     return true;
   }
 
   auto *sub_p_elem =
       new (pc->mem_root) partition_element(pc->current_partition);
   if (sub_p_elem == nullptr) return true;
 
   if (check_string_char_length(to_lex_cstring(name), "", NAME_CHAR_LEN,
                                system_charset_info, true)) {
     my_error(ER_TOO_LONG_IDENT, MYF(0), name);
     return true;
   }
 
   sub_p_elem->partition_name = name;
 
   part_info->use_default_subpartitions = false;
   part_info->use_default_num_subpartitions = false;
   pc->count_curr_subparts++;
 
   Partition_parse_context subpart_pc(pc->thd, part_info, pc->current_partition,
                                      sub_p_elem,
                                      pc->is_add_or_reorganize_partition);
 
   if (options != nullptr) {
     for (auto option : *options) {
       if (option->contextualize(&subpart_pc)) return true;
     }
     if (sub_p_elem->engine_type != nullptr)
       part_info->default_engine_type = sub_p_elem->engine_type;
   }
   if (pc->current_partition->subpartitions.push_back(sub_p_elem)) return true;
 
   return false;
 }
@@ -104,11 +104,11 @@ bool PT_subpartition::do_contextualize(Partition_parse_context *pc) {
 bool PT_part_value_item_max::do_contextualize(Partition_parse_context *pc) {
   if (super::do_contextualize(pc)) return true;
 
   if (pc->part_info->part_type == partition_type::LIST) {
-    error(pc, pos, ER_THD(pc->thd, ER_MAXVALUE_IN_VALUES_IN));
+    error(pc, m_pos, ER_THD(pc->thd, ER_MAXVALUE_IN_VALUES_IN));
     return true;
   }
   if (pc->add_max_value()) return true;
 
   return false;
 }
@@ -116,13 +116,13 @@ bool PT_part_value_item_max::do_contextualize(Partition_parse_context *pc) {
 bool PT_part_value_item_expr::do_contextualize(Partition_parse_context *pc) {
   LEX *const lex = pc->thd->lex;
   lex->safe_to_cache_query = true;
   if (super::do_contextualize(pc) || expr->itemize(pc, &expr)) return true;
 
   if (!lex->safe_to_cache_query) {
-    error(pc, pos, ER_THD(pc->thd, ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR));
+    error(pc, m_pos, ER_THD(pc->thd, ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR));
     return true;
   }
   if (pc->add_column_list_value(pc->thd, expr)) return true;
 
   return false;
 }
@@ -163,24 +163,24 @@ bool PT_part_value_item_list_paren::do_contextualize(
 bool PT_part_values_in_item::do_contextualize(Partition_parse_context *pc) {
   if (super::do_contextualize(pc) || item->contextualize(pc)) return true;
 
   partition_info *const part_info = pc->part_info;
   part_info->print_debug("part_values_in: part_value_item_list_paren", nullptr);
 
   if (part_info->num_columns != 1U) {
     if (!pc->is_add_or_reorganize_partition || part_info->num_columns == 0 ||
         part_info->num_columns > MAX_REF_PARTS) {
       part_info->print_debug("Kilroy III", nullptr);
-      error(pc, pos, ER_THD(pc->thd, ER_PARTITION_COLUMN_LIST_ERROR));
+      error(pc, m_errpos, ER_THD(pc->thd, ER_PARTITION_COLUMN_LIST_ERROR));
       return true;
     }
     /*
       Reorganize the current large array into a list of small
       arrays with one entry in each array. This can happen
       in the first partition of an ALTER TABLE statement where
       we ADD or REORGANIZE partitions. Also can only happen
       for LIST [COLUMNS] partitions.
     */
     if (pc->reorganize_into_single_field_col_val()) return true;
   }
   return false;
 }
@@ -188,13 +188,13 @@ bool PT_part_values_in_item::do_contextualize(Partition_parse_context *pc) {
 bool PT_part_values_in_list::do_contextualize(Partition_parse_context *pc) {
   if (super::do_contextualize(pc)) return true;
 
   for (auto item : *list) {
     if (item->contextualize(pc)) return true;
   }
 
   if (pc->part_info->num_columns < 2U) {
-    error(pc, pos, ER_THD(pc->thd, ER_ROW_SINGLE_PARTITION_FIELD_ERROR));
+    error(pc, m_errpos, ER_THD(pc->thd, ER_ROW_SINGLE_PARTITION_FIELD_ERROR));
     return true;
   }
   return false;
 }
@@ -202,117 +202,119 @@ bool PT_part_values_in_list::do_contextualize(Partition_parse_context *pc) {
 bool PT_part_definition::do_contextualize(Partition_parse_context *pc) {
   assert(pc->current_partition == nullptr && pc->curr_part_elem == nullptr);
 
   if (super::do_contextualize(pc)) return true;
 
   partition_info *const part_info = pc->part_info;
 
   auto *const curr_part = new (pc->thd->mem_root) partition_element();
   if (curr_part == nullptr) return true;
 
   Partition_parse_context ppc(pc->thd, part_info, curr_part, curr_part,
                               pc->is_add_or_reorganize_partition);
 
   if (!curr_part || part_info->partitions.push_back(curr_part)) return true;
   curr_part->part_state = PART_NORMAL;
   part_info->use_default_partitions = false;
   part_info->use_default_num_partitions = false;
 
   if (check_string_char_length(to_lex_cstring(name), "", NAME_CHAR_LEN,
                                system_charset_info, true)) {
     my_error(ER_TOO_LONG_IDENT, MYF(0), name.str);
     return true;
   }
 
   curr_part->partition_name = name.str;
 
   switch (type) {
     case partition_type::HASH: {
       if (part_info->part_type == partition_type::NONE)
         part_info->part_type = partition_type::HASH;
       else if (part_info->part_type == partition_type::RANGE) {
-        errorf(&ppc, pos, ER_THD(pc->thd, ER_PARTITION_REQUIRES_VALUES_ERROR),
-               "RANGE", "LESS THAN");
+        errorf(&ppc, m_errpos,
+               ER_THD(pc->thd, ER_PARTITION_REQUIRES_VALUES_ERROR), "RANGE",
+               "LESS THAN");
         return true;
       } else if (part_info->part_type == partition_type::LIST) {
-        errorf(&ppc, pos, ER_THD(pc->thd, ER_PARTITION_REQUIRES_VALUES_ERROR),
-               "LIST", "IN");
+        errorf(&ppc, m_errpos,
+               ER_THD(pc->thd, ER_PARTITION_REQUIRES_VALUES_ERROR), "LIST",
+               "IN");
         return true;
       }
     } break;
     case partition_type::RANGE: {
       if (part_info->part_type == partition_type::NONE)
         part_info->part_type = partition_type::RANGE;
       else if (part_info->part_type != partition_type::RANGE) {
         my_error(ER_PARTITION_WRONG_VALUES_ERROR, MYF(0), "RANGE", "LESS THAN");
         return true;
       }
 
       if (opt_part_values == nullptr)  // MAX_VALUE_SYM
       {
         if (part_info->num_columns && part_info->num_columns != 1U) {
           part_info->print_debug("Kilroy II", nullptr);
           error(&ppc, values_pos,
                 ER_THD(pc->thd, ER_PARTITION_COLUMN_LIST_ERROR));
           return true;
         } else
           part_info->num_columns = 1U;
         if (ppc.init_column_part() || ppc.add_max_value()) return true;
       } else if (opt_part_values->contextualize(&ppc))
         return true;
     } break;
     case partition_type::LIST: {
       if (part_info->part_type == partition_type::NONE)
         part_info->part_type = partition_type::LIST;
       else if (part_info->part_type != partition_type::LIST) {
         my_error(ER_PARTITION_WRONG_VALUES_ERROR, MYF(0), "LIST", "IN");
         return true;
       }
 
       if (opt_part_values->contextualize(&ppc)) return true;
     } break;
     default:
       assert(false);
-      error(&ppc, pos, ER_THD(pc->thd, ER_UNKNOWN_ERROR));
+      error(&ppc, m_errpos, ER_THD(pc->thd, ER_UNKNOWN_ERROR));
       return true;
   }
 
   if (opt_part_options != nullptr) {
     for (auto option : *opt_part_options) {
       if (option->contextualize(&ppc)) return true;
     }
     if (curr_part->engine_type != nullptr)
       part_info->default_engine_type = curr_part->engine_type;
   }
 
   if (opt_sub_partitions == nullptr) {
     if (part_info->num_subparts != 0 && !part_info->use_default_subpartitions) {
       /*
         We come here when we have defined subpartitions on the first
         partition but not on all the subsequent partitions.
       */
       error(&ppc, sub_partitions_pos,
             ER_THD(pc->thd, ER_PARTITION_WRONG_NO_SUBPART_ERROR));
       return true;
     }
   } else {
     for (auto subpartition : *opt_sub_partitions) {
       if (subpartition->contextualize(&ppc)) return true;
     }
 
     if (part_info->num_subparts != 0) {
       if (part_info->num_subparts != ppc.count_curr_subparts) {
         error(&ppc, sub_partitions_pos,
               ER_THD(pc->thd, ER_PARTITION_WRONG_NO_SUBPART_ERROR));
         return true;
       }
     } else if (ppc.count_curr_subparts > 0) {
       if (part_info->partitions.elements > 1) {
         error(&ppc, sub_partitions_pos,
               ER_THD(pc->thd, ER_PARTITION_WRONG_NO_SUBPART_ERROR));
         return true;
       }
       part_info->num_subparts = ppc.count_curr_subparts;
     }
   }
   return false;
 }
diff --git a/sql/parse_tree_partitions.h b/sql/parse_tree_partitions.h
index 48a5a2629f2..83952d92eba 100644
--- a/sql/parse_tree_partitions.h
+++ b/sql/parse_tree_partitions.h
@@ -81,538 +81,571 @@ typedef Parse_tree_node_tmpl<Partition_parse_context> Parse_tree_part_node;
 
   @ingroup ptn_part_options
 */
-class PT_partition_option : public Parse_tree_part_node {};
+class PT_partition_option : public Parse_tree_part_node {
+ protected:
+  explicit PT_partition_option(const POS &pos) : Parse_tree_part_node(pos) {}
+};
 
 /**
   Node for the @SQL{COMMENT [=] @<string@>} partition option
 
   @ingroup ptn_part_options
 */
 class PT_partition_comment : public PT_partition_option {
   typedef PT_partition_option super;
 
   char *comment;
 
  public:
-  explicit PT_partition_comment(char *comment) : comment(comment) {}
+  explicit PT_partition_comment(const POS &pos, char *comment)
+      : super(pos), comment(comment) {}
 
   bool do_contextualize(Partition_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
 
     pc->curr_part_elem->part_comment = comment;
     return false;
   }
 };
 
 /**
   Node for the @SQL{INDEX DIRECTORY [=] @<string@>} partition option
 
   @ingroup ptn_part_options
 */
 class PT_partition_index_directory : public PT_partition_option {
   typedef PT_partition_option super;
 
   const char *index_directory;
 
  public:
-  explicit PT_partition_index_directory(const char *index_directory)
-      : index_directory(index_directory) {}
+  explicit PT_partition_index_directory(const POS &pos,
+                                        const char *index_directory)
+      : super(pos), index_directory(index_directory) {}
 
   bool do_contextualize(Partition_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
 
     pc->curr_part_elem->index_file_name = index_directory;
     return false;
   }
 };
 
 /**
   Node for the @SQL{DATA DIRECTORY [=] @<string@>} partition option
 
   @ingroup ptn_part_options
 */
 class PT_partition_data_directory : public PT_partition_option {
   typedef PT_partition_option super;
 
   const char *data_directory;
 
  public:
-  explicit PT_partition_data_directory(const char *data_directory)
-      : data_directory(data_directory) {}
+  explicit PT_partition_data_directory(const POS &pos,
+                                       const char *data_directory)
+      : super(pos), data_directory(data_directory) {}
 
   bool do_contextualize(Partition_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
 
     pc->curr_part_elem->data_file_name = data_directory;
     return false;
   }
 };
 
 /**
   Node for the @SQL{MIN_ROWS [=] @<integer@>} partition option
 
   @ingroup ptn_part_options
 */
 class PT_partition_min_rows : public PT_partition_option {
   typedef PT_partition_option super;
 
   ha_rows min_rows;
 
  public:
-  explicit PT_partition_min_rows(ha_rows min_rows) : min_rows(min_rows) {}
+  explicit PT_partition_min_rows(const POS &pos, ha_rows min_rows)
+      : super(pos), min_rows(min_rows) {}
 
   bool do_contextualize(Partition_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
 
     pc->curr_part_elem->part_min_rows = min_rows;
     return false;
   }
 };
 
 /**
   Node for the @SQL{MAX_ROWS [=] @<integer@>} partition option
 
   @ingroup ptn_part_options
 */
 class PT_partition_max_rows : public PT_partition_option {
   typedef PT_partition_option super;
 
   ha_rows max_rows;
 
  public:
-  explicit PT_partition_max_rows(ha_rows max_rows) : max_rows(max_rows) {}
+  explicit PT_partition_max_rows(const POS &pos, ha_rows max_rows)
+      : super(pos), max_rows(max_rows) {}
 
   bool do_contextualize(Partition_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
 
     pc->curr_part_elem->part_max_rows = max_rows;
     return false;
   }
 };
 
 /**
   Node for the @SQL{NODEGROUP [=] @<integer@>} partition option
 
   @ingroup ptn_part_options
 */
 class PT_partition_nodegroup : public PT_partition_option {
   typedef PT_partition_option super;
 
   uint16 nodegroup;
 
  public:
-  explicit PT_partition_nodegroup(uint16 nodegroup) : nodegroup(nodegroup) {}
+  explicit PT_partition_nodegroup(const POS &pos, uint16 nodegroup)
+      : super(pos), nodegroup(nodegroup) {}
 
   bool do_contextualize(Partition_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
 
     pc->curr_part_elem->nodegroup_id = nodegroup;
     return false;
   }
 };
 
 /**
   Node for the @SQL{[STORAGE] ENGINE [=] @<identifier|string@>} partition option
 
   @ingroup ptn_part_options
 */
 class PT_partition_engine : public PT_partition_option {
   typedef PT_partition_option super;
 
  public:
   const LEX_CSTRING name;
 
-  explicit PT_partition_engine(const LEX_CSTRING &name) : name(name) {}
+  explicit PT_partition_engine(const POS &pos, const LEX_CSTRING &name)
+      : super(pos), name(name) {}
 
   bool do_contextualize(Partition_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
 
     return resolve_engine(pc->thd, name, false,  // partition can't be temporary
                           false, &pc->curr_part_elem->engine_type);
   }
 };
 
 /**
   Node for the @SQL{TABLESPACE [=] @<identifier@>} partition option
 
   @ingroup ptn_part_options
 */
 class PT_partition_tablespace : public PT_partition_option {
   typedef PT_partition_option super;
 
   const char *tablespace;
 
  public:
-  explicit PT_partition_tablespace(const char *tablespace)
-      : tablespace(tablespace) {}
+  explicit PT_partition_tablespace(const POS &pos, const char *tablespace)
+      : super(pos), tablespace(tablespace) {}
 
   bool do_contextualize(Partition_parse_context *pc) override {
     if (super::do_contextualize(pc)) return true;
 
     pc->curr_part_elem->tablespace_name = tablespace;
     return false;
   }
 };
 
 /**
   Node for the @SQL{SUBRAPTITION} clause of @SQL{CREATE/ALTER TABLE}
 
   @ingroup ptn_partitioning
 */
 class PT_subpartition : public Parse_tree_part_node {
-  const POS pos;
+  const POS m_errpos;
   const char *name;
   const Mem_root_array<PT_partition_option *> *options;
 
  public:
-  PT_subpartition(const POS &pos, const char *name,
+  PT_subpartition(const POS &pos, const POS &errpos, const char *name,
                   Mem_root_array<PT_partition_option *> *options)
-      : pos(pos), name(name), options(options) {}
+      : Parse_tree_part_node(pos),
+        m_errpos(errpos),
+        name(name),
+        options(options) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Base class for partition value nodes: @SQL{MAX_VALUE} values or expressions
 
   @ingroup ptn_partitioning
 */
-class PT_part_value_item : public Parse_tree_part_node {};
+class PT_part_value_item : public Parse_tree_part_node {
+ protected:
+  explicit PT_part_value_item(const POS &pos) : Parse_tree_part_node(pos) {}
+};
 
 /**
   Node for the @SQL{MAX_VALUE} partition value in @SQL{CREATE/ALTER TABLE}
 
   @ingroup ptn_partitioning
 */
 class PT_part_value_item_max : public PT_part_value_item {
   typedef PT_part_value_item super;
 
-  const POS pos;
-
  public:
-  explicit PT_part_value_item_max(const POS &pos) : pos(pos) {}
+  explicit PT_part_value_item_max(const POS &pos) : super(pos) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for the partitioning expression in @SQL{CREATE/ALTER TABLE}
 
   @ingroup ptn_partitioning
 */
 class PT_part_value_item_expr : public PT_part_value_item {
   typedef PT_part_value_item super;
 
-  const POS pos;
   Item *expr;
 
  public:
   explicit PT_part_value_item_expr(const POS &pos, Item *expr)
-      : pos(pos), expr(expr) {}
+      : super(pos), expr(expr) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Base class for @SQL{VALUES} partitioning clauses
 
   @ingroup ptn_partitioning
 */
-class PT_part_values : public Parse_tree_part_node {};
+class PT_part_values : public Parse_tree_part_node {
+ protected:
+  explicit PT_part_values(const POS &pos) : Parse_tree_part_node(pos) {}
+};
 
 /**
   Node for a list of partitioning values in @SQL{VALUES} clauses
 
   @ingroup ptn_partitioning
 */
 class PT_part_value_item_list_paren : public PT_part_values {
   typedef PT_part_values super;
 
   Mem_root_array<PT_part_value_item *> *values;
   const POS paren_pos;
 
  public:
   explicit PT_part_value_item_list_paren(
-      Mem_root_array<PT_part_value_item *> *values, const POS &paren_pos)
-      : values(values), paren_pos(paren_pos) {}
+      const POS &pos, Mem_root_array<PT_part_value_item *> *values,
+      const POS &paren_pos)
+      : super(pos), values(values), paren_pos(paren_pos) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for a list of partitioning values in the @SQL{VALUES IN} clause
 
   @ingroup ptn_partitioning
 */
 class PT_part_values_in_item : public PT_part_values {
   typedef PT_part_values super;
 
-  const POS pos;
+  const POS m_errpos;
   PT_part_value_item_list_paren *item;
 
  public:
-  explicit PT_part_values_in_item(const POS &pos,
+  explicit PT_part_values_in_item(const POS &pos, const POS &errpos,
                                   PT_part_value_item_list_paren *item)
-      : pos(pos), item(item) {}
+      : super(pos), m_errpos(errpos), item(item) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for a list of partitioning values in the @SQL{VALUES IN} clause
 
   @ingroup ptn_partitioning
 */
 class PT_part_values_in_list : public PT_part_values {
   typedef PT_part_values super;
 
-  const POS pos;
+  const POS m_errpos;
   Mem_root_array<PT_part_value_item_list_paren *> *list;
 
  public:
   explicit PT_part_values_in_list(
-      const POS &pos, Mem_root_array<PT_part_value_item_list_paren *> *list)
-      : pos(pos), list(list) {}
+      const POS &pos, const POS &errpos,
+      Mem_root_array<PT_part_value_item_list_paren *> *list)
+      : super(pos), m_errpos(errpos), list(list) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{PARTITION} clause of CREATE/ALTER TABLE
 
   @ingroup ptn_partitioning
 */
 class PT_part_definition : public Parse_tree_part_node {
   typedef Parse_tree_part_node super;
 
-  const POS pos;
+  const POS m_errpos;
   const LEX_STRING name;
   partition_type type;
   PT_part_values *const opt_part_values;
   const POS values_pos;
   Mem_root_array<PT_partition_option *> *opt_part_options;
   Mem_root_array<PT_subpartition *> *opt_sub_partitions;
   const POS sub_partitions_pos;
 
  public:
-  PT_part_definition(const POS &pos, const LEX_STRING &name,
+  PT_part_definition(const POS &pos, const POS &errpos, const LEX_STRING &name,
                      partition_type type, PT_part_values *const opt_part_values,
                      const POS &values_pos,
                      Mem_root_array<PT_partition_option *> *opt_part_options,
                      Mem_root_array<PT_subpartition *> *opt_sub_partitions,
                      const POS &sub_partitions_pos)
-      : pos(pos),
+      : super(pos),
+        m_errpos(errpos),
         name(name),
         type(type),
         opt_part_values(opt_part_values),
         values_pos(values_pos),
         opt_part_options(opt_part_options),
         opt_sub_partitions(opt_sub_partitions),
         sub_partitions_pos(sub_partitions_pos) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Base class for all subpartitioning clause nodes
 
   @ingroup ptn_partitioning
 */
-class PT_sub_partition : public Parse_tree_part_node {};
+class PT_sub_partition : public Parse_tree_part_node {
+ protected:
+  explicit PT_sub_partition(const POS &pos) : Parse_tree_part_node(pos) {}
+};
 
 /**
   Node for the @SQL{SUBRAPTITION BY HASH} definition clause
 
   @ingroup ptn_partitioning
 */
 class PT_sub_partition_by_hash : public PT_sub_partition {
   typedef PT_sub_partition super;
 
   const bool is_linear;
   const POS hash_pos;
   Item *hash;
   const uint opt_num_subparts;
 
  public:
-  PT_sub_partition_by_hash(bool is_linear, const POS &hash_pos, Item *hash,
-                           uint opt_num_subparts)
-      : is_linear(is_linear),
+  PT_sub_partition_by_hash(const POS &pos, bool is_linear, const POS &hash_pos,
+                           Item *hash, uint opt_num_subparts)
+      : super(pos),
+        is_linear(is_linear),
         hash_pos(hash_pos),
         hash(hash),
         opt_num_subparts(opt_num_subparts) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{SUBRAPTITION BY KEY} definition clause
 
   @ingroup ptn_partitioning
 */
 class PT_sub_partition_by_key : public PT_sub_partition {
   typedef PT_sub_partition super;
 
   const bool is_linear;
   enum_key_algorithm key_algo;
   List<char> *field_names;
   const uint opt_num_subparts;
 
  public:
-  PT_sub_partition_by_key(bool is_linear, enum_key_algorithm key_algo,
-                          List<char> *field_names, const uint opt_num_subparts)
-      : is_linear(is_linear),
+  PT_sub_partition_by_key(const POS &pos, bool is_linear,
+                          enum_key_algorithm key_algo, List<char> *field_names,
+                          const uint opt_num_subparts)
+      : super(pos),
+        is_linear(is_linear),
         key_algo(key_algo),
         field_names(field_names),
         opt_num_subparts(opt_num_subparts) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 class PT_part_type_def : public Parse_tree_part_node {
  protected:
+  explicit PT_part_type_def(const POS &pos) : Parse_tree_part_node(pos) {}
+
   bool set_part_field_list(Partition_parse_context *pc, List<char> *list);
 
   bool itemize_part_expr(Partition_parse_context *pc, const POS &pos,
                          Item **item);
 };
 
 /**
   Node for the @SQL{PARTITION BY [LINEAR] KEY} type clause
 
   @ingroup ptn_partitioning
 */
 class PT_part_type_def_key : public PT_part_type_def {
   typedef PT_part_type_def super;
 
   const bool is_linear;
   const enum_key_algorithm key_algo;
   List<char> *const opt_columns;
 
  public:
-  PT_part_type_def_key(bool is_linear, enum_key_algorithm key_algo,
-                       List<char> *opt_columns)
-      : is_linear(is_linear), key_algo(key_algo), opt_columns(opt_columns) {}
+  PT_part_type_def_key(const POS &pos, bool is_linear,
+                       enum_key_algorithm key_algo, List<char> *opt_columns)
+      : super(pos),
+        is_linear(is_linear),
+        key_algo(key_algo),
+        opt_columns(opt_columns) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{PARTITION BY [LINEAR] HASH} type clause
 
   @ingroup ptn_partitioning
 */
 class PT_part_type_def_hash : public PT_part_type_def {
   typedef PT_part_type_def super;
 
   const bool is_linear;
   const POS expr_pos;
   Item *expr;
 
  public:
-  PT_part_type_def_hash(bool is_linear, const POS &expr_pos, Item *expr)
-      : is_linear(is_linear), expr_pos(expr_pos), expr(expr) {}
+  PT_part_type_def_hash(const POS &pos, bool is_linear, const POS &expr_pos,
+                        Item *expr)
+      : super(pos), is_linear(is_linear), expr_pos(expr_pos), expr(expr) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{PARTITION BY RANGE (@<expression@>) } type clause
 
   @ingroup ptn_partitioning
 */
 class PT_part_type_def_range_expr : public PT_part_type_def {
   typedef PT_part_type_def super;
 
   const POS expr_pos;
   Item *expr;
 
  public:
-  PT_part_type_def_range_expr(const POS &expr_pos, Item *expr)
-      : expr_pos(expr_pos), expr(expr) {}
+  PT_part_type_def_range_expr(const POS &pos, const POS &expr_pos, Item *expr)
+      : super(pos), expr_pos(expr_pos), expr(expr) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{PARTITION BY RANGE COLUMNS (@<ident list@>) } type clause
 
   @ingroup ptn_partitioning
 */
 class PT_part_type_def_range_columns : public PT_part_type_def {
   typedef PT_part_type_def super;
 
   List<char> *const columns;
 
  public:
-  explicit PT_part_type_def_range_columns(List<char> *columns)
-      : columns(columns) {}
+  explicit PT_part_type_def_range_columns(const POS &pos, List<char> *columns)
+      : super(pos), columns(columns) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{PARTITION BY LIST (@<expression@>) } type clause
 
   @ingroup ptn_partitioning
 */
 class PT_part_type_def_list_expr : public PT_part_type_def {
   typedef PT_part_type_def super;
 
   const POS expr_pos;
   Item *expr;
 
  public:
-  PT_part_type_def_list_expr(const POS &expr_pos, Item *expr)
-      : expr_pos(expr_pos), expr(expr) {}
+  PT_part_type_def_list_expr(const POS &pos, const POS &expr_pos, Item *expr)
+      : super(pos), expr_pos(expr_pos), expr(expr) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{PARTITION BY LIST COLUMNS (@<ident list@>) } type clause
 
   @ingroup ptn_partitioning
 */
 class PT_part_type_def_list_columns : public PT_part_type_def {
   typedef PT_part_type_def super;
 
   List<char> *const columns;
 
  public:
-  explicit PT_part_type_def_list_columns(List<char> *columns)
-      : columns(columns) {}
+  explicit PT_part_type_def_list_columns(const POS &pos, List<char> *columns)
+      : super(pos), columns(columns) {}
 
   bool do_contextualize(Partition_parse_context *pc) override;
 };
 
 /**
   Node for the @SQL{PARTITION} definition clause
 
   @ingroup ptn_partitioning
 */
 class PT_partition : public Parse_tree_node {
   typedef Parse_tree_node super;
 
   PT_part_type_def *const part_type_def;
   const uint opt_num_parts;
   PT_sub_partition *const opt_sub_part;
   const POS part_defs_pos;
   Mem_root_array<PT_part_definition *> *part_defs;
 
  public:
   partition_info part_info;
 
  public:
-  PT_partition(PT_part_type_def *part_type_def, uint opt_num_parts,
-               PT_sub_partition *opt_sub_part, const POS &part_defs_pos,
+  PT_partition(const POS &pos, PT_part_type_def *part_type_def,
+               uint opt_num_parts, PT_sub_partition *opt_sub_part,
+               const POS &part_defs_pos,
                Mem_root_array<PT_part_definition *> *part_defs)
-      : part_type_def(part_type_def),
+      : super(pos),
+        part_type_def(part_type_def),
         opt_num_parts(opt_num_parts),
         opt_sub_part(opt_sub_part),
         part_defs_pos(part_defs_pos),
         part_defs(part_defs) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
 
 #endif /* PARSE_TREE_PARTITIONS_INCLUDED */
diff --git a/sql/parse_tree_window.h b/sql/parse_tree_window.h
index ed44f057dc8..e6c34371d7c 100644
--- a/sql/parse_tree_window.h
+++ b/sql/parse_tree_window.h
@@ -34,38 +34,38 @@ class PT_order_list;
 /**
   Parse tree node for a window; just a shallow wrapper for
   class Window, q.v.
 */
 class PT_window : public Parse_tree_node, public Window {
   typedef Parse_tree_node super;
 
  public:
-  PT_window(PT_order_list *partition_by, PT_order_list *order_by,
-            PT_frame *frame)
-      : Window(partition_by, order_by, frame) {}
+  PT_window(const POS &pos, PT_order_list *partition_by,
+            PT_order_list *order_by, PT_frame *frame)
+      : super(pos), Window(partition_by, order_by, frame) {}
 
-  PT_window(PT_order_list *partition_by, PT_order_list *order_by,
-            PT_frame *frame, Item_string *inherit)
-      : Window(partition_by, order_by, frame, inherit) {}
+  PT_window(const POS &pos, PT_order_list *partition_by,
+            PT_order_list *order_by, PT_frame *frame, Item_string *inherit)
+      : super(pos), Window(partition_by, order_by, frame, inherit) {}
 
-  PT_window(Item_string *name) : Window(name) {}
+  PT_window(const POS &pos, Item_string *name) : super(pos), Window(name) {}
 
   bool do_contextualize(Parse_context *pc) override;
 };
 
 /**
   Parse tree node for a list of window definitions corresponding
   to a \<window clause\> in SQL 2003.
 */
 class PT_window_list : public Parse_tree_node {
   typedef Parse_tree_node super;
   List<Window> m_windows;
 
  public:
-  PT_window_list() = default;
+  explicit PT_window_list(const POS &pos) : super(pos) {}
 
   bool do_contextualize(Parse_context *pc) override;
 
   bool push_back(PT_window *w) { return m_windows.push_back(w); }
 };
 
 #endif  // SQL_PARSE_TREE_WINDOW_INCLUDED
diff --git a/sql/sql_resolver.cc b/sql/sql_resolver.cc
index 0055c08881c..d76bea75df9 100644
--- a/sql/sql_resolver.cc
+++ b/sql/sql_resolver.cc
@@ -6822,183 +6822,184 @@ struct Lifted_fields_map {
   @param      thd              session context
   @param      derived          the derived table being created in the transform
   @param      lifted_where     the WHERE condition we move out to the JOIN cond
   @param[out] lifted_fields    mapping of where inner fields end up in the
                                derived table's fields.
   @param[out] added_card_check set to true if we are adding a cardinality check
 */
 bool Query_block::decorrelate_derived_scalar_subquery_pre(
     THD *thd, Table_ref *derived, Item *lifted_where,
     Lifted_fields_map *lifted_fields, bool *added_card_check) {
   const uint hidden_fields = CountHiddenFields(fields);
   const uint first_non_hidden = hidden_fields;
   assert((fields.size() - hidden_fields) == 1);  // scalar subquery
 
 #ifndef NDEBUG
   // Hidden fields should come before non-hidden.
   for (uint i = 0; i < fields.size(); i++) {
     assert((fields[i]->hidden) != (i >= hidden_fields));
   }
 #endif
 
   Item_field *selected_field = nullptr;
   if (fields[first_non_hidden]->type() == Item::FIELD_ITEM) {
     selected_field = down_cast<Item_field *>(fields[first_non_hidden]);
   }
 
   // Collect referenced fields, a mixture of inner fields and the correlated
   // fields.
   Item::Collect_item_fields_or_refs info{&lifted_fields->m_fields};
   if (lifted_where->walk(&Item::collect_item_field_or_ref_processor,
                          enum_walk::PREFIX | enum_walk::POSTFIX,
                          pointer_cast<uchar *>(&info)))
     return true;
 
   // Run through the inner fields and add them to the derived table's
   // SELECT list if not already present (only one can be present, since it's a
   // scalar subquery), and make a note of where in the derived table's Field
   // list they are positioned: we need that information in
   // Query_block::decorrelate_derived_scalar_subquery_post
   Item *field_or_ref;
   List_iterator<Item> li(lifted_fields->m_fields);
 
   while ((field_or_ref = li++)) {
     Item_field *const f = down_cast<Item_field *>(field_or_ref->real_item());
     if (!field_or_ref->is_outer_reference()) {
       // Add non-correlated fields in WHERE clause to select_list if not
       // already present
       if (selected_field == nullptr || f->field != selected_field->field) {
         m_added_non_hidden_fields++;
 
         // If f->hidden, f should be among the hidden fields in 'fields'.
         assert(std::any_of(fields.cbegin(), fields.cbegin() + first_non_hidden,
                            [&f](const Item *item) { return f == item; }) ==
                f->hidden);
 
         Item_field *inner_field;
 
         if (f->hidden) {
           // Make a new Item_field to avoid changing the set of hidden
           // Item_fields.
           inner_field = new (thd->mem_root) Item_field(thd, f);
           assert(!inner_field->hidden);
         } else {
           inner_field = f;
         }
 
         // select_n_where_fields is counted, so safe to add to base_ref_items
         base_ref_items[fields.size()] = inner_field;
 
         // Compute position in resulting derived table (TABLE::fields)
         // Note the corresponding slice position calculation performed in
         //     - change_to_use_tmp_fields_except_sums  (example figure
         //     expanded)
         //     - change_to_use_tmp_fields
         // takes this new situation into account.
         lifted_fields->m_field_positions.push_back(fields.size() -
                                                    hidden_fields);
         fields.push_back(inner_field);
         inner_field->increment_ref_count();
         // We have added to fields; master_query_expression->types must
         // always be equal to it;
         master_query_expression()->types.push_back(inner_field);
       } else {
         // This is the field present in the scalar subquery initially, so it
         // will be first in the derived table's set of fields.
         lifted_fields->m_field_positions.push_back(0);
       }
     }
   }
 
   li.rewind();
 
   // Run through the inner fields and add them to GROUP BY if not present
   bool selected_field_in_group_by = false;
   while ((field_or_ref = li++)) {
     Item_field *f = down_cast<Item_field *>(field_or_ref->real_item());
     if (!field_or_ref->is_outer_reference()) {
       bool found = false;
       for (ORDER *group = group_list.first; group != nullptr;
            group = group->next) {
         Item *item = *group->item;
         if (item->type() == Item::FIELD_ITEM &&
             down_cast<Item_field *>(item)->field == f->field) {
           found = true;
           break;
         }
       }
       if (!found) {
         Item_field *in_select = f;
         if (selected_field != nullptr && (selected_field->field == f->field)) {
           // We need GROUP BY to use the Item_field present in the select
           // list, not the one in the predicate. The only f that didn't get
           // added to the select list above, is the one whose Field was already
           // there, so use that, lest create_tmp_table gets confused.
           in_select = selected_field;
           selected_field_in_group_by = true;
         }
-        ORDER *o = new (thd->mem_root) PT_order_expr(in_select, ORDER_ASC);
+        ORDER *o =
+            new (thd->mem_root) PT_order_expr(POS(), in_select, ORDER_ASC);
         if (o == nullptr) return true;
         o->direction = ORDER_NOT_RELEVANT;  // ignored by constructur
         o->in_field_list = true;
         o->used = in_select->used_tables();
         // Add at back of list
         group_list.link_in_list(o, &o->next);
       }
     }
   }
 
   // Wrap the field in the select list in Item_func_any_value if it was not
   // added to group by above.
   if (!selected_field_in_group_by &&
       !fields[first_non_hidden]->has_aggregation()) {
     Item *const old_field = fields[first_non_hidden];
     Item *func_any = new (thd->mem_root) Item_func_any_value(old_field);
     if (func_any == nullptr) return true;
     if (func_any->fix_fields(thd, &func_any)) return true;
     fields[first_non_hidden] = func_any;
     replace_referenced_item(old_field, func_any);
   }
 
   if (!m_agg_func_used) {
     // Add COUNT(*) to SELECT list
     Item_int *number_0 = new (thd->mem_root) Item_int(int32{0}, 1);
     if (number_0 == nullptr) return true;
     Item *cnt = new (thd->mem_root) Item_sum_count(number_0);
     if (cnt == nullptr) return true;
     int item_no = fields.size() + 1;
     baptize_item(thd, cnt, &item_no);
     m_added_non_hidden_fields++;
     {
       // prelude to binding COUNT(*)
       const bool save_asf = thd->lex->allow_sum_func;
       Query_block *save_query_block = thd->lex->current_query_block();
       assert(save_query_block == outer_query_block());
       thd->lex->set_current_query_block(this);
       auto save_allow_sum_func = thd->lex->allow_sum_func;
       thd->lex->allow_sum_func |= (nesting_map)1 << nest_level;
 
       if (cnt->fix_fields(thd, &cnt)) return true;
 
       // postlude to binding COUNT(*)
       thd->lex->allow_sum_func = save_asf;
       thd->lex->set_current_query_block(save_query_block);
       thd->lex->allow_sum_func = save_allow_sum_func;
     }
     // This should be safe, because we have reserved space for
     // select_n_where_fields, but at least one of them is an outer reference
     // so this extra COUNT(*) can use the first such space:
     base_ref_items[fields.size()] = cnt;
     lifted_fields->m_field_positions.push_back(fields.size() - hidden_fields);
     fields.push_back(cnt);
     cnt->increment_ref_count();
     m_agg_func_used = true;
     // Add a new column to the derived table's query expression
     derived->derived_query_expression()->types.push_back(cnt);
     *added_card_check = true;
   }
   return false;
 }
 
 /**
   See explanation in companion method decorrelate_derived_scalar_subquery_pre.
 */
diff --git a/sql/sql_show_processlist.cc b/sql/sql_show_processlist.cc
index a178c70257c..7e791715186 100644
--- a/sql/sql_show_processlist.cc
+++ b/sql/sql_show_processlist.cc
@@ -117,139 +117,140 @@ static bool add_expression(const POS &pos, THD *thd,
 bool build_processlist_query(const POS &pos, THD *thd, bool verbose) {
   LEX_STRING info_len;
   /*
     Default Info field length is 100. Verbose field length is limited to the
     size of the INFO columns in the Performance Schema.
   */
   assert(PROCESS_LIST_WIDTH == 100);
   if (verbose) {
     if (lex_string_strmake(thd->mem_root, &info_len, "1024", 4)) return true;
   } else {
     if (lex_string_strmake(thd->mem_root, &info_len, "100", 3)) return true;
   }
 
   /* Id, User, Host, db, Command, Time, State */
-  PT_select_item_list *item_list = new (thd->mem_root) PT_select_item_list();
+  PT_select_item_list *item_list = new (thd->mem_root) PT_select_item_list(pos);
   if (item_list == nullptr) return true;
 
   if (add_expression(pos, thd, item_list, field_id, alias_id)) return true;
   if (add_expression(pos, thd, item_list, field_user, alias_user)) return true;
   if (add_expression(pos, thd, item_list, field_host, alias_host)) return true;
   if (add_expression(pos, thd, item_list, field_db, alias_db)) return true;
   if (add_expression(pos, thd, item_list, field_command, alias_command))
     return true;
   if (add_expression(pos, thd, item_list, field_time, alias_time)) return true;
   if (add_expression(pos, thd, item_list, field_state, alias_state))
     return true;
 
   /* ... INFO ... */
   PTI_simple_ident_ident *ident_info =
       new (thd->mem_root) PTI_simple_ident_ident(pos, field_info);
   if (ident_info == nullptr) return true;
 
   /* Info length is either "100" or "1024" depending on verbose */
   Item_int *item_info_len = new (thd->mem_root) Item_int(pos, info_len);
   if (item_info_len == nullptr) return true;
 
   /* ... LEFT(INFO, <info_len>) AS Info ...*/
   Item_func_left *func_left =
       new (thd->mem_root) Item_func_left(pos, ident_info, item_info_len);
   if (func_left == nullptr) return true;
 
   PTI_expr_with_alias *expr_left = new (thd->mem_root)
       PTI_expr_with_alias(pos, func_left, pos.cpp, alias_info);
   if (expr_left == nullptr) return true;
 
   item_list->push_back(expr_left);
 
   /*
     make_table_list() might alter the database and table name strings. Create
     copies and leave the original values unaltered.
   */
 
   /* ... performance_schema ... */
   LEX_CSTRING tmp_db_name;
   if (lex_string_strmake(thd->mem_root, &tmp_db_name, pfs.str, pfs.length))
     return true;
 
   /* ... performance_schema.processlist ... */
   LEX_CSTRING tmp_table_processlist;
   if (lex_string_strmake(thd->mem_root, &tmp_table_processlist,
                          table_processlist.str, table_processlist.length))
     return true;
 
   Table_ident *table_ident_processlist =
       new (thd->mem_root) Table_ident(tmp_db_name, tmp_table_processlist);
   if (table_ident_processlist == nullptr) return true;
 
   PT_table_factor_table_ident *table_factor_processlist =
       new (thd->mem_root) PT_table_factor_table_ident(
-          table_ident_processlist, nullptr, NULL_CSTR, nullptr);
+          pos, table_ident_processlist, nullptr, NULL_CSTR, nullptr);
   if (table_factor_processlist == nullptr) return true;
 
   Mem_root_array_YY<PT_table_reference *> table_reference_list;
   table_reference_list.init(thd->mem_root);
   if (table_reference_list.push_back(table_factor_processlist)) return true;
 
   Item *where_clause = nullptr;
 
   /* Form subquery
      SELECT ID Id, USER User, HOST Host, DB db, COMMAND Command,
             TIME Time STATE state, LEFT(INFO, <info_len>) Info
      FROM performance_schema.processlist
   */
   PT_query_primary *query_specification =
       new (thd->mem_root) PT_query_specification(
-          options, item_list, table_reference_list, where_clause);
+          pos, options, item_list, table_reference_list, where_clause);
   if (query_specification == nullptr) return true;
 
   PT_query_expression *query_expression =
-      new (thd->mem_root) PT_query_expression(query_specification);
+      new (thd->mem_root) PT_query_expression(pos, query_specification);
   if (query_expression == nullptr) return true;
 
   PT_subquery *sub_query =
       new (thd->mem_root) PT_subquery(pos, query_expression);
   if (sub_query == nullptr) return true;
 
   Create_col_name_list column_names;
   column_names.init(thd->mem_root);
 
   /* ... AS show_processlist */
   PT_derived_table *derived_table = new (thd->mem_root)
-      PT_derived_table(false, sub_query, table_processlist, &column_names);
+      PT_derived_table(pos, false, sub_query, table_processlist, &column_names);
   if (derived_table == nullptr) return true;
 
   Mem_root_array_YY<PT_table_reference *> table_reference_list1;
   table_reference_list1.init(thd->mem_root);
   if (table_reference_list1.push_back(derived_table)) return true;
 
   /* SELECT <star> */
   Item_asterisk *ident_star =
       new (thd->mem_root) Item_asterisk(pos, nullptr, nullptr);
   if (ident_star == nullptr) return true;
 
-  PT_select_item_list *item_list1 = new (thd->mem_root) PT_select_item_list();
+  PT_select_item_list *item_list1 =
+      new (thd->mem_root) PT_select_item_list(pos);
   if (item_list1 == nullptr) return true;
   item_list1->push_back(ident_star);
 
   /* SELECT * FROM
       (SELECT ... FROM performance_schema.processlist)
      AS show_processlist
   */
   PT_query_specification *query_specification2 =
       new (thd->mem_root) PT_query_specification(
-          options, item_list1, table_reference_list1, nullptr);
+          pos, options, item_list1, table_reference_list1, nullptr);
   if (query_specification2 == nullptr) return true;
 
   PT_query_expression *query_expression2 =
-      new (thd->mem_root) PT_query_expression(query_specification2);
+      new (thd->mem_root) PT_query_expression(pos, query_specification2);
   if (query_expression2 == nullptr) return true;
 
   LEX *lex = thd->lex;
   Query_block *current_query_block = lex->current_query_block();
   Parse_context pc(thd, current_query_block);
   assert(!thd->is_error());
 
   if (query_expression2->contextualize(&pc)) return true;
   if (pc.finalize_query_expression()) return true;
   return false;
 }
diff --git a/sql/sql_show_status.cc b/sql/sql_show_status.cc
index f3a11854798..f65c81eb5b9 100644
--- a/sql/sql_show_status.cc
+++ b/sql/sql_show_status.cc
@@ -1,269 +1,274 @@
 /* Copyright (c) 2015, 2023, Oracle and/or its affiliates.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License, version 2.0,
    as published by the Free Software Foundation.
 
    This program is also distributed with certain software (including
    but not limited to OpenSSL) that is licensed under separate terms,
    as designated in a particular file or component or in included license
    documentation.  The authors of MySQL hereby grant you an additional
    permission to link the program and your derivative works with the
    separately licensed software that they have included with MySQL.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License, version 2.0, for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
 #include "sql/sql_show_status.h"
 
 #include "lex_string.h"
 #include "my_alloc.h"  // operator new
 #include "my_sqlcommand.h"
 #include "sql/item_cmpfunc.h"  // Item_func_like
 #include "sql/mem_root_array.h"
 #include "sql/parse_tree_items.h"      // PTI_simple_ident_ident
 #include "sql/parse_tree_node_base.h"  // Parse_context
 #include "sql/parse_tree_nodes.h"      // PT_select_item_list
 #include "sql/parser_yystype.h"        // Create_col_name_list
 #include "sql/sql_class.h"             // THD
 #include "sql/sql_lex.h"               // Query_options
 #include "sql/strfunc.h"
 #include "sql_string.h"
 #include "string_with_len.h"
 
 /**
   Build a replacement query for SHOW STATUS.
   When the parser accepts the following syntax:
 
+  TODO: pos parameter is probably not required. For PT_* class construction,
+  pos is required only for json parse tree generation, which we are not doing
+  here. For PTI_* class construction, pos parameter is just a dummy parameter;
+  so we can just generate one here rather than getting it from the caller.
+
   <code>
     SHOW GLOBAL STATUS
   </code>
 
   the parsed tree built for this query is in fact:
 
   <code>
     SELECT * FROM
              (SELECT VARIABLE_NAME as Variable_name, VARIABLE_VALUE as Value
               FROM performance_schema.global_status) global_status
   </code>
 
   Likewise, the query:
 
   <code>
     SHOW GLOBAL STATUS LIKE "<value>"
   </code>
 
   is built as:
 
   <code>
     SELECT * FROM
              (SELECT VARIABLE_NAME as Variable_name, VARIABLE_VALUE as Value
               FROM performance_schema.global_status) global_status
               WHERE Variable_name LIKE "<value>"
   </code>
 
   Likewise, the query:
 
   <code>
     SHOW GLOBAL STATUS where @<where_clause@>
   </code>
 
   is built as:
 
   <code>
     SELECT * FROM
              (SELECT VARIABLE_NAME as Variable_name, VARIABLE_VALUE as Value
               FROM performance_schema.global_status) global_status
               WHERE @<where_clause@>
   </code>
 */
 static Query_block *build_query(const POS &pos, THD *thd,
                                 enum_sql_command command,
                                 const LEX_CSTRING &table_name,
                                 const String *wild, Item *where_cond) {
   /*
     MAINTAINER:
     This code builds a parsed tree for a query.
     Write the query to build in SQL first,
     then see turn_parser_debug_on() in sql_yacc.yy
     to understand which grammar actions are needed to
     build a parsed tree for this SQL query.
   */
   static const LEX_CSTRING col_name = {STRING_WITH_LEN("VARIABLE_NAME")};
   static const LEX_CSTRING as_name = {STRING_WITH_LEN("Variable_name")};
   static const LEX_CSTRING col_value = {STRING_WITH_LEN("VARIABLE_VALUE")};
   static const LEX_CSTRING as_value = {STRING_WITH_LEN("Value")};
   static const LEX_CSTRING pfs = {STRING_WITH_LEN("performance_schema")};
 
   static const Query_options options = {
       0 /* query_spec_options */
   };
 
   /* ... VARIABLE_NAME ... */
   PTI_simple_ident_ident *ident_name;
   ident_name = new (thd->mem_root) PTI_simple_ident_ident(pos, col_name);
   if (ident_name == nullptr) return nullptr;
 
   /* ... VARIABLE_NAME as Variable_name ... */
   PTI_expr_with_alias *expr_name;
   expr_name = new (thd->mem_root)
       PTI_expr_with_alias(pos, ident_name, pos.cpp, as_name);
   if (expr_name == nullptr) return nullptr;
 
   /* ... VARIABLE_VALUE ... */
   PTI_simple_ident_ident *ident_value;
   ident_value = new (thd->mem_root) PTI_simple_ident_ident(pos, col_value);
   if (ident_value == nullptr) return nullptr;
 
   /* ... VARIABLE_VALUE as Value ... */
   PTI_expr_with_alias *expr_value;
   expr_value = new (thd->mem_root)
       PTI_expr_with_alias(pos, ident_value, pos.cpp, as_value);
   if (expr_value == nullptr) return nullptr;
 
   /* ... VARIABLE_NAME as Variable_name, VARIABLE_VALUE as Value ... */
   PT_select_item_list *item_list;
-  item_list = new (thd->mem_root) PT_select_item_list();
+  item_list = new (thd->mem_root) PT_select_item_list(pos);
   if (item_list == nullptr) return nullptr;
   item_list->push_back(expr_name);
   item_list->push_back(expr_value);
 
   /*
     make_table_list() might alter the database and table name strings. Create
     copies and leave the original values unaltered.
   */
 
   /* ... performance_schema ... */
   LEX_CSTRING tmp_db_name;
   if (lex_string_strmake(thd->mem_root, &tmp_db_name, pfs.str, pfs.length))
     return nullptr;
 
   /* ... <table_name> ... */
   LEX_CSTRING tmp_table_name;
   if (lex_string_strmake(thd->mem_root, &tmp_table_name, table_name.str,
                          table_name.length))
     return nullptr;
 
   /* ... performance_schema.<table_name> ... */
   Table_ident *table_ident;
   table_ident = new (thd->mem_root) Table_ident(tmp_db_name, tmp_table_name);
   if (table_ident == nullptr) return nullptr;
 
   /* ... FROM performance_schema.<table_name> ... */
   PT_table_factor_table_ident *table_factor;
-  table_factor = new (thd->mem_root)
-      PT_table_factor_table_ident(table_ident, nullptr, NULL_CSTR, nullptr);
+  table_factor = new (thd->mem_root) PT_table_factor_table_ident(
+      pos, table_ident, nullptr, NULL_CSTR, nullptr);
   if (table_factor == nullptr) return nullptr;
 
   Mem_root_array_YY<PT_table_reference *> table_reference_list;
   table_reference_list.init(thd->mem_root);
   if (table_reference_list.push_back(table_factor)) return nullptr;
 
   /* Form subquery */
   /* SELECT VARIABLE_NAME as Variable_name, VARIABLE_VALUE as Value FROM
    * performance_schema.<table_name> */
   PT_query_primary *query_specification;
   query_specification =
-      new (thd->mem_root) PT_query_specification(options, item_list,
+      new (thd->mem_root) PT_query_specification(pos, options, item_list,
                                                  table_reference_list,  // from
                                                  nullptr);              // where
   if (query_specification == nullptr) return nullptr;
 
   PT_query_expression *query_expression;
   query_expression =
-      new (thd->mem_root) PT_query_expression(query_specification);
+      new (thd->mem_root) PT_query_expression(pos, query_specification);
   if (query_expression == nullptr) return nullptr;
 
   PT_subquery *sub_query;
   sub_query = new (thd->mem_root) PT_subquery(pos, query_expression);
   if (sub_query == nullptr) return nullptr;
 
   Create_col_name_list column_names;
   column_names.init(thd->mem_root);
   PT_derived_table *derived_table;
   derived_table = new (thd->mem_root)
-      PT_derived_table(false, sub_query, table_name, &column_names);
+      PT_derived_table(pos, false, sub_query, table_name, &column_names);
   if (derived_table == nullptr) return nullptr;
 
   Mem_root_array_YY<PT_table_reference *> table_reference_list1;
   table_reference_list1.init(thd->mem_root);
   if (table_reference_list1.push_back(derived_table)) return nullptr;
 
   /* SELECT * ... */
   Item_asterisk *ident_star;
   ident_star = new (thd->mem_root) Item_asterisk(pos, nullptr, nullptr);
   if (ident_star == nullptr) return nullptr;
 
   PT_select_item_list *item_list1;
-  item_list1 = new (thd->mem_root) PT_select_item_list();
+  item_list1 = new (thd->mem_root) PT_select_item_list(pos);
   if (item_list1 == nullptr) return nullptr;
   item_list1->push_back(ident_star);
 
   /* Process where clause */
   Item *where_clause = nullptr;
 
   if (wild != nullptr) {
     /* ... Variable_name ... */
     PTI_simple_ident_ident *ident_name_where;
     ident_name_where = new (thd->mem_root) PTI_simple_ident_ident(pos, as_name);
     if (ident_name_where == nullptr) return nullptr;
 
     /* ... <value> ... */
     LEX_STRING *lex_string;
     lex_string = static_cast<LEX_STRING *>(thd->alloc(sizeof(LEX_STRING)));
     if (lex_string == nullptr) return nullptr;
     lex_string->length = wild->length();
     lex_string->str = thd->strmake(wild->ptr(), wild->length());
     if (lex_string->str == nullptr) return nullptr;
 
     PTI_text_literal_text_string *wild_string;
     wild_string = new (thd->mem_root) PTI_text_literal_text_string(
         pos, false, *lex_string);  // TODO WL#6629 check is_7bit
     if (wild_string == nullptr) return nullptr;
 
     /* ... Variable_name LIKE <value> ... */
     Item_func_like *func_like =
         new (thd->mem_root) Item_func_like(pos, ident_name_where, wild_string);
     if (func_like == nullptr) return nullptr;
 
     /* ... WHERE Variable_name LIKE <value> ... */
     where_clause = new (thd->mem_root) PTI_where(pos, func_like);
     if (where_clause == nullptr) return nullptr;
   } else {
     where_clause = where_cond;
   }
 
   /* SELECT * FROM (SELECT ...) derived_table [ WHERE Variable_name LIKE <value>
    * ] */
   /* SELECT * FROM (SELECT ...) derived_table [ WHERE <cond> ] */
   PT_query_specification *query_specification2;
   query_specification2 =
-      new (thd->mem_root) PT_query_specification(options, item_list1,
+      new (thd->mem_root) PT_query_specification(pos, options, item_list1,
                                                  table_reference_list1,  // from
                                                  where_clause);  // where
   if (query_specification2 == nullptr) return nullptr;
 
   PT_query_expression *query_expression2;
   query_expression2 =
-      new (thd->mem_root) PT_query_expression(query_specification2);
+      new (thd->mem_root) PT_query_expression(pos, query_specification2);
   if (query_expression2 == nullptr) return nullptr;
 
   LEX *lex = thd->lex;
   Query_block *current_query_block = lex->current_query_block();
   Parse_context pc(thd, current_query_block);
   if (thd->is_error()) return nullptr;
 
   lex->sql_command = SQLCOM_SELECT;
   if (query_expression2->contextualize(&pc)) return nullptr;
   if (pc.finalize_query_expression()) return nullptr;
   /* contextualize sets to COM_SELECT */
   lex->sql_command = command;
 
   return current_query_block;
 }
diff --git a/sql/sql_yacc.yy b/sql/sql_yacc.yy
index d4b0ecead8a..3119290463e 100644
--- a/sql/sql_yacc.yy
+++ b/sql/sql_yacc.yy
@@ -3405,51 +3405,51 @@ opt_channel:
 create_table_stmt:
           CREATE opt_temporary TABLE_SYM opt_if_not_exists table_ident
           '(' table_element_list ')' opt_create_table_options_etc
           {
-            $$= NEW_PTN PT_create_table_stmt(YYMEM_ROOT, $2, $4, $5,
+            $$= NEW_PTN PT_create_table_stmt(@$, YYMEM_ROOT, $2, $4, $5,
                                              $7,
                                              $9.opt_create_table_options,
                                              $9.opt_partitioning,
                                              $9.on_duplicate,
                                              $9.opt_query_expression);
           }
         | CREATE opt_temporary TABLE_SYM opt_if_not_exists table_ident
           opt_create_table_options_etc
           {
-            $$= NEW_PTN PT_create_table_stmt(YYMEM_ROOT, $2, $4, $5,
+            $$= NEW_PTN PT_create_table_stmt(@$, YYMEM_ROOT, $2, $4, $5,
                                              NULL,
                                              $6.opt_create_table_options,
                                              $6.opt_partitioning,
                                              $6.on_duplicate,
                                              $6.opt_query_expression);
           }
         | CREATE opt_temporary TABLE_SYM opt_if_not_exists table_ident
           LIKE table_ident
           {
-            $$= NEW_PTN PT_create_table_stmt(YYMEM_ROOT, $2, $4, $5, $7);
+            $$= NEW_PTN PT_create_table_stmt(@$, YYMEM_ROOT, $2, $4, $5, $7);
           }
         | CREATE opt_temporary TABLE_SYM opt_if_not_exists table_ident
           '(' LIKE table_ident ')'
           {
-            $$= NEW_PTN PT_create_table_stmt(YYMEM_ROOT, $2, $4, $5, $8);
+            $$= NEW_PTN PT_create_table_stmt(@$, YYMEM_ROOT, $2, $4, $5, $8);
           }
         ;
 
 create_role_stmt:
           CREATE ROLE_SYM opt_if_not_exists role_list
           {
-            $$= NEW_PTN PT_create_role(!!$3, $4);
+            $$= NEW_PTN PT_create_role(@$, !!$3, $4);
           }
         ;
 
 create_resource_group_stmt:
           CREATE RESOURCE_SYM GROUP_SYM ident TYPE_SYM
           opt_equal resource_group_types
           opt_resource_group_vcpu_list opt_resource_group_priority
           opt_resource_group_enable_disable
           {
-            $$= NEW_PTN PT_create_resource_group(to_lex_cstring($4), $7, $8, $9,
+            $$= NEW_PTN PT_create_resource_group(@$, to_lex_cstring($4), $7, $8, $9,
                                                  $10.is_default ? true :
                                                  $10.value);
           }
         ;
@@ -3563,13 +3563,13 @@ create:
 create_srs_stmt:
           CREATE OR_SYM REPLACE_SYM SPATIAL_SYM REFERENCE_SYM SYSTEM_SYM
           real_ulonglong_num srs_attributes
           {
-            $$= NEW_PTN PT_create_srs($7, *$8, true, false);
+            $$= NEW_PTN PT_create_srs(@$, $7, *$8, true, false);
           }
         | CREATE SPATIAL_SYM REFERENCE_SYM SYSTEM_SYM opt_if_not_exists
           real_ulonglong_num srs_attributes
           {
-            $$= NEW_PTN PT_create_srs($6, *$7, false, $5);
+            $$= NEW_PTN PT_create_srs(@$, $6, *$7, false, $5);
           }
         ;
 
@@ -3647,27 +3647,27 @@ default_role_clause:
 create_index_stmt:
           CREATE opt_unique INDEX_SYM ident opt_index_type_clause
           ON_SYM table_ident '(' key_list_with_expression ')' opt_index_options
           opt_index_lock_and_algorithm
           {
-            $$= NEW_PTN PT_create_index_stmt(YYMEM_ROOT, $2, $4, $5,
+            $$= NEW_PTN PT_create_index_stmt(@$, YYMEM_ROOT, $2, $4, $5,
                                              $7, $9, $11,
                                              $12.algo.get_or_default(),
                                              $12.lock.get_or_default());
           }
         | CREATE FULLTEXT_SYM INDEX_SYM ident ON_SYM table_ident
           '(' key_list_with_expression ')' opt_fulltext_index_options opt_index_lock_and_algorithm
           {
-            $$= NEW_PTN PT_create_index_stmt(YYMEM_ROOT, KEYTYPE_FULLTEXT, $4,
+            $$= NEW_PTN PT_create_index_stmt(@$, YYMEM_ROOT, KEYTYPE_FULLTEXT, $4,
                                              NULL, $6, $8, $10,
                                              $11.algo.get_or_default(),
                                              $11.lock.get_or_default());
           }
         | CREATE SPATIAL_SYM INDEX_SYM ident ON_SYM table_ident
           '(' key_list_with_expression ')' opt_spatial_index_options opt_index_lock_and_algorithm
           {
-            $$= NEW_PTN PT_create_index_stmt(YYMEM_ROOT, KEYTYPE_SPATIAL, $4,
+            $$= NEW_PTN PT_create_index_stmt(@$, YYMEM_ROOT, KEYTYPE_SPATIAL, $4,
                                              NULL, $6, $8, $10,
                                              $11.algo.get_or_default(),
                                              $11.lock.get_or_default());
           }
         ;
@@ -3996,7 +3996,7 @@ sp_suid:
 call_stmt:
           CALL_SYM sp_name opt_paren_expr_list
           {
-            $$= NEW_PTN PT_call($2, $3);
+            $$= NEW_PTN PT_call(@$, $2, $3);
           }
         ;
 
@@ -6077,14 +6077,14 @@ lg_undofile:
 ts_option_initial_size:
           INITIAL_SIZE_SYM opt_equal size_number
           {
-            $$= NEW_PTN PT_alter_tablespace_option_initial_size($3);
+            $$= NEW_PTN PT_alter_tablespace_option_initial_size(@$, $3);
           }
         ;
 
 ts_option_autoextend_size:
           option_autoextend_size
           {
-            $$ = NEW_PTN PT_alter_tablespace_option_autoextend_size($1);
+            $$ = NEW_PTN PT_alter_tablespace_option_autoextend_size(@$, $1);
           }
         ;
 
@@ -6095,74 +6095,74 @@ option_autoextend_size:
 ts_option_max_size:
           MAX_SIZE_SYM opt_equal size_number
           {
-            $$= NEW_PTN PT_alter_tablespace_option_max_size($3);
+            $$= NEW_PTN PT_alter_tablespace_option_max_size(@$, $3);
           }
         ;
 
 ts_option_extent_size:
           EXTENT_SIZE_SYM opt_equal size_number
           {
-            $$= NEW_PTN PT_alter_tablespace_option_extent_size($3);
+            $$= NEW_PTN PT_alter_tablespace_option_extent_size(@$, $3);
           }
         ;
 
 ts_option_undo_buffer_size:
           UNDO_BUFFER_SIZE_SYM opt_equal size_number
           {
-            $$= NEW_PTN PT_alter_tablespace_option_undo_buffer_size($3);
+            $$= NEW_PTN PT_alter_tablespace_option_undo_buffer_size(@$, $3);
           }
         ;
 
 ts_option_redo_buffer_size:
           REDO_BUFFER_SIZE_SYM opt_equal size_number
           {
-            $$= NEW_PTN PT_alter_tablespace_option_redo_buffer_size($3);
+            $$= NEW_PTN PT_alter_tablespace_option_redo_buffer_size(@$, $3);
           }
         ;
 
 ts_option_nodegroup:
           NODEGROUP_SYM opt_equal real_ulong_num
           {
-            $$= NEW_PTN PT_alter_tablespace_option_nodegroup($3);
+            $$= NEW_PTN PT_alter_tablespace_option_nodegroup(@$, $3);
           }
         ;
 
 ts_option_comment:
           COMMENT_SYM opt_equal TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_alter_tablespace_option_comment($3);
+            $$= NEW_PTN PT_alter_tablespace_option_comment(@$, $3);
           }
         ;
 
 ts_option_engine:
           opt_storage ENGINE_SYM opt_equal ident_or_text
           {
-            $$= NEW_PTN PT_alter_tablespace_option_engine(to_lex_cstring($4));
+            $$= NEW_PTN PT_alter_tablespace_option_engine(@$, to_lex_cstring($4));
           }
         ;
 
 ts_option_file_block_size:
           FILE_BLOCK_SIZE_SYM opt_equal size_number
           {
-            $$= NEW_PTN PT_alter_tablespace_option_file_block_size($3);
+            $$= NEW_PTN PT_alter_tablespace_option_file_block_size(@$, $3);
           }
         ;
 
 ts_option_wait:
           WAIT_SYM
           {
-            $$= NEW_PTN PT_alter_tablespace_option_wait_until_completed(true);
+            $$= NEW_PTN PT_alter_tablespace_option_wait_until_completed(@$, true);
           }
         | NO_WAIT_SYM
           {
-            $$= NEW_PTN PT_alter_tablespace_option_wait_until_completed(false);
+            $$= NEW_PTN PT_alter_tablespace_option_wait_until_completed(@$, false);
           }
         ;
 
 ts_option_encryption:
           ENCRYPTION_SYM opt_equal TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_alter_tablespace_option_encryption($3);
+            $$= NEW_PTN PT_alter_tablespace_option_encryption(@$, $3);
           }
         ;
 
@@ -6307,39 +6307,39 @@ as_create_query_expression:
  The partition grammar can be called from two places.
  1) CREATE TABLE ... PARTITION ..
  2) ALTER TABLE table_name PARTITION ...
 */
 partition_clause:
           PARTITION_SYM BY part_type_def opt_num_parts opt_sub_part
           opt_part_defs
           {
-            $$= NEW_PTN PT_partition($3, $4, $5, @6, $6);
+            $$= NEW_PTN PT_partition(@$, $3, $4, $5, @6, $6);
           }
         ;
 
 part_type_def:
           opt_linear KEY_SYM opt_key_algo '(' opt_name_list ')'
           {
-            $$= NEW_PTN PT_part_type_def_key($1, $3, $5);
+            $$= NEW_PTN PT_part_type_def_key(@$, $1, $3, $5);
           }
         | opt_linear HASH_SYM '(' bit_expr ')'
           {
-            $$= NEW_PTN PT_part_type_def_hash($1, @4, $4);
+            $$= NEW_PTN PT_part_type_def_hash(@$, $1, @4, $4);
           }
         | RANGE_SYM '(' bit_expr ')'
           {
-            $$= NEW_PTN PT_part_type_def_range_expr(@3, $3);
+            $$= NEW_PTN PT_part_type_def_range_expr(@$, @3, $3);
           }
         | RANGE_SYM COLUMNS '(' name_list ')'
           {
-            $$= NEW_PTN PT_part_type_def_range_columns($4);
+            $$= NEW_PTN PT_part_type_def_range_columns(@$, $4);
           }
         | LIST_SYM '(' bit_expr ')'
           {
-            $$= NEW_PTN PT_part_type_def_list_expr(@3, $3);
+            $$= NEW_PTN PT_part_type_def_list_expr(@$, @3, $3);
           }
         | LIST_SYM COLUMNS '(' name_list ')'
           {
-            $$= NEW_PTN PT_part_type_def_list_columns($4);
+            $$= NEW_PTN PT_part_type_def_list_columns(@$, $4);
           }
         ;
 
@@ -6382,14 +6382,14 @@ opt_num_parts:
 opt_sub_part:
           %empty { $$= NULL; }
         | SUBPARTITION_SYM BY opt_linear HASH_SYM '(' bit_expr ')'
           opt_num_subparts
           {
-            $$= NEW_PTN PT_sub_partition_by_hash($3, @6, $6, $8);
+            $$= NEW_PTN PT_sub_partition_by_hash(@$, $3, @6, $6, $8);
           }
         | SUBPARTITION_SYM BY opt_linear KEY_SYM opt_key_algo
           '(' name_list ')' opt_num_subparts
           {
-            $$= NEW_PTN PT_sub_partition_by_key($3, $5, $7, $9);
+            $$= NEW_PTN PT_sub_partition_by_key(@$, $3, $5, $7, $9);
           }
         ;
 
@@ -6451,7 +6451,7 @@ part_def_list:
 part_definition:
           PARTITION_SYM ident opt_part_values opt_part_options opt_sub_partition
           {
-            $$= NEW_PTN PT_part_definition(@0, $2, $3.type, $3.values, @3,
+            $$= NEW_PTN PT_part_definition(@$, @0, $2, $3.type, $3.values, @3,
                                            $4, $5, @5);
           }
         ;
@@ -6481,11 +6481,11 @@ part_func_max:
 part_values_in:
           part_value_item_list_paren
           {
-            $$= NEW_PTN PT_part_values_in_item(@1, $1);
+            $$= NEW_PTN PT_part_values_in_item(@$, @1, $1);
           }
         | '(' part_value_list ')'
           {
-            $$= NEW_PTN PT_part_values_in_list(@3, $2);
+            $$= NEW_PTN PT_part_values_in_list(@$, @3, $2);
           }
         ;
 
@@ -6508,18 +6508,18 @@ part_value_list:
 part_value_item_list_paren:
           '('
           {
             /*
               This empty action is required because it resolves 2 reduce/reduce
               conflicts with an anonymous row expression:
 
               simple_expr:
                         ...
                       | '(' expr ',' expr_list ')'
             */
           }
           part_value_item_list ')'
           {
-            $$= NEW_PTN PT_part_value_item_list_paren($3, @4);
+            $$= NEW_PTN PT_part_value_item_list_paren(@$, $3, @4);
           }
         ;
 
@@ -6539,8 +6539,8 @@ part_value_item_list:
         ;
 
 part_value_item:
-          MAX_VALUE_SYM { $$= NEW_PTN PT_part_value_item_max(@1); }
-        | bit_expr      { $$= NEW_PTN PT_part_value_item_expr(@1, $1); }
+          MAX_VALUE_SYM { $$= NEW_PTN PT_part_value_item_max(@$); }
+        | bit_expr      { $$= NEW_PTN PT_part_value_item_expr(@$, $1); }
         ;
 
 
@@ -6567,7 +6567,7 @@ sub_part_list:
 sub_part_definition:
           SUBPARTITION_SYM ident_or_text opt_part_options
           {
-            $$= NEW_PTN PT_subpartition(@1, $2.str, $3);
+            $$= NEW_PTN PT_subpartition(@$, @1, $2.str, $3);
           }
         ;
 
@@ -6593,23 +6593,23 @@ part_option_list:
 
 part_option:
           TABLESPACE_SYM opt_equal ident
-          { $$= NEW_PTN PT_partition_tablespace($3.str); }
+          { $$= NEW_PTN PT_partition_tablespace(@$, $3.str); }
         | opt_storage ENGINE_SYM opt_equal ident_or_text
-          { $$= NEW_PTN PT_partition_engine(to_lex_cstring($4)); }
+          { $$= NEW_PTN PT_partition_engine(@$, to_lex_cstring($4)); }
         | NODEGROUP_SYM opt_equal real_ulong_num
-          { $$= NEW_PTN PT_partition_nodegroup($3); }
+          { $$= NEW_PTN PT_partition_nodegroup(@$, $3); }
         | MAX_ROWS opt_equal real_ulonglong_num
-          { $$= NEW_PTN PT_partition_max_rows($3); }
+          { $$= NEW_PTN PT_partition_max_rows(@$, $3); }
         | MIN_ROWS opt_equal real_ulonglong_num
-          { $$= NEW_PTN PT_partition_min_rows($3); }
+          { $$= NEW_PTN PT_partition_min_rows(@$, $3); }
         | DATA_SYM DIRECTORY_SYM opt_equal TEXT_STRING_sys
-          { $$= NEW_PTN PT_partition_data_directory($4.str); }
+          { $$= NEW_PTN PT_partition_data_directory(@$, $4.str); }
         | INDEX_SYM DIRECTORY_SYM opt_equal TEXT_STRING_sys
-          { $$= NEW_PTN PT_partition_index_directory($4.str); }
+          { $$= NEW_PTN PT_partition_index_directory(@$, $4.str); }
         | COMMENT_SYM opt_equal TEXT_STRING_sys
-          { $$= NEW_PTN PT_partition_comment($3.str); }
+          { $$= NEW_PTN PT_partition_comment(@$, $3.str); }
         ;
 
 /*
  End of partition parser part
 */
@@ -6719,176 +6719,176 @@ opt_comma:
 create_table_option:
           ENGINE_SYM opt_equal ident_or_text
           {
-            $$= NEW_PTN PT_create_table_engine_option(to_lex_cstring($3));
+            $$= NEW_PTN PT_create_table_engine_option(@$, to_lex_cstring($3));
           }
         | SECONDARY_ENGINE_SYM opt_equal NULL_SYM
           {
-            $$= NEW_PTN PT_create_table_secondary_engine_option();
+            $$= NEW_PTN PT_create_table_secondary_engine_option(@$);
           }
         | SECONDARY_ENGINE_SYM opt_equal ident_or_text
           {
-            $$= NEW_PTN PT_create_table_secondary_engine_option(to_lex_cstring($3));
+            $$= NEW_PTN PT_create_table_secondary_engine_option(@$, to_lex_cstring($3));
           }
         | MAX_ROWS opt_equal ulonglong_num
           {
-            $$= NEW_PTN PT_create_max_rows_option($3);
+            $$= NEW_PTN PT_create_max_rows_option(@$, $3);
           }
         | MIN_ROWS opt_equal ulonglong_num
           {
-            $$= NEW_PTN PT_create_min_rows_option($3);
+            $$= NEW_PTN PT_create_min_rows_option(@$, $3);
           }
         | AVG_ROW_LENGTH opt_equal ulonglong_num
           {
             // The frm-format only allocated 4 bytes for avg_row_length, and
             // there is code which assumes it can be represented as an uint,
             // so we constrain it here.
             if ($3 > std::numeric_limits<std::uint32_t>::max()) {
               YYTHD->syntax_error_at(@3,
               "The valid range for avg_row_length is [0,4294967295]. Error"
               );
               MYSQL_YYABORT;
             }
-            $$= NEW_PTN PT_create_avg_row_length_option($3);
+            $$= NEW_PTN PT_create_avg_row_length_option(@$, $3);
           }
         | PASSWORD opt_equal TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_create_password_option($3.str);
+            $$= NEW_PTN PT_create_password_option(@$, $3.str);
           }
         | COMMENT_SYM opt_equal TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_create_commen_option($3);
+            $$= NEW_PTN PT_create_commen_option(@$, $3);
           }
         | COMPRESSION_SYM opt_equal TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_create_compress_option($3);
+            $$= NEW_PTN PT_create_compress_option(@$, $3);
           }
         | ENCRYPTION_SYM opt_equal TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_create_encryption_option($3);
+            $$= NEW_PTN PT_create_encryption_option(@$, $3);
           }
         | AUTO_INC opt_equal ulonglong_num
           {
-            $$= NEW_PTN PT_create_auto_increment_option($3);
+            $$= NEW_PTN PT_create_auto_increment_option(@$, $3);
           }
         | PACK_KEYS_SYM opt_equal ternary_option
           {
-            $$= NEW_PTN PT_create_pack_keys_option($3);
+            $$= NEW_PTN PT_create_pack_keys_option(@$, $3);
           }
         | STATS_AUTO_RECALC_SYM opt_equal ternary_option
           {
-            $$= NEW_PTN PT_create_stats_auto_recalc_option($3);
+            $$= NEW_PTN PT_create_stats_auto_recalc_option(@$, $3);
           }
         | STATS_PERSISTENT_SYM opt_equal ternary_option
           {
-            $$= NEW_PTN PT_create_stats_persistent_option($3);
+            $$= NEW_PTN PT_create_stats_persistent_option(@$, $3);
           }
         | STATS_SAMPLE_PAGES_SYM opt_equal ulong_num
           {
             /* From user point of view STATS_SAMPLE_PAGES can be specified as
             STATS_SAMPLE_PAGES=N (where 0<N<=65535, it does not make sense to
             scan 0 pages) or STATS_SAMPLE_PAGES=default. Internally we record
             =default as 0. See create_frm() in sql/table.cc, we use only two
             bytes for stats_sample_pages and this is why we do not allow
             larger values. 65535 pages, 16kb each means to sample 1GB, which
             is impractical. If at some point this needs to be extended, then
             we can store the higher bits from stats_sample_pages in .frm too. */
             if ($3 == 0 || $3 > 0xffff)
             {
               YYTHD->syntax_error_at(@3,
               "The valid range for stats_sample_pages is [1, 65535]. Error");
               MYSQL_YYABORT;
             }
-            $$= NEW_PTN PT_create_stats_stable_pages($3);
+            $$= NEW_PTN PT_create_stats_stable_pages(@$, $3);
           }
         | STATS_SAMPLE_PAGES_SYM opt_equal DEFAULT_SYM
           {
-            $$= NEW_PTN PT_create_stats_stable_pages;
+            $$= NEW_PTN PT_create_stats_stable_pages(@$);
           }
         | CHECKSUM_SYM opt_equal ulong_num
           {
-            $$= NEW_PTN PT_create_checksum_option($3);
+            $$= NEW_PTN PT_create_checksum_option(@$, $3);
           }
         | TABLE_CHECKSUM_SYM opt_equal ulong_num
           {
-            $$= NEW_PTN PT_create_checksum_option($3);
+            $$= NEW_PTN PT_create_checksum_option(@$, $3);
           }
         | DELAY_KEY_WRITE_SYM opt_equal ulong_num
           {
-            $$= NEW_PTN PT_create_delay_key_write_option($3);
+            $$= NEW_PTN PT_create_delay_key_write_option(@$, $3);
           }
         | ROW_FORMAT_SYM opt_equal row_types
           {
-            $$= NEW_PTN PT_create_row_format_option($3);
+            $$= NEW_PTN PT_create_row_format_option(@$, $3);
           }
         | UNION_SYM opt_equal '(' opt_table_list ')'
           {
-            $$= NEW_PTN PT_create_union_option($4);
+            $$= NEW_PTN PT_create_union_option(@$, $4);
           }
         | default_charset
           {
-            $$= NEW_PTN PT_create_table_default_charset($1);
+            $$= NEW_PTN PT_create_table_default_charset(@$, $1);
           }
         | default_collation
           {
-            $$= NEW_PTN PT_create_table_default_collation($1);
+            $$= NEW_PTN PT_create_table_default_collation(@$, $1);
           }
         | INSERT_METHOD opt_equal merge_insert_types
           {
-            $$= NEW_PTN PT_create_insert_method_option($3);
+            $$= NEW_PTN PT_create_insert_method_option(@$, $3);
           }
         | DATA_SYM DIRECTORY_SYM opt_equal TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_create_data_directory_option($4.str);
+            $$= NEW_PTN PT_create_data_directory_option(@$, $4.str);
           }
         | INDEX_SYM DIRECTORY_SYM opt_equal TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_create_index_directory_option($4.str);
+            $$= NEW_PTN PT_create_index_directory_option(@$, $4.str);
           }
         | TABLESPACE_SYM opt_equal ident
           {
-            $$= NEW_PTN PT_create_tablespace_option($3.str);
+            $$= NEW_PTN PT_create_tablespace_option(@$, $3.str);
           }
         | STORAGE_SYM DISK_SYM
           {
-            $$= NEW_PTN PT_create_storage_option(HA_SM_DISK);
+            $$= NEW_PTN PT_create_storage_option(@$, HA_SM_DISK);
           }
         | STORAGE_SYM MEMORY_SYM
           {
-            $$= NEW_PTN PT_create_storage_option(HA_SM_MEMORY);
+            $$= NEW_PTN PT_create_storage_option(@$, HA_SM_MEMORY);
           }
         | CONNECTION_SYM opt_equal TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_create_connection_option($3);
+            $$= NEW_PTN PT_create_connection_option(@$, $3);
           }
         | KEY_BLOCK_SIZE opt_equal ulonglong_num
           {
             // The frm-format only allocated 2 bytes for key_block_size,
             // even if it is represented as std::uint32_t in HA_CREATE_INFO and
             // elsewhere.
             if ($3 > std::numeric_limits<std::uint16_t>::max()) {
               YYTHD->syntax_error_at(@3,
               "The valid range for key_block_size is [0,65535]. Error");
               MYSQL_YYABORT;
             }
 
             $$= NEW_PTN
-            PT_create_key_block_size_option(static_cast<std::uint32_t>($3));
+            PT_create_key_block_size_option(@$, static_cast<std::uint32_t>($3));
           }
         | START_SYM TRANSACTION_SYM
           {
-            $$= NEW_PTN PT_create_start_transaction_option(true);
+            $$= NEW_PTN PT_create_start_transaction_option(@$, true);
 	  }
         | ENGINE_ATTRIBUTE_SYM opt_equal json_attribute
           {
             $$ = make_table_engine_attribute(YYMEM_ROOT, $3);
           }
         | SECONDARY_ENGINE_ATTRIBUTE_SYM opt_equal json_attribute
           {
             $$ = make_table_secondary_engine_attribute(YYMEM_ROOT, $3);
           }
         | option_autoextend_size
           {
-            $$ = NEW_PTN PT_create_ts_autoextend_size_option($1);
+            $$ = NEW_PTN PT_create_ts_autoextend_size_option(@$, $1);
           }
         ;
 
@@ -6967,7 +6967,7 @@ table_element:
 column_def:
           ident field_def opt_references
           {
-            $$= NEW_PTN PT_column_def($1, $2, $3);
+            $$= NEW_PTN PT_column_def(@$, $1, $2, $3);
           }
         ;
 
@@ -6983,42 +6983,42 @@ opt_references:
 table_constraint_def:
           key_or_index opt_index_name_and_type '(' key_list_with_expression ')'
           opt_index_options
           {
-            $$= NEW_PTN PT_inline_index_definition(KEYTYPE_MULTIPLE,
+            $$= NEW_PTN PT_inline_index_definition(@$, KEYTYPE_MULTIPLE,
                                                    $2.name, $2.type, $4, $6);
           }
         | FULLTEXT_SYM opt_key_or_index opt_ident '(' key_list_with_expression ')'
           opt_fulltext_index_options
           {
-            $$= NEW_PTN PT_inline_index_definition(KEYTYPE_FULLTEXT, $3, NULL,
+            $$= NEW_PTN PT_inline_index_definition(@$, KEYTYPE_FULLTEXT, $3, NULL,
                                                    $5, $7);
           }
         | SPATIAL_SYM opt_key_or_index opt_ident '(' key_list_with_expression ')'
           opt_spatial_index_options
           {
-            $$= NEW_PTN PT_inline_index_definition(KEYTYPE_SPATIAL, $3, NULL, $5, $7);
+            $$= NEW_PTN PT_inline_index_definition(@$, KEYTYPE_SPATIAL, $3, NULL, $5, $7);
           }
         | opt_constraint_name constraint_key_type opt_index_name_and_type
           '(' key_list_with_expression ')' opt_index_options
           {
             /*
               Constraint-implementing indexes are named by the constraint type
               by default.
             */
             LEX_STRING name= $3.name.str != NULL ? $3.name : $1;
-            $$= NEW_PTN PT_inline_index_definition($2, name, $3.type, $5, $7);
+            $$= NEW_PTN PT_inline_index_definition(@$, $2, name, $3.type, $5, $7);
           }
         | opt_constraint_name FOREIGN KEY_SYM opt_ident '(' key_list ')' references
           {
-            $$= NEW_PTN PT_foreign_key_definition($1, $4, $6, $8.table_name,
+            $$= NEW_PTN PT_foreign_key_definition(@$, $1, $4, $6, $8.table_name,
                                                   $8.reference_list,
                                                   $8.fk_match_option,
                                                   $8.fk_update_opt,
                                                   $8.fk_delete_opt);
           }
         | opt_constraint_name check_constraint opt_constraint_enforcement
           {
-            $$= NEW_PTN PT_check_constraint($1, $2, $3);
+            $$= NEW_PTN PT_check_constraint(@$, $1, $2, $3);
             if ($$ == nullptr) MYSQL_YYABORT; // OOM
           }
         ;
@@ -7049,26 +7049,26 @@ constraint_enforcement:
 field_def:
           type opt_column_attribute_list
           {
-            $$= NEW_PTN PT_field_def($1, $2);
+            $$= NEW_PTN PT_field_def(@$, $1, $2);
           }
         | type opt_collate opt_generated_always
           AS '(' expr ')'
           opt_stored_attribute opt_column_attribute_list
           {
             auto *opt_attrs= $9;
             if ($2 != NULL)
             {
               if (opt_attrs == NULL)
               {
                 opt_attrs= NEW_PTN
                   Mem_root_array<PT_column_attr_base *>(YYMEM_ROOT);
               }
               auto *collation= NEW_PTN PT_collate_column_attr(@2, $2);
               if (opt_attrs == nullptr || collation == nullptr ||
                   opt_attrs->push_back(collation))
                 MYSQL_YYABORT; // OOM
             }
-            $$= NEW_PTN PT_generated_field_def($1, $6, $8, opt_attrs);
+            $$= NEW_PTN PT_generated_field_def(@$, $1, $6, $8, opt_attrs);
           }
         ;
 
@@ -7086,211 +7086,211 @@ opt_stored_attribute:
 type:
           int_type opt_field_length field_options
           {
-            $$= NEW_PTN PT_numeric_type(YYTHD, $1, $2, $3);
+            $$= NEW_PTN PT_numeric_type(@$, YYTHD, $1, $2, $3);
           }
         | real_type opt_precision field_options
           {
-            $$= NEW_PTN PT_numeric_type(YYTHD, $1, $2.length, $2.dec, $3);
+            $$= NEW_PTN PT_numeric_type(@$, YYTHD, $1, $2.length, $2.dec, $3);
           }
         | numeric_type float_options field_options
           {
-            $$= NEW_PTN PT_numeric_type(YYTHD, $1, $2.length, $2.dec, $3);
+            $$= NEW_PTN PT_numeric_type(@$, YYTHD, $1, $2.length, $2.dec, $3);
           }
         | BIT_SYM %prec KEYWORD_USED_AS_KEYWORD
           {
-            $$= NEW_PTN PT_bit_type;
+            $$= NEW_PTN PT_bit_type(@$);
           }
         | BIT_SYM field_length
           {
-            $$= NEW_PTN PT_bit_type($2);
+            $$= NEW_PTN PT_bit_type(@$, $2);
           }
         | BOOL_SYM
           {
-            $$= NEW_PTN PT_boolean_type;
+            $$= NEW_PTN PT_boolean_type(@$);
           }
         | BOOLEAN_SYM
           {
-            $$= NEW_PTN PT_boolean_type;
+            $$= NEW_PTN PT_boolean_type(@$);
           }
         | CHAR_SYM field_length opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_char_type(Char_type::CHAR, $2, $3.charset,
+            $$= NEW_PTN PT_char_type(@$, Char_type::CHAR, $2, $3.charset,
                                      $3.force_binary);
           }
         | CHAR_SYM opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_char_type(Char_type::CHAR, $2.charset,
+            $$= NEW_PTN PT_char_type(@$, Char_type::CHAR, $2.charset,
                                      $2.force_binary);
           }
         | nchar field_length opt_bin_mod
           {
             const CHARSET_INFO *cs= $3 ?
               get_bin_collation(national_charset_info) : national_charset_info;
             if (cs == NULL)
               MYSQL_YYABORT;
-            $$= NEW_PTN PT_char_type(Char_type::CHAR, $2, cs);
+            $$= NEW_PTN PT_char_type(@$, Char_type::CHAR, $2, cs);
             warn_about_deprecated_national(YYTHD);
           }
         | nchar opt_bin_mod
           {
             const CHARSET_INFO *cs= $2 ?
               get_bin_collation(national_charset_info) : national_charset_info;
             if (cs == NULL)
               MYSQL_YYABORT;
-            $$= NEW_PTN PT_char_type(Char_type::CHAR, cs);
+            $$= NEW_PTN PT_char_type(@$, Char_type::CHAR, cs);
             warn_about_deprecated_national(YYTHD);
           }
         | BINARY_SYM field_length
           {
-            $$= NEW_PTN PT_char_type(Char_type::CHAR, $2, &my_charset_bin);
+            $$= NEW_PTN PT_char_type(@$, Char_type::CHAR, $2, &my_charset_bin);
           }
         | BINARY_SYM
           {
-            $$= NEW_PTN PT_char_type(Char_type::CHAR, &my_charset_bin);
+            $$= NEW_PTN PT_char_type(@$, Char_type::CHAR, &my_charset_bin);
           }
         | varchar field_length opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_char_type(Char_type::VARCHAR, $2, $3.charset,
+            $$= NEW_PTN PT_char_type(@$, Char_type::VARCHAR, $2, $3.charset,
                                      $3.force_binary);
           }
         | nvarchar field_length opt_bin_mod
           {
             const CHARSET_INFO *cs= $3 ?
               get_bin_collation(national_charset_info) : national_charset_info;
             if (cs == NULL)
               MYSQL_YYABORT;
-            $$= NEW_PTN PT_char_type(Char_type::VARCHAR, $2, cs);
+            $$= NEW_PTN PT_char_type(@$, Char_type::VARCHAR, $2, cs);
             warn_about_deprecated_national(YYTHD);
           }
         | VARBINARY_SYM field_length
           {
-            $$= NEW_PTN PT_char_type(Char_type::VARCHAR, $2, &my_charset_bin);
+            $$= NEW_PTN PT_char_type(@$, Char_type::VARCHAR, $2, &my_charset_bin);
           }
         | YEAR_SYM opt_field_length field_options
           {
             if ($2)
             {
               errno= 0;
               ulong length= strtoul($2, NULL, 10);
               if (errno != 0 || length != 4)
               {
                 /* Only support length is 4 */
                 my_error(ER_INVALID_YEAR_COLUMN_LENGTH, MYF(0), "YEAR");
                 MYSQL_YYABORT;
               }
               push_deprecated_warn(YYTHD, "YEAR(4)", "YEAR");
             }
             if ($3 == UNSIGNED_FLAG)
             {
               push_warning(YYTHD, Sql_condition::SL_WARNING,
                            ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
                            ER_THD(YYTHD, ER_WARN_DEPRECATED_YEAR_UNSIGNED));
             }
             // We can ignore field length and UNSIGNED/ZEROFILL attributes here.
-            $$= NEW_PTN PT_year_type;
+            $$= NEW_PTN PT_year_type(@$);
           }
         | DATE_SYM
           {
-            $$= NEW_PTN PT_date_type;
+            $$= NEW_PTN PT_date_type(@$);
           }
         | TIME_SYM type_datetime_precision
           {
-            $$= NEW_PTN PT_time_type(Time_type::TIME, $2);
+            $$= NEW_PTN PT_time_type(@$, Time_type::TIME, $2);
           }
         | TIMESTAMP_SYM type_datetime_precision
           {
-            $$= NEW_PTN PT_timestamp_type($2);
+            $$= NEW_PTN PT_timestamp_type(@$, $2);
           }
         | DATETIME_SYM type_datetime_precision
           {
-            $$= NEW_PTN PT_time_type(Time_type::DATETIME, $2);
+            $$= NEW_PTN PT_time_type(@$, Time_type::DATETIME, $2);
           }
         | TINYBLOB_SYM
           {
-            $$= NEW_PTN PT_blob_type(Blob_type::TINY, &my_charset_bin);
+            $$= NEW_PTN PT_blob_type(@$, Blob_type::TINY, &my_charset_bin);
           }
         | BLOB_SYM opt_field_length
           {
-            $$= NEW_PTN PT_blob_type($2);
+            $$= NEW_PTN PT_blob_type(@$, $2);
           }
         | spatial_type
         | MEDIUMBLOB_SYM
           {
-            $$= NEW_PTN PT_blob_type(Blob_type::MEDIUM, &my_charset_bin);
+            $$= NEW_PTN PT_blob_type(@$, Blob_type::MEDIUM, &my_charset_bin);
           }
         | LONGBLOB_SYM
           {
-            $$= NEW_PTN PT_blob_type(Blob_type::LONG, &my_charset_bin);
+            $$= NEW_PTN PT_blob_type(@$, Blob_type::LONG, &my_charset_bin);
           }
         | LONG_SYM VARBINARY_SYM
           {
-            $$= NEW_PTN PT_blob_type(Blob_type::MEDIUM, &my_charset_bin);
+            $$= NEW_PTN PT_blob_type(@$, Blob_type::MEDIUM, &my_charset_bin);
           }
         | LONG_SYM varchar opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_blob_type(Blob_type::MEDIUM, $3.charset,
+            $$= NEW_PTN PT_blob_type(@$, Blob_type::MEDIUM, $3.charset,
                                      $3.force_binary);
           }
         | TINYTEXT_SYN opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_blob_type(Blob_type::TINY, $2.charset,
+            $$= NEW_PTN PT_blob_type(@$, Blob_type::TINY, $2.charset,
                                      $2.force_binary);
           }
         | TEXT_SYM opt_field_length opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_char_type(Char_type::TEXT, $2, $3.charset,
+            $$= NEW_PTN PT_char_type(@$, Char_type::TEXT, $2, $3.charset,
                                      $3.force_binary);
           }
         | MEDIUMTEXT_SYM opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_blob_type(Blob_type::MEDIUM, $2.charset,
+            $$= NEW_PTN PT_blob_type(@$, Blob_type::MEDIUM, $2.charset,
                                      $2.force_binary);
           }
         | LONGTEXT_SYM opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_blob_type(Blob_type::LONG, $2.charset,
+            $$= NEW_PTN PT_blob_type(@$, Blob_type::LONG, $2.charset,
                                      $2.force_binary);
           }
         | ENUM_SYM '(' string_list ')' opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_enum_type($3, $5.charset, $5.force_binary);
+            $$= NEW_PTN PT_enum_type(@$, $3, $5.charset, $5.force_binary);
           }
         | SET_SYM '(' string_list ')' opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_set_type($3, $5.charset, $5.force_binary);
+            $$= NEW_PTN PT_set_type(@$, $3, $5.charset, $5.force_binary);
           }
         | LONG_SYM opt_charset_with_opt_binary
           {
-            $$= NEW_PTN PT_blob_type(Blob_type::MEDIUM, $2.charset,
+            $$= NEW_PTN PT_blob_type(@$, Blob_type::MEDIUM, $2.charset,
                                      $2.force_binary);
           }
         | SERIAL_SYM
           {
-            $$= NEW_PTN PT_serial_type;
+            $$= NEW_PTN PT_serial_type(@$);
           }
         | JSON_SYM
           {
-            $$= NEW_PTN PT_json_type;
+            $$= NEW_PTN PT_json_type(@$);
           }
         ;
 
 spatial_type:
           GEOMETRY_SYM
-          { $$= NEW_PTN PT_spacial_type(Field::GEOM_GEOMETRY); }
+          { $$= NEW_PTN PT_spacial_type(@$, Field::GEOM_GEOMETRY); }
         | GEOMETRYCOLLECTION_SYM
-          { $$= NEW_PTN PT_spacial_type(Field::GEOM_GEOMETRYCOLLECTION); }
+          { $$= NEW_PTN PT_spacial_type(@$, Field::GEOM_GEOMETRYCOLLECTION); }
         | POINT_SYM
-          { $$= NEW_PTN PT_spacial_type(Field::GEOM_POINT); }
+          { $$= NEW_PTN PT_spacial_type(@$, Field::GEOM_POINT); }
         | MULTIPOINT_SYM
-          { $$= NEW_PTN PT_spacial_type(Field::GEOM_MULTIPOINT); }
+          { $$= NEW_PTN PT_spacial_type(@$, Field::GEOM_MULTIPOINT); }
         | LINESTRING_SYM
-          { $$= NEW_PTN PT_spacial_type(Field::GEOM_LINESTRING); }
+          { $$= NEW_PTN PT_spacial_type(@$, Field::GEOM_LINESTRING); }
         | MULTILINESTRING_SYM
-          { $$= NEW_PTN PT_spacial_type(Field::GEOM_MULTILINESTRING); }
+          { $$= NEW_PTN PT_spacial_type(@$, Field::GEOM_MULTILINESTRING); }
         | POLYGON_SYM
-          { $$= NEW_PTN PT_spacial_type(Field::GEOM_POLYGON); }
+          { $$= NEW_PTN PT_spacial_type(@$, Field::GEOM_POLYGON); }
         | MULTIPOLYGON_SYM
-          { $$= NEW_PTN PT_spacial_type(Field::GEOM_MULTIPOLYGON); }
+          { $$= NEW_PTN PT_spacial_type(@$, Field::GEOM_MULTIPOLYGON); }
         ;
 
 nchar:
@@ -7482,102 +7482,102 @@ column_attribute_list:
 column_attribute:
           NULL_SYM
           {
-            $$= NEW_PTN PT_null_column_attr;
+            $$= NEW_PTN PT_null_column_attr(@$);
           }
         | not NULL_SYM
           {
-            $$= NEW_PTN PT_not_null_column_attr;
+            $$= NEW_PTN PT_not_null_column_attr(@$);
           }
         | not SECONDARY_SYM
           {
-            $$= NEW_PTN PT_secondary_column_attr;
+            $$= NEW_PTN PT_secondary_column_attr(@$);
           }
         | DEFAULT_SYM now_or_signed_literal
           {
-            $$= NEW_PTN PT_default_column_attr($2);
+            $$= NEW_PTN PT_default_column_attr(@$, $2);
           }
         | DEFAULT_SYM '(' expr ')'
           {
-            $$= NEW_PTN PT_generated_default_val_column_attr($3);
+            $$= NEW_PTN PT_generated_default_val_column_attr(@$, $3);
           }
         | ON_SYM UPDATE_SYM now
           {
-            $$= NEW_PTN PT_on_update_column_attr(static_cast<uint8>($3));
+            $$= NEW_PTN PT_on_update_column_attr(@$, static_cast<uint8>($3));
           }
         | AUTO_INC
           {
-            $$= NEW_PTN PT_auto_increment_column_attr;
+            $$= NEW_PTN PT_auto_increment_column_attr(@$);
           }
         | SERIAL_SYM DEFAULT_SYM VALUE_SYM
           {
-            $$= NEW_PTN PT_serial_default_value_column_attr;
+            $$= NEW_PTN PT_serial_default_value_column_attr(@$);
           }
         | opt_primary KEY_SYM
           {
-            $$= NEW_PTN PT_primary_key_column_attr;
+            $$= NEW_PTN PT_primary_key_column_attr(@$);
           }
         | UNIQUE_SYM
           {
-            $$= NEW_PTN PT_unique_key_column_attr;
+            $$= NEW_PTN PT_unique_key_column_attr(@$);
           }
         | UNIQUE_SYM KEY_SYM
           {
-            $$= NEW_PTN PT_unique_key_column_attr;
+            $$= NEW_PTN PT_unique_key_column_attr(@$);
           }
         | COMMENT_SYM TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_comment_column_attr(to_lex_cstring($2));
+            $$= NEW_PTN PT_comment_column_attr(@$, to_lex_cstring($2));
           }
         | COLLATE_SYM collation_name
           {
-            $$= NEW_PTN PT_collate_column_attr(@2, $2);
+            $$= NEW_PTN PT_collate_column_attr(@$, $2);
           }
         | COLUMN_FORMAT_SYM column_format
           {
-            $$= NEW_PTN PT_column_format_column_attr($2);
+            $$= NEW_PTN PT_column_format_column_attr(@$, $2);
           }
         | STORAGE_SYM storage_media
           {
-            $$= NEW_PTN PT_storage_media_column_attr($2);
+            $$= NEW_PTN PT_storage_media_column_attr(@$, $2);
           }
         | SRID_SYM real_ulonglong_num
           {
             if ($2 > std::numeric_limits<gis::srid_t>::max())
             {
               my_error(ER_DATA_OUT_OF_RANGE, MYF(0), "SRID", "SRID");
               MYSQL_YYABORT;
             }
-            $$= NEW_PTN PT_srid_column_attr(static_cast<gis::srid_t>($2));
+            $$= NEW_PTN PT_srid_column_attr(@$, static_cast<gis::srid_t>($2));
           }
         | opt_constraint_name check_constraint
           /* See the next branch for [NOT] ENFORCED. */
           {
-            $$= NEW_PTN PT_check_constraint_column_attr($1, $2);
+            $$= NEW_PTN PT_check_constraint_column_attr(@$, $1, $2);
           }
         | constraint_enforcement
           /*
             This branch is needed to workaround the need of a lookahead of 2 for
             the grammar:
 
              { [NOT] NULL | CHECK(...) [NOT] ENFORCED } ...
 
             Note: the column_attribute_list rule rejects all unexpected
                   [NOT] ENFORCED sequences.
           */
           {
-            $$ = NEW_PTN PT_constraint_enforcement_attr($1);
+            $$ = NEW_PTN PT_constraint_enforcement_attr(@$, $1);
           }
         | ENGINE_ATTRIBUTE_SYM opt_equal json_attribute
           {
             $$ = make_column_engine_attribute(YYMEM_ROOT, $3);
           }
         | SECONDARY_ENGINE_ATTRIBUTE_SYM opt_equal json_attribute
           {
             $$ = make_column_secondary_engine_attribute(YYMEM_ROOT, $3);
           }
         | visibility
           {
-            $$ = NEW_PTN PT_column_visibility_attr($1);
+            $$ = NEW_PTN PT_column_visibility_attr(@$, $1);
           }
         ;
 
@@ -7913,15 +7913,15 @@ fulltext_index_options:
 fulltext_index_option:
           common_index_option
         | WITH PARSER_SYM IDENT_sys
           {
             LEX_CSTRING plugin_name= {$3.str, $3.length};
             if (!plugin_is_ready(plugin_name, MYSQL_FTPARSER_PLUGIN))
             {
               my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), $3.str);
               MYSQL_YYABORT;
             }
             else
-              $$= NEW_PTN PT_fulltext_index_parser_name(to_lex_cstring($3));
+              $$= NEW_PTN PT_fulltext_index_parser_name(@$, to_lex_cstring($3));
           }
         ;
 
@@ -7976,46 +7976,46 @@ index_option:
 
 // These options are common for all index types.
 common_index_option:
-          KEY_BLOCK_SIZE opt_equal ulong_num { $$= NEW_PTN PT_block_size($3); }
+          KEY_BLOCK_SIZE opt_equal ulong_num { $$= NEW_PTN PT_block_size(@$, $3); }
         | COMMENT_SYM TEXT_STRING_sys
           {
-            $$= NEW_PTN PT_index_comment(to_lex_cstring($2));
+            $$= NEW_PTN PT_index_comment(@$, to_lex_cstring($2));
           }
         | visibility
           {
-            $$= NEW_PTN PT_index_visibility($1);
+            $$= NEW_PTN PT_index_visibility(@$, $1);
           }
         | ENGINE_ATTRIBUTE_SYM opt_equal json_attribute
           {
             $$ = make_index_engine_attribute(YYMEM_ROOT, $3);
           }
         | SECONDARY_ENGINE_ATTRIBUTE_SYM opt_equal json_attribute
           {
             $$ = make_index_secondary_engine_attribute(YYMEM_ROOT, $3);
           }
         ;
 
 /*
   The syntax for defining an index is:
 
     ... INDEX [index_name] [USING|TYPE] <index_type> ...
 
   The problem is that whereas USING is a reserved word, TYPE is not. We can
   still handle it if an index name is supplied, i.e.:
 
     ... INDEX type TYPE <index_type> ...
 
   here the index's name is unmbiguously 'type', but for this:
 
     ... INDEX TYPE <index_type> ...
 
   it's impossible to know what this actually mean - is 'type' the name or the
   type? For this reason we accept the TYPE syntax only if a name is supplied.
 */
 opt_index_name_and_type:
           opt_ident                  { $$= {$1, NULL}; }
-        | opt_ident USING index_type { $$= {$1, NEW_PTN PT_index_type($3)}; }
-        | ident TYPE_SYM index_type  { $$= {$1, NEW_PTN PT_index_type($3)}; }
+        | opt_ident USING index_type { $$= {$1, NEW_PTN PT_index_type(@$, $3)}; }
+        | ident TYPE_SYM index_type  { $$= {$1, NEW_PTN PT_index_type(@$, $3)}; }
         ;
 
 opt_index_type_clause:
@@ -8024,8 +8024,8 @@ opt_index_type_clause:
         ;
 
 index_type_clause:
-          USING index_type    { $$= NEW_PTN PT_index_type($2); }
-        | TYPE_SYM index_type { $$= NEW_PTN PT_index_type($2); }
+          USING index_type    { $$= NEW_PTN PT_index_type(@$, $2); }
+        | TYPE_SYM index_type { $$= NEW_PTN PT_index_type(@$, $2); }
         ;
 
 visibility:
@@ -8058,20 +8058,20 @@ key_list:
 key_part:
           ident opt_ordering_direction
           {
-            $$= NEW_PTN PT_key_part_specification(to_lex_cstring($1), $2, 0);
+            $$= NEW_PTN PT_key_part_specification(@$, to_lex_cstring($1), $2, 0);
             if ($$ == NULL)
               MYSQL_YYABORT;
           }
         | ident '(' NUM ')' opt_ordering_direction
           {
             int key_part_length= atoi($3.str);
             if (!key_part_length)
             {
               my_error(ER_KEY_PART_0, MYF(0), $1.str);
             }
-            $$= NEW_PTN PT_key_part_specification(to_lex_cstring($1), $5,
+            $$= NEW_PTN PT_key_part_specification(@$, to_lex_cstring($1), $5,
                                                   key_part_length);
             if ($$ == NULL)
               MYSQL_YYABORT; /* purecov: deadcode */
           }
         ;
@@ -8095,9 +8095,9 @@ key_list_with_expression:
 key_part_with_expression:
           key_part
         | '(' expr ')' opt_ordering_direction
           {
-            $$= NEW_PTN PT_key_part_specification($2, $4);
+            $$= NEW_PTN PT_key_part_specification(@$, $2, $4);
             if ($$ == NULL)
               MYSQL_YYABORT;
           }
         ;
@@ -8128,22 +8128,24 @@ string_list:
 alter_table_stmt:
           ALTER TABLE_SYM table_ident opt_alter_table_actions
           {
             $$= NEW_PTN PT_alter_table_stmt(
+                  @$,
                   YYMEM_ROOT,
                   $3,
                   $4.actions,
                   $4.flags.algo.get_or_default(),
                   $4.flags.lock.get_or_default(),
                   $4.flags.validation.get_or_default());
           }
         | ALTER TABLE_SYM table_ident standalone_alter_table_action
           {
             $$= NEW_PTN PT_alter_table_standalone_stmt(
+                  @$,
                   YYMEM_ROOT,
                   $3,
                   $4.action,
                   $4.flags.algo.get_or_default(),
                   $4.flags.lock.get_or_default(),
                   $4.flags.validation.get_or_default());
           }
         ;
@@ -8410,81 +8412,81 @@ alter_server_stmt:
 alter_user_stmt:
           alter_user_command alter_user_list require_clause
           connect_options opt_account_lock_password_expire_options
           opt_user_attribute
         | alter_user_command user_func identified_by_random_password
           opt_replace_password opt_retain_current_password
           {
             $2->first_factor_auth_info = *$3;
 
             if ($4.str != nullptr) {
               $2->current_auth = $4;
               $2->uses_replace_clause = true;
             }
             $2->discard_old_password = false;
             $2->retain_current_password = $5;
           }
         | alter_user_command user_func identified_by_password
           opt_replace_password opt_retain_current_password
           {
             $2->first_factor_auth_info = *$3;
 
             if ($4.str != nullptr) {
               $2->current_auth = $4;
               $2->uses_replace_clause = true;
             }
             $2->discard_old_password = false;
             $2->retain_current_password = $5;
           }
         | alter_user_command user_func DISCARD_SYM OLD_SYM PASSWORD
           {
             $2->discard_old_password = true;
             $2->retain_current_password = false;
           }
         | alter_user_command user DEFAULT_SYM ROLE_SYM ALL
           {
             List<LEX_USER> *users= new (YYMEM_ROOT) List<LEX_USER>;
             if (users == NULL || users->push_back($2))
               MYSQL_YYABORT;
             List<LEX_USER> *role_list= new (YYMEM_ROOT) List<LEX_USER>;
             auto *tmp=
-                NEW_PTN PT_alter_user_default_role(Lex->drop_if_exists,
+                NEW_PTN PT_alter_user_default_role(@$, Lex->drop_if_exists,
                                                    users, role_list,
                                                    role_enum::ROLE_ALL);
               MAKE_CMD(tmp);
           }
         | alter_user_command user DEFAULT_SYM ROLE_SYM NONE_SYM
           {
             List<LEX_USER> *users= new (YYMEM_ROOT) List<LEX_USER>;
             if (users == NULL || users->push_back($2))
               MYSQL_YYABORT;
             List<LEX_USER> *role_list= new (YYMEM_ROOT) List<LEX_USER>;
             auto *tmp=
-                NEW_PTN PT_alter_user_default_role(Lex->drop_if_exists,
+                NEW_PTN PT_alter_user_default_role(@$, Lex->drop_if_exists,
                                                    users, role_list,
                                                    role_enum::ROLE_NONE);
               MAKE_CMD(tmp);
           }
         | alter_user_command user DEFAULT_SYM ROLE_SYM role_list
           {
             List<LEX_USER> *users= new (YYMEM_ROOT) List<LEX_USER>;
             if (users == NULL || users->push_back($2))
               MYSQL_YYABORT;
             auto *tmp=
-              NEW_PTN PT_alter_user_default_role(Lex->drop_if_exists,
+              NEW_PTN PT_alter_user_default_role(@$, Lex->drop_if_exists,
                                                  users, $5,
                                                  role_enum::ROLE_NAME);
             MAKE_CMD(tmp);
           }
         | alter_user_command user opt_user_registration
           {
             if ($2->mfa_list.push_back($3))
               MYSQL_YYABORT;  // OOM
             LEX *lex=Lex;
             lex->users_list.push_front ($2);
           }
         | alter_user_command user_func opt_user_registration
           {
             if ($2->mfa_list.push_back($3))
               MYSQL_YYABORT;  // OOM
           }
         ;
@@ -8497,9 +8499,9 @@ opt_replace_password:
 alter_resource_group_stmt:
           ALTER RESOURCE_SYM GROUP_SYM ident opt_resource_group_vcpu_list
           opt_resource_group_priority opt_resource_group_enable_disable
           opt_force
           {
-            $$= NEW_PTN PT_alter_resource_group(to_lex_cstring($4),
+            $$= NEW_PTN PT_alter_resource_group(@$, to_lex_cstring($4),
                                                 $5, $6, $7, $8);
           }
         ;
@@ -8787,11 +8789,11 @@ standalone_alter_table_action:
 alter_table_partition_options:
           partition_clause
           {
-            $$= NEW_PTN PT_alter_table_partition_by($1);
+            $$= NEW_PTN PT_alter_table_partition_by(@$, $1);
           }
         | REMOVE_SYM PARTITIONING_SYM
           {
-            $$= NEW_PTN PT_alter_table_remove_partitioning;
+            $$= NEW_PTN PT_alter_table_remove_partitioning(@$);
           }
         ;
 
@@ -8818,101 +8820,101 @@ opt_alter_command_list:
 standalone_alter_commands:
           DISCARD_SYM TABLESPACE_SYM
           {
-            $$= NEW_PTN PT_alter_table_discard_tablespace;
+            $$= NEW_PTN PT_alter_table_discard_tablespace(@$);
           }
         | IMPORT TABLESPACE_SYM
           {
-            $$= NEW_PTN PT_alter_table_import_tablespace;
+            $$= NEW_PTN PT_alter_table_import_tablespace(@$);
           }
 /*
   This part was added for release 5.1 by Mikael Ronström.
   From here we insert a number of commands to manage the partitions of a
   partitioned table such as adding partitions, dropping partitions,
   reorganising partitions in various manners. In future releases the list
   will be longer.
 */
         | ADD PARTITION_SYM opt_no_write_to_binlog
           {
-            $$= NEW_PTN PT_alter_table_add_partition($3);
+            $$= NEW_PTN PT_alter_table_add_partition(@$, $3);
           }
         | ADD PARTITION_SYM opt_no_write_to_binlog '(' part_def_list ')'
           {
-            $$= NEW_PTN PT_alter_table_add_partition_def_list($3, $5);
+            $$= NEW_PTN PT_alter_table_add_partition_def_list(@$, $3, $5);
           }
         | ADD PARTITION_SYM opt_no_write_to_binlog PARTITIONS_SYM real_ulong_num
           {
-            $$= NEW_PTN PT_alter_table_add_partition_num($3, $5);
+            $$= NEW_PTN PT_alter_table_add_partition_num(@$, $3, $5);
           }
         | DROP PARTITION_SYM ident_string_list
           {
-            $$= NEW_PTN PT_alter_table_drop_partition(*$3);
+            $$= NEW_PTN PT_alter_table_drop_partition(@$, *$3);
           }
         | REBUILD_SYM PARTITION_SYM opt_no_write_to_binlog
           all_or_alt_part_name_list
           {
-            $$= NEW_PTN PT_alter_table_rebuild_partition($3, $4);
+            $$= NEW_PTN PT_alter_table_rebuild_partition(@$, $3, $4);
           }
         | OPTIMIZE PARTITION_SYM opt_no_write_to_binlog
           all_or_alt_part_name_list
           {
-            $$= NEW_PTN PT_alter_table_optimize_partition($3, $4);
+            $$= NEW_PTN PT_alter_table_optimize_partition(@$, $3, $4);
           }
         | ANALYZE_SYM PARTITION_SYM opt_no_write_to_binlog
           all_or_alt_part_name_list
           {
-            $$= NEW_PTN PT_alter_table_analyze_partition($3, $4);
+            $$= NEW_PTN PT_alter_table_analyze_partition(@$, $3, $4);
           }
         | CHECK_SYM PARTITION_SYM all_or_alt_part_name_list opt_mi_check_types
           {
-            $$= NEW_PTN PT_alter_table_check_partition($3,
+            $$= NEW_PTN PT_alter_table_check_partition(@$, $3,
                                                        $4.flags, $4.sql_flags);
           }
         | REPAIR PARTITION_SYM opt_no_write_to_binlog
           all_or_alt_part_name_list
           opt_mi_repair_types
           {
-            $$= NEW_PTN PT_alter_table_repair_partition($3, $4,
+            $$= NEW_PTN PT_alter_table_repair_partition(@$, $3, $4,
                                                         $5.flags, $5.sql_flags);
           }
         | COALESCE PARTITION_SYM opt_no_write_to_binlog real_ulong_num
           {
-            $$= NEW_PTN PT_alter_table_coalesce_partition($3, $4);
+            $$= NEW_PTN PT_alter_table_coalesce_partition(@$, $3, $4);
           }
         | TRUNCATE_SYM PARTITION_SYM all_or_alt_part_name_list
           {
-            $$= NEW_PTN PT_alter_table_truncate_partition($3);
+            $$= NEW_PTN PT_alter_table_truncate_partition(@$, $3);
           }
         | REORGANIZE_SYM PARTITION_SYM opt_no_write_to_binlog
           {
-            $$= NEW_PTN PT_alter_table_reorganize_partition($3);
+            $$= NEW_PTN PT_alter_table_reorganize_partition(@$, $3);
           }
         | REORGANIZE_SYM PARTITION_SYM opt_no_write_to_binlog
           ident_string_list INTO '(' part_def_list ')'
           {
-            $$= NEW_PTN PT_alter_table_reorganize_partition_into($3, *$4, $7);
+            $$= NEW_PTN PT_alter_table_reorganize_partition_into(@$, $3, *$4, $7);
           }
         | EXCHANGE_SYM PARTITION_SYM ident
           WITH TABLE_SYM table_ident opt_with_validation
           {
-            $$= NEW_PTN PT_alter_table_exchange_partition($3, $6, $7);
+            $$= NEW_PTN PT_alter_table_exchange_partition(@$, $3, $6, $7);
           }
         | DISCARD_SYM PARTITION_SYM all_or_alt_part_name_list
           TABLESPACE_SYM
           {
-            $$= NEW_PTN PT_alter_table_discard_partition_tablespace($3);
+            $$= NEW_PTN PT_alter_table_discard_partition_tablespace(@$, $3);
           }
         | IMPORT PARTITION_SYM all_or_alt_part_name_list
           TABLESPACE_SYM
           {
-            $$= NEW_PTN PT_alter_table_import_partition_tablespace($3);
+            $$= NEW_PTN PT_alter_table_import_partition_tablespace(@$, $3);
           }
         | SECONDARY_LOAD_SYM
           {
-            $$= NEW_PTN PT_alter_table_secondary_load;
+            $$= NEW_PTN PT_alter_table_secondary_load(@$);
           }
         | SECONDARY_UNLOAD_SYM
           {
-            $$= NEW_PTN PT_alter_table_secondary_unload;
+            $$= NEW_PTN PT_alter_table_secondary_unload(@$);
           }
         ;
 
@@ -8985,115 +8987,116 @@ alter_commands_modifier_list:
 alter_list_item:
           ADD opt_column ident field_def opt_references opt_place
           {
-            $$= NEW_PTN PT_alter_table_add_column($3, $4, $5, $6);
+            $$= NEW_PTN PT_alter_table_add_column(@$, $3, $4, $5, $6);
           }
         | ADD opt_column '(' table_element_list ')'
           {
-            $$= NEW_PTN PT_alter_table_add_columns($4);
+            $$= NEW_PTN PT_alter_table_add_columns(@$, $4);
           }
         | ADD table_constraint_def
           {
-            $$= NEW_PTN PT_alter_table_add_constraint($2);
+            $$= NEW_PTN PT_alter_table_add_constraint(@$, $2);
           }
         | CHANGE opt_column ident ident field_def opt_place
           {
-            $$= NEW_PTN PT_alter_table_change_column($3, $4, $5, $6);
+            $$= NEW_PTN PT_alter_table_change_column(@$, $3, $4, $5, $6);
           }
         | MODIFY_SYM opt_column ident field_def opt_place
           {
-            $$= NEW_PTN PT_alter_table_change_column($3, $4, $5);
+            $$= NEW_PTN PT_alter_table_change_column(@$, $3, $4, $5);
           }
         | DROP opt_column ident opt_restrict
           {
             // Note: opt_restrict ($4) is ignored!
-            $$= NEW_PTN PT_alter_table_drop_column($3.str);
+            $$= NEW_PTN PT_alter_table_drop_column(@$, $3.str);
           }
         | DROP FOREIGN KEY_SYM ident
           {
-            $$= NEW_PTN PT_alter_table_drop_foreign_key($4.str);
+            $$= NEW_PTN PT_alter_table_drop_foreign_key(@$, $4.str);
           }
         | DROP PRIMARY_SYM KEY_SYM
           {
-            $$= NEW_PTN PT_alter_table_drop_key(primary_key_name);
+            $$= NEW_PTN PT_alter_table_drop_key(@$, primary_key_name);
           }
         | DROP key_or_index ident
           {
-            $$= NEW_PTN PT_alter_table_drop_key($3.str);
+            $$= NEW_PTN PT_alter_table_drop_key(@$, $3.str);
           }
         | DROP CHECK_SYM ident
           {
-            $$= NEW_PTN PT_alter_table_drop_check_constraint($3.str);
+            $$= NEW_PTN PT_alter_table_drop_check_constraint(@$, $3.str);
           }
         | DROP CONSTRAINT ident
           {
-            $$= NEW_PTN PT_alter_table_drop_constraint($3.str);
+            $$= NEW_PTN PT_alter_table_drop_constraint(@$, $3.str);
           }
         | DISABLE_SYM KEYS
           {
-            $$= NEW_PTN PT_alter_table_enable_keys(false);
+            $$= NEW_PTN PT_alter_table_enable_keys(@$, false);
           }
         | ENABLE_SYM KEYS
           {
-            $$= NEW_PTN PT_alter_table_enable_keys(true);
+            $$= NEW_PTN PT_alter_table_enable_keys(@$, true);
           }
         | ALTER opt_column ident SET_SYM DEFAULT_SYM signed_literal_or_null
           {
-            $$= NEW_PTN PT_alter_table_set_default($3.str, $6);
+            $$= NEW_PTN PT_alter_table_set_default(@$, $3.str, $6);
           }
         |  ALTER opt_column ident SET_SYM DEFAULT_SYM '(' expr ')'
           {
-            $$= NEW_PTN PT_alter_table_set_default($3.str, $7);
+            $$= NEW_PTN PT_alter_table_set_default(@$, $3.str, $7);
           }
         | ALTER opt_column ident DROP DEFAULT_SYM
           {
-            $$= NEW_PTN PT_alter_table_set_default($3.str, NULL);
+            $$= NEW_PTN PT_alter_table_set_default(@$, $3.str, NULL);
           }
 
         | ALTER opt_column ident SET_SYM visibility
           {
-            $$= NEW_PTN PT_alter_table_column_visibility($3.str, $5);
+            $$= NEW_PTN PT_alter_table_column_visibility(@$, $3.str, $5);
           }
         | ALTER INDEX_SYM ident visibility
           {
-            $$= NEW_PTN PT_alter_table_index_visible($3.str, $4);
+            $$= NEW_PTN PT_alter_table_index_visible(@$, $3.str, $4);
           }
         | ALTER CHECK_SYM ident constraint_enforcement
           {
-            $$ = NEW_PTN PT_alter_table_enforce_check_constraint($3.str, $4);
+            $$ = NEW_PTN PT_alter_table_enforce_check_constraint(@$, $3.str, $4);
           }
         | ALTER CONSTRAINT ident constraint_enforcement
           {
-            $$ = NEW_PTN PT_alter_table_enforce_constraint($3.str, $4);
+            $$ = NEW_PTN PT_alter_table_enforce_constraint(@$, $3.str, $4);
           }
         | RENAME opt_to table_ident
           {
-            $$= NEW_PTN PT_alter_table_rename($3);
+            $$= NEW_PTN PT_alter_table_rename(@$, $3);
           }
         | RENAME key_or_index ident TO_SYM ident
           {
-            $$= NEW_PTN PT_alter_table_rename_key($3.str, $5.str);
+            $$= NEW_PTN PT_alter_table_rename_key(@$, $3.str, $5.str);
           }
         | RENAME COLUMN_SYM ident TO_SYM ident
           {
-            $$= NEW_PTN PT_alter_table_rename_column($3.str, $5.str);
+            $$= NEW_PTN PT_alter_table_rename_column(@$, $3.str, $5.str);
           }
         | CONVERT_SYM TO_SYM character_set charset_name opt_collate
           {
-            $$= NEW_PTN PT_alter_table_convert_to_charset($4, $5);
+            $$= NEW_PTN PT_alter_table_convert_to_charset(@$, $4, $5);
           }
         | CONVERT_SYM TO_SYM character_set DEFAULT_SYM opt_collate
           {
             $$ = NEW_PTN PT_alter_table_convert_to_charset(
+                @$,
                 YYTHD->variables.collation_database,
                 $5 ? $5 : YYTHD->variables.collation_database);
           }
         | FORCE_SYM
           {
-            $$= NEW_PTN PT_alter_table_force;
+            $$= NEW_PTN PT_alter_table_force(@$);
           }
         | ORDER_SYM BY alter_order_list
           {
-            $$= NEW_PTN PT_alter_table_order($3);
+            $$= NEW_PTN PT_alter_table_order(@$, $3);
           }
         ;
 
@@ -9535,8 +9538,8 @@ opt_checksum_type:
 repair_table_stmt:
           REPAIR opt_no_write_to_binlog table_or_tables
           table_list opt_mi_repair_types
           {
-            $$= NEW_PTN PT_repair_table_stmt(YYMEM_ROOT, $2, $4,
+            $$= NEW_PTN PT_repair_table_stmt(@$, YYMEM_ROOT, $2, $4,
                                              $5.flags, $5.sql_flags);
           }
         ;
@@ -9564,15 +9567,15 @@ mi_repair_type:
 analyze_table_stmt:
           ANALYZE_SYM opt_no_write_to_binlog table_or_tables table_list
           opt_histogram
           {
             if ($5.param) {
-              $$= NEW_PTN PT_analyze_table_stmt(YYMEM_ROOT, $2, $4,
+              $$= NEW_PTN PT_analyze_table_stmt(@$, YYMEM_ROOT, $2, $4,
                                                 $5.command, $5.param->num_buckets,
                                                 $5.columns, $5.param->data);
             } else {
-              $$= NEW_PTN PT_analyze_table_stmt(YYMEM_ROOT, $2, $4,
+              $$= NEW_PTN PT_analyze_table_stmt(@$, YYMEM_ROOT, $2, $4,
                                                 $5.command, 0,
                                                 $5.columns, {nullptr, 0});
             }
           }
         ;
@@ -9642,7 +9645,7 @@ binlog_base64_event:
 check_table_stmt:
           CHECK_SYM table_or_tables table_list opt_mi_check_types
           {
-            $$= NEW_PTN PT_check_table_stmt(YYMEM_ROOT, $3,
+            $$= NEW_PTN PT_check_table_stmt(@$, YYMEM_ROOT, $3,
                                             $4.flags, $4.sql_flags);
           }
         ;
@@ -9679,7 +9682,7 @@ mi_check_type:
 optimize_table_stmt:
           OPTIMIZE opt_no_write_to_binlog table_or_tables table_list
           {
-            $$= NEW_PTN PT_optimize_table_stmt(YYMEM_ROOT, $2, $4);
+            $$= NEW_PTN PT_optimize_table_stmt(@$, YYMEM_ROOT, $2, $4);
           }
         ;
 
@@ -9736,12 +9739,12 @@ table_to_table:
 keycache_stmt:
           CACHE_SYM INDEX_SYM keycache_list IN_SYM key_cache_name
           {
-            $$= NEW_PTN PT_cache_index_stmt(YYMEM_ROOT, $3, $5);
+            $$= NEW_PTN PT_cache_index_stmt(@$, YYMEM_ROOT, $3, $5);
           }
         | CACHE_SYM INDEX_SYM table_ident adm_partition opt_cache_key_list
           IN_SYM key_cache_name
           {
-            $$= NEW_PTN PT_cache_index_partitions_stmt(YYMEM_ROOT,
+            $$= NEW_PTN PT_cache_index_partitions_stmt(@$, YYMEM_ROOT,
                                                        $3, $4, $5, $7);
           }
         ;
@@ -9764,7 +9767,7 @@ keycache_list:
 assign_to_keycache:
           table_ident opt_cache_key_list
           {
-            $$= NEW_PTN PT_assign_to_keycache($1, $2);
+            $$= NEW_PTN PT_assign_to_keycache(@$, $1, $2);
           }
         ;
 
@@ -9776,12 +9779,12 @@ key_cache_name:
 preload_stmt:
           LOAD INDEX_SYM INTO CACHE_SYM
           table_ident adm_partition opt_cache_key_list opt_ignore_leaves
           {
-            $$= NEW_PTN PT_load_index_partitions_stmt(YYMEM_ROOT, $5,$6, $7, $8);
+            $$= NEW_PTN PT_load_index_partitions_stmt(@$, YYMEM_ROOT, $5,$6, $7, $8);
           }
         | LOAD INDEX_SYM INTO CACHE_SYM preload_list
           {
-            $$= NEW_PTN PT_load_index_stmt(YYMEM_ROOT, $5);
+            $$= NEW_PTN PT_load_index_stmt(@$, YYMEM_ROOT, $5);
           }
         ;
 
@@ -9803,14 +9806,14 @@ preload_list:
 preload_keys:
           table_ident opt_cache_key_list opt_ignore_leaves
           {
-            $$= NEW_PTN PT_preload_keys($1, $2, $3);
+            $$= NEW_PTN PT_preload_keys(@$, $1, $2, $3);
           }
         ;
 
 adm_partition:
           PARTITION_SYM '(' all_or_alt_part_name_list ')'
           {
-            $$= NEW_PTN PT_adm_partition($3);
+            $$= NEW_PTN PT_adm_partition(@$, $3);
           }
         ;
 
@@ -9833,209 +9836,219 @@ opt_ignore_leaves:
 select_stmt:
           query_expression
           {
-            $$ = NEW_PTN PT_select_stmt($1);
+            $$ = NEW_PTN PT_select_stmt(@$, $1);
           }
         | query_expression locking_clause_list
           {
-            $$ = NEW_PTN PT_select_stmt(NEW_PTN PT_locking($1, $2),
+            $$ = NEW_PTN PT_select_stmt(@$, NEW_PTN PT_locking(@$, $1, $2),
                                         nullptr, true);
           }
         | select_stmt_with_into
         ;
 
 /*
   MySQL has a syntax extension that allows into clauses in any one of two
   places. They may appear either before the from clause or at the end. All in
   a top-level select statement. This extends the standard syntax in two
   ways. First, we don't have the restriction that the result can contain only
   one row: the into clause might be INTO OUTFILE/DUMPFILE in which case any
   number of rows is allowed. Hence MySQL does not have any special case for
   the standard's <select statement: single row>. Secondly, and this has more
   severe implications for the parser, it makes the grammar ambiguous, because
   in a from-clause-less select statement with an into clause, it is not clear
   whether the into clause is the leading or the trailing one.
 
   While it's possible to write an unambiguous grammar, it would force us to
   duplicate the entire <select statement> syntax all the way down to the <into
   clause>. So instead we solve it by writing an ambiguous grammar and use
   precedence rules to sort out the shift/reduce conflict.
 
   The problem is when the parser has seen SELECT <select list>, and sees an
   INTO token. It can now either shift it or reduce what it has to a table-less
   query expression. If it shifts the token, it will accept seeing a FROM token
   next and hence the INTO will be interpreted as the leading INTO. If it
   reduces what it has seen to a table-less select, however, it will interpret
   INTO as the trailing into. But what if the next token is FROM? Obviously,
   we want to always shift INTO. We do this by two precedence declarations: We
   make the INTO token right-associative, and we give it higher precedence than
   an empty from clause, using the artificial token EMPTY_FROM_CLAUSE.
 
   The remaining problem is that now we allow the leading INTO anywhere, when
   it should be allowed on the top level only. We solve this by manually
   throwing parse errors whenever we reduce a nested query expression if it
   contains an into clause.
 */
 select_stmt_with_into:
           '(' select_stmt_with_into ')'
           {
             $$ = $2;
+            $$->m_pos = @$;
           }
         | query_expression into_clause
           {
-            $$ = NEW_PTN PT_select_stmt($1, $2);
+            $$ = NEW_PTN PT_select_stmt(@$, $1, $2);
           }
         | query_expression into_clause locking_clause_list
           {
-            $$ = NEW_PTN PT_select_stmt(NEW_PTN PT_locking($1, $3), $2, true);
+            $$ = NEW_PTN PT_select_stmt(@$, NEW_PTN PT_locking(@$, $1, $3), $2, true);
           }
         | query_expression locking_clause_list into_clause
           {
-            $$ = NEW_PTN PT_select_stmt(NEW_PTN PT_locking($1, $2), $3);
+            $$ = NEW_PTN PT_select_stmt(@$, NEW_PTN PT_locking(@$, $1, $2), $3);
           }
         ;
 
 /**
   A <query_expression> within parentheses can be used as an <expr>. Now,
   because both a <query_expression> and an <expr> can appear syntactically
   within any number of parentheses, we get an ambiguous grammar: Where do the
   parentheses belong? Techically, we have to tell Bison by which rule to
   reduce the extra pair of parentheses. We solve it in a somewhat tedious way
   by defining a query_expression so that it can't have enclosing
   parentheses. This forces us to be very explicit about exactly where we allow
   parentheses; while the standard defines only one rule for <query expression>
   parentheses, we have to do it in several places. But this is a blessing in
   disguise, as we are able to define our syntax in a more fine-grained manner,
   and this is necessary in order to support some MySQL extensions, for example
   as in the last two sub-rules here.
 
   Even if we define a query_expression not to have outer parentheses, we still
   get a shift/reduce conflict for the <subquery> rule, but we solve this by
   using an artifical token SUBQUERY_AS_EXPR that has less priority than
   parentheses. This ensures that the parser consumes as many parentheses as it
   can, and only when that fails will it try to reduce, and by then it will be
   clear from the lookahead token whether we have a subquery or just a
   query_expression within parentheses. For example, if the lookahead token is
   UNION it's just a query_expression within parentheses and the parentheses
   don't mean it's a subquery. If the next token is PLUS, we know it must be an
   <expr> and the parentheses really mean it's a subquery.
 
   A word about CTE's: The rules below are duplicated, one with a with_clause
   and one without, instead of using a single rule with an opt_with_clause. The
   reason we do this is because it would make Bison try to cram both rules into
   a single state, where it would have to decide whether to reduce a with_clause
   before seeing the rest of the input. This way we force Bison to parse the
   entire query expression before trying to reduce.
 */
 query_expression:
           query_expression_body
           opt_order_clause
           opt_limit_clause
           {
-            $$ = NEW_PTN PT_query_expression($1.body, $2, $3);
+            $$ = NEW_PTN PT_query_expression(@$, $1.body, $2, $3);
           }
         | with_clause
           query_expression_body
           opt_order_clause
           opt_limit_clause
           {
-            $$= NEW_PTN PT_query_expression($1, $2.body, $3, $4);
+            $$= NEW_PTN PT_query_expression(@$, $1, $2.body, $3, $4);
           }
         ;
 
 query_expression_body:
           query_primary
           {
             $$ = {$1, false};
           }
         | query_expression_parens %prec SUBQUERY_AS_EXPR
           {
             $$ = {$1, true};
           }
         | query_expression_body UNION_SYM union_option query_expression_body
           {
-            $$ = {NEW_PTN PT_union($1.body, $3, $4.body, $4.is_parenthesized),
+            $$ = {NEW_PTN PT_union(@$, $1.body, $3, $4.body, $4.is_parenthesized),
                   false};
           }
         | query_expression_body EXCEPT_SYM union_option query_expression_body
           {
-            $$ = {NEW_PTN PT_except($1.body, $3, $4.body, $4.is_parenthesized),
+            $$ = {NEW_PTN PT_except(@$, $1.body, $3, $4.body, $4.is_parenthesized),
                   false};
           }
         | query_expression_body INTERSECT_SYM union_option query_expression_body
           {
-            $$ = {NEW_PTN PT_intersect($1.body, $3, $4.body, $4.is_parenthesized),
+            $$ = {NEW_PTN PT_intersect(@$, $1.body, $3, $4.body, $4.is_parenthesized),
                   false};
           }
         ;
 
 query_expression_parens:
-          '(' query_expression_parens ')'                       { $$ = $2; }
-        | '(' query_expression_with_opt_locking_clauses')'      { $$ = $2; }
+          '(' query_expression_parens ')'
+          { $$ = $2;
+            $$->m_pos = @$;
+          }
+        | '(' query_expression_with_opt_locking_clauses')'
+          { $$ = $2;
+            $$->m_pos = @$;
+          }
         ;
 
 query_primary:
           query_specification
           {
             // Bison doesn't get polymorphism.
             $$= $1;
           }
         | table_value_constructor
           {
-            $$= NEW_PTN PT_table_value_constructor($1);
+            $$= NEW_PTN PT_table_value_constructor(@$, $1);
           }
         | explicit_table
           {
-            auto item_list= NEW_PTN PT_select_item_list;
-            auto asterisk= NEW_PTN Item_asterisk(@$, nullptr, nullptr);
+            // Pass empty position because asterisk is not user-supplied.
+            auto item_list= NEW_PTN PT_select_item_list(POS());
+            auto asterisk= NEW_PTN Item_asterisk(POS(), nullptr, nullptr);
             if (item_list == nullptr || asterisk == nullptr ||
                 item_list->push_back(asterisk))
               MYSQL_YYABORT;
-            $$= NEW_PTN PT_explicit_table({}, item_list, $1);
+            $$= NEW_PTN PT_explicit_table(@$, {}, item_list, $1);
           }
         ;
 
 query_specification:
           SELECT_SYM
           select_options
           select_item_list
           into_clause
           opt_from_clause
           opt_where_clause
           opt_group_clause
           opt_having_clause
           opt_window_clause
           {
             $$= NEW_PTN PT_query_specification(
+                                      @$,
                                       $1,  // SELECT_SYM
                                       $2,  // select_options
                                       $3,  // select_item_list
                                       $4,  // into_clause
                                       $5,  // from
                                       $6,  // where
                                       $7,  // group
                                       $8,  // having
                                       $9,  // windows
                                       @5.raw.is_empty()); // implicit FROM
           }
         | SELECT_SYM
           select_options
           select_item_list
           opt_from_clause
           opt_where_clause
           opt_group_clause
           opt_having_clause
           opt_window_clause
           {
             $$= NEW_PTN PT_query_specification(
+                                      @$,
                                       $1,  // SELECT_SYM
                                       $2,  // select_options
                                       $3,  // select_item_list
                                       NULL,// no INTO clause
                                       $4,  // from
                                       $5,  // where
                                       $6,  // group
                                       $7,  // having
                                       $8,  // windows
                                       @4.raw.is_empty()); // implicit FROM
           }
         ;
@@ -10079,10 +10092,10 @@ table_value_constructor:
 explicit_table:
           TABLE_SYM table_ident
           {
             $$.init(YYMEM_ROOT);
             auto table= NEW_PTN
-                PT_table_factor_table_ident($2, nullptr, NULL_CSTR, nullptr);
+                PT_table_factor_table_ident(@$, $2, nullptr, NULL_CSTR, nullptr);
             if ($$.push_back(table))
               MYSQL_YYABORT; // OOM
           }
         ;
@@ -10120,14 +10133,14 @@ select_option:
 locking_clause_list:
           locking_clause_list locking_clause
           {
             $$= $1;
             if ($$->push_back($2))
               MYSQL_YYABORT; // OOM
           }
         | locking_clause
           {
-            $$= NEW_PTN PT_locking_clause_list(YYTHD->mem_root);
+            $$= NEW_PTN PT_locking_clause_list(@$, YYTHD->mem_root);
             if ($$ == nullptr || $$->push_back($1))
               MYSQL_YYABORT; // OOM
           }
         ;
@@ -10135,15 +10148,15 @@ locking_clause_list:
 locking_clause:
           FOR_SYM lock_strength opt_locked_row_action
           {
-            $$= NEW_PTN PT_query_block_locking_clause($2, $3);
+            $$= NEW_PTN PT_query_block_locking_clause(@$, $2, $3);
           }
         | FOR_SYM lock_strength table_locking_list opt_locked_row_action
           {
-            $$= NEW_PTN PT_table_locking_clause($2, $3, $4);
+            $$= NEW_PTN PT_table_locking_clause(@$, $2, $3, $4);
           }
         | LOCK_SYM IN_SYM SHARE_SYM MODE_SYM
           {
-            $$= NEW_PTN PT_query_block_locking_clause(Lock_strength::SHARE);
+            $$= NEW_PTN PT_query_block_locking_clause(@$, Lock_strength::SHARE);
           }
         ;
 
@@ -10169,21 +10182,22 @@ locked_row_action:
 select_item_list:
           select_item_list ',' select_item
           {
             if ($1 == NULL || $1->push_back($3))
               MYSQL_YYABORT;
             $$= $1;
+            $$->m_pos = @$;
           }
         | select_item
           {
-            $$= NEW_PTN PT_select_item_list;
+            $$= NEW_PTN PT_select_item_list(@$);
             if ($$ == NULL || $$->push_back($1))
               MYSQL_YYABORT;
           }
         | '*'
           {
             Item *item = NEW_PTN Item_asterisk(@$, nullptr, nullptr);
-            $$ = NEW_PTN PT_select_item_list;
+            $$ = NEW_PTN PT_select_item_list(@$);
             if ($$ == nullptr || item == nullptr || $$->push_back(item))
               MYSQL_YYABORT;
           }
         ;
@@ -10213,49 +10227,51 @@ optional_braces:
 /* all possible expressions */
 expr:
           expr or expr %prec OR_SYM
           {
             $$= flatten_associative_operator<Item_cond_or,
                                              Item_func::COND_OR_FUNC>(
                                                  YYMEM_ROOT, @$, $1, $3);
+            $$->m_pos = @$;
           }
         | expr XOR expr %prec XOR
           {
             /* XOR is a proprietary extension */
             $$ = NEW_PTN Item_func_xor(@$, $1, $3);
           }
         | expr and expr %prec AND_SYM
           {
             $$= flatten_associative_operator<Item_cond_and,
                                              Item_func::COND_AND_FUNC>(
                                                  YYMEM_ROOT, @$, $1, $3);
+            $$->m_pos = @$;
           }
         | NOT_SYM expr %prec NOT_SYM
           {
             $$= NEW_PTN PTI_truth_transform(@$, $2, Item::BOOL_NEGATED);
           }
         | bool_pri IS TRUE_SYM %prec IS
           {
             $$= NEW_PTN PTI_truth_transform(@$, $1, Item::BOOL_IS_TRUE);
           }
         | bool_pri IS not TRUE_SYM %prec IS
           {
             $$= NEW_PTN PTI_truth_transform(@$, $1, Item::BOOL_NOT_TRUE);
           }
         | bool_pri IS FALSE_SYM %prec IS
           {
             $$= NEW_PTN PTI_truth_transform(@$, $1, Item::BOOL_IS_FALSE);
           }
         | bool_pri IS not FALSE_SYM %prec IS
           {
             $$= NEW_PTN PTI_truth_transform(@$, $1, Item::BOOL_NOT_FALSE);
           }
         | bool_pri IS UNKNOWN_SYM %prec IS
           {
             $$= NEW_PTN Item_func_isnull(@$, $1);
           }
         | bool_pri IS not UNKNOWN_SYM %prec IS
           {
             $$= NEW_PTN Item_func_isnotnull(@$, $1);
           }
         | bool_pri %prec SET_VAR
         ;
@@ -10292,90 +10308,90 @@ bool_pri:
 predicate:
           bit_expr IN_SYM table_subquery
           {
             $$= NEW_PTN Item_in_subselect(@$, $1, $3);
           }
         | bit_expr not IN_SYM table_subquery
           {
             Item *item= NEW_PTN Item_in_subselect(@$, $1, $4);
             $$= NEW_PTN PTI_truth_transform(@$, item, Item::BOOL_NEGATED);
           }
         | bit_expr IN_SYM '(' expr ')'
           {
             $$= NEW_PTN PTI_handle_sql2003_note184_exception(@$, $1, true, $4);
           }
         | bit_expr IN_SYM '(' expr ',' expr_list ')'
           {
             if ($6 == NULL || $6->push_front($4) || $6->push_front($1))
               MYSQL_YYABORT;
 
             $$= NEW_PTN Item_func_in(@$, $6, false);
           }
         | bit_expr not IN_SYM '(' expr ')'
           {
             $$= NEW_PTN PTI_handle_sql2003_note184_exception(@$, $1, false, $5);
           }
         | bit_expr not IN_SYM '(' expr ',' expr_list ')'
           {
             if ($7 == nullptr)
               MYSQL_YYABORT;
             $7->push_front($5);
             $7->value.push_front($1);
 
             $$= NEW_PTN Item_func_in(@$, $7, true);
           }
         | bit_expr MEMBER_SYM opt_of '(' simple_expr ')'
           {
             $$= NEW_PTN Item_func_member_of(@$, $1, $5);
           }
         | bit_expr BETWEEN_SYM bit_expr AND_SYM predicate
           {
             $$= NEW_PTN Item_func_between(@$, $1, $3, $5, false);
           }
         | bit_expr not BETWEEN_SYM bit_expr AND_SYM predicate
           {
             $$= NEW_PTN Item_func_between(@$, $1, $4, $6, true);
           }
         | bit_expr SOUNDS_SYM LIKE bit_expr
           {
             Item *item1= NEW_PTN Item_func_soundex(@$, $1);
             Item *item4= NEW_PTN Item_func_soundex(@$, $4);
             if ((item1 == NULL) || (item4 == NULL))
               MYSQL_YYABORT;
             $$= NEW_PTN Item_func_eq(@$, item1, item4);
           }
         | bit_expr LIKE simple_expr
           {
             $$ = NEW_PTN Item_func_like(@$, $1, $3);
           }
         | bit_expr LIKE simple_expr ESCAPE_SYM simple_expr %prec LIKE
           {
             $$ = NEW_PTN Item_func_like(@$, $1, $3, $5);
           }
         | bit_expr not LIKE simple_expr
           {
             auto item = NEW_PTN Item_func_like(@$, $1, $4);
             $$ = NEW_PTN Item_func_not(@$, item);
           }
         | bit_expr not LIKE simple_expr ESCAPE_SYM simple_expr %prec LIKE
           {
             auto item = NEW_PTN Item_func_like(@$, $1, $4, $6);
             $$ = NEW_PTN Item_func_not(@$, item);
           }
         | bit_expr REGEXP bit_expr
           {
-            auto args= NEW_PTN PT_item_list;
+            auto args= NEW_PTN PT_item_list(@$);
             args->push_back($1);
             args->push_back($3);
 
             $$= NEW_PTN Item_func_regexp_like(@1, args);
           }
         | bit_expr not REGEXP bit_expr
           {
-            auto args= NEW_PTN PT_item_list;
+            auto args= NEW_PTN PT_item_list(@$);
             args->push_back($1);
             args->push_back($4);
             Item *item= NEW_PTN Item_func_regexp_like(@$, args);
             $$= NEW_PTN PTI_truth_transform(@$, item, Item::BOOL_NEGATED);
           }
         | bit_expr %prec SET_VAR
         ;
@@ -11055,15 +11071,18 @@ opt_udf_expr_list:
 udf_expr_list:
           udf_expr
           {
-            $$= NEW_PTN PT_item_list;
+            $$= NEW_PTN PT_item_list(@$);
             if ($$ == NULL || $$->push_back($1))
               MYSQL_YYABORT;
           }
         | udf_expr_list ',' udf_expr
           {
             if ($1 == NULL || $1->push_back($3))
               MYSQL_YYABORT;
             $$= $1;
+            // This will override earlier udf_expr_list, until
+            // we get the whole location.
+            $$->m_pos = @$;
           }
         ;
 
@@ -11197,65 +11216,65 @@ sum_expr:
 window_func_call:       // Window functions which do not exist as set functions
           ROW_NUMBER_SYM '(' ')' windowing_clause
           {
             $$=  NEW_PTN Item_row_number(@$, $4);
           }
         | RANK_SYM '(' ')' windowing_clause
           {
             $$= NEW_PTN Item_rank(@$, false, $4);
           }
         | DENSE_RANK_SYM '(' ')' windowing_clause
           {
             $$= NEW_PTN Item_rank(@$, true, $4);
           }
         | CUME_DIST_SYM '(' ')' windowing_clause
           {
             $$=  NEW_PTN Item_cume_dist(@$, $4);
           }
         | PERCENT_RANK_SYM '(' ')' windowing_clause
           {
             $$= NEW_PTN Item_percent_rank(@$, $4);
           }
         | NTILE_SYM '(' stable_integer ')' windowing_clause
           {
             $$=NEW_PTN Item_ntile(@$, $3, $5);
           }
         | LEAD_SYM '(' expr opt_lead_lag_info ')' opt_null_treatment windowing_clause
           {
-            PT_item_list *args= NEW_PTN PT_item_list;
+            PT_item_list *args= NEW_PTN PT_item_list(@expr, @opt_lead_lag_info);
             if (args == NULL || args->push_back($3))
               MYSQL_YYABORT; // OOM
             if ($4.offset != NULL && args->push_back($4.offset))
               MYSQL_YYABORT; // OOM
             if ($4.default_value != NULL && args->push_back($4.default_value))
               MYSQL_YYABORT; // OOM
             $$= NEW_PTN Item_lead_lag(@$, true, args, $6, $7);
           }
         | LAG_SYM '(' expr opt_lead_lag_info ')' opt_null_treatment windowing_clause
           {
-            PT_item_list *args= NEW_PTN PT_item_list;
+            PT_item_list *args= NEW_PTN PT_item_list(@expr, @opt_lead_lag_info);
             if (args == NULL || args->push_back($3))
               MYSQL_YYABORT; // OOM
             if ($4.offset != NULL && args->push_back($4.offset))
               MYSQL_YYABORT; // OOM
             if ($4.default_value != NULL && args->push_back($4.default_value))
               MYSQL_YYABORT; // OOM
             $$= NEW_PTN Item_lead_lag(@$, false, args, $6, $7);
           }
         | FIRST_VALUE_SYM '(' expr ')' opt_null_treatment windowing_clause
           {
             $$= NEW_PTN Item_first_last_value(@$, true, $3, $5, $6);
           }
         | LAST_VALUE_SYM  '(' expr ')' opt_null_treatment windowing_clause
           {
             $$= NEW_PTN Item_first_last_value(@$, false, $3, $5, $6);
           }
         | NTH_VALUE_SYM '(' expr ',' simple_expr ')' opt_from_first_last opt_null_treatment windowing_clause
           {
-            PT_item_list *args= NEW_PTN PT_item_list;
+            PT_item_list *args= NEW_PTN PT_item_list(@expr, @simple_expr);
             if (args == NULL ||
                 args->push_back($3) ||
                 args->push_back($5))
               MYSQL_YYABORT;
             $$= NEW_PTN Item_nth_value(@$, args, $7 == NFL_FROM_LAST, $8, $9);
           }
         ;
@@ -11351,10 +11370,10 @@ windowing_clause:
 window_name_or_spec:
           window_name
           {
-            $$= NEW_PTN PT_window($1);
+            $$= NEW_PTN PT_window(@$, $1);
           }
         | window_spec
           {
             $$= $1;
           }
         ;
@@ -11369,27 +11388,28 @@ window_name:
 window_spec:
           '(' window_spec_details ')'
           {
             $$= $2;
+            $$->m_pos = @$;
           }
         ;
 
 window_spec_details:
            opt_existing_window_name
            opt_partition_clause
            opt_window_order_by_clause
            opt_window_frame_clause
            {
              auto frame= $4;
              if (!frame) // build an equivalent frame spec
              {
-               auto start_bound= NEW_PTN PT_border(WBT_UNBOUNDED_PRECEDING);
-               auto end_bound= NEW_PTN PT_border($3 ? WBT_CURRENT_ROW :
+               auto start_bound= NEW_PTN PT_border(POS(), WBT_UNBOUNDED_PRECEDING);
+               auto end_bound= NEW_PTN PT_border(POS(), $3 ? WBT_CURRENT_ROW :
                  WBT_UNBOUNDED_FOLLOWING);
-               auto bounds= NEW_PTN PT_borders(start_bound, end_bound);
-               frame= NEW_PTN PT_frame(WFU_RANGE, bounds, nullptr);
+               auto bounds= NEW_PTN PT_borders(POS(), start_bound, end_bound);
+               frame= NEW_PTN PT_frame(POS(), WFU_RANGE, bounds, nullptr);
                frame->m_originally_absent= true;
              }
-             $$= NEW_PTN PT_window($2, $3, frame, $1);
+             $$= NEW_PTN PT_window(POS(), $2, $3, frame, $1);
            }
          ;
 
@@ -11429,24 +11449,24 @@ opt_window_order_by_clause:
 opt_window_frame_clause:
           %empty
           {
             $$= NULL;
           }
         | window_frame_units
           window_frame_extent
           opt_window_frame_exclusion
           {
-            $$= NEW_PTN PT_frame($1, $2, $3);
+            $$= NEW_PTN PT_frame(@$, $1, $2, $3);
           }
         ;
 
 window_frame_extent:
           window_frame_start
           {
-            auto end_bound= NEW_PTN PT_border(WBT_CURRENT_ROW);
-            $$= NEW_PTN PT_borders($1, end_bound);
+            auto end_bound= NEW_PTN PT_border(@$, WBT_CURRENT_ROW);
+            $$= NEW_PTN PT_borders(@$, $1, end_bound);
           }
         | window_frame_between
           {
             $$= $1;
           }
         ;
@@ -11454,75 +11474,75 @@ window_frame_extent:
 window_frame_start:
           UNBOUNDED_SYM PRECEDING_SYM
           {
-            $$= NEW_PTN PT_border(WBT_UNBOUNDED_PRECEDING);
+            $$= NEW_PTN PT_border(@$, WBT_UNBOUNDED_PRECEDING);
           }
         | NUM_literal PRECEDING_SYM
           {
-            $$= NEW_PTN PT_border(WBT_VALUE_PRECEDING, $1);
+            $$= NEW_PTN PT_border(@$, WBT_VALUE_PRECEDING, $1);
           }
         | param_marker PRECEDING_SYM
           {
-            $$= NEW_PTN PT_border(WBT_VALUE_PRECEDING, $1);
+            $$= NEW_PTN PT_border(@$, WBT_VALUE_PRECEDING, $1);
           }
         | INTERVAL_SYM expr interval PRECEDING_SYM
           {
-            $$= NEW_PTN PT_border(WBT_VALUE_PRECEDING, $2, $3);
+            $$= NEW_PTN PT_border(@$, WBT_VALUE_PRECEDING, $2, $3);
           }
         | CURRENT_SYM ROW_SYM
           {
-            $$= NEW_PTN PT_border(WBT_CURRENT_ROW);
+            $$= NEW_PTN PT_border(@$, WBT_CURRENT_ROW);
           }
         ;
 
 window_frame_between:
           BETWEEN_SYM window_frame_bound AND_SYM window_frame_bound
           {
-            $$= NEW_PTN PT_borders($2, $4);
+            $$= NEW_PTN PT_borders(@$, $2, $4);
           }
         ;
 
 window_frame_bound:
           window_frame_start
           {
             $$= $1;
           }
         | UNBOUNDED_SYM FOLLOWING_SYM
           {
-            $$= NEW_PTN PT_border(WBT_UNBOUNDED_FOLLOWING);
+            $$= NEW_PTN PT_border(@$, WBT_UNBOUNDED_FOLLOWING);
           }
         | NUM_literal FOLLOWING_SYM
           {
-            $$= NEW_PTN PT_border(WBT_VALUE_FOLLOWING, $1);
+            $$= NEW_PTN PT_border(@$, WBT_VALUE_FOLLOWING, $1);
           }
         | param_marker FOLLOWING_SYM
           {
-            $$= NEW_PTN PT_border(WBT_VALUE_FOLLOWING, $1);
+            $$= NEW_PTN PT_border(@$, WBT_VALUE_FOLLOWING, $1);
           }
         | INTERVAL_SYM expr interval FOLLOWING_SYM
           {
-            $$= NEW_PTN PT_border(WBT_VALUE_FOLLOWING, $2, $3);
+            $$= NEW_PTN PT_border(@$, WBT_VALUE_FOLLOWING, $2, $3);
           }
         ;
 
 opt_window_frame_exclusion:
           %empty
           {
             $$= NULL;
           }
         | EXCLUDE_SYM CURRENT_SYM ROW_SYM
           {
-            $$= NEW_PTN PT_exclusion(WFX_CURRENT_ROW);
+            $$= NEW_PTN PT_exclusion(@$, WFX_CURRENT_ROW);
           }
         | EXCLUDE_SYM GROUP_SYM
           {
-            $$= NEW_PTN PT_exclusion(WFX_GROUP);
+            $$= NEW_PTN PT_exclusion(@$, WFX_GROUP);
           }
         | EXCLUDE_SYM TIES_SYM
           {
-            $$= NEW_PTN PT_exclusion(WFX_TIES);
+            $$= NEW_PTN PT_exclusion(@$, WFX_TIES);
           }
         | EXCLUDE_SYM NO_SYM OTHERS_SYM
-          { $$= NEW_PTN PT_exclusion(WFX_NO_OTHERS);
+          { $$= NEW_PTN PT_exclusion(@$, WFX_NO_OTHERS);
           }
         ;
 
@@ -11584,14 +11604,17 @@ opt_gorder_clause:
 gorder_list:
           gorder_list ',' order_expr
           {
             $1->push_back($3);
             $$= $1;
+            // This will override earlier list, until
+            // we get the whole location.
+            $$->m_pos = @$;
           }
         | order_expr
           {
-            $$= NEW_PTN PT_gorder_list();
+            $$= NEW_PTN PT_gorder_list(@$);
             if ($$ == NULL)
               MYSQL_YYABORT;
             $$->push_back($1);
           }
         ;
@@ -11782,15 +11805,16 @@ opt_expr_list:
 expr_list:
           expr
           {
-            $$= NEW_PTN PT_item_list;
+            $$= NEW_PTN PT_item_list(@$);
             if ($$ == NULL || $$->push_back($1))
               MYSQL_YYABORT;
           }
         | expr_list ',' expr
           {
             if ($1 == NULL || $1->push_back($3))
               MYSQL_YYABORT;
             $$= $1;
+            $$->m_pos = @$;
           }
         ;
 
@@ -11802,15 +11826,18 @@ ident_list_arg:
 ident_list:
           simple_ident
           {
-            $$= NEW_PTN PT_item_list;
+            $$= NEW_PTN PT_item_list(@$);
             if ($$ == NULL || $$->push_back($1))
               MYSQL_YYABORT;
           }
         | ident_list ',' simple_ident
           {
             if ($1 == NULL || $1->push_back($3))
               MYSQL_YYABORT;
             $$= $1;
+            // This will override location of earlier list, until we get the
+            // whole location.
+            $$->m_pos = @$;
           }
         ;
 
@@ -11936,39 +11963,39 @@ esc_table_reference:
   Natural joins are also syntactically conditionless, but we need to make sure
   that they are never right associative. We handle them in their own rule
   natural_join, which is left-associative only. In this case we know that
   there is no join condition to wait for, so we can reduce immediately.
 */
 joined_table:
           table_reference inner_join_type table_reference ON_SYM expr
           {
-            $$= NEW_PTN PT_joined_table_on($1, @2, $2, $3, $5);
+            $$= NEW_PTN PT_joined_table_on(@$, $1, @2, $2, $3, $5);
           }
         | table_reference inner_join_type table_reference USING
           '(' using_list ')'
           {
-            $$= NEW_PTN PT_joined_table_using($1, @2, $2, $3, $6);
+            $$= NEW_PTN PT_joined_table_using(@$, $1, @2, $2, $3, $6);
           }
         | table_reference outer_join_type table_reference ON_SYM expr
           {
-            $$= NEW_PTN PT_joined_table_on($1, @2, $2, $3, $5);
+            $$= NEW_PTN PT_joined_table_on(@$, $1, @2, $2, $3, $5);
           }
         | table_reference outer_join_type table_reference USING '(' using_list ')'
           {
-            $$= NEW_PTN PT_joined_table_using($1, @2, $2, $3, $6);
+            $$= NEW_PTN PT_joined_table_using(@$, $1, @2, $2, $3, $6);
           }
         | table_reference inner_join_type table_reference
           %prec CONDITIONLESS_JOIN
           {
-            auto this_cross_join= NEW_PTN PT_cross_join($1, @2, $2, NULL);
+            auto this_cross_join= NEW_PTN PT_cross_join(@$, $1, @2, $2, NULL);
 
             if ($3 == NULL)
               MYSQL_YYABORT; // OOM
 
             $$= $3->add_cross_join(this_cross_join);
           }
         | table_reference natural_join_type table_factor
           {
-            $$= NEW_PTN PT_joined_table_using($1, @2, $2, $3);
+            $$= NEW_PTN PT_joined_table_using(@$, $1, @2, $2, $3);
           }
         ;
 
@@ -12030,21 +12057,21 @@ use_partition:
   A <table_factor> may be a <single_table>, a <subquery>, a <derived_table>, a
   <joined_table>, or the bespoke <table_reference_list_parens>, each of those
   enclosed in any number of parentheses. This makes for an ambiguous grammar
   since a <table_factor> may also be enclosed in parentheses. We get around
   this by designing the grammar so that a <table_factor> does not have
   parentheses, but all the sub-cases of it have their own parentheses-rules,
   i.e. <single_table_parens>, <joined_table_parens> and
   <table_reference_list_parens>. It's a bit tedious but the grammar is
   unambiguous and doesn't have shift/reduce conflicts.
 */
 table_factor:
           single_table
         | single_table_parens
         | derived_table { $$ = $1; }
         | joined_table_parens
-          { $$= NEW_PTN PT_table_factor_joined_table($1); }
+          { $$= NEW_PTN PT_table_factor_joined_table(@$, $1); }
         | table_reference_list_parens
-          { $$= NEW_PTN PT_table_reference_list_parens($1); }
+          { $$= NEW_PTN PT_table_reference_list_parens(@$, $1); }
         | table_function { $$ = $1; }
         ;
 
@@ -12066,7 +12093,7 @@ single_table_parens:
 single_table:
           table_ident opt_use_partition opt_table_alias opt_key_definition
           {
-            $$= NEW_PTN PT_table_factor_table_ident($1, $2, $3, $4);
+            $$= NEW_PTN PT_table_factor_table_ident(@$, $1, $2, $3, $4);
           }
         ;
 
@@ -12078,40 +12105,40 @@ joined_table_parens:
 derived_table:
           table_subquery opt_table_alias opt_derived_column_list
           {
             /*
               The alias is actually not optional at all, but being MySQL we
               are friendly and give an informative error message instead of
               just 'syntax error'.
             */
             if ($2.str == nullptr)
               my_message(ER_DERIVED_MUST_HAVE_ALIAS,
                          ER_THD(YYTHD, ER_DERIVED_MUST_HAVE_ALIAS), MYF(0));
 
-            $$= NEW_PTN PT_derived_table(false, $1, $2, &$3);
+            $$= NEW_PTN PT_derived_table(@$, false, $1, $2, &$3);
           }
         | LATERAL_SYM table_subquery opt_table_alias opt_derived_column_list
           {
             if ($3.str == nullptr)
               my_message(ER_DERIVED_MUST_HAVE_ALIAS,
                          ER_THD(YYTHD, ER_DERIVED_MUST_HAVE_ALIAS), MYF(0));
 
-            $$= NEW_PTN PT_derived_table(true, $2, $3, &$4);
+            $$= NEW_PTN PT_derived_table(@$, true, $2, $3, &$4);
           }
         ;
 
 table_function:
           JSON_TABLE_SYM '(' expr ',' text_literal columns_clause ')'
           opt_table_alias
           {
             // Alias isn't optional, follow derived's behavior
             if ($8 == NULL_CSTR)
             {
               my_message(ER_TF_MUST_HAVE_ALIAS,
                          ER_THD(YYTHD, ER_TF_MUST_HAVE_ALIAS), MYF(0));
               MYSQL_YYABORT;
             }
 
-            $$= NEW_PTN PT_table_factor_function($3, $5, $6, to_lex_string($8));
+            $$= NEW_PTN PT_table_factor_function(@$, $3, $5, $6, to_lex_string($8));
           }
         ;
 
@@ -12140,21 +12167,21 @@ columns_list:
 jt_column:
           ident FOR_SYM ORDINALITY_SYM
           {
-            $$= NEW_PTN PT_json_table_column_for_ordinality($1);
+            $$= NEW_PTN PT_json_table_column_for_ordinality(@$, $1);
           }
         | ident type opt_collate jt_column_type PATH_SYM text_literal
           opt_on_empty_or_error_json_table
           {
             auto column = make_unique_destroy_only<Json_table_column>(
                 YYMEM_ROOT, $4, $6, $7.error.type, $7.error.default_string,
                 $7.empty.type, $7.empty.default_string);
             if (column == nullptr) MYSQL_YYABORT;  // OOM
-            $$ = NEW_PTN PT_json_table_column_with_path(std::move(column), $1,
+            $$ = NEW_PTN PT_json_table_column_with_path(@$, std::move(column), $1,
                                                         $2, $3);
           }
         | NESTED_SYM PATH_SYM text_literal columns_clause
           {
-            $$= NEW_PTN PT_json_table_column_with_nested_path($3, $4);
+            $$= NEW_PTN PT_json_table_column_with_nested_path(@$, $3, $4);
           }
         ;
 
@@ -12411,24 +12438,25 @@ opt_having_clause:
 with_clause:
           WITH with_list
           {
-            $$= NEW_PTN PT_with_clause($2, false);
+            $$= NEW_PTN PT_with_clause(@$, $2, false);
           }
         | WITH RECURSIVE_SYM with_list
           {
-            $$= NEW_PTN PT_with_clause($3, true);
+            $$= NEW_PTN PT_with_clause(@$, $3, true);
           }
         ;
 
 with_list:
           with_list ',' common_table_expr
           {
             if ($1->push_back($3))
               MYSQL_YYABORT;
+            $$->m_pos = @$;
           }
         | common_table_expr
           {
-            $$= NEW_PTN PT_with_list(YYTHD->mem_root);
+            $$= NEW_PTN PT_with_list(@$, YYTHD->mem_root);
             if ($$ == NULL || $$->push_back($1))
               MYSQL_YYABORT;    /* purecov: inspected */
           }
         ;
@@ -12436,15 +12464,15 @@ with_list:
 common_table_expr:
           ident opt_derived_column_list AS table_subquery
           {
             LEX_STRING subq_text;
             subq_text.length= @4.cpp.length();
             subq_text.str= YYTHD->strmake(@4.cpp.start, subq_text.length);
             if (subq_text.str == NULL)
               MYSQL_YYABORT;   /* purecov: inspected */
             uint subq_text_offset= @4.cpp.start - YYLIP->get_cpp_buf();
-            $$= NEW_PTN PT_common_table_expr($1, subq_text, subq_text_offset,
+            $$= NEW_PTN PT_common_table_expr(@$, $1, subq_text, subq_text_offset,
                                              $4, &$2, YYTHD->mem_root);
             if ($$ == NULL)
               MYSQL_YYABORT;   /* purecov: inspected */
           }
         ;
@@ -12494,28 +12522,30 @@ opt_window_clause:
 window_definition_list:
           window_definition
           {
-            $$= NEW_PTN PT_window_list();
+            $$= NEW_PTN PT_window_list(@$);
             if ($$ == NULL || $$->push_back($1))
               MYSQL_YYABORT; // OOM
           }
         | window_definition_list ',' window_definition
           {
             if ($1->push_back($3))
               MYSQL_YYABORT; // OOM
             $$= $1;
+            $$->m_pos = @$;
           }
         ;
 
 window_definition:
           window_name AS window_spec
           {
             $$= $3;
+            $$->m_pos = @$;
             if ($$ == NULL)
               MYSQL_YYABORT; // OOM
             $$->set_name($1);
           }
         ;
 
 /*
    group by statement in select
 */
@@ -12523,22 +12553,23 @@ window_definition:
 opt_group_clause:
           %empty { $$= NULL; }
         | GROUP_SYM BY group_list olap_opt
           {
-            $$= NEW_PTN PT_group($3, $4);
+            $$= NEW_PTN PT_group(@$, $3, $4);
           }
         ;
 
 group_list:
           group_list ',' grouping_expr
           {
             $1->push_back($3);
             $$= $1;
+            $$->m_pos = @$;
           }
         | grouping_expr
           {
-            $$= NEW_PTN PT_order_list();
+            $$= NEW_PTN PT_order_list(@$);
             if ($$ == NULL)
               MYSQL_YYABORT;
             $$->push_back($1);
           }
         ;
@@ -12563,14 +12594,15 @@ olap_opt:
 alter_order_list:
           alter_order_list ',' alter_order_item
           {
             $$= $1;
             $$->push_back($3);
+            $$->m_pos = @$;
           }
         | alter_order_item
           {
-            $$= NEW_PTN PT_order_list();
+            $$= NEW_PTN PT_order_list(@$);
             if ($$ == NULL)
               MYSQL_YYABORT;
             $$->push_back($1);
           }
         ;
@@ -12578,7 +12610,7 @@ alter_order_list:
 alter_order_item:
           simple_ident_nospvar opt_ordering_direction
           {
-            $$= NEW_PTN PT_order_expr($1, $2);
+            $$= NEW_PTN PT_order_expr(@$, $1, $2);
           }
         ;
 
@@ -12590,21 +12622,22 @@ opt_order_clause:
 order_clause:
           ORDER_SYM BY order_list
           {
-            $$= NEW_PTN PT_order($3);
+            $$= NEW_PTN PT_order(@$, $3);
           }
         ;
 
 order_list:
           order_list ',' order_expr
           {
             $1->push_back($3);
             $$= $1;
+            $$->m_pos = @$;
           }
         | order_expr
           {
-            $$= NEW_PTN PT_order_list();
+            $$= NEW_PTN PT_order_list(@$);
             if ($$ == NULL)
               MYSQL_YYABORT;
             $$->push_back($1);
           }
         ;
@@ -12627,7 +12660,7 @@ opt_limit_clause:
 limit_clause:
           LIMIT limit_options
           {
-            $$= NEW_PTN PT_limit_clause($2);
+            $$= NEW_PTN PT_limit_clause(@$, $2);
           }
         ;
 
@@ -12741,11 +12774,11 @@ select_var_list:
 select_var_ident:
           '@' ident_or_text
           {
-            $$= NEW_PTN PT_select_var($2);
+            $$= NEW_PTN PT_select_var(@$, $2);
           }
         | ident_or_text
           {
-            $$= NEW_PTN PT_select_sp_var($1);
+            $$= NEW_PTN PT_select_sp_var(@$, $1);
           }
         ;
 
@@ -12777,12 +12810,12 @@ into_destination:
 do_stmt:
           DO_SYM select_item_list
           {
-            $$= NEW_PTN PT_select_stmt(SQLCOM_DO,
-                  NEW_PTN PT_query_expression(
-                    NEW_PTN PT_query_specification({}, $2)));
+            $$= NEW_PTN PT_select_stmt(@$, SQLCOM_DO,
+                  NEW_PTN PT_query_expression(@$,
+                    NEW_PTN PT_query_specification(@$, {}, $2)));
           }
         ;
 
 /*
   Drop : delete tables or index or user or role
 */
@@ -12806,8 +12839,8 @@ drop_table_stmt:
 drop_index_stmt:
           DROP INDEX_SYM ident ON_SYM table_ident opt_index_lock_and_algorithm
           {
-            $$= NEW_PTN PT_drop_index_stmt(YYMEM_ROOT, $3.str, $5,
+            $$= NEW_PTN PT_drop_index_stmt(@$, YYMEM_ROOT, $3.str, $5,
                                            $6.algo.get_or_default(),
                                            $6.lock.get_or_default());
           }
         ;
@@ -12883,7 +12916,7 @@ drop_function_stmt:
 drop_resource_group_stmt:
           DROP RESOURCE_SYM GROUP_SYM ident opt_force
           {
-            $$= NEW_PTN PT_drop_resource_group(to_lex_cstring($4), $5);
+            $$= NEW_PTN PT_drop_resource_group(@$, to_lex_cstring($4), $5);
           }
          ;
 
@@ -13023,14 +13056,14 @@ drop_server_stmt:
 drop_srs_stmt:
           DROP SPATIAL_SYM REFERENCE_SYM SYSTEM_SYM if_exists real_ulonglong_num
           {
-            $$= NEW_PTN PT_drop_srs($6, $5);
+            $$= NEW_PTN PT_drop_srs(@$, $6, $5);
           }
         ;
 
 drop_role_stmt:
           DROP ROLE_SYM if_exists role_list
           {
-            $$= NEW_PTN PT_drop_role($3, $4);
+            $$= NEW_PTN PT_drop_role(@$, $3, $4);
           }
         ;
 
@@ -13110,57 +13143,57 @@ drop_ts_option:
 insert_stmt:
           INSERT_SYM                   /* #1 */
           insert_lock_option           /* #2 */
           opt_ignore                   /* #3 */
           opt_INTO                     /* #4 */
           table_ident                  /* #5 */
           opt_use_partition            /* #6 */
           insert_from_constructor      /* #7 */
           opt_values_reference         /* #8 */
           opt_insert_update_list       /* #9 */
           {
             DBUG_EXECUTE_IF("bug29614521_simulate_oom",
                              DBUG_SET("+d,simulate_out_of_memory"););
-            $$= NEW_PTN PT_insert(false, $1, $2, $3, $5, $6,
+            $$= NEW_PTN PT_insert(@$, false, $1, $2, $3, $5, $6,
                                   $7.column_list, $7.row_value_list,
                                   NULL,
                                   $8.table_alias, $8.column_list,
                                   $9.column_list, $9.value_list);
             DBUG_EXECUTE_IF("bug29614521_simulate_oom",
                             DBUG_SET("-d,bug29614521_simulate_oom"););
           }
         | INSERT_SYM                   /* #1 */
           insert_lock_option           /* #2 */
           opt_ignore                   /* #3 */
           opt_INTO                     /* #4 */
           table_ident                  /* #5 */
           opt_use_partition            /* #6 */
           SET_SYM                      /* #7 */
           update_list                  /* #8 */
           opt_values_reference         /* #9 */
           opt_insert_update_list       /* #10 */
           {
-            PT_insert_values_list *one_row= NEW_PTN PT_insert_values_list(YYMEM_ROOT);
+            PT_insert_values_list *one_row= NEW_PTN PT_insert_values_list(@$, YYMEM_ROOT);
             if (one_row == NULL || one_row->push_back(&$8.value_list->value))
               MYSQL_YYABORT; // OOM
-            $$= NEW_PTN PT_insert(false, $1, $2, $3, $5, $6,
+            $$= NEW_PTN PT_insert(@$, false, $1, $2, $3, $5, $6,
                                   $8.column_list, one_row,
                                   NULL,
                                   $9.table_alias, $9.column_list,
                                   $10.column_list, $10.value_list);
           }
         | INSERT_SYM                   /* #1 */
           insert_lock_option           /* #2 */
           opt_ignore                   /* #3 */
           opt_INTO                     /* #4 */
           table_ident                  /* #5 */
           opt_use_partition            /* #6 */
           insert_query_expression      /* #7 */
           opt_insert_update_list       /* #8 */
           {
-            $$= NEW_PTN PT_insert(false, $1, $2, $3, $5, $6,
+            $$= NEW_PTN PT_insert(@$, false, $1, $2, $3, $5, $6,
                                   $7.column_list, NULL,
                                   $7.insert_query_expression,
                                   NULL_CSTR, NULL,
                                   $8.column_list, $8.value_list);
           }
         ;
@@ -13168,45 +13201,45 @@ insert_stmt:
 replace_stmt:
           REPLACE_SYM                   /* #1 */
           replace_lock_option           /* #2 */
           opt_INTO                      /* #3 */
           table_ident                   /* #4 */
           opt_use_partition             /* #5 */
           insert_from_constructor       /* #6 */
           {
-            $$= NEW_PTN PT_insert(true, $1, $2, false, $4, $5,
+            $$= NEW_PTN PT_insert(@$, true, $1, $2, false, $4, $5,
                                   $6.column_list, $6.row_value_list,
                                   NULL,
                                   NULL_CSTR, NULL,
                                   NULL, NULL);
           }
         | REPLACE_SYM                   /* #1 */
           replace_lock_option           /* #2 */
           opt_INTO                      /* #3 */
           table_ident                   /* #4 */
           opt_use_partition             /* #5 */
           SET_SYM                       /* #6 */
           update_list                   /* #7 */
           {
-            PT_insert_values_list *one_row= NEW_PTN PT_insert_values_list(YYMEM_ROOT);
+            PT_insert_values_list *one_row= NEW_PTN PT_insert_values_list(@$, YYMEM_ROOT);
             if (one_row == NULL || one_row->push_back(&$7.value_list->value))
               MYSQL_YYABORT; // OOM
-            $$= NEW_PTN PT_insert(true, $1, $2, false, $4, $5,
+            $$= NEW_PTN PT_insert(@$, true, $1, $2, false, $4, $5,
                                   $7.column_list, one_row,
                                   NULL,
                                   NULL_CSTR, NULL,
                                   NULL, NULL);
           }
         | REPLACE_SYM                   /* #1 */
           replace_lock_option           /* #2 */
           opt_INTO                      /* #3 */
           table_ident                   /* #4 */
           opt_use_partition             /* #5 */
           insert_query_expression       /* #6 */
           {
-            $$= NEW_PTN PT_insert(true, $1, $2, false, $4, $5,
+            $$= NEW_PTN PT_insert(@$, true, $1, $2, false, $4, $5,
                                   $6.column_list, NULL,
                                   $6.insert_query_expression,
                                   NULL_CSTR, NULL,
                                   NULL, NULL);
           }
         ;
@@ -13247,17 +13280,18 @@ opt_INTO:
 insert_from_constructor:
           insert_values
           {
-            $$.column_list= NEW_PTN PT_item_list;
+            // No position because there is no column list.
+            $$.column_list= NEW_PTN PT_item_list(POS());
             $$.row_value_list= $1;
           }
         | '(' ')' insert_values
           {
-            $$.column_list= NEW_PTN PT_item_list;
+            $$.column_list= NEW_PTN PT_item_list(POS()); // No position.
             $$.row_value_list= $3;
           }
         | '(' insert_columns ')' insert_values
           {
             $$.column_list= $2;
             $$.row_value_list= $4;
           }
         ;
@@ -13265,17 +13299,17 @@ insert_from_constructor:
 insert_query_expression:
           query_expression_with_opt_locking_clauses
           {
-            $$.column_list= NEW_PTN PT_item_list;
+            $$.column_list= NEW_PTN PT_item_list(POS()); // No column list.
             $$.insert_query_expression= $1;
           }
         | '(' ')' query_expression_with_opt_locking_clauses
           {
-            $$.column_list= NEW_PTN PT_item_list;
+            $$.column_list= NEW_PTN PT_item_list(POS()); // No column list.
             $$.insert_query_expression= $3;
           }
         | '(' insert_columns ')' query_expression_with_opt_locking_clauses
           {
             $$.column_list= $2;
             $$.insert_query_expression= $4;
           }
         ;
@@ -13283,14 +13317,15 @@ insert_query_expression:
 insert_columns:
           insert_columns ',' insert_column
           {
             if ($$->push_back($3))
               MYSQL_YYABORT;
             $$= $1;
+            $$->m_pos = @$;
           }
         | insert_column
           {
-            $$= NEW_PTN PT_item_list;
+            $$= NEW_PTN PT_item_list(@$);
             if ($$ == NULL || $$->push_back($1))
               MYSQL_YYABORT;
           }
         ;
@@ -13305,8 +13340,8 @@ insert_values:
 query_expression_with_opt_locking_clauses:
           query_expression                      { $$ = $1; }
         | query_expression locking_clause_list
           {
-            $$ = NEW_PTN PT_locking($1, $2);
+            $$ = NEW_PTN PT_locking(@$, $1, $2);
           }
         ;
 
@@ -13318,13 +13353,14 @@ value_or_values:
 values_list:
           values_list ','  row_value
           {
             if ($$->push_back(&$3->value))
               MYSQL_YYABORT;
+            $$->m_pos = @$;
           }
         | row_value
           {
-            $$= NEW_PTN PT_insert_values_list(YYMEM_ROOT);
+            $$= NEW_PTN PT_insert_values_list(@$, YYMEM_ROOT);
             if ($$ == NULL || $$->push_back(&$1->value))
               MYSQL_YYABORT;
           }
         ;
@@ -13333,13 +13369,14 @@ values_list:
 values_row_list:
           values_row_list ',' row_value_explicit
           {
             if ($$->push_back(&$3->value))
               MYSQL_YYABORT;
+            $$->m_pos = @$;
           }
         | row_value_explicit
           {
-            $$= NEW_PTN PT_insert_values_list(YYMEM_ROOT);
+            $$= NEW_PTN PT_insert_values_list(@$, YYMEM_ROOT);
             if ($$ == nullptr || $$->push_back(&$1->value))
               MYSQL_YYABORT;
           }
         ;
@@ -13365,9 +13402,9 @@ row_value_explicit:
 opt_values:
           %empty
           {
-            $$= NEW_PTN PT_item_list;
+            $$= NEW_PTN PT_item_list(POS());
             if ($$ == NULL)
               MYSQL_YYABORT;
           }
         | values
         ;
@@ -13375,14 +13412,15 @@ opt_values:
 values:
           values ','  expr_or_default
           {
             if ($1->push_back($3))
               MYSQL_YYABORT;
             $$= $1;
+            $$->m_pos = @$;
           }
         | expr_or_default
           {
-            $$= NEW_PTN PT_item_list;
+            $$= NEW_PTN PT_item_list(@$);
             if ($$ == NULL || $$->push_back($1))
               MYSQL_YYABORT;
           }
         ;
@@ -13430,16 +13468,16 @@ opt_insert_update_list:
 update_stmt:
           opt_with_clause
           UPDATE_SYM            /* #1 */
           opt_low_priority      /* #2 */
           opt_ignore            /* #3 */
           table_reference_list  /* #4 */
           SET_SYM               /* #5 */
           update_list           /* #6 */
           opt_where_clause      /* #7 */
           opt_order_clause      /* #8 */
           opt_simple_limit      /* #9 */
           {
-            $$= NEW_PTN PT_update($1, $2, $3, $4, $5, $7.column_list, $7.value_list,
+            $$= NEW_PTN PT_update(@$, $1, $2, $3, $4, $5, $7.column_list, $7.value_list,
                                   $8, $9, $10);
           }
         ;
@@ -13452,18 +13490,18 @@ opt_with_clause:
 update_list:
           update_list ',' update_elem
           {
             $$= $1;
             if ($$.column_list->push_back($3.column) ||
                 $$.value_list->push_back($3.value))
               MYSQL_YYABORT; // OOM
           }
         | update_elem
           {
-            $$.column_list= NEW_PTN PT_item_list;
-            $$.value_list= NEW_PTN PT_item_list;
+            $$.column_list= NEW_PTN PT_item_list(@$);
+            $$.value_list= NEW_PTN PT_item_list(@$);
             if ($$.column_list == NULL || $$.value_list == NULL ||
                 $$.column_list->push_back($1.column) ||
                 $$.value_list->push_back($1.value))
               MYSQL_YYABORT; // OOM
           }
         ;
@@ -13486,37 +13524,37 @@ opt_low_priority:
 delete_stmt:
           opt_with_clause
           DELETE_SYM
           opt_delete_options
           FROM
           table_ident
           opt_table_alias
           opt_use_partition
           opt_where_clause
           opt_order_clause
           opt_simple_limit
           {
-            $$= NEW_PTN PT_delete($1, $2, $3, $5, $6, $7, $8, $9, $10);
+            $$= NEW_PTN PT_delete(@$, $1, $2, $3, $5, $6, $7, $8, $9, $10);
           }
         | opt_with_clause
           DELETE_SYM
           opt_delete_options
           table_alias_ref_list
           FROM
           table_reference_list
           opt_where_clause
           {
-            $$= NEW_PTN PT_delete($1, $2, $3, $4, $6, $7);
+            $$= NEW_PTN PT_delete(@$, $1, $2, $3, $4, $6, $7);
           }
         | opt_with_clause
           DELETE_SYM
           opt_delete_options
           FROM
           table_alias_ref_list
           USING
           table_reference_list
           opt_where_clause
           {
-            $$= NEW_PTN PT_delete($1, $2, $3, $5, $7, $8);
+            $$= NEW_PTN PT_delete(@$, $1, $2, $3, $5, $7, $8);
           }
         ;
 
@@ -13539,7 +13577,7 @@ opt_delete_option:
 truncate_stmt:
           TRUNCATE_SYM opt_table table_ident
           {
-            $$= NEW_PTN PT_truncate_table_stmt($3);
+            $$= NEW_PTN PT_truncate_table_stmt(@$, $3);
           }
         ;
 
@@ -14001,38 +14039,38 @@ describe_stmt:
 explain_stmt:
           describe_command opt_explain_options explainable_stmt
           {
-            $$= NEW_PTN PT_explain($2.explain_format_type, $2.is_analyze,
+            $$= NEW_PTN PT_explain(@$, $2.explain_format_type, $2.is_analyze,
                                    $2.is_explicit, $3,
                                    /*explain_into_variable_name=*/std::nullopt);
           }
         | describe_command
           opt_explain_options   // Using the opt_explain_options rule instead
                                 // of opt_explain_format here allows for
                                 // the implementation of EXPLAIN ANALYZE INTO
                                 // without changing the language in the future.
           INTO '@' ident_or_text
           select_stmt           // Using the select_stmt rule is the simplest
                                 // way to only allow for SELECT statements.
                                 // Change to explainable_stmt when EXPLAIN INTO
                                 // is implemented for other statements.
           {
             if ($2.is_analyze) {
               MYSQL_YYABORT_ERROR(ER_EXPLAIN_INTO_ANALYZE_NOT_SUPPORTED, MYF(0));
             }
             if (!$2.is_explicit) {
               MYSQL_YYABORT_ERROR(ER_EXPLAIN_INTO_IMPLICIT_FORMAT_NOT_SUPPORTED,
                                   MYF(0));
             }
             if ($2.explain_format_type != Explain_format_type::JSON) {
               if ($2.explain_format_type == Explain_format_type::TREE) {
                 MYSQL_YYABORT_ERROR(ER_EXPLAIN_INTO_FORMAT_NOT_SUPPORTED, MYF(0),
                                     "TREE");
               } else {
                 MYSQL_YYABORT_ERROR(ER_EXPLAIN_INTO_FORMAT_NOT_SUPPORTED, MYF(0),
                                     "TRADITIONAL");
               }
             }
-            $$= NEW_PTN PT_explain($2.explain_format_type, $2.is_analyze,
+            $$= NEW_PTN PT_explain(@$, $2.explain_format_type, $2.is_analyze,
                                    $2.is_explicit, $6, to_string_view($5));
           }
         ;
@@ -14040,12 +14078,12 @@ explain_stmt:
 explainable_stmt:
           select_stmt
         | insert_stmt
         | replace_stmt
         | update_stmt
         | delete_stmt
         | FOR_SYM CONNECTION_SYM real_ulong_num
           {
-            $$= NEW_PTN PT_explain_for_connection(static_cast<my_thread_id>($3));
+            $$= NEW_PTN PT_explain_for_connection(@$, static_cast<my_thread_id>($3));
           }
         ;
 
@@ -14398,46 +14436,46 @@ use:
 load_stmt:
           LOAD                          /*  1 */
           data_or_xml                   /*  2 */
           load_data_lock                /*  3 */
           opt_from_keyword              /*  4 */
           opt_local                     /*  5 */
           load_source_type              /*  6 */
           TEXT_STRING_filesystem        /*  7 */
           opt_source_count              /*  8 */
           opt_source_order              /*  9 */
           opt_duplicate                 /* 10 */
           INTO                          /* 11 */
           TABLE_SYM                     /* 12 */
           table_ident                   /* 13 */
           opt_use_partition             /* 14 */
           opt_load_data_charset         /* 15 */
           opt_xml_rows_identified_by    /* 16 */
           opt_field_term                /* 17 */
           opt_line_term                 /* 18 */
           opt_ignore_lines              /* 19 */
           opt_field_or_var_spec         /* 20 */
           opt_load_data_set_spec        /* 21 */
           opt_load_algorithm            /* 22 */
           {
-            $$= NEW_PTN PT_load_table($2,  // data_or_xml
+            $$= NEW_PTN PT_load_table(@$, $2,  // data_or_xml
                                       $3,  // load_data_lock
                                       $5,  // opt_local
                                       $6,  // source type
                                       $7,  // TEXT_STRING_filesystem
                                       $8,  // opt_source_count
                                       $9,  // opt_source_order
                                       $10, // opt_duplicate
                                       $13, // table_ident
                                       $14, // opt_use_partition
                                       $15, // opt_load_data_charset
                                       $16, // opt_xml_rows_identified_by
                                       $17, // opt_field_term
                                       $18, // opt_line_term
                                       $19, // opt_ignore_lines
                                       $20, // opt_field_or_var_spec
                                       $21.set_var_list,// opt_load_data_set_spec
                                       $21.set_expr_list,
                                       $21.set_expr_str_list,
                                       $22); // opt_load_algorithm
           }
         ;
@@ -14587,14 +14625,15 @@ opt_field_or_var_spec:
 fields_or_vars:
           fields_or_vars ',' field_or_var
           {
             $$= $1;
             if ($$->push_back($3))
               MYSQL_YYABORT; // OOM
+            $$->m_pos = @$;
           }
         | field_or_var
           {
-            $$= NEW_PTN PT_item_list;
+            $$= NEW_PTN PT_item_list(@$);
             if ($$ == nullptr || $$->push_back($1))
               MYSQL_YYABORT; // OOM
           }
         ;
@@ -14615,27 +14654,27 @@ opt_load_data_set_spec:
 load_data_set_list:
           load_data_set_list ',' load_data_set_elem
           {
             $$= $1;
             if ($$.set_var_list->push_back($3.set_var) ||
                 $$.set_expr_list->push_back($3.set_expr) ||
                 $$.set_expr_str_list->push_back($3.set_expr_str))
               MYSQL_YYABORT; // OOM
           }
         | load_data_set_elem
           {
-            $$.set_var_list= NEW_PTN PT_item_list;
+            $$.set_var_list= NEW_PTN PT_item_list(@$);
             if ($$.set_var_list == nullptr ||
                 $$.set_var_list->push_back($1.set_var))
               MYSQL_YYABORT; // OOM
 
-            $$.set_expr_list= NEW_PTN PT_item_list;
+            $$.set_expr_list= NEW_PTN PT_item_list(@$);
             if ($$.set_expr_list == nullptr ||
                 $$.set_expr_list->push_back($1.set_expr))
               MYSQL_YYABORT; // OOM
 
             $$.set_expr_str_list= NEW_PTN List<String>;
             if ($$.set_expr_str_list == nullptr ||
                 $$.set_expr_str_list->push_back($1.set_expr_str))
               MYSQL_YYABORT; // OOM
           }
         ;
@@ -14869,14 +14908,14 @@ table_wild:
 order_expr:
           expr opt_ordering_direction
           {
-            $$= NEW_PTN PT_order_expr($1, $2);
+            $$= NEW_PTN PT_order_expr(@$, $1, $2);
           }
         ;
 
 grouping_expr:
           expr
           {
-            $$= NEW_PTN PT_order_expr($1, ORDER_NOT_RELEVANT);
+            $$= NEW_PTN PT_order_expr(@$, $1, ORDER_NOT_RELEVANT);
           }
         ;
 
@@ -15784,55 +15823,55 @@ ident_keywords_ambiguous_4_system_variables:
 set:
           SET_SYM start_option_value_list
           {
-            $$= NEW_PTN PT_set(@1, $2);
+            $$= NEW_PTN PT_set(@$, @1, $2);
           }
         ;
 
 
 // Start of option value list
 start_option_value_list:
           option_value_no_option_type option_value_list_continued
           {
-            $$= NEW_PTN PT_start_option_value_list_no_type($1, @1, $2);
+            $$= NEW_PTN PT_start_option_value_list_no_type(@$, $1, @1, $2);
           }
         | TRANSACTION_SYM transaction_characteristics
           {
-            $$= NEW_PTN PT_start_option_value_list_transaction($2, @2);
+            $$= NEW_PTN PT_start_option_value_list_transaction(@$, $2, @2);
           }
         | option_type start_option_value_list_following_option_type
           {
-            $$= NEW_PTN PT_start_option_value_list_type($1, $2);
+            $$= NEW_PTN PT_start_option_value_list_type(@$, $1, $2);
           }
         | PASSWORD equal TEXT_STRING_password opt_replace_password opt_retain_current_password
           {
-            $$= NEW_PTN PT_option_value_no_option_type_password($3.str, $4.str,
+            $$= NEW_PTN PT_option_value_no_option_type_password(@$, $3.str, $4.str,
                                                                 $5,
                                                                 false,
                                                                 @4);
           }
         | PASSWORD TO_SYM RANDOM_SYM opt_replace_password opt_retain_current_password
           {
             // RANDOM PASSWORD GENERATION AND RETURN RESULT SET...
-            $$= NEW_PTN PT_option_value_no_option_type_password($3.str, $4.str,
+            $$= NEW_PTN PT_option_value_no_option_type_password(@$, $3.str, $4.str,
                                                                 $5,
                                                                 true,
                                                                 @4);
           }
         | PASSWORD FOR_SYM user equal TEXT_STRING_password opt_replace_password opt_retain_current_password
           {
-            $$= NEW_PTN PT_option_value_no_option_type_password_for($3, $5.str,
+            $$= NEW_PTN PT_option_value_no_option_type_password_for(@$, $3, $5.str,
                                                                     $6.str,
                                                                     $7,
                                                                     false,
                                                                     @6);
           }
         | PASSWORD FOR_SYM user TO_SYM RANDOM_SYM opt_replace_password opt_retain_current_password
           {
             // RANDOM PASSWORD GENERATION AND RETURN RESULT SET...
-            $$= NEW_PTN PT_option_value_no_option_type_password_for($3, $5.str,
+            $$= NEW_PTN PT_option_value_no_option_type_password_for(@$, $3, $5.str,
                                                                     $6.str,
                                                                     $7,
                                                                     true,
                                                                     @6);
           }
         ;
@@ -15840,36 +15879,36 @@ start_option_value_list:
 set_role_stmt:
           SET_SYM ROLE_SYM role_list
           {
-            $$= NEW_PTN PT_set_role($3);
+            $$= NEW_PTN PT_set_role(@$, $3);
           }
         | SET_SYM ROLE_SYM NONE_SYM
           {
-            $$= NEW_PTN PT_set_role(role_enum::ROLE_NONE);
+            $$= NEW_PTN PT_set_role(@$, role_enum::ROLE_NONE);
             Lex->sql_command= SQLCOM_SET_ROLE;
           }
         | SET_SYM ROLE_SYM DEFAULT_SYM
           {
-            $$= NEW_PTN PT_set_role(role_enum::ROLE_DEFAULT);
+            $$= NEW_PTN PT_set_role(@$, role_enum::ROLE_DEFAULT);
             Lex->sql_command= SQLCOM_SET_ROLE;
           }
         | SET_SYM DEFAULT_SYM ROLE_SYM role_list TO_SYM role_list
           {
-            $$= NEW_PTN PT_alter_user_default_role(false, $6, $4,
+            $$= NEW_PTN PT_alter_user_default_role(@$, false, $6, $4,
                                                     role_enum::ROLE_NAME);
           }
         | SET_SYM DEFAULT_SYM ROLE_SYM NONE_SYM TO_SYM role_list
           {
-            $$= NEW_PTN PT_alter_user_default_role(false, $6, NULL,
+            $$= NEW_PTN PT_alter_user_default_role(@$, false, $6, NULL,
                                                    role_enum::ROLE_NONE);
           }
         | SET_SYM DEFAULT_SYM ROLE_SYM ALL TO_SYM role_list
           {
-            $$= NEW_PTN PT_alter_user_default_role(false, $6, NULL,
+            $$= NEW_PTN PT_alter_user_default_role(@$, false, $6, NULL,
                                                    role_enum::ROLE_ALL);
           }
         | SET_SYM ROLE_SYM ALL opt_except_role_list
           {
-            $$= NEW_PTN PT_set_role(role_enum::ROLE_ALL, $4);
+            $$= NEW_PTN PT_set_role(@$, role_enum::ROLE_ALL, $4);
             Lex->sql_command= SQLCOM_SET_ROLE;
           }
         ;
@@ -15882,11 +15921,11 @@ opt_except_role_list:
 set_resource_group_stmt:
           SET_SYM RESOURCE_SYM GROUP_SYM ident
           {
-            $$= NEW_PTN PT_set_resource_group(to_lex_cstring($4), nullptr);
+            $$= NEW_PTN PT_set_resource_group(@$, to_lex_cstring($4), nullptr);
           }
         | SET_SYM RESOURCE_SYM GROUP_SYM ident FOR_SYM thread_id_list_options
           {
-            $$= NEW_PTN PT_set_resource_group(to_lex_cstring($4), $6);
+            $$= NEW_PTN PT_set_resource_group(@$, to_lex_cstring($4), $6);
           }
        ;
 
@@ -15912,18 +15951,18 @@ thread_id_list_options:
 // Start of option value list, option_type was given
 start_option_value_list_following_option_type:
           option_value_following_option_type option_value_list_continued
           {
             $$=
-              NEW_PTN PT_start_option_value_list_following_option_type_eq($1,
+              NEW_PTN PT_start_option_value_list_following_option_type_eq(@$, $1,
                                                                           @1,
                                                                           $2);
           }
         | TRANSACTION_SYM transaction_characteristics
           {
             $$= NEW_PTN
-              PT_start_option_value_list_following_option_type_transaction($2,
+              PT_start_option_value_list_following_option_type_transaction(@$, $2,
                                                                            @2);
           }
         ;
 
 // Remainder of the option value list after first option value.
@@ -15935,20 +15974,20 @@ option_value_list_continued:
 // Repeating list of option values after first option value.
 option_value_list:
           option_value
           {
-            $$= NEW_PTN PT_option_value_list_head(@0, $1, @1);
+            $$= NEW_PTN PT_option_value_list_head(@$, @0, $1, @1);
           }
         | option_value_list ',' option_value
           {
-            $$= NEW_PTN PT_option_value_list($1, @2, $3, @3);
+            $$= NEW_PTN PT_option_value_list(@$, $1, @2, $3, @3);
           }
         ;
 
 // Wrapper around option values following the first option value in the stmt.
 option_value:
           option_type option_value_following_option_type
           {
-            $$= NEW_PTN PT_option_value_type($1, $2);
+            $$= NEW_PTN PT_option_value_type(@$, $1, $2);
           }
         | option_value_no_option_type { $$= $1; }
         ;
@@ -15987,46 +16026,46 @@ opt_set_var_ident_type:
 // Option values with preceding option_type.
 option_value_following_option_type:
           lvalue_variable equal set_expr_or_default
           {
             $$ = NEW_PTN PT_set_scoped_system_variable(
-                @1, $1.prefix, $1.name, $3);
+                @$, @1, $1.prefix, $1.name, $3);
           }
         ;
 
 // Option values without preceding option_type.
 option_value_no_option_type:
           lvalue_variable equal set_expr_or_default
           {
-            $$ = NEW_PTN PT_set_variable(@1, $1.prefix, $1.name, @3, $3);
+            $$ = NEW_PTN PT_set_variable(@$, @1, $1.prefix, $1.name, @3, $3);
           }
         | '@' ident_or_text equal expr
           {
-            $$= NEW_PTN PT_option_value_no_option_type_user_var($2, $4);
+            $$= NEW_PTN PT_option_value_no_option_type_user_var(@$, $2, $4);
           }
         | '@' '@' opt_set_var_ident_type lvalue_variable equal
           set_expr_or_default
           {
             $$ = NEW_PTN PT_set_system_variable(
-                $3, @4, $4.prefix, $4.name, $6);
+                @$, $3, @4, $4.prefix, $4.name, $6);
           }
         | character_set old_or_new_charset_name_or_default
           {
-            $$= NEW_PTN PT_option_value_no_option_type_charset($2);
+            $$= NEW_PTN PT_option_value_no_option_type_charset(@$, $2);
           }
         | NAMES_SYM equal expr
           {
             /*
               Bad syntax, always fails with an error
             */
-            $$= NEW_PTN PT_option_value_no_option_type_names(@2);
+            $$= NEW_PTN PT_option_value_no_option_type_names(@$, @2);
           }
         | NAMES_SYM charset_name opt_collate
           {
-            $$= NEW_PTN PT_set_names($2, $3);
+            $$= NEW_PTN PT_set_names(@$, $2, $3);
           }
         | NAMES_SYM DEFAULT_SYM
           {
-            $$ = NEW_PTN PT_set_names(nullptr, nullptr);
+            $$ = NEW_PTN PT_set_names(@$, nullptr, nullptr);
           }
         ;
 
@@ -16073,18 +16112,18 @@ rvalue_system_variable:
 transaction_characteristics:
           transaction_access_mode opt_isolation_level
           {
-            $$= NEW_PTN PT_transaction_characteristics($1, $2);
+            $$= NEW_PTN PT_transaction_characteristics(@$, $1, $2);
           }
         | isolation_level opt_transaction_access_mode
           {
-            $$= NEW_PTN PT_transaction_characteristics($1, $2);
+            $$= NEW_PTN PT_transaction_characteristics(@$, $1, $2);
           }
         ;
 
 transaction_access_mode:
           transaction_access_mode_types
           {
-            $$= NEW_PTN PT_transaction_access_mode($1);
+            $$= NEW_PTN PT_transaction_access_mode(@$, $1);
           }
         ;
 
@@ -16096,7 +16135,7 @@ opt_transaction_access_mode:
 isolation_level:
           ISOLATION LEVEL_SYM isolation_types
           {
-            $$= NEW_PTN PT_isolation_level($3);
+            $$= NEW_PTN PT_isolation_level(@$, $3);
           }
         ;
 
@@ -16265,69 +16304,69 @@ alter_instance_stmt:
 alter_instance_action:
           ROTATE_SYM ident_or_text MASTER_SYM KEY_SYM
           {
             if (is_identifier($2, "INNODB"))
             {
-              $$= NEW_PTN PT_alter_instance(ROTATE_INNODB_MASTER_KEY, EMPTY_CSTR);
+              $$= NEW_PTN PT_alter_instance(@$, ROTATE_INNODB_MASTER_KEY, EMPTY_CSTR);
             }
             else if (is_identifier($2, "BINLOG"))
             {
-              $$= NEW_PTN PT_alter_instance(ROTATE_BINLOG_MASTER_KEY, EMPTY_CSTR);
+              $$= NEW_PTN PT_alter_instance(@$, ROTATE_BINLOG_MASTER_KEY, EMPTY_CSTR);
             }
             else
             {
               YYTHD->syntax_error_at(@2);
               MYSQL_YYABORT;
             }
           }
         | RELOAD TLS_SYM
           {
-            $$ = NEW_PTN PT_alter_instance(ALTER_INSTANCE_RELOAD_TLS_ROLLBACK_ON_ERROR, to_lex_cstring("mysql_main"));
+            $$ = NEW_PTN PT_alter_instance(@$, ALTER_INSTANCE_RELOAD_TLS_ROLLBACK_ON_ERROR, to_lex_cstring("mysql_main"));
           }
         | RELOAD TLS_SYM NO_SYM ROLLBACK_SYM ON_SYM ERROR_SYM
           {
-            $$ = NEW_PTN PT_alter_instance(ALTER_INSTANCE_RELOAD_TLS, to_lex_cstring("mysql_main"));
+            $$ = NEW_PTN PT_alter_instance(@$, ALTER_INSTANCE_RELOAD_TLS, to_lex_cstring("mysql_main"));
           }
         | RELOAD TLS_SYM FOR_SYM CHANNEL_SYM ident {
-            $$ = NEW_PTN PT_alter_instance(ALTER_INSTANCE_RELOAD_TLS_ROLLBACK_ON_ERROR, to_lex_cstring($5));
+            $$ = NEW_PTN PT_alter_instance(@$, ALTER_INSTANCE_RELOAD_TLS_ROLLBACK_ON_ERROR, to_lex_cstring($5));
           }
         | RELOAD TLS_SYM FOR_SYM CHANNEL_SYM ident NO_SYM ROLLBACK_SYM ON_SYM ERROR_SYM {
-            $$ = NEW_PTN PT_alter_instance(ALTER_INSTANCE_RELOAD_TLS, to_lex_cstring($5));
+            $$ = NEW_PTN PT_alter_instance(@$, ALTER_INSTANCE_RELOAD_TLS, to_lex_cstring($5));
           }
         | ENABLE_SYM ident ident
           {
             if (!is_identifier($2, "INNODB"))
             {
               YYTHD->syntax_error_at(@2);
               MYSQL_YYABORT;
             }
 
             if (!is_identifier($3, "REDO_LOG"))
             {
               YYTHD->syntax_error_at(@3);
               MYSQL_YYABORT;
             }
-            $$ = NEW_PTN PT_alter_instance(ALTER_INSTANCE_ENABLE_INNODB_REDO, EMPTY_CSTR);
+            $$ = NEW_PTN PT_alter_instance(@$, ALTER_INSTANCE_ENABLE_INNODB_REDO, EMPTY_CSTR);
           }
         | DISABLE_SYM ident ident
           {
             if (!is_identifier($2, "INNODB"))
             {
               YYTHD->syntax_error_at(@2);
               MYSQL_YYABORT;
             }
 
             if (!is_identifier($3, "REDO_LOG"))
             {
               YYTHD->syntax_error_at(@3);
               MYSQL_YYABORT;
             }
-            $$ = NEW_PTN PT_alter_instance(ALTER_INSTANCE_DISABLE_INNODB_REDO, EMPTY_CSTR);
+            $$ = NEW_PTN PT_alter_instance(@$, ALTER_INSTANCE_DISABLE_INNODB_REDO, EMPTY_CSTR);
           }
         | RELOAD KEYRING_SYM {
-            $$ = NEW_PTN PT_alter_instance(RELOAD_KEYRING, EMPTY_CSTR);
+            $$ = NEW_PTN PT_alter_instance(@$, RELOAD_KEYRING, EMPTY_CSTR);
           }
         ;
 
 /*
 ** Handler: direct access to ISAM functions
 */
@@ -16401,64 +16440,64 @@ handler_rkey_mode:
 revoke:
           REVOKE if_exists role_or_privilege_list FROM user_list opt_ignore_unknown_user
           {
             Lex->grant_if_exists = $2;
             Lex->ignore_unknown_user = $6;
-            auto *tmp= NEW_PTN PT_revoke_roles($3, $5);
+            auto *tmp= NEW_PTN PT_revoke_roles(@$, $3, $5);
             MAKE_CMD(tmp);
           }
         | REVOKE if_exists role_or_privilege_list ON_SYM opt_acl_type grant_ident FROM user_list opt_ignore_unknown_user
           {
             LEX *lex= Lex;
             lex->grant_if_exists = $2;
             Lex->ignore_unknown_user = $9;
             if (apply_privileges(YYTHD, *$3))
               MYSQL_YYABORT;
             lex->sql_command= (lex->grant == GLOBAL_ACLS) ? SQLCOM_REVOKE_ALL
                                                           : SQLCOM_REVOKE;
             if ($5 != Acl_type::TABLE && !lex->columns.is_empty())
             {
               YYTHD->syntax_error();
               MYSQL_YYABORT;
             }
             lex->type= static_cast<ulong>($5);
             lex->users_list= *$8;
           }
         | REVOKE if_exists ALL opt_privileges
           {
             Lex->grant_if_exists = $2;
             Lex->all_privileges= 1;
             Lex->grant= GLOBAL_ACLS;
           }
           ON_SYM opt_acl_type grant_ident FROM user_list opt_ignore_unknown_user
           {
             LEX *lex= Lex;
             lex->sql_command= (lex->grant == (GLOBAL_ACLS & ~GRANT_ACL)) ?
                                                             SQLCOM_REVOKE_ALL
                                                           : SQLCOM_REVOKE;
             if ($7 != Acl_type::TABLE && !lex->columns.is_empty())
             {
               YYTHD->syntax_error();
               MYSQL_YYABORT;
             }
             lex->type= static_cast<ulong>($7);
             lex->users_list= *$10;
             lex->ignore_unknown_user = $11;
           }
         | REVOKE if_exists ALL opt_privileges ',' GRANT OPTION FROM user_list opt_ignore_unknown_user
           {
             Lex->grant_if_exists = $2;
             Lex->ignore_unknown_user = $10;
             Lex->sql_command = SQLCOM_REVOKE_ALL;
             Lex->users_list= *$9;
           }
         | REVOKE if_exists PROXY_SYM ON_SYM user FROM user_list opt_ignore_unknown_user
           {
             LEX *lex= Lex;
             lex->grant_if_exists = $2;
             lex->ignore_unknown_user = $8;
             lex->sql_command= SQLCOM_REVOKE;
             lex->users_list= *$7;
             lex->users_list.push_front ($5);
             lex->type= TYPE_ENUM_PROXY;
           }
         ;
@@ -16466,50 +16505,50 @@ revoke:
 grant:
           GRANT role_or_privilege_list TO_SYM user_list opt_with_admin_option
           {
-            auto *tmp= NEW_PTN PT_grant_roles($2, $4, $5);
+            auto *tmp= NEW_PTN PT_grant_roles(@$, $2, $4, $5);
             MAKE_CMD(tmp);
           }
         | GRANT role_or_privilege_list ON_SYM opt_acl_type grant_ident TO_SYM user_list
           grant_options opt_grant_as
           {
             LEX *lex= Lex;
             lex->sql_command= SQLCOM_GRANT;
             if (apply_privileges(YYTHD, *$2))
               MYSQL_YYABORT;
 
             if ($4 != Acl_type::TABLE && !lex->columns.is_empty())
             {
               YYTHD->syntax_error();
               MYSQL_YYABORT;
             }
             lex->type= static_cast<ulong>($4);
             lex->users_list= *$7;
           }
         | GRANT ALL opt_privileges
           {
             Lex->all_privileges= 1;
             Lex->grant= GLOBAL_ACLS;
           }
           ON_SYM opt_acl_type grant_ident TO_SYM user_list grant_options opt_grant_as
           {
             LEX *lex= Lex;
             lex->sql_command= SQLCOM_GRANT;
             if ($6 != Acl_type::TABLE && !lex->columns.is_empty())
             {
               YYTHD->syntax_error();
               MYSQL_YYABORT;
             }
             lex->type= static_cast<ulong>($6);
             lex->users_list= *$9;
           }
         | GRANT PROXY_SYM ON_SYM user TO_SYM user_list opt_grant_option
           {
             LEX *lex= Lex;
             lex->sql_command= SQLCOM_GRANT;
             if ($7)
               lex->grant |= GRANT_ACL;
             lex->users_list= *$6;
             lex->users_list.push_front ($4);
             lex->type= TYPE_ENUM_PROXY;
           }
         ;
@@ -16544,92 +16583,92 @@ role_or_privilege_list:
 role_or_privilege:
           role_ident_or_text opt_column_list
           {
             if ($2 == NULL)
-              $$= NEW_PTN PT_role_or_dynamic_privilege(@1, $1);
+              $$= NEW_PTN PT_role_or_dynamic_privilege(@$, @1, $1);
             else
-              $$= NEW_PTN PT_dynamic_privilege(@1, $1);
+              $$= NEW_PTN PT_dynamic_privilege(@$, @1, $1);
           }
         | role_ident_or_text '@' ident_or_text
-          { $$= NEW_PTN PT_role_at_host(@1, $1, $3); }
+          { $$= NEW_PTN PT_role_at_host(@$, @1, $1, $3); }
         | SELECT_SYM opt_column_list
-          { $$= NEW_PTN PT_static_privilege(@1, SELECT_ACL, $2); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, SELECT_ACL, $2); }
         | INSERT_SYM opt_column_list
-          { $$= NEW_PTN PT_static_privilege(@1, INSERT_ACL, $2); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, INSERT_ACL, $2); }
         | UPDATE_SYM opt_column_list
-          { $$= NEW_PTN PT_static_privilege(@1, UPDATE_ACL, $2); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, UPDATE_ACL, $2); }
         | REFERENCES opt_column_list
-          { $$= NEW_PTN PT_static_privilege(@1, REFERENCES_ACL, $2); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, REFERENCES_ACL, $2); }
         | DELETE_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, DELETE_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, DELETE_ACL); }
         | USAGE
-          { $$= NEW_PTN PT_static_privilege(@1, 0); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, 0); }
         | INDEX_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, INDEX_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, INDEX_ACL); }
         | ALTER
-          { $$= NEW_PTN PT_static_privilege(@1, ALTER_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, ALTER_ACL); }
         | CREATE
-          { $$= NEW_PTN PT_static_privilege(@1, CREATE_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, CREATE_ACL); }
         | DROP
-          { $$= NEW_PTN PT_static_privilege(@1, DROP_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, DROP_ACL); }
         | EXECUTE_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, EXECUTE_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, EXECUTE_ACL); }
         | RELOAD
-          { $$= NEW_PTN PT_static_privilege(@1, RELOAD_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, RELOAD_ACL); }
         | SHUTDOWN
-          { $$= NEW_PTN PT_static_privilege(@1, SHUTDOWN_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, SHUTDOWN_ACL); }
         | PROCESS
-          { $$= NEW_PTN PT_static_privilege(@1, PROCESS_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, PROCESS_ACL); }
         | FILE_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, FILE_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, FILE_ACL); }
         | GRANT OPTION
           {
-            $$= NEW_PTN PT_static_privilege(@1, GRANT_ACL);
+            $$= NEW_PTN PT_static_privilege(@$, @1, GRANT_ACL);
             Lex->grant_privilege= true;
           }
         | SHOW DATABASES
-          { $$= NEW_PTN PT_static_privilege(@1, SHOW_DB_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, SHOW_DB_ACL); }
         | SUPER_SYM
           {
             /* DEPRECATED */
-            $$= NEW_PTN PT_static_privilege(@1, SUPER_ACL);
+            $$= NEW_PTN PT_static_privilege(@$, @1, SUPER_ACL);
             if (Lex->grant != GLOBAL_ACLS)
             {
               /*
                  An explicit request was made for the SUPER priv id
               */
               push_warning(Lex->thd, Sql_condition::SL_WARNING,
                            ER_WARN_DEPRECATED_SYNTAX,
                            "The SUPER privilege identifier is deprecated");
             }
           }
         | CREATE TEMPORARY TABLES
-          { $$= NEW_PTN PT_static_privilege(@1, CREATE_TMP_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, CREATE_TMP_ACL); }
         | LOCK_SYM TABLES
-          { $$= NEW_PTN PT_static_privilege(@1, LOCK_TABLES_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, LOCK_TABLES_ACL); }
         | REPLICATION SLAVE
-          { $$= NEW_PTN PT_static_privilege(@1, REPL_SLAVE_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, REPL_SLAVE_ACL); }
         | REPLICATION CLIENT_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, REPL_CLIENT_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, REPL_CLIENT_ACL); }
         | CREATE VIEW_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, CREATE_VIEW_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, CREATE_VIEW_ACL); }
         | SHOW VIEW_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, SHOW_VIEW_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, SHOW_VIEW_ACL); }
         | CREATE ROUTINE_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, CREATE_PROC_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, CREATE_PROC_ACL); }
         | ALTER ROUTINE_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, ALTER_PROC_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, ALTER_PROC_ACL); }
         | CREATE USER
-          { $$= NEW_PTN PT_static_privilege(@1, CREATE_USER_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, CREATE_USER_ACL); }
         | EVENT_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, EVENT_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, EVENT_ACL); }
         | TRIGGER_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, TRIGGER_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, TRIGGER_ACL); }
         | CREATE TABLESPACE_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, CREATE_TABLESPACE_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, CREATE_TABLESPACE_ACL); }
         | CREATE ROLE_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, CREATE_ROLE_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, CREATE_ROLE_ACL); }
         | DROP ROLE_SYM
-          { $$= NEW_PTN PT_static_privilege(@1, DROP_ROLE_ACL); }
+          { $$= NEW_PTN PT_static_privilege(@$, @1, DROP_ROLE_ACL); }
         ;
 
 opt_with_admin_option:
@@ -18144,14 +18183,14 @@ opt_install_set_value_list:
 install_stmt:
           INSTALL_SYM PLUGIN_SYM ident SONAME_SYM TEXT_STRING_sys
           {
             LEX *lex= Lex;
             lex->sql_command= SQLCOM_INSTALL_PLUGIN;
             lex->m_sql_cmd= new (YYMEM_ROOT) Sql_cmd_install_plugin(to_lex_cstring($3), $5);
             $$ = nullptr;
           }
         | INSTALL_SYM COMPONENT_SYM TEXT_STRING_sys_list opt_install_set_value_list
           {
-            $$ = NEW_PTN PT_install_component(YYTHD, $3, $4);
+            $$ = NEW_PTN PT_install_component(@$, YYTHD, $3, $4);
           }
         ;
 
diff --git a/sql/window.cc b/sql/window.cc
index 2730078e971..7309e807f66 100644
--- a/sql/window.cc
+++ b/sql/window.cc
@@ -79,22 +79,22 @@
 /**
   Shallow clone the list of ORDER objects using mem_root and return
   the cloned list.
 */
 static ORDER *clone(THD *thd, ORDER *order) {
   ORDER *clone = nullptr;
   ORDER **prev_next = &clone;
   for (; order != nullptr; order = order->next) {
-    ORDER *o = new (thd->mem_root) PT_order_expr(nullptr, ORDER_ASC);
+    ORDER *o = new (thd->mem_root) PT_order_expr(POS(), nullptr, ORDER_ASC);
     std::memcpy(o, order, sizeof(*order));
     *prev_next = o;
     prev_next = &o->next;
   }
 
   *prev_next = nullptr;  // final object should have a null next pointer
   return clone;
 }
 
 /**
   Append order expressions at the end of *first_next ordering list
   representing the partitioning columns.
 */
diff --git a/unittest/gunit/dd_info_schema_native_func-t.cc b/unittest/gunit/dd_info_schema_native_func-t.cc
index 72552ba4e26..28ee6bf1147 100644
--- a/unittest/gunit/dd_info_schema_native_func-t.cc
+++ b/unittest/gunit/dd_info_schema_native_func-t.cc
@@ -50,242 +50,242 @@ class ISNativeFuncTest : public ::testing::Test {
 // Test case to verify native functions with all NULL arguments.
 TEST_F(ISNativeFuncTest, AllNullArguments) {
   Item *item = nullptr;
   Item_null *null = new (thd()->mem_root) Item_null();
-  PT_item_list *null_list = new (thd()->mem_root) PT_item_list;
+  PT_item_list *null_list = new (thd()->mem_root) PT_item_list(POS());
   auto prepare_null_list = [null_list, null](int cnt) {
     for (int i = 0; i < cnt; i++) null_list->push_front(null);
     return null_list;
   };
 
 #define NULL_ARG null
 #define TWO_NULL_ARGS NULL_ARG, NULL_ARG
 #define THREE_NULL_ARGS TWO_NULL_ARGS, NULL_ARG
 #define FOUR_NULL_ARGS THREE_NULL_ARGS, NULL_ARG
 #define FIVE_NULL_ARGS FOUR_NULL_ARGS, NULL_ARG
 #define CREATE_ITEM(X, ARGS) item = new (thd()->mem_root) X(POS(), ARGS)
 
   // INTERNAL_TABLE_ROWS(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
   CREATE_ITEM(Item_func_internal_table_rows, prepare_null_list(8));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_AVG_ROW_LENGTH(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_avg_row_length, prepare_null_list(8));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_DATA_LENGTH(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_data_length, prepare_null_list(8));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_MAX_DATA_LENGTH(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_max_data_length, prepare_null_list(8));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_INDEX_LENGTH(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_index_length, prepare_null_list(8));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_DATA_FREE(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_data_free, prepare_null_list(8));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_AUTO_INCREMENT(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
   // NULL)
   CREATE_ITEM(Item_func_internal_auto_increment, prepare_null_list(9));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_UPDATE_TIME(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_update_time, prepare_null_list(8));
   MYSQL_TIME ldate;
   item->get_date(&ldate, 0);
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_CHECK_TIME(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_check_time, prepare_null_list(8));
   item->get_date(&ldate, 0);
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_CHECKSUM(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_checksum, prepare_null_list(8));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_DD_CHAR_LENGTH(NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_dd_char_length, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_GET_VIEW_WARNING_OR_ERROR(NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_get_view_warning_or_error,
               prepare_null_list(4));
   // null_value is not set in this function. So verifying only val_int() return
   // value.
   EXPECT_EQ(0, item->val_int());
 
   // INTERNAL_GET_COMMENT_OR_ERROR(NULL, NULL, NULL, NULL, NULL)
   String str;
   CREATE_ITEM(Item_func_internal_get_comment_or_error, prepare_null_list(5));
   item->val_str(&str);
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_INDEX_COLUMN_CARDINALITY(NULL, NULL, NULL, NULL, NULL,
   //                                   NULL, NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_internal_index_column_cardinality,
               prepare_null_list(11));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // GET_DD_INDEX_SUB_PART_LENGTH(NULL, NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_get_dd_index_sub_part_length, prepare_null_list(5));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // GET_DD_COLUMN_PRIVILEGES(NULL, NULL, NULL)
   CREATE_ITEM(Item_func_get_dd_column_privileges, THREE_NULL_ARGS);
   // Empty string value is returned in this case.
   EXPECT_EQ(static_cast<size_t>(0), (item->val_str(&str))->length());
 
   // INTERNAL_KEYS_DISABLED(NULL)
   CREATE_ITEM(Item_func_internal_keys_disabled, NULL_ARG);
   EXPECT_EQ(0, item->val_int());
 
   // CAN_ACCESS_DATABASE(NULL)
   CREATE_ITEM(Item_func_can_access_database, NULL_ARG);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // CAN_ACCESS_TABLE(NULL, NULL)
   CREATE_ITEM(Item_func_can_access_table, TWO_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // CAN_ACCESS_VIEW(NULL, NULL, NULL, NULL)
   CREATE_ITEM(Item_func_can_access_view, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // CAN_ACCESS_COLUMN(NULL, NULL, NULL)
   CREATE_ITEM(Item_func_can_access_column, THREE_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // CAN_ACCESS_TRIGGER(NULL, NULL, NULL)
   CREATE_ITEM(Item_func_can_access_trigger, TWO_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // CAN_ACCESS_ROUTINE(NULL, NULL, NULL)
   CREATE_ITEM(Item_func_can_access_routine, prepare_null_list(5));
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // CAN_ACCESS_EVENT(NULL, NULL, NULL)
   CREATE_ITEM(Item_func_can_access_event, NULL_ARG);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // GET_DD_CREATE_OPTIONS(NULL, NULL, NULL)
   CREATE_ITEM(Item_func_get_dd_create_options, THREE_NULL_ARGS);
   // Empty string value is returned in this case.
   EXPECT_EQ(static_cast<size_t>(0), (item->val_str(&str))->length());
 
   // GET_DD_SCHEMA_OPTIONS(NULL)
   CREATE_ITEM(Item_func_get_dd_schema_options, NULL_ARG);
   // Empty string value is returned in this case.
   EXPECT_EQ(static_cast<size_t>(0), (item->val_str(&str))->length());
 
   // INTERNAL_GET_PARTITION_NODEGROUP()
   CREATE_ITEM(Item_func_get_partition_nodegroup, NULL_ARG);
   EXPECT_EQ(0, strcmp((item->val_str(&str))->ptr(), "default"));
 
   // INTERNAL_TABLESPACE_ID()
   CREATE_ITEM(Item_func_internal_tablespace_id, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_TABLESPACE_TYPE()
   CREATE_ITEM(Item_func_internal_tablespace_type, FOUR_NULL_ARGS);
   EXPECT_EQ(nullptr, item->val_str(&str));
 
   // INTERNAL_TABLESPACE_FREE_EXTENTS()
   CREATE_ITEM(Item_func_internal_tablespace_free_extents, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_TABLESPACE_TOTAL_EXTENTS()
   CREATE_ITEM(Item_func_internal_tablespace_total_extents, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_TABLESPACE_EXTENT_SIZE()
   CREATE_ITEM(Item_func_internal_tablespace_extent_size, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_TABLESPACE_INITIAL_SIZE()
   CREATE_ITEM(Item_func_internal_tablespace_initial_size, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_TABLESPACE_MAXIMUM_SIZE()
   CREATE_ITEM(Item_func_internal_tablespace_maximum_size, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_TABLESPACE_AUTOEXTEND_SIZE()
   CREATE_ITEM(Item_func_internal_tablespace_autoextend_size, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_TABLESPACE_DATA_FREE()
   CREATE_ITEM(Item_func_internal_tablespace_data_free, FOUR_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_TABLESPACE_STATUS()
   CREATE_ITEM(Item_func_internal_tablespace_status, FOUR_NULL_ARGS);
   EXPECT_EQ(nullptr, item->val_str(&str));
 
   // GET_DD_PROPERTY_KEY_VALUE()
   CREATE_ITEM(Item_func_get_dd_property_key_value, TWO_NULL_ARGS);
   EXPECT_EQ(nullptr, item->val_str(&str));
 
   // REMOVE_DD_PROPERTY_KEY()
   CREATE_ITEM(Item_func_remove_dd_property_key, TWO_NULL_ARGS);
   EXPECT_EQ(nullptr, item->val_str(&str));
 
   // INTERNAL_GET_DD_COLUMN_EXTRA()
   CREATE_ITEM(Item_func_internal_get_dd_column_extra, prepare_null_list(8));
   item->val_str(&str);
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_GET_USERNAME()
   CREATE_ITEM(Item_func_internal_get_username, prepare_null_list(1));
   EXPECT_EQ(nullptr, item->val_str(&str));
 
   // INTERNAL_GET_HOSTNAME()
   CREATE_ITEM(Item_func_internal_get_hostname, prepare_null_list(1));
   EXPECT_EQ(nullptr, item->val_str(&str));
 
   // INTERNAL_IS_MANDATORY_ROLE()
   CREATE_ITEM(Item_func_internal_is_mandatory_role, TWO_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // INTERNAL_IS_ENABLED_ROLE()
   CREATE_ITEM(Item_func_internal_is_enabled_role, TWO_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 
   // CAN_ACCESS_USER(NULL, NULL, NULL)
   CREATE_ITEM(Item_func_can_access_user, TWO_NULL_ARGS);
   item->val_int();
   EXPECT_EQ(1, item->null_value);
 }
 }  // namespace dd_info_schema_native_func
diff --git a/unittest/gunit/item_filter-t.cc b/unittest/gunit/item_filter-t.cc
index 7adc25dd49d..506c22198b8 100644
--- a/unittest/gunit/item_filter-t.cc
+++ b/unittest/gunit/item_filter-t.cc
@@ -56,159 +56,159 @@ std::ostream &operator<<(std::ostream &s, const TestFailLinePrinter &v) {
 class ItemFilterTest : public ::testing::Test {
  protected:
   ItemFilterTest() : rows_in_table(200) {}
 
   void SetUp() override {
     initializer.SetUp();
     init_sql_alloc(PSI_NOT_INSTRUMENTED, &m_alloc,
                    thd()->variables.range_alloc_block_size);
   }
 
   void TearDown() override {
     delete m_table;
 
     initializer.TearDown();
   }
 
   THD *thd() { return initializer.thd(); }
 
   /**
     Create a table with the requested number of columns without
     creating indexes.
 
     @param  nbr_columns       The number of columns in the table
     @param  columns_nullable  Whether or not columns in the table can be NULL
   */
   void create_table(int nbr_columns, bool columns_nullable) {
     m_table = new Fake_TABLE(nbr_columns, columns_nullable);
     m_field = m_table->field;
     m_table_list = m_table->pos_in_table_list;
   }
 
   /**
     Create a table with the requested number of non-nullable columns
     without creating indexes.
 
     @param  nbr_columns       The number of columns in the table
   */
   void create_table(int nbr_columns) { create_table(nbr_columns, false); }
 
   /**
     Utility funtion used to simplify creation of func items used as
     range predicates.
 
     @param type            The type of range predicate operator requested
     @param fld             The field used in the range predicate
     @param val1            Value used in the range predicate (if the predicate
                            takes two or more arguments)
     @param val2            Value used in the range predicate (if the predicate
                            takes three or more arguments)
 
     @return Item for the specified range predicate
   */
   Item_func *create_item(Item_func::Functype type, Field *fld, int val1,
                          int val2);
 
 // Undefined at end of this file
 #define create_item_check_filter(er, op, f1, v1, v2, ut, fti) \
   do_create_item_check_filter(er, op, f1, v1, v2, ut, fti,    \
                               TestFailLinePrinter(__LINE__))
   Item *do_create_item_check_filter(const float expected_result,
                                     const Item_func::Functype type, Field *fld,
                                     const int val1, const int val2,
                                     const table_map used_tables,
                                     MY_BITMAP *fields_to_ignore,
                                     TestFailLinePrinter called_from_line) {
     SCOPED_TRACE(called_from_line);
     Item *item = create_item(type, fld, val1, val2);
 
     const float filter =
         item->get_filtering_effect(thd(), m_table_list->map(), used_tables,
                                    fields_to_ignore, rows_in_table);
     EXPECT_FLOAT_EQ(expected_result, filter);
     return item;
   }
 
 #define create_anditem_check_filter(er, lst, ut, fti) \
   do_create_anditem_check_filter(er, lst, ut, fti,    \
                                  TestFailLinePrinter(__LINE__))
   Item_cond_and *do_create_anditem_check_filter(
       const float expected_result, List<Item> &lst, const table_map used_tables,
       MY_BITMAP *fields_to_ignore, TestFailLinePrinter called_from_line) {
     SCOPED_TRACE(called_from_line);
 
     Item_cond_and *and_item = new Item_cond_and(lst);
 
     Item *itm = static_cast<Item *>(and_item);
     and_item->fix_fields(thd(), &itm);
 
     const float filter =
         and_item->get_filtering_effect(thd(), m_table_list->map(), used_tables,
                                        fields_to_ignore, rows_in_table);
     EXPECT_FLOAT_EQ(expected_result, filter);
 
     return and_item;
   }
 
 #define create_oritem_check_filter(er, lst, ut, fti) \
   do_create_oritem_check_filter(er, lst, ut, fti, TestFailLinePrinter(__LINE__))
   Item_cond_or *do_create_oritem_check_filter(
       const float expected_result, List<Item> &lst, const table_map used_tables,
       MY_BITMAP *fields_to_ignore, TestFailLinePrinter called_from_line) {
     SCOPED_TRACE(called_from_line);
 
     Item_cond_or *or_item = new Item_cond_or(lst);
 
     Item *itm = static_cast<Item *>(or_item);
     or_item->fix_fields(thd(), &itm);
 
     const float filter =
         or_item->get_filtering_effect(thd(), m_table_list->map(), used_tables,
                                       fields_to_ignore, rows_in_table);
     EXPECT_FLOAT_EQ(expected_result, filter);
 
     return or_item;
   }
 
 #define create_initem_check_filter(er, lst, ut, fti) \
   do_create_initem_check_filter(er, lst, ut, fti, TestFailLinePrinter(__LINE__))
   Item_func_in *do_create_initem_check_filter(
       const float expected_result, const mem_root_deque<Item *> &lst,
       const table_map used_tables, MY_BITMAP *fields_to_ignore,
       TestFailLinePrinter called_from_line) {
     SCOPED_TRACE(called_from_line);
 
-    PT_item_list *list = new (thd()->mem_root) PT_item_list;
+    PT_item_list *list = new (thd()->mem_root) PT_item_list(POS());
     list->value = lst;
     Item_func_in *in_item = new Item_func_in(POS(), list, false);
     Parse_context pc(thd(), thd()->lex->current_query_block());
     EXPECT_FALSE(in_item->itemize(&pc, (Item **)&in_item));
 
     Item *itm = static_cast<Item *>(in_item);
     in_item->fix_fields(thd(), &itm);
 
     const float filter =
         in_item->get_filtering_effect(thd(), m_table_list->map(), used_tables,
                                       fields_to_ignore, rows_in_table);
     EXPECT_FLOAT_EQ(expected_result, filter);
 
     return in_item;
   }
 
   /*
     Many filtering estimates depends on the number of rows in the
     table. For example, P("col = <const>") = max(0.005, 1/rows_in_table)
 
     This variable determines the number of rows in the table.
   */
   double rows_in_table;
   Server_initializer initializer;
   MEM_ROOT m_alloc;
 
   Fake_TABLE *m_table;
   Table_ref *m_table_list;
   /*
     Pointer to m_table->field. Only valid if the table was
     created by calling one of ItemFilterTest::create_table*()
    */
   Field **m_field;
 };
diff --git a/unittest/gunit/mock_parse_tree.h b/unittest/gunit/mock_parse_tree.h
index 1840ae757e0..51966c06d70 100644
--- a/unittest/gunit/mock_parse_tree.h
+++ b/unittest/gunit/mock_parse_tree.h
@@ -57,21 +57,22 @@ inline Item *make_fixed_literal(THD *thd, const char *pattern) {
 
 class Mock_pt_item_list : public PT_item_list {
  public:
-  Mock_pt_item_list(std::initializer_list<const char *> strings) {
+  Mock_pt_item_list(std::initializer_list<const char *> strings)
+      : PT_item_list(POS()) {
     for (auto string : strings) push_back(new Mock_text_literal(string));
   }
 
   template <typename T>
-  Mock_pt_item_list(T t) {
+  explicit Mock_pt_item_list(T t) : PT_item_list(POS()) {
     push_back(t);
   }
 
   template <typename T, typename... Ts>
   Mock_pt_item_list(T t, Ts... ts) : Mock_pt_item_list(ts...) {
     push_front(t);
   }
 };
 
 }  // namespace my_testing
 
 #endif  // MOCK_PARSE_TREE_INCLUDED
diff --git a/unittest/gunit/opt_range-t.cc b/unittest/gunit/opt_range-t.cc
index 105bbe2591e..7b106f0da34 100644
--- a/unittest/gunit/opt_range-t.cc
+++ b/unittest/gunit/opt_range-t.cc
@@ -1640,30 +1640,30 @@ static Item_row *new_Item_row(Field **fields, int count) {
 TEST_F(OptRangeTest, RowConstructorIn2) {
   create_table(2);
 
   m_opt_param->add_key();
 
   // We build the expression (field_1, field_2) IN ((3, 4), (1, 2)) ...
-  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list;
+  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list(POS());
   all_args->push_front(new_Item_row(1, 2));
   all_args->push_front(new_Item_row(3, 4));
   all_args->push_front(new_Item_row(m_opt_param->table->field, 2));
   Item *cond = new Item_func_in(POS(), all_args, false);
   Parse_context pc(thd(), thd()->lex->current_query_block());
   EXPECT_FALSE(cond->itemize(&pc, &cond));
 
   // ... and resolve it.
   Item *item = cond;
   cond->fix_fields(thd(), &item);
 
   SEL_TREE *sel_tree = get_mm_tree(thd(), m_opt_param, 0, 0, m_current_table,
                                    /*remove_jump_scans=*/true, cond);
 
   EXPECT_FALSE(sel_tree == nullptr);
   EXPECT_EQ(Key_map(1), sel_tree->keys_map);
 
   const char *expected =
       "result keys[0]: "
       "(field_1 = 1 AND field_2 = 2) OR "
       "(field_1 = 3 AND field_2 = 4)\n";
   check_tree_result(sel_tree, SEL_TREE::KEY, expected);
 }
@@ -1671,31 +1671,31 @@ TEST_F(OptRangeTest, RowConstructorIn2) {
 TEST_F(OptRangeTest, RowConstructorIn3) {
   create_table(3);
 
   m_opt_param->add_key();
 
   // We build the expression (field_1, field_2) IN ((3, 4), (1, 2)) ...
-  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list;
+  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list(POS());
   all_args->push_front(new_Item_row(1, 2, 3));
   all_args->push_front(new_Item_row(4, 5, 6));
   all_args->push_front(new_Item_row(m_opt_param->table->field, 3));
   Item *cond = new Item_func_in(POS(), all_args, false);
   Parse_context pc(thd(), thd()->lex->current_query_block());
   EXPECT_FALSE(cond->itemize(&pc, &cond));
 
   // ... and resolve it.
   Item *item = cond;
   cond->fix_fields(thd(), &item);
 
   SEL_TREE *sel_tree = get_mm_tree(thd(), m_opt_param, 0, 0, m_current_table,
                                    /*remove_jump_scans=*/true, cond);
 
   EXPECT_FALSE(sel_tree == nullptr);
   EXPECT_EQ(Key_map(1), sel_tree->keys_map);
 
   const char *expected =
       "result keys[0]: "
       "(field_1 = 1 AND field_2 = 2 AND field_3 = 3) OR "
       "(field_1 = 4 AND field_2 = 5 AND field_3 = 6)\n";
 
   check_tree_result(sel_tree, SEL_TREE::KEY, expected);
 }
diff --git a/unittest/gunit/opt_ref-t.cc b/unittest/gunit/opt_ref-t.cc
index bc35532e0d9..e518ccae316 100644
--- a/unittest/gunit/opt_ref-t.cc
+++ b/unittest/gunit/opt_ref-t.cc
@@ -143,62 +143,62 @@ static Item_row *make_item_row(Item *a, Item *b) {
 TEST_F(OptRefTest, addKeyFieldsFromInOneRow) {
   /*
     We simulate the where condition (a, b) IN ((0, 0)). Note that this
     can't happen in practice since the parser is hacked to parse such
     an expression in to (a, b) = (0, 0), which gets rewritten into a =
     0 AND b = 0 before the ref optimizer runs.
    */
-  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list;
+  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list(POS());
   all_args->push_front(make_item_row(item_zero, item_zero));
   all_args->push_front(make_item_row(item_field_t1_a, item_field_t1_b));
   Item *cond = new Item_func_in(POS(), all_args, false);
   Parse_context pc(thd(), thd()->lex->current_query_block());
   EXPECT_FALSE(cond->itemize(&pc, &cond));
 
   call_add_key_fields(cond);
 
   // We expect the key_fields pointer not to be incremented.
   EXPECT_EQ(0, t1_key_fields - static_cast<Key_field *>(&t1_key_field_arr[0]));
   EXPECT_EQ(indexes, t1_join_tab.const_keys)
       << "SARGable index not present in const_keys";
   EXPECT_EQ(indexes, t1_join_tab.keys());
   EXPECT_EQ(0U, t1_key_field_arr[0].level);
   EXPECT_EQ(0U, t1_key_field_arr[1].level);
 }
 
 TEST_F(OptRefTest, addKeyFieldsFromInTwoRows) {
   // We simulate the where condition (col_a, col_b) IN ((0, 0), (1, 1))
-  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list;
+  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list(POS());
   all_args->push_front(make_item_row(item_one, item_one));
   all_args->push_front(make_item_row(item_zero, item_zero));
   all_args->push_front(make_item_row(item_field_t1_a, item_field_t1_b));
   Item *cond = new Item_func_in(POS(), all_args, false);
   Parse_context pc(thd(), thd()->lex->current_query_block());
   EXPECT_FALSE(cond->itemize(&pc, &cond));
 
   call_add_key_fields(cond);
 
   // We expect the key_fields pointer not to be incremented.
   EXPECT_EQ(0, t1_key_fields - static_cast<Key_field *>(&t1_key_field_arr[0]));
   EXPECT_EQ(indexes, t1_join_tab.const_keys)
       << "SARGable index not present in const_keys";
   EXPECT_EQ(indexes, t1_join_tab.keys());
 }
 
 TEST_F(OptRefTest, addKeyFieldsFromInOneRowWithCols) {
   // We simulate the where condition (t1.a, t1.b) IN ((t2.a, t2.b))
-  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list;
+  PT_item_list *all_args = new (current_thd->mem_root) PT_item_list(POS());
   all_args->push_front(make_item_row(item_field_t2_a, item_field_t2_b));
   all_args->push_front(make_item_row(item_field_t1_a, item_field_t1_b));
   Item *cond = new Item_func_in(POS(), all_args, false);
   Parse_context pc(thd(), thd()->lex->current_query_block());
   EXPECT_FALSE(cond->itemize(&pc, &cond));
 
   call_add_key_fields(cond);
 
   // We expect the key_fields pointer not to be incremented.
   EXPECT_EQ(0, t1_key_fields - static_cast<Key_field *>(&t1_key_field_arr[0]));
   EXPECT_EQ(Key_map(0), t1_join_tab.const_keys);
   EXPECT_EQ(indexes, t1_join_tab.keys());
 
   EXPECT_EQ(t2->pos_in_table_list->map(), t1_join_tab.key_dependent);
 }
