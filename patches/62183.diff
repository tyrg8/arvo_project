commit ccdced7d6a30828a9988616f199cea014150175d
Author: Akshay Ragir <akshay.ragir@ittiam.com>
Date:   Fri Sep 8 17:01:00 2023 +0530

    Fix for Divide-by-zero in impd_drc_stft_drc_gain_calc_init
    
    These changes handle the Divide-by-zero runtime error reported
    when the drc gain coordinates are identical or slope is
    perpendicular to the gain value.
    
    Bug: ossFuzz:61683
    Test: poc in bug

diff --git a/encoder/drc_src/impd_drc_api.c b/encoder/drc_src/impd_drc_api.c
index 84e97d5..6525dbb 100644
--- a/encoder/drc_src/impd_drc_api.c
+++ b/encoder/drc_src/impd_drc_api.c
@@ -230,69 +230,68 @@ static IA_ERRORCODE impd_drc_validate_drc_instructions(
 IA_ERRORCODE impd_drc_enc_init(VOID *pstr_drc_state, VOID *ptr_drc_scratch,
                                ia_drc_input_config *pstr_inp_config) {
   IA_ERRORCODE err_code = IA_NO_ERROR;
   WORD32 bit_count = 0;
   ia_drc_enc_state *pstr_drc_state_local = pstr_drc_state;
 
 #ifdef ENABLE_SET_JUMP
   jmp_buf drc_enc_init_jmp_buf;
   err_code = setjmp(drc_enc_init_jmp_buf);
   if (err_code != IA_NO_ERROR) {
     return IA_EXHEAACE_INIT_FATAL_DRC_INSUFFICIENT_WRITE_BUFFER_SIZE;
   }
 #endif  // ENABLE_SET_JUMP
 
   pstr_drc_state_local->drc_scratch_mem = ptr_drc_scratch;
   pstr_drc_state_local->drc_scratch_used = 0;
 
   iusace_create_bit_buffer(&pstr_drc_state_local->str_bit_buf_cfg,
                            pstr_drc_state_local->bit_buf_base_cfg,
                            sizeof(pstr_drc_state_local->bit_buf_base_cfg), 1);
 
   iusace_create_bit_buffer(&pstr_drc_state_local->str_bit_buf_cfg_ext,
                            pstr_drc_state_local->bit_buf_base_cfg_ext,
                            sizeof(pstr_drc_state_local->bit_buf_base_cfg_ext), 1);
 
   iusace_create_bit_buffer(&pstr_drc_state_local->str_bit_buf_cfg_tmp,
                            pstr_drc_state_local->bit_buf_base_cfg_tmp,
                            sizeof(pstr_drc_state_local->bit_buf_base_cfg_tmp), 1);
 
   iusace_create_bit_buffer(&pstr_drc_state_local->str_bit_buf_out,
                            pstr_drc_state_local->bit_buf_base_out,
                            sizeof(pstr_drc_state_local->bit_buf_base_out), 1);
 
 #ifdef ENABLE_SET_JUMP
   pstr_drc_state_local->str_bit_buf_cfg.impd_drc_jmp_buf = &drc_enc_init_jmp_buf;
   pstr_drc_state_local->str_bit_buf_cfg_ext.impd_drc_jmp_buf = &drc_enc_init_jmp_buf;
   pstr_drc_state_local->str_bit_buf_cfg_tmp.impd_drc_jmp_buf = &drc_enc_init_jmp_buf;
   pstr_drc_state_local->str_bit_buf_out.impd_drc_jmp_buf = &drc_enc_init_jmp_buf;
 #endif  // ENABLE_SET_JUMP
 
   impd_drc_validate_config_params(pstr_inp_config);
 
   err_code = impd_drc_gain_enc_init(
       &pstr_drc_state_local->str_gain_enc, &pstr_inp_config->str_uni_drc_config,
       &pstr_inp_config->str_enc_loudness_info_set, pstr_inp_config->str_enc_params.frame_size,
       pstr_inp_config->str_enc_params.sample_rate, pstr_inp_config->str_enc_params.delay_mode,
       pstr_inp_config->str_enc_params.domain);
-  if (err_code & IA_FATAL_ERROR) {
-    return IA_EXHEAACE_CONFIG_FATAL_DRC_INVALID_CONFIG;
+  if (err_code) {
+    return err_code;
   }
-
   pstr_drc_state_local->str_enc_params = pstr_inp_config->str_enc_params;
   pstr_drc_state_local->str_uni_drc_config = pstr_inp_config->str_uni_drc_config;
   pstr_drc_state_local->str_enc_gain_extension = pstr_inp_config->str_enc_gain_extension;
 
   err_code = impd_drc_validate_drc_instructions(&pstr_inp_config->str_uni_drc_config);
   if (err_code & IA_FATAL_ERROR) {
     return IA_EXHEAACE_CONFIG_FATAL_DRC_INVALID_CONFIG;
   }
 
   err_code = impd_drc_write_uni_drc_config(pstr_drc_state_local, &bit_count);
   if (err_code & IA_FATAL_ERROR) {
     return err_code;
   }
 
   pstr_drc_state_local->drc_config_data_size_bit = bit_count;
 
   return err_code;
 }
diff --git a/encoder/drc_src/impd_drc_enc.c b/encoder/drc_src/impd_drc_enc.c
index 823b9b6..1b92856 100644
--- a/encoder/drc_src/impd_drc_enc.c
+++ b/encoder/drc_src/impd_drc_enc.c
@@ -81,177 +81,177 @@ static VOID impd_drc_util_td_read_gain_config(
 IA_ERRORCODE impd_drc_gain_enc_init(ia_drc_gain_enc_struct *pstr_gain_enc,
                                     ia_drc_uni_drc_config_struct *pstr_uni_drc_config,
                                     ia_drc_loudness_info_set_struct *pstr_loudness_info_set,
                                     const WORD32 frame_size, const WORD32 sample_rate,
                                     const WORD32 delay_mode, const WORD32 domain) {
   IA_ERRORCODE err_code = IA_NO_ERROR;
   LOOPIDX i, j, k, l, m, ch;
   WORD32 num_gain_values_max;
   WORD32 params_found;
   UWORD8 found_ch_idx;
   UWORD32 ch_idx;
 
   ia_drc_uni_drc_config_ext_struct *pstr_uni_drc_config_ext =
       &pstr_uni_drc_config->str_uni_drc_config_ext;
   ia_drc_coefficients_uni_drc_struct *pstr_drc_coefficients_uni_drc =
       &pstr_uni_drc_config->str_drc_coefficients_uni_drc[0];
   ia_drc_coefficients_uni_drc_struct *pstr_drc_coefficients_uni_drc_v1 =
       &pstr_uni_drc_config_ext->str_drc_coefficients_uni_drc_v1[0];
 
   if (pstr_uni_drc_config_ext->drc_coefficients_uni_drc_v1_count <= 0) {
     WORD32 all_band_gain_count = 0;
     WORD32 gain_set_count = pstr_drc_coefficients_uni_drc->gain_set_count;
     for (i = 0; i < gain_set_count; i++) {
       all_band_gain_count += pstr_drc_coefficients_uni_drc->str_gain_set_params[i].band_count;
     }
     pstr_gain_enc->n_sequences = all_band_gain_count;
   } else {
     pstr_gain_enc->n_sequences = pstr_drc_coefficients_uni_drc_v1->gain_sequence_count;
   }
 
   if (pstr_gain_enc->n_sequences > IMPD_DRCMAX_NSEQ) {
     return IA_EXHEAACE_CONFIG_FATAL_DRC_PARAM_OUT_OF_RANGE;
   }
 
   if ((pstr_uni_drc_config_ext->drc_coefficients_uni_drc_v1_count > 0) &&
       (pstr_drc_coefficients_uni_drc_v1->drc_frame_size_present)) {
     pstr_gain_enc->drc_frame_size = pstr_drc_coefficients_uni_drc_v1->drc_frame_size;
   } else if ((pstr_uni_drc_config->drc_coefficients_uni_drc_count > 0) &&
              (pstr_drc_coefficients_uni_drc->drc_frame_size_present)) {
     pstr_gain_enc->drc_frame_size = pstr_drc_coefficients_uni_drc->drc_frame_size;
   } else {
     pstr_gain_enc->drc_frame_size = frame_size;
   }
 
   if (pstr_gain_enc->drc_frame_size > IMPD_DRCMAX_FRAMESIZE) {
     return IA_EXHEAACE_CONFIG_FATAL_DRC_PARAM_OUT_OF_RANGE;
   }
   if (pstr_gain_enc->drc_frame_size < 1) {
     return IA_EXHEAACE_CONFIG_FATAL_DRC_INVALID_CONFIG;
   }
 
   if (!pstr_uni_drc_config->sample_rate_present) {
     pstr_gain_enc->sample_rate = sample_rate;
   } else {
     pstr_gain_enc->sample_rate = pstr_uni_drc_config->sample_rate;
   }
 
   pstr_gain_enc->domain = domain;
   pstr_gain_enc->delay_mode = delay_mode;
   pstr_gain_enc->delta_tmin_default = impd_drc_get_delta_t_min(pstr_gain_enc->sample_rate);
 
   if ((pstr_uni_drc_config_ext->drc_coefficients_uni_drc_v1_count > 0) &&
       (pstr_drc_coefficients_uni_drc_v1->str_gain_set_params[0].time_delta_min_present == 1)) {
     pstr_gain_enc->delta_tmin =
         pstr_drc_coefficients_uni_drc_v1->str_gain_set_params[0].delta_tmin;
   } else if ((pstr_uni_drc_config->drc_coefficients_uni_drc_count > 0) &&
              (pstr_drc_coefficients_uni_drc->str_gain_set_params[0].time_delta_min_present ==
               1)) {
     pstr_gain_enc->delta_tmin = pstr_drc_coefficients_uni_drc->str_gain_set_params[0].delta_tmin;
   } else {
     pstr_gain_enc->delta_tmin = impd_drc_get_delta_t_min(pstr_gain_enc->sample_rate);
   }
 
   num_gain_values_max = pstr_gain_enc->drc_frame_size / pstr_gain_enc->delta_tmin;
   pstr_gain_enc->base_ch_count = pstr_uni_drc_config->str_channel_layout.base_ch_count;
 
   memcpy(&pstr_gain_enc->str_uni_drc_config, pstr_uni_drc_config,
          sizeof(ia_drc_uni_drc_config_struct));
   memcpy(&pstr_gain_enc->str_loudness_info_set, pstr_loudness_info_set,
          sizeof(ia_drc_loudness_info_set_struct));
 
   k = 0;
   if (pstr_uni_drc_config->drc_coefficients_uni_drc_count > 0) {
     for (j = 0; j < pstr_drc_coefficients_uni_drc->gain_set_count; j++) {
       ch_idx = 0;
       found_ch_idx = 0;
       ia_drc_gain_set_params_struct *pstr_gain_set_params =
           &pstr_drc_coefficients_uni_drc->str_gain_set_params[j];
 
       for (m = 0; m < pstr_uni_drc_config->drc_instructions_uni_drc_count; m++) {
         if (pstr_uni_drc_config->str_drc_instructions_uni_drc[m].drc_location ==
             pstr_drc_coefficients_uni_drc->drc_location) {
           for (ch = 0; ch < MAX_CHANNEL_COUNT; ch++) {
             if (pstr_uni_drc_config->str_drc_instructions_uni_drc[m].gain_set_index[ch] == j) {
               ch_idx = ch;
               found_ch_idx = 1;
               break;
             }
           }
         }
         if (found_ch_idx) {
           break;
         }
       }
       if (ch_idx >= (UWORD32)pstr_gain_enc->base_ch_count) {
         return IA_EXHEAACE_INIT_FATAL_DRC_INVALID_CHANNEL_INDEX;
       }
       if (pstr_gain_set_params->band_count > 1) {
         impd_drc_util_stft_read_gain_config(pstr_gain_enc->str_drc_stft_gain_handle[0][j],
                                             pstr_gain_set_params->band_count,
                                             pstr_gain_set_params);
 
         for (l = 0; l < pstr_gain_set_params->band_count; l++) {
           err_code = impd_drc_stft_drc_gain_calc_init(pstr_gain_enc, 0, j, l);
-          if (err_code & IA_FATAL_ERROR) {
+          if (err_code) {
             return err_code;
           }
           pstr_gain_enc->str_drc_stft_gain_handle[0][j][l].ch_idx = ch_idx;
           pstr_gain_enc->str_drc_stft_gain_handle[0][j][l].is_valid = 1;
         }
       } else if (pstr_gain_set_params->band_count == 1) {
         impd_drc_util_td_read_gain_config(&pstr_gain_enc->str_drc_compand[0][j],
                                           pstr_gain_set_params);
 
         pstr_gain_enc->str_drc_compand[0][j].initial_volume = 0.0f;
 
         err_code = impd_drc_td_drc_gain_calc_init(pstr_gain_enc, 0, j);
         if (err_code & IA_FATAL_ERROR) {
           return err_code;
         }
         pstr_gain_enc->str_drc_compand[0][j].ch_idx = ch_idx;
         pstr_gain_enc->str_drc_compand[0][j].is_valid = 1;
       }
 
       for (l = 0; l < pstr_gain_set_params->band_count; l++) {
         pstr_gain_enc->str_drc_gain_seq_buf[k].str_drc_group.n_gain_values = 1;
         pstr_gain_enc->str_drc_gain_seq_buf[k].str_gain_set_params =
             pstr_drc_coefficients_uni_drc->str_gain_set_params[j];
         k++;
       }
     }
   }
   if (pstr_uni_drc_config_ext->drc_coefficients_uni_drc_v1_count > 0) {
     for (i = 0; i < pstr_gain_enc->n_sequences; i++) {
       params_found = 0;
 
       for (j = 0; j < pstr_drc_coefficients_uni_drc_v1->gain_set_count; j++) {
         for (l = 0; l < pstr_drc_coefficients_uni_drc_v1->str_gain_set_params[j].band_count;
              l++) {
           if (i == pstr_drc_coefficients_uni_drc_v1->str_gain_set_params[j]
                        .gain_params[l]
                        .gain_sequence_index) {
             pstr_gain_enc->str_drc_gain_seq_buf[i].str_drc_group.n_gain_values = 1;
             pstr_gain_enc->str_drc_gain_seq_buf[i].str_gain_set_params =
                 pstr_drc_coefficients_uni_drc_v1->str_gain_set_params[j];
             params_found = 1;
           }
           if (params_found == 1) {
             break;
           }
         }
         if (params_found == 1) {
           break;
         }
       }
     }
   }
 
   impd_drc_generate_delta_time_code_table(num_gain_values_max,
                                           pstr_gain_enc->str_delta_time_code_table);
 
   for (i = num_gain_values_max - 1; i >= 0; i--) {
     pstr_gain_enc->delta_time_quant_table[i] = pstr_gain_enc->delta_tmin * (i + 1);
   }
 
   return err_code;
 }
diff --git a/encoder/drc_src/impd_drc_gain_calculator.c b/encoder/drc_src/impd_drc_gain_calculator.c
index 24514c3..2a3400e 100644
--- a/encoder/drc_src/impd_drc_gain_calculator.c
+++ b/encoder/drc_src/impd_drc_gain_calculator.c
@@ -1,47 +1,48 @@
 /******************************************************************************
  *                                                                            *
  * Copyright (C) 2023 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
  */
 #include <math.h>
+#include <float.h>
 #include "ixheaac_type_def.h"
 #include "ixheaac_error_standards.h"
 #include "ixheaace_error_codes.h"
 
 #include "iusace_cnst.h"
 #include "iusace_block_switch_const.h"
 #include "iusace_bitbuffer.h"
 
 #include "impd_drc_common_enc.h"
 #include "impd_drc_uni_drc.h"
 #include "impd_drc_tables.h"
 #include "impd_drc_api.h"
 
 #include "iusace_tns_usac.h"
 #include "iusace_psy_mod.h"
 #include "ixheaace_sbr_header.h"
 #include "ixheaace_config.h"
 #include "iusace_config.h"
 
 #include "iusace_rom.h"
 #include "iusace_fft.h"
 
 #include "impd_drc_uni_drc_eq.h"
 #include "impd_drc_uni_drc_filter_bank.h"
 #include "impd_drc_gain_enc.h"
 #include "impd_drc_struct_def.h"
 #include "impd_drc_enc.h"
@@ -323,160 +324,190 @@ VOID impd_drc_stft_drc_gain_calc_process(ia_drc_gain_enc_struct *pstr_drc_gain_e
 IA_ERRORCODE impd_drc_stft_drc_gain_calc_init(ia_drc_gain_enc_struct *pstr_drc_gain_enc,
                                               WORD32 drc_coefficients_uni_drc_idx,
                                               WORD32 gain_set_idx, WORD32 band_idx) {
   ULOOPIDX i, j;
   UWORD32 num_points;
   FLOAT32 width_e;
   FLOAT64 g1, g2;
   FLOAT64 x, y, cx, cy, r;
   FLOAT64 inp_1, inp_2, out_1, out_2, theta, len;
   ia_drc_compand_chan_param_struct *pstr_chan_param;
   ia_drc_stft_gain_calc_struct *pstr_drc_stft_gain_handle;
 
   if ((drc_coefficients_uni_drc_idx >= MAX_DRC_COEFF_COUNT) ||
       (gain_set_idx >= GAIN_SET_COUNT_MAX) || (band_idx >= MAX_BAND_COUNT)) {
     return IA_EXHEAACE_CONFIG_FATAL_DRC_COMPAND_FAILED;
   }
 
   pstr_drc_stft_gain_handle =
       &pstr_drc_gain_enc
            ->str_drc_stft_gain_handle[drc_coefficients_uni_drc_idx][gain_set_idx][band_idx];
 
   width_e = (FLOAT32)(pstr_drc_stft_gain_handle->width_db * M_LN10_DIV_20);
 
   pstr_drc_stft_gain_handle->nb_segments = (pstr_drc_stft_gain_handle->nb_points + 4) * 2;
 
   for (i = 0; i < pstr_drc_stft_gain_handle->nb_points; i++) {
     if (i && pstr_drc_stft_gain_handle->str_segment[2 * ((i - 1) + 1)].x >
                  pstr_drc_stft_gain_handle->str_segment[2 * (i + 1)].x) {
       return IA_EXHEAACE_CONFIG_FATAL_DRC_COMPAND_FAILED;
     }
     pstr_drc_stft_gain_handle->str_segment[2 * (i + 1)].y -=
         pstr_drc_stft_gain_handle->str_segment[2 * (i + 1)].x;
   }
   num_points = pstr_drc_stft_gain_handle->nb_points;
 
   if (num_points == 0 || pstr_drc_stft_gain_handle->str_segment[2 * ((num_points - 1) + 1)].x) {
     num_points++;
   }
 
   pstr_drc_stft_gain_handle->str_segment[0].x =
       pstr_drc_stft_gain_handle->str_segment[2].x - pstr_drc_stft_gain_handle->width_db;
   pstr_drc_stft_gain_handle->str_segment[0].y = pstr_drc_stft_gain_handle->str_segment[2].y;
   num_points++;
 
   for (i = 2; i < num_points; i++) {
     g1 = (pstr_drc_stft_gain_handle->str_segment[2 * (i - 1)].y -
           pstr_drc_stft_gain_handle->str_segment[2 * (i - 2)].y) *
          (pstr_drc_stft_gain_handle->str_segment[2 * i].x -
           pstr_drc_stft_gain_handle->str_segment[2 * (i - 1)].x);
     g2 = (pstr_drc_stft_gain_handle->str_segment[2 * i].y -
           pstr_drc_stft_gain_handle->str_segment[2 * (i - 1)].y) *
          (pstr_drc_stft_gain_handle->str_segment[2 * (i - 1)].x -
           pstr_drc_stft_gain_handle->str_segment[2 * (i - 2)].x);
 
     if (fabs(g1 - g2)) {
       continue;
     }
     num_points--;
 
     for (j = --i; j < num_points; j++) {
       pstr_drc_stft_gain_handle->str_segment[2 * j] =
           pstr_drc_stft_gain_handle->str_segment[2 * (j + 1)];
     }
   }
 
   for (i = 0; i < pstr_drc_stft_gain_handle->nb_segments; i += 2) {
     pstr_drc_stft_gain_handle->str_segment[i].y += pstr_drc_stft_gain_handle->gain_db;
     pstr_drc_stft_gain_handle->str_segment[i].x *= M_LN10_DIV_20;
     pstr_drc_stft_gain_handle->str_segment[i].y *= M_LN10_DIV_20;
   }
 
   for (i = 4; i < pstr_drc_stft_gain_handle->nb_segments; i += 2) {
+    FLOAT64 denominator;
+    FLOAT64 numerator;
+
+    denominator = pstr_drc_stft_gain_handle->str_segment[i - 2].x -
+                  pstr_drc_stft_gain_handle->str_segment[i - 4].x;
+    numerator = pstr_drc_stft_gain_handle->str_segment[i - 2].y -
+                pstr_drc_stft_gain_handle->str_segment[i - 4].y;
+    len = hypot(denominator , numerator);
+    if (len == 0) {
+      return IA_EXHEAACE_EXE_NONFATAL_USAC_INVALID_GAIN_POINTS;
+    }
+    if (fabs(denominator) < FLT_EPSILON) {
+      if (denominator < 0)
+        denominator = -FLT_EPSILON;
+      else
+        denominator = FLT_EPSILON;
+    }
     pstr_drc_stft_gain_handle->str_segment[i - 4].a = 0;
-    pstr_drc_stft_gain_handle->str_segment[i - 4].b =
-        (pstr_drc_stft_gain_handle->str_segment[i - 2].y -
-         pstr_drc_stft_gain_handle->str_segment[i - 4].y) /
-        (pstr_drc_stft_gain_handle->str_segment[i - 2].x -
-         pstr_drc_stft_gain_handle->str_segment[i - 4].x);
-
+    pstr_drc_stft_gain_handle->str_segment[i - 4].b = numerator / denominator;
+
+    denominator = pstr_drc_stft_gain_handle->str_segment[i].x -
+                  pstr_drc_stft_gain_handle->str_segment[i - 2].x;
+    numerator = pstr_drc_stft_gain_handle->str_segment[i].y -
+                pstr_drc_stft_gain_handle->str_segment[i - 2].y;
+    len = hypot(denominator, numerator);
+    if (len == 0) {
+      return IA_EXHEAACE_EXE_NONFATAL_USAC_INVALID_GAIN_POINTS;
+    }
+    if (fabs(denominator) < FLT_EPSILON) {
+      if (denominator < 0)
+        denominator = -FLT_EPSILON;
+      else
+        denominator = FLT_EPSILON;
+    }
     pstr_drc_stft_gain_handle->str_segment[i - 2].a = 0;
-    pstr_drc_stft_gain_handle->str_segment[i - 2].b =
-        (pstr_drc_stft_gain_handle->str_segment[i].y -
-         pstr_drc_stft_gain_handle->str_segment[i - 2].y) /
-        (pstr_drc_stft_gain_handle->str_segment[i].x -
-         pstr_drc_stft_gain_handle->str_segment[i - 2].x);
-
-    theta = atan2(pstr_drc_stft_gain_handle->str_segment[i - 2].y -
-                      pstr_drc_stft_gain_handle->str_segment[i - 4].y,
-                  pstr_drc_stft_gain_handle->str_segment[i - 2].x -
-                      pstr_drc_stft_gain_handle->str_segment[i - 4].x);
-    len = hypot(pstr_drc_stft_gain_handle->str_segment[i - 2].x -
-                    pstr_drc_stft_gain_handle->str_segment[i - 4].x,
-                pstr_drc_stft_gain_handle->str_segment[i - 2].y -
-                    pstr_drc_stft_gain_handle->str_segment[i - 4].y);
-    r = MIN(width_e / (2.0f * cos(theta)), len);
+    pstr_drc_stft_gain_handle->str_segment[i - 2].b = numerator / denominator;
+
+
+    denominator = pstr_drc_stft_gain_handle->str_segment[i - 2].x -
+                  pstr_drc_stft_gain_handle->str_segment[i - 4].x;
+    numerator = pstr_drc_stft_gain_handle->str_segment[i - 2].y -
+                pstr_drc_stft_gain_handle->str_segment[i - 4].y;
+    if (fabs(denominator) < FLT_EPSILON) {
+      if (denominator < 0)
+        denominator = -FLT_EPSILON;
+      else
+        denominator = FLT_EPSILON;
+    }
+    theta = atan2(numerator, denominator);
+    len = hypot(denominator, numerator);
+    r = MIN(width_e / (2.0f * cos(theta)), len / 2);
+
     pstr_drc_stft_gain_handle->str_segment[i - 3].x =
         pstr_drc_stft_gain_handle->str_segment[i - 2].x - r * cos(theta);
     pstr_drc_stft_gain_handle->str_segment[i - 3].y =
         pstr_drc_stft_gain_handle->str_segment[i - 2].y - r * sin(theta);
 
     theta = atan2(pstr_drc_stft_gain_handle->str_segment[i].y -
                       pstr_drc_stft_gain_handle->str_segment[i - 2].y,
                   pstr_drc_stft_gain_handle->str_segment[i].x -
                       pstr_drc_stft_gain_handle->str_segment[i - 2].x);
     len = hypot(pstr_drc_stft_gain_handle->str_segment[i].x -
                     pstr_drc_stft_gain_handle->str_segment[i - 2].x,
                 pstr_drc_stft_gain_handle->str_segment[i].y -
                     pstr_drc_stft_gain_handle->str_segment[i - 2].y);
+
     r = MIN(width_e / (2.0f * cos(theta)), len / 2);
     x = pstr_drc_stft_gain_handle->str_segment[i - 2].x + r * cos(theta);
     y = pstr_drc_stft_gain_handle->str_segment[i - 2].y + r * sin(theta);
 
     cx = (pstr_drc_stft_gain_handle->str_segment[i - 3].x +
           pstr_drc_stft_gain_handle->str_segment[i - 2].x + x) /
          3;
     cy = (pstr_drc_stft_gain_handle->str_segment[i - 3].y +
           pstr_drc_stft_gain_handle->str_segment[i - 2].y + y) /
          3;
 
     pstr_drc_stft_gain_handle->str_segment[i - 2].x = x;
     pstr_drc_stft_gain_handle->str_segment[i - 2].y = y;
 
     inp_1 = cx - pstr_drc_stft_gain_handle->str_segment[i - 3].x;
     out_1 = cy - pstr_drc_stft_gain_handle->str_segment[i - 3].y;
     inp_2 = pstr_drc_stft_gain_handle->str_segment[i - 2].x -
             pstr_drc_stft_gain_handle->str_segment[i - 3].x;
     out_2 = pstr_drc_stft_gain_handle->str_segment[i - 2].y -
             pstr_drc_stft_gain_handle->str_segment[i - 3].y;
     pstr_drc_stft_gain_handle->str_segment[i - 3].a =
         (out_2 / inp_2 - out_1 / inp_1) / (inp_2 - inp_1);
     pstr_drc_stft_gain_handle->str_segment[i - 3].b =
         out_1 / inp_1 - pstr_drc_stft_gain_handle->str_segment[i - 3].a * inp_1;
   }
   pstr_drc_stft_gain_handle->str_segment[i - 3].x = 0;
   pstr_drc_stft_gain_handle->str_segment[i - 3].y =
       pstr_drc_stft_gain_handle->str_segment[i - 2].y;
 
   pstr_drc_stft_gain_handle->in_min_db =
       (FLOAT32)(pstr_drc_stft_gain_handle->str_segment[1].x * M_LOG10_E * 20.0f);
   pstr_drc_stft_gain_handle->out_min_db =
       (FLOAT32)(pstr_drc_stft_gain_handle->str_segment[1].y * M_LOG10_E * 20.0f);
 
   pstr_chan_param = &pstr_drc_stft_gain_handle->str_channel_param;
 
   pstr_chan_param->volume = EXP10(pstr_drc_stft_gain_handle->initial_volume / 20.0f);
 
   for (i = 0; i < STFT256_HOP_SIZE; i++) {
     pstr_drc_stft_gain_handle->yl_z1[i] = 0.0f;
   }
 
   pstr_drc_stft_gain_handle->alpha_a =
       expf(-1.0f / ((pstr_drc_stft_gain_handle->attack_ms / (FLOAT32)STFT256_HOP_SIZE) *
                     (FLOAT32)pstr_drc_gain_enc->sample_rate * 0.001f));
 
   pstr_drc_stft_gain_handle->alpha_r =
       expf(-1.0f / ((pstr_drc_stft_gain_handle->release_ms / (FLOAT32)STFT256_HOP_SIZE) *
                     (FLOAT32)pstr_drc_gain_enc->sample_rate * 0.001f));
 
   return IA_NO_ERROR;
 }
diff --git a/encoder/iusace_enc_main.c b/encoder/iusace_enc_main.c
index 492d300..503f9c9 100644
--- a/encoder/iusace_enc_main.c
+++ b/encoder/iusace_enc_main.c
@@ -507,310 +507,315 @@ WORD32 iusace_limitbitrate(WORD32 core_sample_rate, WORD32 frame_len, WORD32 num
 IA_ERRORCODE iusace_enc_init(ia_usac_encoder_config_struct *ptr_usac_config,
                              ixheaace_audio_specific_config_struct *pstr_asc,
                              ia_usac_data_struct *pstr_state) {
   WORD32 err_code = 0;
   WORD32 i, j, k, idx, i_ch;
   UWORD32 elem_idx = 0;
   ia_usac_data_struct *usac_data = (pstr_state);
   ixheaace_audio_specific_config_struct *p_audio_specific_config = pstr_asc;
   ia_usac_config_struct *pstr_asc_usac_config = &(p_audio_specific_config->str_usac_config);
   WORD32 nbuff = 2048;
   usac_data->usac_independency_flag_count = 0;
   usac_data->usac_independency_flag_interval = 25;
   for (j = 0; j < MAX_TIME_CHANNELS; j++) {
     memset(usac_data->overlap_buf[j], 0, nbuff * sizeof(FLOAT64 *));
 
     usac_data->str_ms_info[j].ms_mask = 0;
     for (i = 0; i < MAX_SHORT_WINDOWS; i++) {
       for (k = 0; k < MAX_SFB_LONG; k++) {
         usac_data->str_ms_info[j].ms_used[i][k] = 0;
       }
     }
   }
 
   iusace_scratch_mem_init(usac_data, ptr_usac_config->channels,
                           ptr_usac_config->core_sample_rate);
 
   for (i = 0; i < MAX_TIME_CHANNELS; i++) {
     if (ptr_usac_config->cmplx_pred_flag) {
       usac_data->str_ms_info[i].ms_mask = 3;
     }
     usac_data->ptr_dmx_re_save[i] = &usac_data->arr_dmx_save_float[i][0];
     usac_data->ptr_dmx_im[i] = &usac_data->arr_dmx_im[i][0];
   }
 
   pstr_asc_usac_config->num_elements = 0;
   pstr_asc_usac_config->usac_cfg_ext_present = 0;
   pstr_asc_usac_config->num_config_extensions = 0;
 
   if (ptr_usac_config->channels > 0) {
     if (ptr_usac_config->channels < 7) {
       p_audio_specific_config->channel_configuration = ptr_usac_config->channels;
     }
   }
 
   // DRC Config
   if (ptr_usac_config->use_drc_element) {
     ptr_usac_config->str_drc_cfg.str_uni_drc_config.str_channel_layout.base_ch_count =
         ptr_usac_config->channels;
 
     memset(&usac_data->str_drc_state, 0, sizeof(ia_drc_enc_state));
 
     err_code = impd_drc_enc_init(&usac_data->str_drc_state, pstr_state->str_scratch.drc_scratch,
                                  &ptr_usac_config->str_drc_cfg);
+    if (err_code == IA_EXHEAACE_EXE_NONFATAL_USAC_INVALID_GAIN_POINTS) {
+      ptr_usac_config->use_drc_element = 0;
+    }
     if (err_code & IA_FATAL_ERROR) {
       return err_code;
     }
 
-    ia_usac_enc_element_config_struct *pstr_usac_elem_config =
+    if (ptr_usac_config->use_drc_element) {
+      ia_usac_enc_element_config_struct *pstr_usac_elem_config =
         &(pstr_asc_usac_config->str_usac_element_config[pstr_asc_usac_config->num_elements]);
-    pstr_asc_usac_config->usac_element_type[pstr_asc_usac_config->num_elements] = ID_USAC_EXT;
-    pstr_usac_elem_config->usac_ext_ele_type = ID_EXT_ELE_UNI_DRC;
-    pstr_usac_elem_config->usac_ext_ele_dflt_len_present = 0;
-    pstr_usac_elem_config->usac_ext_ele_payload_present = 0;
-    pstr_usac_elem_config->drc_config_data = usac_data->str_drc_state.bit_buf_base_cfg;
-    pstr_usac_elem_config->usac_ext_ele_cfg_len =
+      pstr_asc_usac_config->usac_element_type[pstr_asc_usac_config->num_elements] = ID_USAC_EXT;
+      pstr_usac_elem_config->usac_ext_ele_type = ID_EXT_ELE_UNI_DRC;
+      pstr_usac_elem_config->usac_ext_ele_dflt_len_present = 0;
+      pstr_usac_elem_config->usac_ext_ele_payload_present = 0;
+      pstr_usac_elem_config->drc_config_data = usac_data->str_drc_state.bit_buf_base_cfg;
+      pstr_usac_elem_config->usac_ext_ele_cfg_len =
         (usac_data->str_drc_state.drc_config_data_size_bit + 7) >> 3;
-    pstr_asc_usac_config->num_elements++;
+      pstr_asc_usac_config->num_elements++;
+    }
   }
   if (ptr_usac_config->use_drc_element)  // For Loudness
   {
     pstr_asc_usac_config->usac_config_ext_type[pstr_asc_usac_config->num_config_extensions] =
         ID_CONFIG_EXT_LOUDNESS_INFO;
     pstr_asc_usac_config->usac_config_ext_len[pstr_asc_usac_config->num_config_extensions] =
         (usac_data->str_drc_state.drc_config_ext_data_size_bit + 7) >> 3;
     pstr_asc_usac_config->usac_config_ext_buf[pstr_asc_usac_config->num_config_extensions] =
         usac_data->str_drc_state.bit_buf_base_cfg_ext;
     pstr_asc_usac_config->num_config_extensions++;
     pstr_asc_usac_config->usac_cfg_ext_present = 1;
   }
 
   p_audio_specific_config->sampling_frequency = ptr_usac_config->native_sample_rate;
   p_audio_specific_config->num_audio_channels = ptr_usac_config->channels;
   elem_idx = pstr_asc_usac_config->num_elements;
   ptr_usac_config->num_ext_elements = elem_idx;
   pstr_asc_usac_config->num_ext_elements = elem_idx;
   i = elem_idx;
 
   if (ptr_usac_config->channels != 0) {
     ptr_usac_config->num_elements = iusace_get_num_elements(ptr_usac_config->channels);
     pstr_asc_usac_config->num_elements += ptr_usac_config->num_elements;
 
     for (; i < (WORD32)pstr_asc_usac_config->num_elements; i++) {
       pstr_asc_usac_config->usac_element_type[i] = iusace_get_element_type(
           (i - ptr_usac_config->num_ext_elements), ptr_usac_config->channels);
     }
   }
 
   WORD32 count = ptr_usac_config->num_elements;
   ptr_usac_config->num_elements = pstr_asc_usac_config->num_elements;
   iusace_qc_create(&usac_data->str_qc_main);
 
   if (count > 2) {
     WORD32 num_mono = 0, num_stereo = 0, num_lfe = 0;
 
     for (WORD8 ch_idx = 0; ch_idx < count; ch_idx++) {
       switch (
           pstr_asc_usac_config->usac_element_type[ch_idx + ptr_usac_config->num_ext_elements]) {
         case ID_USAC_SCE:
           num_mono++;
           break;
         case ID_USAC_CPE:
           num_stereo++;
           break;
         case ID_USAC_EXT:
           break;
         default:
           return -1;
       }
     }
 
     WORD32 bitrate_per_stereo = (WORD32)((ptr_usac_config->basic_bitrate - (num_lfe)*8000) /
                                          (num_mono * 0.625 + num_stereo));
     WORD32 bitrate_per_mono = (WORD32)(0.625 * bitrate_per_stereo);
 
     for (WORD8 ch_idx = 0; ch_idx < count; ch_idx++) {
       switch (
           pstr_asc_usac_config->usac_element_type[ch_idx + ptr_usac_config->num_ext_elements]) {
         case ID_USAC_SCE:
           usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate = bitrate_per_mono;
           break;
         case ID_USAC_CPE:
           usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate = bitrate_per_stereo;
           break;
         case ID_USAC_EXT:
           break;
         default:
           return -1;
       }
 
       usac_data->str_qc_main.str_qc_data[ch_idx].num_ch = 1;
       if (ID_USAC_CPE ==
           pstr_asc_usac_config->usac_element_type[ch_idx + ptr_usac_config->num_ext_elements]) {
         usac_data->str_qc_main.str_qc_data[ch_idx].num_ch = 2;
       }
 
       usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate =
           MIN(360000 * usac_data->str_qc_main.str_qc_data[ch_idx].num_ch,
               usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate);
       usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate =
           MAX(8000 * usac_data->str_qc_main.str_qc_data[ch_idx].num_ch,
               usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate);
 
       usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate =
           iusace_limitbitrate(ptr_usac_config->core_sample_rate, 512,
                               usac_data->str_qc_main.str_qc_data[ch_idx].num_ch,
                               usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate);
 
       usac_data->str_qc_main.str_qc_data[ch_idx].avg_bits =
           (usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate * ptr_usac_config->ccfl) /
           ptr_usac_config->core_sample_rate;
     }
   } else {
     for (WORD8 ch_idx = 0; ch_idx < count; ch_idx++) {
       usac_data->str_qc_main.str_qc_data[ch_idx].num_ch = (WORD8)ptr_usac_config->channels;
       usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate = ptr_usac_config->basic_bitrate;
       usac_data->str_qc_main.str_qc_data[ch_idx].avg_bits =
           (usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate * ptr_usac_config->ccfl) /
           ptr_usac_config->core_sample_rate;
     }
   }
 
   for (i_ch = 0;
        i_ch < (WORD32)(ptr_usac_config->num_elements - ptr_usac_config->num_ext_elements);
        i_ch++) {
     iusace_bw_init(ptr_usac_config, p_audio_specific_config, i_ch);
 
     usac_data->noise_filling[i_ch] = ptr_usac_config->flag_noiseFilling;
   }
 
   memset(&usac_data->str_psy_mod.str_psy_out_data, 0,
          sizeof(ia_psy_mod_out_data_struct) * MAX_TIME_CHANNELS);
 
   i_ch = 0;
   for (UWORD32 ch_idx = 0;
        ch_idx < pstr_asc_usac_config->num_elements - ptr_usac_config->num_ext_elements;
        ch_idx++) {
     iusace_psy_mod_init(
         &usac_data->str_psy_mod, (ptr_usac_config->core_sample_rate),
         usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate, ptr_usac_config->bw_limit[ch_idx],
         usac_data->str_qc_main.str_qc_data[ch_idx].num_ch, i_ch, ch_idx, ptr_usac_config->ccfl);
     i_ch += usac_data->str_qc_main.str_qc_data[ch_idx].num_ch;
   }
 
   for (; elem_idx < pstr_asc_usac_config->num_elements; elem_idx++) {
     idx = elem_idx - pstr_asc_usac_config->num_ext_elements;
     pstr_asc_usac_config->str_usac_element_config[idx].noise_filling =
         usac_data->noise_filling[idx];
     usac_data->channel_elem_type[idx] = pstr_asc_usac_config->usac_element_type[elem_idx];
   }
 
   if (ptr_usac_config->use_fill_element) {
     ia_usac_enc_element_config_struct *pstr_usac_elem_config =
         &(pstr_asc_usac_config->str_usac_element_config[pstr_asc_usac_config->num_elements]);
     pstr_asc_usac_config->usac_element_type[pstr_asc_usac_config->num_elements] = ID_USAC_EXT;
     pstr_usac_elem_config->usac_ext_ele_type = ID_EXT_ELE_FILL;
     pstr_usac_elem_config->usac_ext_ele_cfg_len = 0;
     pstr_usac_elem_config->usac_ext_ele_dflt_len_present = 0;
     pstr_usac_elem_config->usac_ext_ele_payload_present = 0;
     pstr_asc_usac_config->num_elements++;
   }
 
   if (ptr_usac_config->codec_mode == USAC_SWITCHED) {
     iusace_init_classification(&usac_data->str_sig_class_data);
   }
 
   i_ch = 0;
   for (UWORD32 ch_idx = 0;
        ch_idx < pstr_asc_usac_config->num_elements - ptr_usac_config->num_ext_elements;
        ch_idx++) {
     for (idx = 0; idx < usac_data->str_qc_main.str_qc_data[ch_idx].num_ch; idx++, i_ch++) {
       iusace_init_block_switching(&usac_data->block_switch_ctrl[i_ch],
                                   usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate,
                                   usac_data->str_qc_main.str_qc_data[ch_idx].num_ch);
     }
   }
 
   pstr_asc_usac_config->str_usac_element_config[elem_idx].stereo_config_index = 0;
 
   for (i_ch = 0; i_ch < ptr_usac_config->channels; i_ch++) {
     ptr_usac_config->window_sequence[i_ch] = ONLY_LONG_SEQUENCE;
     ptr_usac_config->window_shape_prev[i_ch] = WIN_SEL_0;
   }
 
   for (i_ch = 0; i_ch < ptr_usac_config->channels; i_ch++) {
     memset(usac_data->td_in_buf[i_ch], 0,
            (FRAME_LEN_LONG + LEN_NEXT_HIGH_RATE) * sizeof(usac_data->td_in_buf[i_ch][0]));
   }
 
   usac_data->max_bitreservoir_bits = MAX_CHANNEL_BITS * ptr_usac_config->channels;
   usac_data->available_bitreservoir_bits = usac_data->max_bitreservoir_bits;
   usac_data->available_bitreservoir_bits -=
       (ptr_usac_config->bit_rate * ptr_usac_config->ccfl) / ptr_usac_config->core_sample_rate;
 
   if (usac_data->available_bitreservoir_bits < 0) {
     return IA_EXHEAACE_INIT_FATAL_USAC_BITRES_SIZE_TOO_SMALL;
   }
   i_ch = 0;
   for (UWORD32 ch_idx = 0;
        ch_idx < pstr_asc_usac_config->num_elements - ptr_usac_config->num_ext_elements;
        ch_idx++) {
     for (idx = 0; idx < usac_data->str_qc_main.str_qc_data[ch_idx].num_ch; idx++, i_ch++) {
       usac_data->td_encoder[i_ch]->max_sfb_short =
           usac_data->str_psy_mod.str_psy_short_config[ch_idx].sfb_count;
       if (ptr_usac_config->tns_select == 0) {
         usac_data->pstr_tns_info[i_ch] = NULL;
       } else {
         usac_data->pstr_tns_info[i_ch]->sfb_offset_table_short =
             usac_data->str_psy_mod.str_psy_short_config[ch_idx].sfb_offset;
         usac_data->pstr_tns_info[i_ch]->sfb_offset_table_long =
             usac_data->str_psy_mod.str_psy_long_config[ch_idx].sfb_offset;
         usac_data->pstr_tns_info[i_ch]->max_sfb_short =
             usac_data->str_psy_mod.str_psy_short_config[ch_idx].sfb_count;
         usac_data->pstr_tns_info[i_ch]->max_sfb_long =
             usac_data->str_psy_mod.str_psy_long_config[ch_idx].sfb_count;
 
         if (iusace_tns_init(ptr_usac_config->core_sample_rate,
                             usac_data->str_qc_main.str_qc_data[ch_idx].ch_bitrate /
                                 usac_data->str_qc_main.str_qc_data[ch_idx].num_ch,
                             usac_data->pstr_tns_info[i_ch],
                             usac_data->str_qc_main.str_qc_data[ch_idx].num_ch))
           return -1;
       }
     }
   }
 
   for (i = 0; i < MAX_TIME_CHANNELS; i++) usac_data->str_quant_info[i].reset = 1;
 
   if (ptr_usac_config->codec_mode == USAC_SWITCHED ||
       ptr_usac_config->codec_mode == USAC_ONLY_TD) {
     for (i_ch = 0; i_ch < ptr_usac_config->channels; i_ch++) {
       if ((ptr_usac_config->core_sample_rate) < SR_MIN ||
           (ptr_usac_config->core_sample_rate) > SR_MAX) {
         return IA_EXHEAACE_CONFIG_FATAL_USAC_SAMP_FREQ;
       } else {
         usac_data->td_encoder[i_ch]->fscale = ptr_usac_config->core_sample_rate;
 
         iusace_init_td_data(usac_data->td_encoder[i_ch], ptr_usac_config->ccfl);
       }
 
       usac_data->td_bitrate[i_ch] = ptr_usac_config->bit_rate;
       usac_data->td_bitrate[i_ch] /= ptr_usac_config->channels;
       iusace_config_acelp_core_mode(usac_data->td_encoder[i_ch],
                                     ptr_usac_config->core_sample_rate,
                                     usac_data->td_bitrate[i_ch]);
 
       usac_data->acelp_core_mode[i_ch] = (usac_data->td_encoder[i_ch])->acelp_core_mode;
     }
   } else {
     usac_data->acelp_core_mode[0] = 0;
   }
 
   for (UWORD32 ch = 0;
        ch < pstr_asc_usac_config->num_elements - ptr_usac_config->num_ext_elements; ch++) {
     iusace_qc_init(&usac_data->str_qc_main.str_qc_data[ch], MAX_CHANNEL_BITS,
                    ptr_usac_config->core_sample_rate, ptr_usac_config->bw_limit[ch],
                    usac_data->str_qc_main.str_qc_data[ch].num_ch, ptr_usac_config->ccfl);
   }
 
   return err_code;
 }
diff --git a/encoder/ixheaace_api.c b/encoder/ixheaace_api.c
index 18d19ff..2845511 100644
--- a/encoder/ixheaace_api.c
+++ b/encoder/ixheaace_api.c
@@ -1662,295 +1662,295 @@ static IA_ERRORCODE ixheaace_alloc_and_assign_mem(ixheaace_api_struct *pstr_api_
     if ((i_idx == IA_MEMTYPE_SCRATCH) && pstr_api_struct->usac_en) {
       pstr_api_struct->pstr_state->str_usac_enc_data.str_scratch.ptr_scratch_buf =
           (UWORD8 *)pstr_api_struct->pp_mem[IA_MEMTYPE_SCRATCH];
       memset(pstr_api_struct->pp_mem[IA_MEMTYPE_SCRATCH], 0,
              pstr_api_struct->pstr_mem_info[i_idx].ui_size);
     }
     if (i_idx == IA_ENHAACPLUSENC_INPUT_IDX) {
       ptr_out_cfg->ui_inp_buf_size = ptr_out_cfg->mem_info_table[i_idx].ui_size;
     }
     ptr_out_cfg->malloc_count++;
   }
   return err_code;
 }
 static IA_ERRORCODE ia_usac_enc_init(ixheaace_api_struct *pstr_api_struct, WORD32 ccfl_idx) {
   IA_ERRORCODE error = IA_NO_ERROR;
   WORD32 i = 0;
   ixheaace_config_struct *pstr_config = &pstr_api_struct->config[0];
   ixheaace_state_struct *pstr_enc_state = pstr_api_struct->pstr_state;
   ia_usac_data_struct *pstr_enc_data = &pstr_enc_state->str_usac_enc_data;
   ia_usac_encoder_config_struct *pstr_usac_config = &pstr_config->usac_config;
 
   pstr_usac_config->bit_rate = pstr_api_struct->config[0].aac_config.bit_rate;
 
   if ((pstr_usac_config->codec_mode == USAC_SWITCHED) ||
       (pstr_usac_config->codec_mode == USAC_ONLY_FD)) {
     pstr_usac_config->aac_allow_scalefacs = 1;
     if (pstr_usac_config->aac_scale_facs == 0) pstr_usac_config->aac_allow_scalefacs = 0;
   }
 
   if (pstr_usac_config->codec_mode == USAC_ONLY_TD) {
     for (i = 0; i < pstr_config->i_channels; i++) {
       pstr_enc_data->core_mode_prev[i] = CORE_MODE_FD;
       pstr_enc_data->core_mode[i] = CORE_MODE_TD;
     }
   } else {
     for (i = 0; i < pstr_config->i_channels; i++) {
       pstr_enc_data->core_mode_prev[i] = CORE_MODE_FD;
       pstr_enc_data->core_mode[i] = CORE_MODE_FD;
     }
   }
 
   if (1 == pstr_usac_config->use_drc_element) {
     pstr_enc_data->str_scratch.drc_scratch = pstr_enc_data->str_scratch.ptr_scratch_buf;
   }
   if (pstr_usac_config->sbr_enable) {
     WORD8 *sbr_scr_ptr = (WORD8 *)pstr_enc_data->str_scratch.ptr_scratch_buf;
     ixheaace_audio_specific_config_struct *pstr_asc = &pstr_enc_state->audio_specific_config;
     ixheaace_str_sbr_cfg spectral_band_replication_config;
     // SBR defaults
     iaace_config *pstr_sbr_config = &(pstr_api_struct->config[0].aac_config);
     WORD32 sbr_ratio = 0;
     WORD32 samples = pstr_usac_config->ccfl;
     // Set scratch buffers for SBR and resampler
     pstr_api_struct->pstr_state->temp_buff_sbr =
         (WORD8 *)pstr_enc_data->str_scratch.ptr_scratch_buf;
     pstr_api_struct->pstr_state->ptr_temp_buff_resamp =
         (WORD8 *)pstr_enc_data->str_scratch.ptr_scratch_buf + ixheaace_sbr_enc_scr_size();
 
     ixheaace_initialize_sbr_defaults(&spectral_band_replication_config);
     // Set SBR codec as USAC
     spectral_band_replication_config.sbr_codec = USAC_SBR;
     spectral_band_replication_config.sbr_pvc_active = pstr_usac_config->sbr_pvc_active;
     spectral_band_replication_config.sbr_harmonic = pstr_usac_config->sbr_harmonic;
     spectral_band_replication_config.hq_esbr = pstr_usac_config->hq_esbr;
     pstr_usac_config->core_sample_rate = pstr_usac_config->sample_rate / 2;
     switch (pstr_usac_config->ccfl_idx) {
       case SBR_4_1:
         spectral_band_replication_config.sbr_ratio_idx = USAC_SBR_RATIO_INDEX_4_1;
         spectral_band_replication_config.sbr_pvc_rate = USAC_SBR_DOWNSAMPLE_RATIO_4_1;
         pstr_usac_config->core_sample_rate = pstr_usac_config->sample_rate / 4;
         sbr_ratio = 4;
         samples *= 4;
         break;
       case SBR_8_3:
         spectral_band_replication_config.sbr_ratio_idx = USAC_SBR_RATIO_INDEX_8_3;
         spectral_band_replication_config.sbr_pvc_rate = USAC_SBR_DOWNSAMPLE_RATIO_2_1;
         sbr_ratio = 2;
         samples *= 8;
         samples /= 3;
         break;
       case SBR_2_1:
         spectral_band_replication_config.sbr_ratio_idx = USAC_SBR_RATIO_INDEX_2_1;
         spectral_band_replication_config.sbr_pvc_rate = USAC_SBR_DOWNSAMPLE_RATIO_2_1;
         sbr_ratio = 2;
         samples *= 2;
         break;
       default:
         spectral_band_replication_config.sbr_ratio_idx = USAC_SBR_RATIO_NO_SBR;
         spectral_band_replication_config.sbr_pvc_rate = 2;
         sbr_ratio = 2;
         break;
     }
     if (pstr_api_struct->pstr_state->mps_enable) {
       ixheaace_mps_212_memory_struct *pstr_mps_memory;
       pstr_mps_memory = pstr_api_struct->pstr_state->mps_pers_mem;
       ixheaace_mps_212_open(&pstr_api_struct->pstr_mps_212_enc, pstr_mps_memory);
       pstr_asc->str_aac_config.num_sac_cfg_bits = 0;
 
       error = ixheaace_mps_212_initialise(
           pstr_api_struct->pstr_mps_212_enc, AOT_USAC, pstr_usac_config->sample_rate,
           &pstr_sbr_config->bit_rate, sbr_ratio, (WORD32)samples, samples, 515 * sbr_ratio,
           (WORD8 *)pstr_api_struct->pstr_state->ptr_temp_buff_resamp);
       if (error) {
         return error;
       }
 
       pstr_asc->str_aac_config.num_sac_cfg_bits = ixheaace_mps_212_get_spatial_specific_config(
           pstr_api_struct->pstr_mps_212_enc, (WORD8 *)pstr_asc->str_aac_config.sac_cfg_data,
           sizeof(pstr_asc->str_aac_config.sac_cfg_data), AOT_USAC);
     }
     ixheaace_adjust_sbr_settings(
         &spectral_band_replication_config, pstr_sbr_config->bit_rate,
         (pstr_api_struct->pstr_state->mps_enable != 1) ? pstr_config->i_channels : 1,
         pstr_usac_config->core_sample_rate, AACENC_TRANS_FAC, 24000,
         pstr_api_struct->spectral_band_replication_tabs.ptr_qmf_tab,
         pstr_api_struct->pstr_state->aot);
 
     error = ixheaace_env_open(
         &pstr_api_struct->pstr_state->spectral_band_replication_enc_pers_mem[0],
         &spectral_band_replication_config, &pstr_sbr_config->band_width, sbr_scr_ptr,
         &(pstr_api_struct->spectral_band_replication_tabs), &pstr_asc->str_aac_config.sbr_config);
     if (error) {
       return error;
     }
 
     if (pstr_api_struct->config[0].ccfl_idx >= 2) {
       pstr_api_struct->pstr_state->downsample[0] = 1;
     } else {
       pstr_api_struct->pstr_state->downsample[0] = 0;
     }
 
     if (pstr_api_struct->pstr_state->downsample[0]) {
       IA_ERRORCODE resamp_error = IA_NO_ERROR;
       WORD32 resamp_ratio = 0, upsamp_fac = 0, downsamp_fac = 0;
       WORD32 ele_idx = 0, ch_idx = 0;
 
       if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {
         upsamp_fac = 3;
         downsamp_fac = 8;
         pstr_usac_config->sample_rate /= 2;
       } else if (pstr_api_struct->config[0].ccfl_idx == SBR_2_1) {
         resamp_ratio = 2;
         pstr_usac_config->sample_rate /= 2;
       } else if (pstr_api_struct->config[0].ccfl_idx == SBR_4_1) {
         resamp_ratio = 4;
         pstr_usac_config->sample_rate /= 4;
       }
 
       if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {
         if (upsamp_fac != 3 || downsamp_fac != 8) {
           return IA_EXHEAACE_CONFIG_FATAL_USAC_RESAMPLER_RATIO;
         }
       } else {
         if (resamp_ratio != 2 && resamp_ratio != 4) {
           return IA_EXHEAACE_CONFIG_FATAL_USAC_RESAMPLER_RATIO;
         }
       }
       if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {  // Upsampler initialization
         resamp_error = ia_enhaacplus_enc_init_iir_sos_resampler(
             &(pstr_api_struct->pstr_state->up_sampler[ele_idx][ch_idx]), upsamp_fac,
             pstr_api_struct->spectral_band_replication_tabs.ptr_sos_upsamp_tab);
         if (resamp_error) {
           return resamp_error;
         }
         if (pstr_api_struct->config[0].i_channels > 1) {
           resamp_error = ia_enhaacplus_enc_init_iir_sos_resampler(
               &(pstr_api_struct->pstr_state->up_sampler[ele_idx][ch_idx + 1]), upsamp_fac,
               pstr_api_struct->spectral_band_replication_tabs.ptr_sos_upsamp_tab);
           if (resamp_error) {
             return resamp_error;
           }
         }
         if (pstr_usac_config->sbr_harmonic) {
           resamp_error = ia_enhaacplus_enc_init_iir_sos_resampler(
               &(pstr_api_struct->pstr_state->hbe_up_sampler[ele_idx][ch_idx]), upsamp_fac,
               pstr_api_struct->spectral_band_replication_tabs.ptr_sos_upsamp_tab);
           if (resamp_error) {
             return resamp_error;
           }
           if (pstr_api_struct->config[0].i_channels > 1) {
             resamp_error = ia_enhaacplus_enc_init_iir_sos_resampler(
                 &(pstr_api_struct->pstr_state->hbe_up_sampler[ele_idx][ch_idx + 1]), upsamp_fac,
                 pstr_api_struct->spectral_band_replication_tabs.ptr_sos_upsamp_tab);
             if (resamp_error) {
               return resamp_error;
             }
           }
         }
         // Downsampler initialization
         resamp_error = ia_enhaacplus_enc_init_iir_sos_resampler(
             &(pstr_api_struct->pstr_state->down_samp_sos[ele_idx][ch_idx]), downsamp_fac,
             pstr_api_struct->spectral_band_replication_tabs.ptr_sos_downsamp_tab);
         if (resamp_error) {
           return resamp_error;
         }
         if (pstr_api_struct->config[0].i_channels > 1) {
           resamp_error = ia_enhaacplus_enc_init_iir_sos_resampler(
               &(pstr_api_struct->pstr_state->down_samp_sos[ele_idx][ch_idx + 1]), downsamp_fac,
               pstr_api_struct->spectral_band_replication_tabs.ptr_sos_downsamp_tab);
           if (resamp_error) {
             return resamp_error;
           }
         }
         if (pstr_usac_config->sbr_harmonic) {
           resamp_error = ia_enhaacplus_enc_init_iir_sos_resampler(
               &(pstr_api_struct->pstr_state->hbe_down_samp_sos[ele_idx][ch_idx]), downsamp_fac,
               pstr_api_struct->spectral_band_replication_tabs.ptr_sos_downsamp_tab);
           if (resamp_error) {
             return resamp_error;
           }
           if (pstr_api_struct->config[0].i_channels > 1) {
             resamp_error = ia_enhaacplus_enc_init_iir_sos_resampler(
                 &(pstr_api_struct->pstr_state->hbe_down_samp_sos[ele_idx][ch_idx + 1]),
                 downsamp_fac,
                 pstr_api_struct->spectral_band_replication_tabs.ptr_sos_downsamp_tab);
             if (resamp_error) {
               return resamp_error;
             }
           }
         }
       } else if (pstr_api_struct->config[0].ccfl_idx == SBR_2_1 ||
                  pstr_api_struct->config[0].ccfl_idx == SBR_4_1) {
         resamp_error = ia_enhaacplus_enc_init_iir_resampler(
             &(pstr_api_struct->pstr_state->down_sampler[ele_idx][ch_idx]), resamp_ratio,
             pstr_api_struct->spectral_band_replication_tabs.ptr_resamp_tab);
         if (resamp_error) {
           return resamp_error;
         }
         if (pstr_api_struct->config[0].i_channels > 1) {
           resamp_error = ia_enhaacplus_enc_init_iir_resampler(
               &(pstr_api_struct->pstr_state->down_sampler[ele_idx][ch_idx + 1]), resamp_ratio,
               pstr_api_struct->spectral_band_replication_tabs.ptr_resamp_tab);
           if (resamp_error) {
             return resamp_error;
           }
         }
         if (pstr_usac_config->sbr_harmonic) {
           resamp_error = ia_enhaacplus_enc_init_iir_resampler(
               &(pstr_api_struct->pstr_state->hbe_down_sampler[ele_idx][ch_idx]), resamp_ratio,
               pstr_api_struct->spectral_band_replication_tabs.ptr_resamp_tab);
           if (resamp_error) {
             return resamp_error;
           }
           if (pstr_api_struct->config[0].i_channels > 1) {
             resamp_error = ia_enhaacplus_enc_init_iir_resampler(
                 &(pstr_api_struct->pstr_state->hbe_down_sampler[ele_idx][ch_idx + 1]),
                 resamp_ratio, pstr_api_struct->spectral_band_replication_tabs.ptr_resamp_tab);
             if (resamp_error) {
               return resamp_error;
             }
           }
         }
       }
     }
   }
 
   error = iusace_enc_init(pstr_usac_config, &pstr_api_struct->pstr_state->audio_specific_config,
                           &pstr_api_struct->pstr_state->str_usac_enc_data);
-  if (error) {
+  if (error & IA_FATAL_ERROR) {
     return error;
   }
 
   ia_bit_buf_struct *pstr_ia_asc_bit_buf;
   pstr_ia_asc_bit_buf = iusace_create_bit_buffer(
       &(pstr_api_struct->pstr_state->str_bit_buf), pstr_api_struct->pp_mem[IA_MEMTYPE_OUTPUT],
       pstr_api_struct->pstr_mem_info[IA_MEMTYPE_OUTPUT].ui_size, 1);
 #ifdef ENABLE_SET_JUMP
   pstr_ia_asc_bit_buf->iusace_jmp_buf = &api_init_jmp_buf;
 #endif
   if (pstr_usac_config->sbr_enable) {
     pstr_api_struct->pstr_state->audio_specific_config.str_usac_config.str_usac_element_config
         ->stereo_config_index = (pstr_api_struct->pstr_state->mps_enable == 1) ? 2 : 0;
     pstr_api_struct->pstr_state->audio_specific_config.str_usac_config.str_usac_element_config
         ->str_usac_sbr_config.bs_inter_tes = pstr_usac_config->sbr_inter_tes_active;
     pstr_api_struct->pstr_state->audio_specific_config.str_usac_config.str_usac_element_config
         ->str_usac_sbr_config.bs_pvc = pstr_usac_config->sbr_pvc_active;
     pstr_api_struct->pstr_state->audio_specific_config.str_usac_config.str_usac_element_config
         ->str_usac_sbr_config.dflt_header_extra1 = 0;
     pstr_api_struct->pstr_state->audio_specific_config.str_usac_config.str_usac_element_config
         ->str_usac_sbr_config.dflt_header_extra2 = 0;
     pstr_api_struct->pstr_state->audio_specific_config.str_usac_config.str_usac_element_config
         ->str_usac_sbr_config.dflt_start_freq = 0;
     pstr_api_struct->pstr_state->audio_specific_config.str_usac_config.str_usac_element_config
         ->str_usac_sbr_config.dflt_stop_freq = 4;
     pstr_api_struct->pstr_state->audio_specific_config.str_usac_config.str_usac_element_config
         ->str_usac_sbr_config.harmonic_sbr = pstr_usac_config->sbr_harmonic;
   }
 
   ixheaace_get_audiospecific_config_bytes(pstr_ia_asc_bit_buf,
                                           &pstr_api_struct->pstr_state->audio_specific_config,
                                           AOT_USAC, ccfl_idx);
   pstr_api_struct->pstr_state->i_out_bytes = (pstr_ia_asc_bit_buf->cnt_bits + 7) >> 3;
 
   return IA_NO_ERROR;
 }
@@ -3376,182 +3376,188 @@ IA_ERRORCODE ixheaace_allocate(pVOID pv_input, pVOID pv_output) {
 IA_ERRORCODE ixheaace_init(pVOID pstr_obj_ixheaace, pVOID pv_input, pVOID pv_output) {
   IA_ERRORCODE error = IA_NO_ERROR;
   WORD32 frame_length;
   WORD32 channels, ele_idx;
   ixheaace_api_struct *pstr_api_struct = (ixheaace_api_struct *)pstr_obj_ixheaace;
   ixheaace_input_config *pstr_input_config = (ixheaace_input_config *)pv_input;
   ixheaace_output_config *pstr_output_config = (ixheaace_output_config *)pv_output;
   WORD32 total_bitrate_used = 0;
   frame_length = pstr_input_config->frame_length;
   channels = 0;
   for (ele_idx = 0; ele_idx < pstr_api_struct->config[0].num_bs_elements; ele_idx++) {
     channels += pstr_api_struct->config[ele_idx].i_channels;
   }
   pstr_api_struct->pstr_state->aot = pstr_input_config->aot;
 
   if ((pstr_api_struct->config[0].use_mps == 1) &&
       (0 == pstr_api_struct->config->aac_classic ||
        pstr_api_struct->pstr_state->aot == AOT_USAC)) {
     pstr_api_struct->pstr_state->mps_enable = pstr_api_struct->config[0].use_mps;
     pstr_api_struct->pstr_state->mps_tree_config = pstr_api_struct->config[0].mps_tree_config;
   }
   if (pstr_api_struct->config[0].num_bs_elements == 1) {
     pstr_api_struct->config[ele_idx].write_program_config_element = 0;
   }
 
   if (pstr_api_struct->pstr_state->aot != AOT_USAC) {
     for (ele_idx = 0; ele_idx < pstr_api_struct->config[0].num_bs_elements; ele_idx++) {
       /* Set config pointer in api obj */
       pstr_api_struct->pstr_state->pstr_config[ele_idx] = &pstr_api_struct->config[ele_idx];
 
       error = ia_enhaacplus_enc_init(pstr_api_struct, ele_idx);
       if (error) {
         return error;
       }
 
       pstr_api_struct->pstr_state->ui_init_done = 1;
       total_bitrate_used += pstr_api_struct->config[ele_idx].aac_config.bit_rate;
     }
     if (pstr_input_config->i_bitrate != total_bitrate_used) {
       pstr_input_config->i_bitrate = total_bitrate_used;
     }
     if (pstr_api_struct->config[0].aac_config.bitreservoir_size != -1) {
       WORD32 avg_bytes_per_frame_per_ch = pstr_api_struct->config[0].aac_config.bitreservoir_size;
       if (pstr_api_struct->config[0].aac_config.flag_framelength_small) {
         if (pstr_api_struct->config[0].aot == AOT_AAC_LC ||
             pstr_api_struct->config[0].aot == AOT_PS ||
             pstr_api_struct->config[0].aot == AOT_SBR) {
           avg_bytes_per_frame_per_ch = (pstr_api_struct->config[0].aac_config.bit_rate) *
                                        FRAME_LEN_960 /
                                        (pstr_api_struct->config[0].aac_config.core_sample_rate *
                                         pstr_api_struct->config[0].i_channels * 8);
         }
         if (pstr_input_config->aot == AOT_AAC_LD || pstr_input_config->aot == AOT_AAC_ELD) {
           avg_bytes_per_frame_per_ch = (pstr_api_struct->config[0].aac_config.bit_rate) *
                                        FRAME_LEN_480 /
                                        (pstr_api_struct->config[0].aac_config.core_sample_rate *
                                         pstr_api_struct->config[0].i_channels * 8);
         }
       } else {
         if (pstr_api_struct->config[0].aot == AOT_AAC_LC ||
             pstr_api_struct->config[0].aot == AOT_PS ||
             pstr_api_struct->config[0].aot == AOT_SBR) {
           avg_bytes_per_frame_per_ch = (pstr_api_struct->config[0].aac_config.bit_rate) *
                                        FRAME_LEN_1024 /
                                        (pstr_api_struct->config[0].aac_config.core_sample_rate *
                                         pstr_api_struct->config[0].i_channels * 8);
         }
         if (pstr_input_config->aot == AOT_AAC_LD || pstr_input_config->aot == AOT_AAC_ELD) {
           avg_bytes_per_frame_per_ch = (pstr_api_struct->config[0].aac_config.bit_rate) *
                                        FRAME_LEN_512 /
                                        (pstr_api_struct->config[0].aac_config.core_sample_rate *
                                         pstr_api_struct->config[0].i_channels * 8);
         }
       }
 
       if (pstr_api_struct->config[0].aac_config.bitreservoir_size < avg_bytes_per_frame_per_ch) {
         return IA_EXHEAACE_CONFIG_NONFATAL_BITRES_SIZE_TOO_SMALL;
       }
     }
     if (pstr_input_config->i_use_es) {
       // Write GA header
       ia_bit_buf_struct *pstr_ia_asc_bit_buf;
       pstr_ia_asc_bit_buf = iusace_create_bit_buffer(
           &(pstr_api_struct->pstr_state->str_bit_buf), pstr_api_struct->pp_mem[IA_MEMTYPE_OUTPUT],
           pstr_api_struct->pstr_mem_info[IA_MEMTYPE_OUTPUT].ui_size, 1);
 
       ixheaace_get_audiospecific_config_bytes(pstr_ia_asc_bit_buf,
                                               &pstr_api_struct->pstr_state->audio_specific_config,
                                               pstr_api_struct->pstr_state->aot
 
                                               ,
                                               pstr_input_config->ccfl_idx);
 
       pstr_api_struct->pstr_state->i_out_bytes = (pstr_ia_asc_bit_buf->cnt_bits + 7) >> 3;
     }
     if (pstr_api_struct->config->aac_classic) {
       pstr_output_config->input_size =
           frame_length * channels * pstr_api_struct->config[0].ui_pcm_wd_sz / 8;
     } else {
       pstr_output_config->input_size =
           2 * frame_length * channels * pstr_api_struct->config[0].ui_pcm_wd_sz / 8;
     }
     pstr_output_config->samp_freq = pstr_api_struct->config[0].native_sample_rate;
     pstr_output_config->header_samp_freq = pstr_api_struct->config[0].aac_config.core_sample_rate;
     pstr_output_config->down_sampling_ratio =
         pstr_api_struct->config->aac_classic == 0 ? 2.0f : 1.0f;
     switch (pstr_api_struct->config->aot) {
       case AOT_AAC_LC:
         pstr_output_config->audio_profile = AUDIO_PROFILE_AAC_LC_L5;
         break;
       case AOT_SBR:
         pstr_output_config->audio_profile = AUDIO_PROFILE_HEAAC_L5;
         break;
       case AOT_PS:
         pstr_output_config->audio_profile = AUDIO_PROFILE_HEAAC_V2_L5;
         break;
       case AOT_AAC_LD:
         pstr_output_config->audio_profile = AUDIO_PROFILE_AAC_LD_L4;
         break;
       case AOT_AAC_ELD:
         if (pstr_api_struct->config[0].use_mps) {
           if (pstr_api_struct->config[0].mps_tree_config == TREE_212) {
             pstr_output_config->audio_profile = AUDIO_PROFILE_AAC_ELD_L2;
           } else {
             pstr_output_config->audio_profile = AUDIO_PROFILE_AAC_ELD_L4;
           }
         } else {
           pstr_output_config->audio_profile = AUDIO_PROFILE_AAC_ELD_L1;
         }
         break;
       default:
         pstr_output_config->audio_profile = AUDIO_PROFILE_NOT_SPECIFIED;
         break;
     }
   }
 
   else {
     pstr_api_struct->pstr_state->pstr_config[0] = &pstr_api_struct->config[0];
     error = ia_usac_enc_init(pstr_api_struct, pstr_input_config->ccfl_idx);
     if (error) {
       return error;
     }
+
     pstr_output_config->input_size =
         frame_length * channels * (pstr_api_struct->config[0].usac_config.ui_pcm_wd_sz >> 3);
 
-    if (pstr_input_config->use_drc_element) {
+    if (pstr_api_struct->config[0].usac_config.use_drc_element) {
       ia_drc_input_config *pstr_drc_cfg = (ia_drc_input_config *)(pstr_input_config->pv_drc_cfg);
       memcpy(pstr_drc_cfg, &pstr_api_struct->config[0].usac_config.str_drc_cfg,
              sizeof(ia_drc_input_config));
     }
 
     pstr_output_config->down_sampling_ratio = 1;
     if (pstr_api_struct->config[0].usac_config.sbr_enable == 1) {
       switch (pstr_api_struct->config[0].ccfl_idx) {
         case SBR_8_3:
           pstr_output_config->input_size *= 8;
           pstr_output_config->input_size /= 3;
           pstr_output_config->down_sampling_ratio = 8.0f / 3.0f;
           break;
 
         case SBR_2_1:
           pstr_output_config->input_size *= 2;
           pstr_output_config->down_sampling_ratio = 2;
           break;
 
         case SBR_4_1:
           pstr_output_config->input_size *= 4;
           pstr_output_config->down_sampling_ratio = 4;
           break;
       }
     }
     pstr_output_config->samp_freq = pstr_api_struct->config[0].usac_config.native_sample_rate;
     pstr_output_config->header_samp_freq =
         pstr_api_struct->config[0].usac_config.native_sample_rate;
     pstr_output_config->audio_profile = AUDIO_PROFILE_USAC_L2;
+    if (pstr_input_config->use_drc_element !=
+        pstr_api_struct->config[0].usac_config.use_drc_element) {
+      error = IA_EXHEAACE_EXE_NONFATAL_USAC_INVALID_GAIN_POINTS;
+    }
+    pstr_input_config->use_drc_element = pstr_api_struct->config[0].usac_config.use_drc_element;
   }
 
   pstr_api_struct->pstr_state->ui_init_done = 1;
   pstr_output_config->i_out_bytes = pstr_api_struct->pstr_state->i_out_bytes;
 
   return error;
 }
@@ -3559,12 +3565,12 @@ IA_ERRORCODE ixheaace_init(pVOID pstr_obj_ixheaace, pVOID pv_input, pVOID pv_out
 IA_ERRORCODE ixheaace_create(pVOID pv_input, pVOID pv_output) {
   IA_ERRORCODE err_code = IA_NO_ERROR;
   ixheaace_output_config *pstr_out_cfg = (ixheaace_output_config *)pv_output;
   err_code = ixheaace_allocate(pv_input, pv_output);
   if (!err_code) {
     err_code = ixheaace_init(pstr_out_cfg->pv_ia_process_api_obj, pv_input, pv_output);
   }
-  if (err_code) {
+  if (err_code & IA_FATAL_ERROR) {
     IXHEAACE_MEM_FREE(pv_output);
   }
   return err_code;
 }
diff --git a/encoder/ixheaace_error_codes.h b/encoder/ixheaace_error_codes.h
index 99e7992..28e0846 100644
--- a/encoder/ixheaace_error_codes.h
+++ b/encoder/ixheaace_error_codes.h
@@ -30,176 +30,178 @@
 typedef enum {
   /*****************************************************************************/
   /* Class 0: API Errors                                                       */
   /*****************************************************************************/
   /* Non Fatal Errors */
 
   // AAC Profiles
 
   // MPS
 
   // USAC
 
   // DRC
 
   /* Fatal Errors */
 
   // AAC Profiles
   IA_EXHEAACE_API_FATAL_MEM_ALLOC = 0xFFFF8000,
   IA_EXHEAACE_API_FATAL_UNSUPPORTED_AOT,
 
   // MPS
 
   // USAC
 
   // DRC
 
   /*****************************************************************************/
   /* Class 1: Configuration Errors                                             */
   /*****************************************************************************/
   /* Non Fatal Errors */
 
   // AAC profiles
   IA_EXHEAACE_CONFIG_NONFATAL_INVALID_CONFIG = 0x00000800,
   IA_EXHEAACE_CONFIG_NONFATAL_BITRES_SIZE_TOO_SMALL,
 
   // MPS
   IA_EXHEAACE_CONFIG_NONFATAL_MPS_INVALID_CONFIG = 0x00000900,
   IA_EXHEAACE_CONFIG_NONFATAL_MPS_PARAM_ERROR,
 
   // USAC
 
   // DRC
   IA_EXHEAACE_CONFIG_NONFATAL_DRC_MISSING_CONFIG = 0x00000B00,
   /* Fatal Errors */
 
   // AAC profiles
   IA_EXHEAACE_CONFIG_FATAL_SAMP_FREQ = 0xFFFF8800,
   IA_EXHEAACE_CONFIG_FATAL_NUM_CHANNELS,
   IA_EXHEAACE_CONFIG_FATAL_USE_STEREO_PRE_PROC,
   IA_EXHEAACE_CONFIG_FATAL_QUALITY_LEVEL,
   IA_EXHEAACE_CONFIG_FATAL_PCM_WDSZ,
   IA_EXHEAACE_CONFIG_FATAL_AAC_CLASSIC_WITH_PS,
   IA_EXHEAACE_CONFIG_FATAL_USE_TNS,
   IA_EXHEAACE_CONFIG_FATAL_CHANNELS_MASK,
   IA_EXHEAACE_CONFIG_FATAL_WRITE_PCE,
   IA_EXHEAACE_CONFIG_FATAL_USE_FULL_BANDWIDTH,
   // MPS
 
   // USAC
   IA_EXHEAACE_CONFIG_FATAL_USAC_SAMP_FREQ = 0xFFFF8A00,
   IA_EXHEAACE_CONFIG_FATAL_USAC_RESAMPLER_RATIO,
 
   // DRC
   IA_EXHEAACE_CONFIG_FATAL_DRC_INVALID_CONFIG = 0xFFFF8B00,
   IA_EXHEAACE_CONFIG_FATAL_DRC_UNSUPPORTED_CONFIG,
   IA_EXHEAACE_CONFIG_FATAL_DRC_PARAM_OUT_OF_RANGE,
   IA_EXHEAACE_CONFIG_FATAL_DRC_COMPAND_FAILED,
   /*****************************************************************************/
   /* Class 2: Initialization Errors                                             */
   /*****************************************************************************/
   /* Non Fatal Errors */
 
+  //DRC
+  IA_EXHEAACE_EXE_NONFATAL_USAC_INVALID_GAIN_POINTS = 0x00001300,
   /* Fatal Errors */
 
   // AAC Profiles
   IA_EXHEAACE_INIT_FATAL_RESAMPLER_INIT_FAILED = 0xFFFF9000,
   IA_EXHEAACE_INIT_FATAL_AAC_INIT_FAILED,
   IA_EXHEAACE_INIT_FATAL_AACPLUS_NOT_AVAIL,
   IA_EXHEAACE_INIT_FATAL_BITRATE_NOT_SUPPORTED,
   IA_EXHEAACE_INIT_FATAL_INVALID_TNS_PARAM,
   IA_EXHEAACE_INIT_FATAL_SCALE_FACTOR_BAND_NOT_SUPPORTED,
   IA_EXHEAACE_INIT_FATAL_INVALID_CORE_SAMPLE_RATE,
   IA_EXHEAACE_INIT_FATAL_INVALID_ELEMENT_TYPE,
   IA_EXHEAACE_INIT_FATAL_NUM_CHANNELS_NOT_SUPPORTED,
   IA_EXHEAACE_INIT_FATAL_INVALID_NUM_CHANNELS_IN_ELE,
   IA_EXHEAACE_INIT_FATAL_SFB_TABLE_INIT_FAILED,
 
   // MPS
   IA_EXHEAACE_INIT_FATAL_MPS_INIT_FAILED = 0xFFFF9100,
 
   // USAC
   IA_EXHEAACE_INIT_FATAL_USAC_RESAMPLER_INIT_FAILED = 0xFFFF9200,
   IA_EXHEAACE_INIT_FATAL_USAC_BITRES_SIZE_TOO_SMALL,
 
   // DRC
   IA_EXHEAACE_INIT_FATAL_DRC_INVALID_CHANNEL_INDEX = 0xFFFF9300,
 
   // SBR
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_NUM_CHANNELS = 0xFFFF9400,
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_SAMPLERATE_MODE,
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_FREQ_COEFFS,
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_NUM_BANDS,
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_BUFFER_LENGTH,
   IA_EXEHAACE_INIT_FATAL_SBR_NOISE_BAND_NOT_SUPPORTED,
 
   /*****************************************************************************/
   /* Class 3: Execution Errors                                                 */
   /*****************************************************************************/
   /* Non Fatal Errors */
 
   // AAC Profiles
   IA_EXHEAACE_EXE_NONFATAL_QUANTIZATION_SPECTRUM_ZERO = 0x00001800,
   // MPS
   IA_EXHEAACE_EXE_NONFATAL_MPS_ENCODE_ERROR = 0x00001900,
   IA_EXHEAACE_EXE_NONFATAL_MPS_INVALID_DATA_BANDS,
 
   // USAC
   IA_EXHEAACE_EXE_NONFATAL_USAC_QUANTIZATION_SPECTRUM_ZERO = 0x00001A00,
   // DRC
 
   // ESBR
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_BANDWIDTH_INDEX = 0x00001C00,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_NUM_PATCH,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_VOCOD_BUF,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_PVC_MODE,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_FFT,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_START_BAND,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_VALUE,
 
   /* Fatal Errors */
 
   // AAC Profiles
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_TIME_SLOTS = 0xFFFF9800,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_IN_CHANNELS,
   IA_EXHEAACE_EXE_FATAL_PS_INVALID_HYBRID_RES_VAL,
   IA_EXHEAACE_EXE_FATAL_UNSUPPORTED_AOT,
   IA_EXHEAACE_EXE_FATAL_INVALID_BLOCK_TYPE,
   IA_EXHEAACE_EXE_FATAL_INVALID_SBR_FRAME_TYPE,
   IA_EXHEAACE_EXE_FATAL_INVALID_SBR_NUM_ENVELOPES,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_BS,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_CODEBOOK,
   IA_EXHEAACE_EXE_FATAL_INVALID_SCALE_FACTOR_GAIN,
   IA_EXHEAACE_EXE_FATAL_INVALID_BIT_RES_LEVEL,
   IA_EXHEAACE_EXE_FATAL_INVALID_BIT_CONSUMPTION,
   IA_EXHEAACE_EXE_FATAL_INVALID_SIDE_INFO_BITS,
   IA_EXHEAACE_EXE_FATAL_INVALID_HUFFMAN_BITS,
   IA_EXHEAACE_EXE_FATAL_INVALID_SCALE_FACTOR_BITS,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_AMP_RES,
   IA_EXHEAACE_EXE_FATAL_INVALID_OUT_BYTES,
   IA_EXHEAACE_EXE_FATAL_INVALID_TNS_FILT_ORDER,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_SAMP_FREQ,
 
   // MPS
   IA_EXHEAACE_EXE_FATAL_MPS_NULL_DATA_HANDLE = 0xFFFF9900,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_HUFF_DATA_TYPE,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_NUM_PARAM_SETS,
   IA_EXHEAACE_EXE_FATAL_MPS_UNSUPPORTED_GUIDED_ENV_SHAPE,
   IA_EXHEAACE_EXE_FATAL_MPS_3D_STEREO_MODE_NOT_SUPPORTED,
   IA_EXHEAACE_EXE_FATAL_MPS_UNSUPPORTED_RESIDUAL_CODING,
   IA_EXHEAACE_EXE_FATAL_MPS_UNSUPPORTED_ARBITARY_DOWNMIX_CODING,
   IA_EXHEAACE_EXE_FATAL_MPS_ARBITARY_TREE_NOT_SUPPORTED,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_QUANT_COARSE,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_RES_STRIDE,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_LEVELS,
   IA_EXHEAACE_EXE_FATAL_MPS_CFFT_PROCESS,
 
   // USAC
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_FAC_LEN = 0xFFFF9A00,
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_NUM_SBK,
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_NUM_CHANNEL,
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_BIT_RSVR_LVL,
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_MAPPING,
 
   // DRC
 
 } ixheaace_error_codes;
diff --git a/fuzzer/xaac_enc_fuzzer.cpp b/fuzzer/xaac_enc_fuzzer.cpp
index 62d49d2..a04f48c 100644
--- a/fuzzer/xaac_enc_fuzzer.cpp
+++ b/fuzzer/xaac_enc_fuzzer.cpp
@@ -348,77 +348,82 @@ static VOID ixheaace_fuzzer_flag(ixheaace_input_config *pstr_in_cfg,
 extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
   FuzzedDataProvider fuzzed_data(data, size);
 
   /* Error code */
   IA_ERRORCODE err_code = 0;
 
   /* API obj */
   pVOID pv_ia_process_api_obj;
 
   pWORD8 pb_inp_buf = NULL;
   WORD32 input_size = 0;
   WORD32 num_proc_iterations = 0;
 
   /* ******************************************************************/
   /* The API config structure                                         */
   /* ******************************************************************/
 
   ixheaace_user_config_struct str_enc_api{};
 
   ixheaace_input_config *pstr_in_cfg = &str_enc_api.input_config;
   ixheaace_output_config *pstr_out_cfg = &str_enc_api.output_config;
   pstr_in_cfg->pv_drc_cfg = malloc_global(sizeof(ia_drc_input_config), DEFAULT_MEM_ALIGN_8);
   ia_drc_input_config *pstr_drc_cfg = (ia_drc_input_config *)pstr_in_cfg->pv_drc_cfg;
   memset(pstr_drc_cfg, 0, sizeof(ia_drc_input_config));
 
   pstr_out_cfg->malloc_xheaace = &malloc_global;
   pstr_out_cfg->free_xheaace = &free_global;
 
   /* ******************************************************************/
   /* Parse input configuration parameters                             */
   /* ******************************************************************/
   ixheaace_fuzzer_flag(pstr_in_cfg, pstr_drc_cfg, &fuzzed_data);
 
   err_code = ixheaace_create((pVOID)pstr_in_cfg, (pVOID)pstr_out_cfg);
   if (err_code) {
     if (pstr_drc_cfg) {
       free(pstr_drc_cfg);
+      pstr_drc_cfg = NULL;
+    }
+    /* Fatal error code */
+    if (err_code & 0x80000000) {
+      ixheaace_delete((pVOID)pstr_out_cfg);
+      return 0;
     }
-    return 0;
   }
 
   pv_ia_process_api_obj = pstr_out_cfg->pv_ia_process_api_obj;
   pb_inp_buf = (pWORD8)pstr_out_cfg->mem_info_table[IA_MEMTYPE_INPUT].mem_ptr;
 
   /* End first part */
 
   /* Second part        */
   /* Initialize process */
   /* Get config params  */
 
   input_size = pstr_out_cfg->input_size;
   memset(pb_inp_buf, 0, input_size);
 
   while (fuzzed_data.remaining_bytes()) {
     if (fuzzed_data.ConsumeBool()) {
       std::vector<WORD8> inputVec = fuzzed_data.ConsumeBytes<WORD8>(input_size);
       memcpy(pb_inp_buf, inputVec.data(), inputVec.size());
     } else {
       memset(pb_inp_buf, fuzzed_data.ConsumeIntegral<WORD8>(), input_size);
     }
     ixheaace_process(pv_ia_process_api_obj, (pVOID)pstr_in_cfg, (pVOID)pstr_out_cfg);
     num_proc_iterations++;
 
     /* Stop processing after 500 frames */
     if (num_proc_iterations > 500)
       break;
   }
 
   ixheaace_delete((pVOID)pstr_out_cfg);
 
   if (pstr_drc_cfg) {
     free(pstr_drc_cfg);
   }
   return 0;
 }
 
 /* End ia_main_process() */
diff --git a/test/encoder/ixheaace_error.c b/test/encoder/ixheaace_error.c
index 63204fe..b149c25 100644
--- a/test/encoder/ixheaace_error.c
+++ b/test/encoder/ixheaace_error.c
@@ -82,6 +82,9 @@ pWORD8 ppb_ia_enhaacplus_enc_drc_config_fatal[IA_MAX_ERROR_SUB_CODE] = {
 
 pWORD8 ppb_ia_enhaacplus_enc_mps_init_non_fatal[IA_MAX_ERROR_SUB_CODE] = {NULL};
 
+pWORD8 ppb_ia_enhaacplus_enc_drc_init_non_fatal[IA_MAX_ERROR_SUB_CODE] = {
+    (pWORD8) "Invalid DRC gain points" };
+
 /* Fatal Errors */
 
 pWORD8 ppb_ia_enhaacplus_enc_init_fatal[IA_MAX_ERROR_SUB_CODE] = {
@@ -221,45 +224,47 @@ ia_error_info_struct ia_enhaacplus_enc_error_info = {
 VOID ia_enhaacplus_enc_error_handler_init() {
   /* The Message Pointers	*/
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][0][0] =
       ppb_ia_enhaacplus_enc_api_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[0][1][0] =
       ppb_ia_enhaacplus_enc_config_non_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[0][1][1] =
       ppb_ia_enhaacplus_enc_mps_config_non_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[0][1][2] =
       ppb_ia_enhaacplus_enc_drc_config_non_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][1][0] =
       ppb_ia_enhaacplus_enc_config_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][1][2] =
       ppb_ia_enhaacplus_enc_usac_config_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][1][3] =
       ppb_ia_enhaacplus_enc_drc_config_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[0][2][1] =
       ppb_ia_enhaacplus_enc_mps_init_non_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][2][0] =
       ppb_ia_enhaacplus_enc_init_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][2][1] =
       ppb_ia_enhaacplus_enc_mps_init_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][2][2] =
       ppb_ia_enhaacplus_enc_usac_init_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][2][3] =
       ppb_ia_enhaacplus_enc_drc_init_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][2][4] =
       ppb_ia_enhaacplus_enc_sbr_init_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[0][3][1] =
       ppb_ia_enhaacplus_enc_mps_exe_non_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[0][3][4] =
       ppb_ia_enhaacplus_enc_esbr_exe_non_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][3][0] =
       ppb_ia_enhaacplus_enc_exe_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][3][1] =
       ppb_ia_enhaacplus_enc_mps_exe_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[1][3][2] =
       ppb_ia_enhaacplus_enc_usac_exe_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[0][3][0] =
     ppb_ia_enhaacplus_enc_aac_exe_non_fatal;
   ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[0][3][2] =
     ppb_ia_enhaacplus_enc_usac_exe_non_fatal;
+  ia_enhaacplus_enc_error_info.ppppb_error_msg_pointers[0][2][3] =
+    ppb_ia_enhaacplus_enc_drc_init_non_fatal;
 }
 
 IA_ERRORCODE ia_error_handler(ia_error_info_struct *p_mod_err_info, WORD8 *pb_context,
