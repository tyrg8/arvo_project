commit fa333e34d6230210bc73a88b0ba6df2102dcda51
Author: Behdad Esfahbod <behdad@behdad.org>
Date:   Thu Dec 27 17:56:22 2018 -0500

    [vector] Remove static_array
    
    Was good idea, but with C++ types with constructor/destructor, was getting in
    the way as compiler was destructing those items where it was not desired.
    Since C++ does not allow zero-sized arrays, just remove it...

diff --git a/src/hb-aat-map.hh b/src/hb-aat-map.hh
index fa312dbec..3853b7e0d 100644
--- a/src/hb-aat-map.hh
+++ b/src/hb-aat-map.hh
@@ -33,59 +33,59 @@
 struct hb_aat_map_t
 {
   friend struct hb_aat_map_builder_t;
 
   public:
 
   void init ()
   {
     memset (this, 0, sizeof (*this));
     chain_flags.init ();
   }
   void fini () { chain_flags.fini (); }
 
   public:
-  hb_vector_t<hb_mask_t, 1> chain_flags;
+  hb_vector_t<hb_mask_t> chain_flags;
 };
 
 struct hb_aat_map_builder_t
 {
   public:
 
   HB_INTERNAL hb_aat_map_builder_t (hb_face_t *face_,
 				    const hb_segment_properties_t *props_ HB_UNUSED) :
 				      face (face_) {}
 
   HB_INTERNAL void add_feature (hb_tag_t tag, unsigned int value=1);
 
   HB_INTERNAL void compile (hb_aat_map_t  &m);
 
   public:
   struct feature_info_t
   {
     hb_aat_layout_feature_type_t  type;
     hb_aat_layout_feature_selector_t  setting;
     unsigned  seq; /* For stable sorting only. */
 
     static int cmp (const void *pa, const void *pb)
     {
       const feature_info_t *a = (const feature_info_t *) pa;
       const feature_info_t *b = (const feature_info_t *) pb;
       return (a->type != b->type) ? (a->type < b->type ? -1 : 1) :
 	     (a->seq < b->seq ? -1 : a->seq > b->seq ? 1 : 0);
     }
 
     int cmp (unsigned int ty) const
     {
       return (type != ty) ? (type < ty ? -1 : 1) : 0;
     }
   };
 
   public:
   hb_face_t *face;
 
   public:
-  hb_vector_t<feature_info_t, 32> features;
+  hb_vector_t<feature_info_t> features;
 };
 
 
 #endif /* HB_AAT_MAP_HH */
diff --git a/src/hb-cff-interp-common.hh b/src/hb-cff-interp-common.hh
index 843256c6b..9a45332b7 100644
--- a/src/hb-cff-interp-common.hh
+++ b/src/hb-cff-interp-common.hh
@@ -392,97 +392,97 @@ template <typename ELEM, int LIMIT>
 struct stack_t
 {
   void init ()
   {
     error = false;
     count = 0;
     elements.init ();
     elements.resize (kSizeLimit);
     for (unsigned int i = 0; i < elements.length; i++)
       elements[i].init ();
   }
 
   void fini ()
   {
     elements.fini_deep ();
   }
 
   ELEM& operator [] (unsigned int i)
   {
     if (unlikely (i >= count)) set_error ();
     return elements[i];
   }
 
   void push (const ELEM &v)
   {
     if (likely (count < elements.length))
       elements[count++] = v;
     else
       set_error ();
   }
 
   ELEM &push ()
   {
     if (likely (count < elements.length))
       return elements[count++];
     else
     {
       set_error ();
       return Crap(ELEM);
     }
   }
 
   ELEM& pop ()
   {
     if (likely (count > 0))
       return elements[--count];
     else
     {
       set_error ();
       return Crap(ELEM);
     }
   }
 
   void pop (unsigned int n)
   {
     if (likely (count >= n))
       count -= n;
     else
       set_error ();
   }
 
   const ELEM& peek ()
   {
     if (likely (count > 0))
       return elements[count-1];
     else
     {
       set_error ();
       return Null(ELEM);
     }
   }
 
   void unpop ()
   {
     if (likely (count < elements.length))
       count++;
     else
       set_error ();
   }
 
   void clear () { count = 0; }
 
   bool in_error () const { return (error || elements.in_error ()); }
   void set_error ()      { error = true; }
 
   unsigned int get_count () const { return count; }
   bool is_empty () const { return count == 0; }
 
   static const unsigned int kSizeLimit = LIMIT;
 
   protected:
   bool error;
   unsigned int count;
-  hb_vector_t<ELEM, kSizeLimit> elements;
+  hb_vector_t<ELEM> elements;
 };
 
 /* argument stack */
diff --git a/src/hb-face.cc b/src/hb-face.cc
index 1042d706c..375ef9293 100644
--- a/src/hb-face.cc
+++ b/src/hb-face.cc
@@ -587,19 +587,19 @@ hb_face_collect_variation_unicodes (hb_face_t *face,
 struct hb_face_builder_data_t
 {
   struct table_entry_t
   {
     int cmp (hb_tag_t t) const
     {
       if (t < tag) return -1;
       if (t > tag) return -1;
       return 0;
     }
 
     hb_tag_t   tag;
     hb_blob_t *blob;
   };
 
-  hb_vector_t<table_entry_t, 32> tables;
+  hb_vector_t<table_entry_t> tables;
 };
 
 static hb_face_builder_data_t *
diff --git a/src/hb-object.hh b/src/hb-object.hh
index adbd3ebc5..68520f2a1 100644
--- a/src/hb-object.hh
+++ b/src/hb-object.hh
@@ -45,101 +45,101 @@
 template <typename item_t, typename lock_t>
 struct hb_lockable_set_t
 {
-  hb_vector_t <item_t, 1> items;
+  hb_vector_t<item_t> items;
 
   void init () { items.init (); }
 
   template <typename T>
   item_t *replace_or_insert (T v, lock_t &l, bool replace)
   {
     l.lock ();
     item_t *item = items.find (v);
     if (item) {
       if (replace) {
 	item_t old = *item;
 	*item = v;
 	l.unlock ();
 	old.fini ();
       }
       else {
         item = nullptr;
 	l.unlock ();
       }
     } else {
       item = items.push (v);
       l.unlock ();
     }
     return item;
   }
 
   template <typename T>
   void remove (T v, lock_t &l)
   {
     l.lock ();
     item_t *item = items.find (v);
     if (item)
     {
       item_t old = *item;
       *item = items[items.length - 1];
       items.pop ();
       l.unlock ();
       old.fini ();
     } else {
       l.unlock ();
     }
   }
 
   template <typename T>
   bool find (T v, item_t *i, lock_t &l)
   {
     l.lock ();
     item_t *item = items.find (v);
     if (item)
       *i = *item;
     l.unlock ();
     return !!item;
   }
 
   template <typename T>
   item_t *find_or_insert (T v, lock_t &l)
   {
     l.lock ();
     item_t *item = items.find (v);
     if (!item) {
       item = items.push (v);
     }
     l.unlock ();
     return item;
   }
 
   void fini (lock_t &l)
   {
     if (!items.length)
     {
       /* No need to lock. */
       items.fini ();
       return;
     }
     l.lock ();
     while (items.length)
     {
       item_t old = items[items.length - 1];
       items.pop ();
       l.unlock ();
       old.fini ();
       l.lock ();
     }
     items.fini ();
     l.unlock ();
   }
 
 };
 
 
 /*
  * Reference-count.
  */
 
 #define HB_REFERENCE_COUNT_INERT_VALUE 0
 #define HB_REFERENCE_COUNT_POISON_VALUE -0x0000DEAD
 #define HB_REFERENCE_COUNT_INIT {HB_ATOMIC_INT_INIT (HB_REFERENCE_COUNT_INERT_VALUE)}
diff --git a/src/hb-ot-cff-common.hh b/src/hb-ot-cff-common.hh
index 05eaf64cf..3a9cce353 100644
--- a/src/hb-ot-cff-common.hh
+++ b/src/hb-ot-cff-common.hh
@@ -61,7 +61,7 @@ struct code_pair_t
   hb_codepoint_t  glyph;
 };
 
-typedef hb_vector_t<unsigned char, 1> str_buff_t;
+typedef hb_vector_t<unsigned char> str_buff_t;
 struct str_buff_vec_t : hb_vector_t<str_buff_t>
 {
   void fini () { SUPER::fini_deep (); }
diff --git a/src/hb-ot-layout-gsubgpos.hh b/src/hb-ot-layout-gsubgpos.hh
index 532cf4b07..dd44e746a 100644
--- a/src/hb-ot-layout-gsubgpos.hh
+++ b/src/hb-ot-layout-gsubgpos.hh
@@ -612,54 +612,54 @@ struct hb_ot_apply_context_t :
 struct hb_get_subtables_context_t :
        hb_dispatch_context_t<hb_get_subtables_context_t, hb_void_t, HB_DEBUG_APPLY>
 {
   template <typename Type>
   static bool apply_to (const void *obj, OT::hb_ot_apply_context_t *c)
   {
     const Type *typed_obj = (const Type *) obj;
     return typed_obj->apply (c);
   }
 
   typedef bool (*hb_apply_func_t) (const void *obj, OT::hb_ot_apply_context_t *c);
 
   struct hb_applicable_t
   {
     template <typename T>
     void init (const T &obj_, hb_apply_func_t apply_func_)
     {
       obj = &obj_;
       apply_func = apply_func_;
       digest.init ();
       obj_.get_coverage ().add_coverage (&digest);
     }
 
     bool apply (OT::hb_ot_apply_context_t *c) const
     {
       return digest.may_have (c->buffer->cur().codepoint) && apply_func (obj, c);
     }
 
     private:
     const void *obj;
     hb_apply_func_t apply_func;
     hb_set_digest_t digest;
   };
 
-  typedef hb_vector_t<hb_applicable_t, 2> array_t;
+  typedef hb_vector_t<hb_applicable_t> array_t;
 
   /* Dispatch interface. */
   const char *get_name () { return "GET_SUBTABLES"; }
   template <typename T>
   return_t dispatch (const T &obj)
   {
     hb_applicable_t *entry = array.push();
     entry->init (obj, apply_to<T>);
     return HB_VOID;
   }
   static return_t default_return_value () { return HB_VOID; }
 
   hb_get_subtables_context_t (array_t &array_) :
 			      array (array_),
 			      debug_depth (0) {}
 
   array_t &array;
   unsigned int debug_depth;
 };
diff --git a/src/hb-ot-map.hh b/src/hb-ot-map.hh
index 9c55864dc..28407c217 100644
--- a/src/hb-ot-map.hh
+++ b/src/hb-ot-map.hh
@@ -42,134 +42,134 @@ static const hb_tag_t table_tags[2] = {HB_OT_TAG_GSUB, HB_OT_TAG_GPOS};
 struct hb_ot_map_t
 {
   friend struct hb_ot_map_builder_t;
 
   public:
 
   struct feature_map_t {
     hb_tag_t tag; /* should be first for our bsearch to work */
     unsigned int index[2]; /* GSUB/GPOS */
     unsigned int stage[2]; /* GSUB/GPOS */
     unsigned int shift;
     hb_mask_t mask;
     hb_mask_t _1_mask; /* mask for value=1, for quick access */
     unsigned int needs_fallback : 1;
     unsigned int auto_zwnj : 1;
     unsigned int auto_zwj : 1;
     unsigned int random : 1;
 
     int cmp (const hb_tag_t tag_) const
     { return tag_ < tag ? -1 : tag_ > tag ? 1 : 0; }
   };
 
   struct lookup_map_t {
     unsigned short index;
     unsigned short auto_zwnj : 1;
     unsigned short auto_zwj : 1;
     unsigned short random : 1;
     hb_mask_t mask;
 
     static int cmp (const void *pa, const void *pb)
     {
       const lookup_map_t *a = (const lookup_map_t *) pa;
       const lookup_map_t *b = (const lookup_map_t *) pb;
       return a->index < b->index ? -1 : a->index > b->index ? 1 : 0;
     }
   };
 
   typedef void (*pause_func_t) (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer);
 
   struct stage_map_t {
     unsigned int last_lookup; /* Cumulative */
     pause_func_t pause_func;
   };
 
   void init ()
   {
     memset (this, 0, sizeof (*this));
 
     features.init ();
     for (unsigned int table_index = 0; table_index < 2; table_index++)
     {
       lookups[table_index].init ();
       stages[table_index].init ();
     }
   }
   void fini ()
   {
     features.fini ();
     for (unsigned int table_index = 0; table_index < 2; table_index++)
     {
       lookups[table_index].fini ();
       stages[table_index].fini ();
     }
   }
 
   hb_mask_t get_global_mask () const { return global_mask; }
 
   hb_mask_t get_mask (hb_tag_t feature_tag, unsigned int *shift = nullptr) const
   {
     const feature_map_t *map = features.bsearch (feature_tag);
     if (shift) *shift = map ? map->shift : 0;
     return map ? map->mask : 0;
   }
 
   bool needs_fallback (hb_tag_t feature_tag) const
   {
     const feature_map_t *map = features.bsearch (feature_tag);
     return map ? map->needs_fallback : false;
   }
 
   hb_mask_t get_1_mask (hb_tag_t feature_tag) const
   {
     const feature_map_t *map = features.bsearch (feature_tag);
     return map ? map->_1_mask : 0;
   }
 
   unsigned int get_feature_index (unsigned int table_index, hb_tag_t feature_tag) const
   {
     const feature_map_t *map = features.bsearch (feature_tag);
     return map ? map->index[table_index] : HB_OT_LAYOUT_NO_FEATURE_INDEX;
   }
 
   unsigned int get_feature_stage (unsigned int table_index, hb_tag_t feature_tag) const
   {
     const feature_map_t *map = features.bsearch (feature_tag);
     return map ? map->stage[table_index] : (unsigned int) -1;
   }
 
   void get_stage_lookups (unsigned int table_index, unsigned int stage,
 			  const struct lookup_map_t **plookups, unsigned int *lookup_count) const
   {
     if (unlikely (stage == (unsigned int) -1)) {
       *plookups = nullptr;
       *lookup_count = 0;
       return;
     }
     assert (stage <= stages[table_index].length);
     unsigned int start = stage ? stages[table_index][stage - 1].last_lookup : 0;
     unsigned int end   = stage < stages[table_index].length ? stages[table_index][stage].last_lookup : lookups[table_index].length;
     *plookups = end == start ? nullptr : &lookups[table_index][start];
     *lookup_count = end - start;
   }
 
   HB_INTERNAL void collect_lookups (unsigned int table_index, hb_set_t *lookups) const;
   template <typename Proxy>
   HB_INTERNAL inline void apply (const Proxy &proxy,
 				 const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;
   HB_INTERNAL void substitute (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;
   HB_INTERNAL void position (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;
 
   public:
   hb_tag_t chosen_script[2];
   bool found_script[2];
 
   private:
 
   hb_mask_t global_mask;
 
-  hb_vector_t<feature_map_t, 8> features;
-  hb_vector_t<lookup_map_t, 16> lookups[2]; /* GSUB/GPOS */
-  hb_vector_t<stage_map_t, 4> stages[2]; /* GSUB/GPOS */
+  hb_vector_t<feature_map_t> features;
+  hb_vector_t<lookup_map_t> lookups[2]; /* GSUB/GPOS */
+  hb_vector_t<stage_map_t> stages[2]; /* GSUB/GPOS */
 };
 
 enum hb_ot_map_feature_flags_t
@@ -199,86 +199,86 @@ struct hb_ot_shape_plan_key_t;
 struct hb_ot_map_builder_t
 {
   public:
 
   HB_INTERNAL hb_ot_map_builder_t (hb_face_t *face_,
 				   const hb_segment_properties_t *props_);
 
   HB_INTERNAL ~hb_ot_map_builder_t ();
 
   HB_INTERNAL void add_feature (hb_tag_t tag,
 				hb_ot_map_feature_flags_t flags=F_NONE,
 				unsigned int value=1);
 
   void add_feature (const hb_ot_map_feature_t &feat)
   { add_feature (feat.tag, feat.flags); }
 
   void enable_feature (hb_tag_t tag,
 			      hb_ot_map_feature_flags_t flags=F_NONE,
 			      unsigned int value=1)
   { add_feature (tag, F_GLOBAL | flags, value); }
 
   void disable_feature (hb_tag_t tag)
   { add_feature (tag, F_GLOBAL, 0); }
 
   void add_gsub_pause (hb_ot_map_t::pause_func_t pause_func)
   { add_pause (0, pause_func); }
   void add_gpos_pause (hb_ot_map_t::pause_func_t pause_func)
   { add_pause (1, pause_func); }
 
   HB_INTERNAL void compile (hb_ot_map_t                  &m,
 			    const hb_ot_shape_plan_key_t &key);
 
   private:
 
   HB_INTERNAL void add_lookups (hb_ot_map_t  &m,
 				unsigned int  table_index,
 				unsigned int  feature_index,
 				unsigned int  variations_index,
 				hb_mask_t     mask,
 				bool          auto_zwnj = true,
 				bool          auto_zwj = true,
 				bool          random = false);
 
   struct feature_info_t {
     hb_tag_t tag;
     unsigned int seq; /* sequence#, used for stable sorting only */
     unsigned int max_value;
     hb_ot_map_feature_flags_t flags;
     unsigned int default_value; /* for non-global features, what should the unset glyphs take */
     unsigned int stage[2]; /* GSUB/GPOS */
 
     static int cmp (const void *pa, const void *pb)
     {
       const feature_info_t *a = (const feature_info_t *) pa;
       const feature_info_t *b = (const feature_info_t *) pb;
       return (a->tag != b->tag) ?  (a->tag < b->tag ? -1 : 1) :
 	     (a->seq < b->seq ? -1 : a->seq > b->seq ? 1 : 0);
     }
   };
 
   struct stage_info_t {
     unsigned int index;
     hb_ot_map_t::pause_func_t pause_func;
   };
 
   HB_INTERNAL void add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func);
 
   public:
 
   hb_face_t *face;
   hb_segment_properties_t props;
 
   hb_tag_t chosen_script[2];
   bool found_script[2];
   unsigned int script_index[2], language_index[2];
 
   private:
 
   unsigned int current_stage[2]; /* GSUB/GPOS */
-  hb_vector_t<feature_info_t, 32> feature_infos;
-  hb_vector_t<stage_info_t, 8> stages[2]; /* GSUB/GPOS */
+  hb_vector_t<feature_info_t> feature_infos;
+  hb_vector_t<stage_info_t> stages[2]; /* GSUB/GPOS */
 };
 
 
 
 #endif /* HB_OT_MAP_HH */
diff --git a/src/hb-ot-post-table.hh b/src/hb-ot-post-table.hh
index 6c8eb180f..a799b869f 100644
--- a/src/hb-ot-post-table.hh
+++ b/src/hb-ot-post-table.hh
@@ -72,221 +72,221 @@ struct postV2Tail
 struct post
 {
   enum { tableTag = HB_OT_TAG_post };
 
   bool subset (hb_subset_plan_t *plan) const
   {
     unsigned int post_prime_length;
     hb_blob_t *post_blob = hb_sanitize_context_t ().reference_table<post>(plan->source);
     hb_blob_t *post_prime_blob = hb_blob_create_sub_blob (post_blob, 0, post::min_size);
     post *post_prime = (post *) hb_blob_get_data_writable (post_prime_blob, &post_prime_length);
     hb_blob_destroy (post_blob);
 
     if (unlikely (!post_prime || post_prime_length != post::min_size))
     {
       hb_blob_destroy (post_prime_blob);
       DEBUG_MSG(SUBSET, nullptr, "Invalid source post table with length %d.", post_prime_length);
       return false;
     }
 
     post_prime->version.major.set (3); // Version 3 does not have any glyph names.
     bool result = plan->add_table (HB_OT_TAG_post, post_prime_blob);
     hb_blob_destroy (post_prime_blob);
 
     return result;
   }
 
   struct accelerator_t
   {
     void init (hb_face_t *face)
     {
       index_to_offset.init ();
 
       table = hb_sanitize_context_t ().reference_table<post> (face);
       unsigned int table_length = table.get_length ();
 
       version = table->version.to_int ();
       if (version != 0x00020000) return;
 
       const postV2Tail &v2 = table->v2X;
 
       glyphNameIndex = &v2.glyphNameIndex;
       pool = &StructAfter<uint8_t> (v2.glyphNameIndex);
 
       const uint8_t *end = (const uint8_t *) (const void *) table + table_length;
       for (const uint8_t *data = pool;
 	   index_to_offset.length < 65535 && data < end && data + *data < end;
 	   data += 1 + *data)
 	index_to_offset.push (data - pool);
     }
     void fini ()
     {
       index_to_offset.fini ();
       free (gids_sorted_by_name.get ());
       table.destroy ();
     }
 
     bool get_glyph_name (hb_codepoint_t glyph,
 			 char *buf, unsigned int buf_len) const
     {
       hb_bytes_t s = find_glyph_name (glyph);
       if (!s.length) return false;
       if (!buf_len) return true;
       unsigned int len = MIN (buf_len - 1, s.length);
       strncpy (buf, s.arrayZ, len);
       buf[len] = '\0';
       return true;
     }
 
     bool get_glyph_from_name (const char *name, int len,
 			      hb_codepoint_t *glyph) const
     {
       unsigned int count = get_glyph_count ();
       if (unlikely (!count)) return false;
 
       if (len < 0) len = strlen (name);
 
       if (unlikely (!len)) return false;
 
     retry:
       uint16_t *gids = gids_sorted_by_name.get ();
 
       if (unlikely (!gids))
       {
 	gids = (uint16_t *) malloc (count * sizeof (gids[0]));
 	if (unlikely (!gids))
 	  return false; /* Anything better?! */
 
 	for (unsigned int i = 0; i < count; i++)
 	  gids[i] = i;
 	hb_sort_r (gids, count, sizeof (gids[0]), cmp_gids, (void *) this);
 
 	if (unlikely (!gids_sorted_by_name.cmpexch (nullptr, gids)))
 	{
 	  free (gids);
 	  goto retry;
 	}
       }
 
       hb_bytes_t st (name, len);
       const uint16_t *gid = (const uint16_t *) hb_bsearch_r (hb_addressof (st), gids, count,
 							     sizeof (gids[0]), cmp_key, (void *) this);
       if (gid)
       {
 	*glyph = *gid;
 	return true;
       }
 
       return false;
     }
 
     protected:
 
     unsigned int get_glyph_count () const
     {
       if (version == 0x00010000)
 	return NUM_FORMAT1_NAMES;
 
       if (version == 0x00020000)
 	return glyphNameIndex->len;
 
       return 0;
     }
 
     static int cmp_gids (const void *pa, const void *pb, void *arg)
     {
       const accelerator_t *thiz = (const accelerator_t *) arg;
       uint16_t a = * (const uint16_t *) pa;
       uint16_t b = * (const uint16_t *) pb;
       return thiz->find_glyph_name (b).cmp (thiz->find_glyph_name (a));
     }
 
     static int cmp_key (const void *pk, const void *po, void *arg)
     {
       const accelerator_t *thiz = (const accelerator_t *) arg;
       const hb_bytes_t *key = (const hb_bytes_t *) pk;
       uint16_t o = * (const uint16_t *) po;
       return thiz->find_glyph_name (o).cmp (*key);
     }
 
     hb_bytes_t find_glyph_name (hb_codepoint_t glyph) const
     {
       if (version == 0x00010000)
       {
 	if (glyph >= NUM_FORMAT1_NAMES)
 	  return hb_bytes_t ();
 
 	return format1_names (glyph);
       }
 
       if (version != 0x00020000 || glyph >= glyphNameIndex->len)
 	return hb_bytes_t ();
 
       unsigned int index = glyphNameIndex->arrayZ[glyph];
       if (index < NUM_FORMAT1_NAMES)
 	return format1_names (index);
       index -= NUM_FORMAT1_NAMES;
 
       if (index >= index_to_offset.length)
 	return hb_bytes_t ();
       unsigned int offset = index_to_offset[index];
 
       const uint8_t *data = pool + offset;
       unsigned int name_length = *data;
       data++;
 
       return hb_bytes_t ((const char *) data, name_length);
     }
 
     private:
     hb_blob_ptr_t<post> table;
     uint32_t version;
     const ArrayOf<HBUINT16> *glyphNameIndex;
-    hb_vector_t<uint32_t, 1> index_to_offset;
+    hb_vector_t<uint32_t> index_to_offset;
     const uint8_t *pool;
     hb_atomic_ptr_t<uint16_t *> gids_sorted_by_name;
   };
 
   bool sanitize (hb_sanitize_context_t *c) const
   {
     TRACE_SANITIZE (this);
     return_trace (likely (c->check_struct (this) &&
 			  (version.to_int () == 0x00010000 ||
 			   (version.to_int () == 0x00020000 && v2X.sanitize (c)) ||
 			   version.to_int () == 0x00030000)));
   }
 
   public:
   FixedVersion<>version;		/* 0x00010000 for version 1.0
 					 * 0x00020000 for version 2.0
 					 * 0x00025000 for version 2.5 (deprecated)
 					 * 0x00030000 for version 3.0 */
   Fixed		italicAngle;		/* Italic angle in counter-clockwise degrees
 					 * from the vertical. Zero for upright text,
 					 * negative for text that leans to the right
 					 * (forward). */
   FWORD		underlinePosition;	/* This is the suggested distance of the top
 					 * of the underline from the baseline
 					 * (negative values indicate below baseline).
 					 * The PostScript definition of this FontInfo
 					 * dictionary key (the y coordinate of the
 					 * center of the stroke) is not used for
 					 * historical reasons. The value of the
 					 * PostScript key may be calculated by
 					 * subtracting half the underlineThickness
 					 * from the value of this field. */
   FWORD		underlineThickness;	/* Suggested values for the underline
 					   thickness. */
   HBUINT32	isFixedPitch;		/* Set to 0 if the font is proportionally
 					 * spaced, non-zero if the font is not
 					 * proportionally spaced (i.e. monospaced). */
   HBUINT32	minMemType42;		/* Minimum memory usage when an OpenType font
 					 * is downloaded. */
   HBUINT32	maxMemType42;		/* Maximum memory usage when an OpenType font
 					 * is downloaded. */
   HBUINT32	minMemType1;		/* Minimum memory usage when an OpenType font
 					 * is downloaded as a Type 1 font. */
   HBUINT32	maxMemType1;		/* Maximum memory usage when an OpenType font
 					 * is downloaded as a Type 1 font. */
   postV2Tail	v2X;
   DEFINE_SIZE_MIN (32);
 };
diff --git a/src/hb-set.hh b/src/hb-set.hh
index 725fa3393..990c2953c 100644
--- a/src/hb-set.hh
+++ b/src/hb-set.hh
@@ -40,699 +40,699 @@
 struct hb_set_t
 {
   HB_NO_COPY_ASSIGN (hb_set_t);
   hb_set_t ()  { init (); }
   ~hb_set_t () { fini (); }
 
   struct page_map_t
   {
     int cmp (const page_map_t &o) const { return (int) o.major - (int) major; }
 
     uint32_t major;
     uint32_t index;
   };
 
   struct page_t
   {
     void init0 () { v.clear (); }
     void init1 () { v.clear (0xFF); }
 
     unsigned int len () const
     { return ARRAY_LENGTH_CONST (v); }
 
     bool is_empty () const
     {
       for (unsigned int i = 0; i < len (); i++)
         if (v[i])
 	  return false;
       return true;
     }
 
     void add (hb_codepoint_t g) { elt (g) |= mask (g); }
     void del (hb_codepoint_t g) { elt (g) &= ~mask (g); }
     bool has (hb_codepoint_t g) const { return !!(elt (g) & mask (g)); }
 
     void add_range (hb_codepoint_t a, hb_codepoint_t b)
     {
       elt_t *la = &elt (a);
       elt_t *lb = &elt (b);
       if (la == lb)
         *la |= (mask (b) << 1) - mask(a);
       else
       {
 	*la |= ~(mask (a) - 1);
 	la++;
 
 	memset (la, 0xff, (char *) lb - (char *) la);
 
 	*lb |= ((mask (b) << 1) - 1);
       }
     }
 
     bool is_equal (const page_t *other) const
     {
       return 0 == hb_memcmp (&v, &other->v, sizeof (v));
     }
 
     unsigned int get_population () const
     {
       unsigned int pop = 0;
       for (unsigned int i = 0; i < len (); i++)
         pop += hb_popcount (v[i]);
       return pop;
     }
 
     bool next (hb_codepoint_t *codepoint) const
     {
       unsigned int m = (*codepoint + 1) & MASK;
       if (!m)
       {
 	*codepoint = INVALID;
 	return false;
       }
       unsigned int i = m / ELT_BITS;
       unsigned int j = m & ELT_MASK;
 
       const elt_t vv = v[i] & ~((elt_t (1) << j) - 1);
       for (const elt_t *p = &vv; i < len (); p = &v[++i])
 	if (*p)
 	{
 	  *codepoint = i * ELT_BITS + elt_get_min (*p);
 	  return true;
 	}
 
       *codepoint = INVALID;
       return false;
     }
     bool previous (hb_codepoint_t *codepoint) const
     {
       unsigned int m = (*codepoint - 1) & MASK;
       if (m == MASK)
       {
 	*codepoint = INVALID;
 	return false;
       }
       unsigned int i = m / ELT_BITS;
       unsigned int j = m & ELT_MASK;
 
       const elt_t vv = v[i] & ((elt_t (1) << (j + 1)) - 1);
       for (const elt_t *p = &vv; (int) i >= 0; p = &v[--i])
 	if (*p)
 	{
 	  *codepoint = i * ELT_BITS + elt_get_max (*p);
 	  return true;
 	}
 
       *codepoint = INVALID;
       return false;
     }
     hb_codepoint_t get_min () const
     {
       for (unsigned int i = 0; i < len (); i++)
         if (v[i])
 	  return i * ELT_BITS + elt_get_min (v[i]);
       return INVALID;
     }
     hb_codepoint_t get_max () const
     {
       for (int i = len () - 1; i >= 0; i--)
         if (v[i])
 	  return i * ELT_BITS + elt_get_max (v[i]);
       return 0;
     }
 
     typedef unsigned long long elt_t;
     enum { PAGE_BITS = 512 };
     static_assert ((PAGE_BITS & ((PAGE_BITS) - 1)) == 0, "");
 
     static unsigned int elt_get_min (const elt_t &elt) { return hb_ctz (elt); }
     static unsigned int elt_get_max (const elt_t &elt) { return hb_bit_storage (elt) - 1; }
 
     typedef hb_vector_size_t<elt_t, PAGE_BITS / 8> vector_t;
 
     enum { ELT_BITS = sizeof (elt_t) * 8 };
     enum { ELT_MASK = ELT_BITS - 1 };
     enum { BITS = sizeof (vector_t) * 8 };
     enum { MASK = BITS - 1 };
     static_assert ((unsigned) PAGE_BITS == (unsigned) BITS, "");
 
     elt_t &elt (hb_codepoint_t g) { return v[(g & MASK) / ELT_BITS]; }
     elt_t const &elt (hb_codepoint_t g) const { return v[(g & MASK) / ELT_BITS]; }
     elt_t mask (hb_codepoint_t g) const { return elt_t (1) << (g & ELT_MASK); }
 
     vector_t v;
   };
   static_assert (page_t::PAGE_BITS == sizeof (page_t) * 8, "");
 
   hb_object_header_t header;
   bool successful; /* Allocations successful */
   mutable unsigned int population;
-  hb_vector_t<page_map_t, 1> page_map;
-  hb_vector_t<page_t, 1> pages;
+  hb_vector_t<page_map_t> page_map;
+  hb_vector_t<page_t> pages;
 
   void init_shallow ()
   {
     successful = true;
     population = 0;
     page_map.init ();
     pages.init ();
   }
   void init ()
   {
     hb_object_init (this);
     init_shallow ();
   }
   void fini_shallow ()
   {
     population = 0;
     page_map.fini ();
     pages.fini ();
   }
   void fini ()
   {
     hb_object_fini (this);
     fini_shallow ();
   }
 
   bool in_error () const { return !successful; }
 
   bool resize (unsigned int count)
   {
     if (unlikely (!successful)) return false;
     if (!pages.resize (count) || !page_map.resize (count))
     {
       pages.resize (page_map.length);
       successful = false;
       return false;
     }
     return true;
   }
 
   void clear ()
   {
     if (unlikely (hb_object_is_immutable (this)))
       return;
     successful = true;
     population = 0;
     page_map.resize (0);
     pages.resize (0);
   }
   bool is_empty () const
   {
     unsigned int count = pages.length;
     for (unsigned int i = 0; i < count; i++)
       if (!pages[i].is_empty ())
         return false;
     return true;
   }
 
   void dirty () { population = (unsigned int) -1; }
 
   void add (hb_codepoint_t g)
   {
     if (unlikely (!successful)) return;
     if (unlikely (g == INVALID)) return;
     dirty ();
     page_t *page = page_for_insert (g); if (unlikely (!page)) return;
     page->add (g);
   }
   bool add_range (hb_codepoint_t a, hb_codepoint_t b)
   {
     if (unlikely (!successful)) return true; /* https://github.com/harfbuzz/harfbuzz/issues/657 */
     if (unlikely (a > b || a == INVALID || b == INVALID)) return false;
     dirty ();
     unsigned int ma = get_major (a);
     unsigned int mb = get_major (b);
     if (ma == mb)
     {
       page_t *page = page_for_insert (a); if (unlikely (!page)) return false;
       page->add_range (a, b);
     }
     else
     {
       page_t *page = page_for_insert (a); if (unlikely (!page)) return false;
       page->add_range (a, major_start (ma + 1) - 1);
 
       for (unsigned int m = ma + 1; m < mb; m++)
       {
 	page = page_for_insert (major_start (m)); if (unlikely (!page)) return false;
 	page->init1 ();
       }
 
       page = page_for_insert (b); if (unlikely (!page)) return false;
       page->add_range (major_start (mb), b);
     }
     return true;
   }
 
   template <typename T>
   void add_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
   {
     if (unlikely (!successful)) return;
     if (!count) return;
     dirty ();
     hb_codepoint_t g = *array;
     while (count)
     {
       unsigned int m = get_major (g);
       page_t *page = page_for_insert (g); if (unlikely (!page)) return;
       unsigned int start = major_start (m);
       unsigned int end = major_start (m + 1);
       do
       {
 	page->add (g);
 
 	array = (const T *) ((const char *) array + stride);
 	count--;
       }
       while (count && (g = *array, start <= g && g < end));
     }
   }
 
   /* Might return false if array looks unsorted.
    * Used for faster rejection of corrupt data. */
   template <typename T>
   bool add_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
   {
     if (unlikely (!successful)) return true; /* https://github.com/harfbuzz/harfbuzz/issues/657 */
     if (!count) return true;
     dirty ();
     hb_codepoint_t g = *array;
     hb_codepoint_t last_g = g;
     while (count)
     {
       unsigned int m = get_major (g);
       page_t *page = page_for_insert (g); if (unlikely (!page)) return false;
       unsigned int end = major_start (m + 1);
       do
       {
         /* If we try harder we can change the following comparison to <=;
 	 * Not sure if it's worth it. */
         if (g < last_g) return false;
 	last_g = g;
 	page->add (g);
 
 	array = (const T *) ((const char *) array + stride);
 	count--;
       }
       while (count && (g = *array, g < end));
     }
     return true;
   }
 
   void del (hb_codepoint_t g)
   {
     /* TODO perform op even if !successful. */
     if (unlikely (!successful)) return;
     page_t *page = page_for (g);
     if (!page)
       return;
     dirty ();
     page->del (g);
   }
   void del_range (hb_codepoint_t a, hb_codepoint_t b)
   {
     /* TODO perform op even if !successful. */
     /* TODO Optimize, like add_range(). */
     if (unlikely (!successful)) return;
     for (unsigned int i = a; i < b + 1; i++)
       del (i);
   }
   bool has (hb_codepoint_t g) const
   {
     const page_t *page = page_for (g);
     if (!page)
       return false;
     return page->has (g);
   }
   bool intersects (hb_codepoint_t first,
 			  hb_codepoint_t last) const
   {
     hb_codepoint_t c = first - 1;
     return next (&c) && c <= last;
   }
   void set (const hb_set_t *other)
   {
     if (unlikely (!successful)) return;
     unsigned int count = other->pages.length;
     if (!resize (count))
       return;
     population = other->population;
     memcpy ((void *) pages, (const void *) other->pages, count * pages.item_size);
     memcpy ((void *) page_map, (const void *) other->page_map, count * page_map.item_size);
   }
 
   bool is_equal (const hb_set_t *other) const
   {
     if (get_population () != other->get_population ())
       return false;
 
     unsigned int na = pages.length;
     unsigned int nb = other->pages.length;
 
     unsigned int a = 0, b = 0;
     for (; a < na && b < nb; )
     {
       if (page_at (a).is_empty ()) { a++; continue; }
       if (other->page_at (b).is_empty ()) { b++; continue; }
       if (page_map[a].major != other->page_map[b].major ||
 	  !page_at (a).is_equal (&other->page_at (b)))
         return false;
       a++;
       b++;
     }
     for (; a < na; a++)
       if (!page_at (a).is_empty ()) { return false; }
     for (; b < nb; b++)
       if (!other->page_at (b).is_empty ()) { return false; }
 
     return true;
   }
 
   bool is_subset (const hb_set_t *larger_set) const
   {
     if (get_population () > larger_set->get_population ())
       return false;
 
     /* TODO Optimize to use pages. */
     hb_codepoint_t c = INVALID;
     while (next (&c))
       if (!larger_set->has (c))
         return false;
 
     return true;
   }
 
   template <class Op>
   void process (const hb_set_t *other)
   {
     if (unlikely (!successful)) return;
 
     dirty ();
 
     unsigned int na = pages.length;
     unsigned int nb = other->pages.length;
     unsigned int next_page = na;
 
     unsigned int count = 0, newCount = 0;
     unsigned int a = 0, b = 0;
     for (; a < na && b < nb; )
     {
       if (page_map[a].major == other->page_map[b].major)
       {
         count++;
 	a++;
 	b++;
       }
       else if (page_map[a].major < other->page_map[b].major)
       {
         if (Op::passthru_left)
 	  count++;
         a++;
       }
       else
       {
         if (Op::passthru_right)
 	  count++;
         b++;
       }
     }
     if (Op::passthru_left)
       count += na - a;
     if (Op::passthru_right)
       count += nb - b;
 
     if (count > pages.length)
       if (!resize (count))
         return;
     newCount = count;
 
     /* Process in-place backward. */
     a = na;
     b = nb;
     for (; a && b; )
     {
       if (page_map[a - 1].major == other->page_map[b - 1].major)
       {
 	a--;
 	b--;
 	count--;
 	page_map[count] = page_map[a];
 	Op::process (page_at (count).v, page_at (a).v, other->page_at (b).v);
       }
       else if (page_map[a - 1].major > other->page_map[b - 1].major)
       {
 	a--;
 	if (Op::passthru_left)
 	{
 	  count--;
 	  page_map[count] = page_map[a];
 	}
       }
       else
       {
 	b--;
 	if (Op::passthru_right)
 	{
 	  count--;
 	  page_map[count].major = other->page_map[b].major;
 	  page_map[count].index = next_page++;
 	  page_at (count).v = other->page_at (b).v;
 	}
       }
     }
     if (Op::passthru_left)
       while (a)
       {
 	a--;
 	count--;
 	page_map[count] = page_map [a];
       }
     if (Op::passthru_right)
       while (b)
       {
 	b--;
 	count--;
 	page_map[count].major = other->page_map[b].major;
 	page_map[count].index = next_page++;
 	page_at (count).v = other->page_at (b).v;
       }
     assert (!count);
     if (pages.length > newCount)
       resize (newCount);
   }
 
   void union_ (const hb_set_t *other)
   {
     process<HbOpOr> (other);
   }
   void intersect (const hb_set_t *other)
   {
     process<HbOpAnd> (other);
   }
   void subtract (const hb_set_t *other)
   {
     process<HbOpMinus> (other);
   }
   void symmetric_difference (const hb_set_t *other)
   {
     process<HbOpXor> (other);
   }
   bool next (hb_codepoint_t *codepoint) const
   {
     if (unlikely (*codepoint == INVALID)) {
       *codepoint = get_min ();
       return *codepoint != INVALID;
     }
 
     page_map_t map = {get_major (*codepoint), 0};
     unsigned int i;
     page_map.bfind (map, &i, HB_BFIND_NOT_FOUND_STORE_CLOSEST);
     if (i < page_map.length && page_map[i].major == map.major)
     {
       if (pages[page_map[i].index].next (codepoint))
       {
 	*codepoint += page_map[i].major * page_t::PAGE_BITS;
 	return true;
       }
       i++;
     }
     for (; i < page_map.length; i++)
     {
       hb_codepoint_t m = pages[page_map[i].index].get_min ();
       if (m != INVALID)
       {
 	*codepoint = page_map[i].major * page_t::PAGE_BITS + m;
 	return true;
       }
     }
     *codepoint = INVALID;
     return false;
   }
   bool previous (hb_codepoint_t *codepoint) const
   {
     if (unlikely (*codepoint == INVALID)) {
       *codepoint = get_max ();
       return *codepoint != INVALID;
     }
 
     page_map_t map = {get_major (*codepoint), 0};
     unsigned int i;
     page_map.bfind (map, &i, HB_BFIND_NOT_FOUND_STORE_CLOSEST);
     if (i < page_map.length && page_map[i].major == map.major)
     {
       if (pages[page_map[i].index].previous (codepoint))
       {
 	*codepoint += page_map[i].major * page_t::PAGE_BITS;
 	return true;
       }
     }
     i--;
     for (; (int) i >= 0; i--)
     {
       hb_codepoint_t m = pages[page_map[i].index].get_max ();
       if (m != INVALID)
       {
 	*codepoint = page_map[i].major * page_t::PAGE_BITS + m;
 	return true;
       }
     }
     *codepoint = INVALID;
     return false;
   }
   bool next_range (hb_codepoint_t *first, hb_codepoint_t *last) const
   {
     hb_codepoint_t i;
 
     i = *last;
     if (!next (&i))
     {
       *last = *first = INVALID;
       return false;
     }
 
     /* TODO Speed up. */
     *last = *first = i;
     while (next (&i) && i == *last + 1)
       (*last)++;
 
     return true;
   }
   bool previous_range (hb_codepoint_t *first, hb_codepoint_t *last) const
   {
     hb_codepoint_t i;
 
     i = *first;
     if (!previous (&i))
     {
       *last = *first = INVALID;
       return false;
     }
 
     /* TODO Speed up. */
     *last = *first = i;
     while (previous (&i) && i == *first - 1)
       (*first)--;
 
     return true;
   }
 
   unsigned int get_population () const
   {
     if (population != (unsigned int) -1)
       return population;
 
     unsigned int pop = 0;
     unsigned int count = pages.length;
     for (unsigned int i = 0; i < count; i++)
       pop += pages[i].get_population ();
 
     population = pop;
     return pop;
   }
   hb_codepoint_t get_min () const
   {
     unsigned int count = pages.length;
     for (unsigned int i = 0; i < count; i++)
       if (!page_at (i).is_empty ())
         return page_map[i].major * page_t::PAGE_BITS + page_at (i).get_min ();
     return INVALID;
   }
   hb_codepoint_t get_max () const
   {
     unsigned int count = pages.length;
     for (int i = count - 1; i >= 0; i++)
       if (!page_at (i).is_empty ())
         return page_map[(unsigned) i].major * page_t::PAGE_BITS + page_at (i).get_max ();
     return INVALID;
   }
 
   static  const hb_codepoint_t INVALID = HB_SET_VALUE_INVALID;
 
   /*
    * Iterator implementation.
    */
   struct const_iter_t : hb_sorted_iter_t<const_iter_t, const hb_codepoint_t>
   {
     const_iter_t (const hb_set_t &s_) :
       s (s_), v (INVALID), l (s.get_population () + 1) { __next__ (); }
 
     typedef hb_codepoint_t __item_type__;
     hb_codepoint_t __item__ () const { return v; }
     bool __more__ () const { return v != INVALID; }
     void __next__ () { s.next (&v); if (l) l--; }
     void __prev__ () { s.previous (&v); }
     unsigned __len__ () { return l; }
 
     protected:
     const hb_set_t &s;
     hb_codepoint_t v;
     unsigned l;
   };
   const_iter_t const_iter () const { return const_iter_t (*this); }
   operator const_iter_t () const { return const_iter (); }
   typedef const_iter_t iter_t;
   iter_t iter () const { return const_iter (); }
 
   protected:
 
   page_t *page_for_insert (hb_codepoint_t g)
   {
     page_map_t map = {get_major (g), pages.length};
     unsigned int i;
     if (!page_map.bfind (map, &i, HB_BFIND_NOT_FOUND_STORE_CLOSEST))
     {
       if (!resize (pages.length + 1))
 	return nullptr;
 
       pages[map.index].init0 ();
       memmove (page_map + i + 1,
 	       page_map + i,
 	       (page_map.length - 1 - i) * page_map.item_size);
       page_map[i] = map;
     }
     return &pages[page_map[i].index];
   }
   page_t *page_for (hb_codepoint_t g)
   {
     page_map_t key = {get_major (g)};
     const page_map_t *found = page_map.bsearch (key);
     if (found)
       return &pages[found->index];
     return nullptr;
   }
   const page_t *page_for (hb_codepoint_t g) const
   {
     page_map_t key = {get_major (g)};
     const page_map_t *found = page_map.bsearch (key);
     if (found)
       return &pages[found->index];
     return nullptr;
   }
   page_t &page_at (unsigned int i) { return pages[page_map[i].index]; }
   const page_t &page_at (unsigned int i) const { return pages[page_map[i].index]; }
   unsigned int get_major (hb_codepoint_t g) const { return g / page_t::PAGE_BITS; }
   hb_codepoint_t major_start (unsigned int major) const { return major * page_t::PAGE_BITS; }
 };
 
 
 #endif /* HB_SET_HH */
diff --git a/src/hb-vector.hh b/src/hb-vector.hh
index 9aa930989..7d615bf6a 100644
--- a/src/hb-vector.hh
+++ b/src/hb-vector.hh
@@ -32,241 +32,229 @@
 #include "hb-null.hh"
 
 
-template <typename Type, unsigned int PreallocedCount=2>
+template <typename Type>
 struct hb_vector_t
 {
   typedef Type item_t;
   enum { item_size = hb_static_size (Type) };
 
-  HB_NO_COPY_ASSIGN_TEMPLATE2 (hb_vector_t, Type, PreallocedCount);
+  HB_NO_COPY_ASSIGN_TEMPLATE (hb_vector_t, Type);
   hb_vector_t ()  { init (); }
   ~hb_vector_t () { fini (); }
 
   unsigned int length;
   private:
   int allocated; /* == -1 means allocation failed. */
   Type *arrayZ_;
-  Type static_array[PreallocedCount];
   public:
 
   void init ()
   {
-    length = 0;
-    allocated = ARRAY_LENGTH (static_array);
+    allocated = length = 0;
     arrayZ_ = nullptr;
   }
 
   void fini ()
   {
     if (arrayZ_)
       free (arrayZ_);
     init ();
   }
   void fini_deep ()
   {
     Type *array = arrayZ();
     unsigned int count = length;
     for (unsigned int i = 0; i < count; i++)
       array[i].fini ();
     fini ();
   }
 
-  const Type * arrayZ () const { return arrayZ_ ? arrayZ_ : static_array; }
-        Type * arrayZ ()       { return arrayZ_ ? arrayZ_ : static_array; }
+  const Type * arrayZ () const { return arrayZ_; }
+        Type * arrayZ ()       { return arrayZ_; }
 
   Type& operator [] (int i_)
   {
     unsigned int i = (unsigned int) i_;
     if (unlikely (i >= length))
       return Crap (Type);
     return arrayZ()[i];
   }
   const Type& operator [] (int i_) const
   {
     unsigned int i = (unsigned int) i_;
     if (unlikely (i >= length))
       return Null(Type);
     return arrayZ()[i];
   }
 
   explicit_operator bool () const { return length; }
 
   hb_array_t<Type> as_array ()
   { return hb_array (arrayZ(), length); }
   hb_array_t<const Type> as_array () const
   { return hb_array (arrayZ(), length); }
 
   hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int count) const
   { return as_array ().sub_array (start_offset, count);}
   hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr /* IN/OUT */) const
   { return as_array ().sub_array (start_offset, count);}
   hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int count)
   { return as_array ().sub_array (start_offset, count);}
   hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr /* IN/OUT */)
   { return as_array ().sub_array (start_offset, count);}
 
   hb_sorted_array_t<Type> as_sorted_array ()
   { return hb_sorted_array (arrayZ(), length); }
   hb_sorted_array_t<const Type> as_sorted_array () const
   { return hb_sorted_array (arrayZ(), length); }
 
   hb_array_t<const Type> sorted_sub_array (unsigned int start_offset, unsigned int count) const
   { return as_sorted_array ().sorted_sub_array (start_offset, count);}
   hb_array_t<const Type> sorted_sub_array (unsigned int start_offset, unsigned int *count = nullptr /* IN/OUT */) const
   { return as_sorted_array ().sorted_sub_array (start_offset, count);}
   hb_array_t<Type> sorted_sub_array (unsigned int start_offset, unsigned int count)
   { return as_sorted_array ().sorted_sub_array (start_offset, count);}
   hb_array_t<Type> sorted_sub_array (unsigned int start_offset, unsigned int *count = nullptr /* IN/OUT */)
   { return as_sorted_array ().sorted_sub_array (start_offset, count);}
 
   template <typename T> explicit_operator T * () { return arrayZ(); }
   template <typename T> explicit_operator const T * () const { return arrayZ(); }
   operator hb_array_t<Type> ()             { return as_array (); }
   operator hb_array_t<const Type> () const { return as_array (); }
 
   Type * operator  + (unsigned int i) { return arrayZ() + i; }
   const Type * operator  + (unsigned int i) const { return arrayZ() + i; }
 
   Type *push ()
   {
     if (unlikely (!resize (length + 1)))
       return &Crap(Type);
     return &arrayZ()[length - 1];
   }
   Type *push (const Type& v)
   {
     Type *p = push ();
     *p = v;
     return p;
   }
 
   bool in_error () const { return allocated < 0; }
 
   /* Allocate for size but don't adjust length. */
   bool alloc (unsigned int size)
   {
     if (unlikely (allocated < 0))
       return false;
 
     if (likely (size <= allocated))
       return true;
 
     /* Reallocate */
 
     unsigned int new_allocated = allocated;
     while (size >= new_allocated)
       new_allocated += (new_allocated >> 1) + 8;
 
     Type *new_array = nullptr;
-
-    if (!arrayZ_)
-    {
-      new_array = (Type *) calloc (new_allocated, sizeof (Type));
-      if (new_array)
-        memcpy (new_array, static_array, length * sizeof (Type));
-    }
-    else
-    {
-      bool overflows =
-	(int) new_allocated < 0 ||
-        (new_allocated < allocated) ||
-	hb_unsigned_mul_overflows (new_allocated, sizeof (Type));
-      if (likely (!overflows))
-        new_array = (Type *) realloc (arrayZ_, new_allocated * sizeof (Type));
-    }
+    bool overflows =
+      (int) new_allocated < 0 ||
+      (new_allocated < allocated) ||
+      hb_unsigned_mul_overflows (new_allocated, sizeof (Type));
+    if (likely (!overflows))
+      new_array = (Type *) realloc (arrayZ_, new_allocated * sizeof (Type));
 
     if (unlikely (!new_array))
     {
       allocated = -1;
       return false;
     }
 
     arrayZ_ = new_array;
     allocated = new_allocated;
 
     return true;
   }
 
   bool resize (int size_)
   {
     unsigned int size = size_ < 0 ? 0u : (unsigned int) size_;
     if (!alloc (size))
       return false;
 
     if (size > length)
       memset (arrayZ() + length, 0, (size - length) * sizeof (*arrayZ()));
 
     length = size;
     return true;
   }
 
   void pop ()
   {
     if (!length) return;
     length--;
   }
 
   void remove (unsigned int i)
   {
     if (unlikely (i >= length))
       return;
     Type *array = arrayZ();
     memmove (static_cast<void *> (&array[i]),
 	     static_cast<void *> (&array[i + 1]),
 	     (length - i - 1) * sizeof (Type));
     length--;
   }
 
   void shrink (int size_)
   {
     unsigned int size = size_ < 0 ? 0u : (unsigned int) size_;
      if (size < length)
        length = size;
   }
 
   template <typename T>
   Type *find (T v)
   {
     Type *array = arrayZ();
     for (unsigned int i = 0; i < length; i++)
       if (array[i] == v)
 	return &array[i];
     return nullptr;
   }
   template <typename T>
   const Type *find (T v) const
   {
     const Type *array = arrayZ();
     for (unsigned int i = 0; i < length; i++)
       if (array[i] == v)
 	return &array[i];
     return nullptr;
   }
 
   void qsort (int (*cmp)(const void*, const void*))
   { as_array ().qsort (cmp); }
   void qsort (unsigned int start = 0, unsigned int end = (unsigned int) -1)
   { as_array ().qsort (start, end); }
 
   template <typename T>
   Type *lsearch (const T &x, Type *not_found = nullptr)
   { return as_array ().lsearch (x, not_found); }
   template <typename T>
   const Type *lsearch (const T &x, const Type *not_found = nullptr) const
   { return as_array ().lsearch (x, not_found); }
 
   template <typename T>
   Type *bsearch (const T &x, Type *not_found = nullptr)
   { return as_sorted_array ().bsearch (x, not_found); }
   template <typename T>
   const Type *bsearch (const T &x, const Type *not_found = nullptr) const
   { return as_sorted_array ().bsearch (x, not_found); }
   template <typename T>
   bool bfind (const T &x, unsigned int *i = nullptr,
 		     hb_bfind_not_found_t not_found = HB_BFIND_NOT_FOUND_DONT_STORE,
 		     unsigned int to_store = (unsigned int) -1) const
   { return as_sorted_array ().bfind (x, i, not_found, to_store); }
 };
 
 
 #endif /* HB_VECTOR_HH */
diff --git a/src/hb.hh b/src/hb.hh
index d604d958e..c6db70aed 100644
--- a/src/hb.hh
+++ b/src/hb.hh
@@ -368,62 +368,65 @@ static_assert ((sizeof (hb_mask_t) == 4), "");
 static_assert ((sizeof (hb_var_int_t) == 4), "");
 
 
 #if __cplusplus >= 201103L
 
 /* We only enable these with C++11 or later, since earlier language
  * does not allow structs with constructors in unions, and we need
  * those. */
 
 #define HB_NO_COPY_ASSIGN(TypeName) \
   TypeName(const TypeName&); \
   void operator=(const TypeName&)
+#define HB_NO_COPY_ASSIGN_TEMPLATE(TypeName, T) \
+  TypeName(const TypeName<T>&); \
+  void operator=(const TypeName<T>&)
 #define HB_NO_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) \
   TypeName(const TypeName<T1, T2>&); \
   void operator=(const TypeName<T1, T2>&)
 #define HB_NO_CREATE_COPY_ASSIGN(TypeName) \
   TypeName(); \
   TypeName(const TypeName&); \
   void operator=(const TypeName&)
 #define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE(TypeName, T) \
   TypeName(); \
   TypeName(const TypeName<T>&); \
   void operator=(const TypeName<T>&)
 #define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) \
   TypeName(); \
   TypeName(const TypeName<T1, T2>&); \
   void operator=(const TypeName<T1, T2>&)
 
 #else /* __cpluspplus >= 201103L */
 
 #define HB_NO_COPY_ASSIGN(TypeName) static_assert (true, "")
 #define HB_NO_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) static_assert (true, "")
 #define HB_NO_CREATE_COPY_ASSIGN(TypeName) static_assert (true, "")
 #define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE(TypeName, T) static_assert (true, "")
 #define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) static_assert (true, "")
 
 #endif /* __cpluspplus >= 201103L */
 
 
 /*
  * Compiler-assisted vectorization parameters.
  */
 
 /*
  * Disable vectorization for now.  To correctly use them, we should
  * use posix_memalign() to allocate in hb_vector_t.  Otherwise, can
  * cause misaligned access.
  *
  * https://bugs.chromium.org/p/chromium/issues/detail?id=860184
  */
 #if !defined(HB_VECTOR_SIZE)
 #  define HB_VECTOR_SIZE 0
 #endif
 
 /* The `vector_size' attribute was introduced in gcc 3.1. */
 #if !defined(HB_VECTOR_SIZE)
 #  if defined( __GNUC__ ) && ( __GNUC__ >= 4 )
 #    define HB_VECTOR_SIZE 128
 #  else
 #    define HB_VECTOR_SIZE 0
 #  endif
 #endif
