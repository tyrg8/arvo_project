commit b56a48eb78a10063c308120302f2496db6488369
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Wed Oct 4 13:41:38 2023 -0400

    respect time to live for Fx option

diff --git a/MagickCore/cache.c b/MagickCore/cache.c
index f4f199353..666a15bb7 100644
--- a/MagickCore/cache.c
+++ b/MagickCore/cache.c
@@ -1683,123 +1683,126 @@ static inline MagickBooleanType ValidatePixelCacheMorphology(
 static Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,
   ExceptionInfo *exception)
 {
   CacheInfo
     *magick_restrict cache_info;
 
   MagickBooleanType
     destroy,
     status;
 
   static MagickSizeType
     cpu_throttle = MagickResourceInfinity,
     cycles = 0;
 
   status=MagickTrue;
   if (cpu_throttle == MagickResourceInfinity)
     cpu_throttle=GetMagickResourceLimit(ThrottleResource);
-  if ((cpu_throttle != 0) && ((cycles++ % 4096) == 0))
-    MagickDelay(cpu_throttle);
-  if (GetMagickTTL() <= 0)
+  if ((cycles++ % 4096) == 0)
     {
+      if (GetMagickTTL() <= 0)
+        {
 #if defined(ECANCELED)
-      errno=ECANCELED;
+          errno=ECANCELED;
 #endif
-      cache_info=(CacheInfo *) image->cache;
-      if (cache_info->file != -1)
-        (void) ClosePixelCacheOnDisk(cache_info);
-      (void) ThrowMagickException(exception,GetMagickModule(),
-        ResourceLimitFatalError,"TimeLimitExceeded","`%s'",image->filename);
-      return((Cache) NULL);
+          cache_info=(CacheInfo *) image->cache;
+          if (cache_info->file != -1)
+            (void) ClosePixelCacheOnDisk(cache_info);
+          (void) ThrowMagickException(exception,GetMagickModule(),
+            ResourceLimitFatalError,"TimeLimitExceeded","`%s'",image->filename);
+          return((Cache) NULL);
+        }
+      if (cpu_throttle != 0)
+        MagickDelay(cpu_throttle);
     }
   LockSemaphoreInfo(image->semaphore);
   assert(image->cache != (Cache) NULL);
   cache_info=(CacheInfo *) image->cache;
 #if defined(MAGICKCORE_OPENCL_SUPPORT)
   CopyOpenCLBuffer(cache_info);
 #endif
   destroy=MagickFalse;
   if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))
     {
       LockSemaphoreInfo(cache_info->semaphore);
       if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))
         {
           CacheInfo
             *clone_info;
 
           Image
             clone_image;
 
           /*
             Clone pixel cache.
           */
           clone_image=(*image);
           clone_image.semaphore=AcquireSemaphoreInfo();
           clone_image.reference_count=1;
           clone_image.cache=ClonePixelCache(cache_info);
           clone_info=(CacheInfo *) clone_image.cache;
           status=OpenPixelCache(&clone_image,IOMode,exception);
           if (status == MagickFalse)
             clone_info=(CacheInfo *) DestroyPixelCache(clone_info);
           else
             {
               if (clone != MagickFalse)
                 status=ClonePixelCacheRepository(clone_info,cache_info,
                   exception);
               if (status == MagickFalse)
                 clone_info=(CacheInfo *) DestroyPixelCache(clone_info);
               else
                 {
                   destroy=MagickTrue;
                   image->cache=clone_info;
                 }
             }
           RelinquishSemaphoreInfo(&clone_image.semaphore);
         }
       UnlockSemaphoreInfo(cache_info->semaphore);
     }
   if (destroy != MagickFalse)
     cache_info=(CacheInfo *) DestroyPixelCache(cache_info);
   if (status != MagickFalse)
     {
       /*
         Ensure the image matches the pixel cache morphology.
       */
       if (image->type != UndefinedType)
         image->type=UndefinedType;
       if (ValidatePixelCacheMorphology(image) == MagickFalse)
         {
           status=OpenPixelCache(image,IOMode,exception);
           cache_info=(CacheInfo *) image->cache;
           if (cache_info->file != -1)
             (void) ClosePixelCacheOnDisk(cache_info);
         }
     }
   UnlockSemaphoreInfo(image->semaphore);
   if (status == MagickFalse)
     return((Cache) NULL);
   return(image->cache);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   G e t I m a g e P i x e l C a c h e T y p e                               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  GetImagePixelCacheType() returns the pixel cache type: UndefinedCache,
 %  DiskCache, MemoryCache, MapCache, or PingCache.
 %
 %  The format of the GetImagePixelCacheType() method is:
 %
 %      CacheType GetImagePixelCacheType(const Image *image)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 */
diff --git a/MagickCore/fx.c b/MagickCore/fx.c
index aac9d7057..3db588838 100644
--- a/MagickCore/fx.c
+++ b/MagickCore/fx.c
@@ -1,108 +1,109 @@
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %                                 FFFFF  X   X                                %
 %                                 F       X X                                 %
 %                                 FFF      X                                  %
 %                                 F       X X                                 %
 %                                 F      X   X                                %
 %                                                                             %
 %                                                                             %
 %                   MagickCore Image Special Effects Methods                  %
 %                                                                             %
 %                               Software Design                               %
 %                             snibgo (Alan Gibson)                            %
 %                                 January 2022                                %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %  Copyright @ 1999 ImageMagick Studio LLC, a non-profit organization         %
 %  dedicated to making software imaging solutions freely available.           %
 %                                                                             %
 %  You may not use this file except in compliance with the License.  You may  %
 %  obtain a copy of the License at                                            %
 %                                                                             %
 %    https://imagemagick.org/script/license.php                               %
 %                                                                             %
 %  Unless required by applicable law or agreed to in writing, software        %
 %  distributed under the License is distributed on an "AS IS" BASIS,          %
 %  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %
 %  See the License for the specific language governing permissions and        %
 %  limitations under the License.                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %
 %
 */
 
 /*
   Include declarations.
 */
 #include "MagickCore/studio.h"
 #include "MagickCore/accelerate-private.h"
 #include "MagickCore/annotate.h"
 #include "MagickCore/artifact.h"
 #include "MagickCore/attribute.h"
 #include "MagickCore/cache.h"
 #include "MagickCore/cache-view.h"
 #include "MagickCore/channel.h"
 #include "MagickCore/color.h"
 #include "MagickCore/color-private.h"
 #include "MagickCore/colorspace-private.h"
 #include "MagickCore/composite.h"
 #include "MagickCore/decorate.h"
 #include "MagickCore/distort.h"
 #include "MagickCore/draw.h"
 #include "MagickCore/effect.h"
 #include "MagickCore/enhance.h"
 #include "MagickCore/exception.h"
 #include "MagickCore/exception-private.h"
 #include "MagickCore/fx.h"
 #include "MagickCore/fx-private.h"
 #include "MagickCore/gem.h"
 #include "MagickCore/gem-private.h"
 #include "MagickCore/geometry.h"
 #include "MagickCore/layer.h"
 #include "MagickCore/list.h"
 #include "MagickCore/log.h"
 #include "MagickCore/image.h"
 #include "MagickCore/image-private.h"
 #include "MagickCore/magick.h"
 #include "MagickCore/memory_.h"
 #include "MagickCore/memory-private.h"
 #include "MagickCore/monitor.h"
 #include "MagickCore/monitor-private.h"
 #include "MagickCore/option.h"
 #include "MagickCore/pixel.h"
 #include "MagickCore/pixel-accessor.h"
 #include "MagickCore/policy.h"
 #include "MagickCore/property.h"
 #include "MagickCore/quantum.h"
 #include "MagickCore/quantum-private.h"
 #include "MagickCore/random_.h"
 #include "MagickCore/random-private.h"
 #include "MagickCore/resample.h"
 #include "MagickCore/resample-private.h"
 #include "MagickCore/resize.h"
 #include "MagickCore/resource_.h"
 #include "MagickCore/splay-tree.h"
 #include "MagickCore/statistic.h"
 #include "MagickCore/statistic-private.h"
 #include "MagickCore/string_.h"
+#include "MagickCore/timer-private.h"
 #include "MagickCore/thread-private.h"
 #include "MagickCore/threshold.h"
 #include "MagickCore/token.h"
 #include "MagickCore/transform.h"
 #include "MagickCore/transform-private.h"
 #include "MagickCore/utility.h"
 
 
 #define MaxTokenLen 100
 #define RpnInit 100
 #define TableExtend 0.1
 #define InitNumOprStack 50
 #define MinValStackSize 100
 #define InitNumUserSymbols 50
@@ -529,10 +530,11 @@ static const SymbolT Symbols[] = {
 /* Run-time controls are in the RPN, not explicitly in the input string. */
 typedef enum {
   rGoto = FirstCont,
+  rGotoChk,
   rIfZeroGoto,
   rIfNotZeroGoto,
   rCopyFrom,
   rCopyTo,
   rZerStk,
   rNull
 } ControlE;
@@ -545,12 +547,13 @@ typedef struct {
 
 static const ControlT Controls[] = {
   {rGoto,          "goto",          0},
+  {rGotoChk,       "gotochk",       0},
   {rIfZeroGoto,    "ifzerogoto",    1},
   {rIfNotZeroGoto, "ifnotzerogoto", 1},
   {rCopyFrom,      "copyfrom",      0},
   {rCopyTo,        "copyto",        1},
   {rZerStk,        "zerstk",        0},
   {rNull,          "rnull",         0}
 };
 
 #define NULL_ADDRESS -2
@@ -648,10 +651,12 @@ typedef struct {
 typedef struct {
   RandomInfo * magick_restrict random_info;
   int numValStack;
   int usedValStack;
   fxFltType * ValStack;
   fxFltType * UserSymVals;
   Quantum * thisPixel;
+  MagickSizeType loopCount;
+  MagickSizeType cpu_throttle;
 } fxRtT;
 
 struct _FxInfo {
@@ -963,38 +968,42 @@ static MagickBooleanType BuildRPN (FxInfo * pfx)
 static MagickBooleanType AllocFxRt (FxInfo * pfx, fxRtT * pfxrt)
 {
   int nRnd;
   int i;
   pfxrt->random_info = AcquireRandomInfo ();
   pfxrt->thisPixel = NULL;
 
   nRnd = 20 + 10 * (int) GetPseudoRandomValue (pfxrt->random_info);
   for (i=0; i < nRnd; i++) (void) GetPseudoRandomValue (pfxrt->random_info);;
 
   pfxrt->usedValStack = 0;
   pfxrt->numValStack = 2 * pfx->maxUsedOprStack;
   if (pfxrt->numValStack < MinValStackSize) pfxrt->numValStack = MinValStackSize;
   pfxrt->ValStack = (fxFltType*) AcquireMagickMemory ((size_t) pfxrt->numValStack * sizeof(fxFltType));
   if (!pfxrt->ValStack) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), ResourceLimitFatalError,
       "ValStack", "%i",
       pfxrt->numValStack);
     return MagickFalse;
   }
 
   pfxrt->UserSymVals = NULL;
 
   if (pfx->usedUserSymbols) {
     pfxrt->UserSymVals = (fxFltType*) AcquireMagickMemory ((size_t) pfx->usedUserSymbols * sizeof(fxFltType));
     if (!pfxrt->UserSymVals) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), ResourceLimitFatalError,
         "UserSymVals", "%i",
         pfx->usedUserSymbols);
       return MagickFalse;
     }
     for (i = 0; i < pfx->usedUserSymbols; i++) pfxrt->UserSymVals[i] = (fxFltType) 0;
   }
+
+  pfxrt->loopCount = 0;
+  pfxrt->cpu_throttle = GetMagickResourceLimit (ThrottleResource);
+
   return MagickTrue;
 }
 
@@ -1035,72 +1044,72 @@ static const char * OprStr (int oprNum)
 static MagickBooleanType DumpRPN (FxInfo * pfx, FILE * fh)
 {
   int i;
 
   fprintf (fh, "DumpRPN:");
   fprintf (fh, "  numElements=%i", pfx->numElements);
   fprintf (fh, "  usedElements=%i", pfx->usedElements);
   fprintf (fh, "  maxUsedOprStack=%i", pfx->maxUsedOprStack);
   fprintf (fh, "  ImgListLen=%g", (double) pfx->ImgListLen);
   fprintf (fh, "  NeedStats=%s", pfx->NeedStats ? "yes" : "no");
   fprintf (fh, "  GotStats=%s", pfx->GotStats ? "yes" : "no");
   fprintf (fh, "  NeedHsl=%s\n", pfx->NeedHsl ? "yes" : "no");
   if      (pfx->runType==rtEntireImage) fprintf (stderr, "EntireImage");
   else if (pfx->runType==rtCornerOnly)  fprintf (stderr, "CornerOnly");
   fprintf (fh, "\n");
 
 
   for (i=0; i < pfx->usedElements; i++) {
     ElementT * pel = &pfx->Elements[i];
     pel->nDest = 0;
   }
   for (i=0; i < pfx->usedElements; i++) {
     ElementT * pel = &pfx->Elements[i];
-    if (pel->oprNum == rGoto || pel->oprNum == rIfZeroGoto || pel->oprNum == rIfNotZeroGoto) {
+    if (pel->oprNum == rGoto || pel->oprNum == rGotoChk || pel->oprNum == rIfZeroGoto || pel->oprNum == rIfNotZeroGoto) {
       if (pel->EleNdx >= 0 && pel->EleNdx < pfx->numElements) {
         ElementT * pelDest = &pfx->Elements[pel->EleNdx];
         pelDest->nDest++;
       }
     }
   }
   for (i=0; i < pfx->usedElements; i++) {
     char UserSym[MagickPathExtent];
 
     ElementT * pel = &pfx->Elements[i];
     const char * str = OprStr (pel->oprNum);
     const char *sRelAbs = "";
 
     if (pel->oprNum == fP || pel->oprNum == fUP || pel->oprNum == fVP || pel->oprNum == fSP)
       sRelAbs = pel->IsRelative ? "[]" : "{}";
 
     if (pel->type == etColourConstant)
       fprintf (fh, "  %i: %s vals=%.*Lg,%.*Lg,%.*Lg '%s%s' nArgs=%i ndx=%i  %s",
                i, sElementTypes[pel->type],
                pfx->precision, pel->val, pfx->precision, pel->val1, pfx->precision, pel->val2,
                str, sRelAbs, pel->nArgs, pel->EleNdx,
                pel->DoPush ? "push" : "NO push");
     else
       fprintf (fh, "  %i: %s val=%.*Lg '%s%s' nArgs=%i ndx=%i  %s",
                i, sElementTypes[pel->type], pfx->precision, pel->val, str, sRelAbs,
                pel->nArgs, pel->EleNdx,
                pel->DoPush ? "push" : "NO push");
 
     if (pel->ImgAttrQual != aNull)
       fprintf (fh, " ia=%s", OprStr((int) pel->ImgAttrQual));
 
     if (pel->ChannelQual != NO_CHAN_QUAL) {
       if (pel->ChannelQual == THIS_CHANNEL) fprintf (stderr, "  ch=this");
       else fprintf (stderr, "  ch=%i", pel->ChannelQual);
     }
 
     if (pel->oprNum == rCopyTo) {
       fprintf (fh, "  CopyTo ==> %s", NameOfUserSym (pfx, pel->EleNdx, UserSym));
     } else if (pel->oprNum == rCopyFrom) {
       fprintf (fh, "  CopyFrom <== %s", NameOfUserSym (pfx, pel->EleNdx, UserSym));
     } else if (OprInPlace (pel->oprNum)) {
       fprintf (fh, "  <==> %s", NameOfUserSym (pfx, pel->EleNdx, UserSym));
     }
     if (pel->nDest > 0)  fprintf (fh, "  <==dest(%i)", pel->nDest);
     fprintf (fh, "\n");
   }
   return MagickTrue;
 }
@@ -1227,18 +1236,18 @@ static MagickBooleanType AddElement (FxInfo * pfx, fxFltType val, int oprNum)
 static MagickBooleanType AddAddressingElement (FxInfo * pfx, int oprNum, int EleNdx)
 {
   ElementT * pel;
   if (!AddElement (pfx, (fxFltType) 0, oprNum)) return MagickFalse;
   pel = &pfx->Elements[pfx->usedElements-1];
   pel->EleNdx = EleNdx;
-  if (oprNum == rGoto || oprNum == rIfZeroGoto || oprNum == rIfNotZeroGoto 
+  if (oprNum == rGoto || oprNum == rGotoChk || oprNum == rIfZeroGoto || oprNum == rIfNotZeroGoto 
    || oprNum == rZerStk)
   {
     pel->DoPush = MagickFalse;
   }
 
   /* Note: for() may or may not need pushing,
      depending on whether the value is needed, eg "for(...)+2" or debug(for(...)).
   */
 
   return MagickTrue;
 }
@@ -1703,355 +1712,355 @@ static inline ssize_t GetHexColour (FxInfo * pfx, fxFltType *v0, fxFltType *v1,
 static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
 {
   /* A function, so get open-parens, n args, close-parens
   */
   const char * funStr = Functions[fe-(int) FirstFunc].str;
   int nArgs = Functions[fe-(int) FirstFunc].nArgs;
   char chLimit = ')';
   char expChLimit = ')';
   const char *strLimit = ",)";
   OperatorE pushOp = oOpenParen;
 
   char * pExpStart;
 
   int lenExp = 0;
 
   int FndArgs = 0;
   int ndx0 = NULL_ADDRESS, ndx1 = NULL_ADDRESS, ndx2 = NULL_ADDRESS, ndx3 = NULL_ADDRESS;
 
   MagickBooleanType coordQual = MagickFalse;
   PixelChannel chQual = NO_CHAN_QUAL;
   ImgAttrE iaQual = aNull;
 
   pfx->pex += pfx->lenToken;
 
   if (fe == fP) {
     char p = PeekChar (pfx);
     if (p=='{') {
       (void) ExpectChar (pfx, '{');
       pushOp = oOpenBrace;
       strLimit = ",}";
       chLimit = '}';
       expChLimit = '}';
     } else if (p=='[') {
       (void) ExpectChar (pfx, '[');
       pushOp = oOpenBracket;
       strLimit = ",]";
       chLimit = ']';
       expChLimit = ']';
     } else {
       nArgs = 0;
       chLimit = ']';
       expChLimit = ']';
     }
   } else if (fe == fU) {
     char p = PeekChar (pfx);
     if (p=='[') {
       (void) ExpectChar (pfx, '[');
       pushOp = oOpenBracket;
       strLimit = ",]";
       chLimit = ']';
       expChLimit = ']';
     } else {
       nArgs = 0;
       chLimit = ']';
       expChLimit = ']';
     }
   } else if (fe == fV || fe == fS) {
       nArgs = 0;
       pushOp = oOpenBracket;
       chLimit = ']';
       expChLimit = ']';
   } else {
     if (!ExpectChar (pfx, '(')) return MagickFalse;
   }
   if (!PushOperatorStack (pfx, (int) pushOp)) return MagickFalse;
 
   pExpStart = pfx->pex;
   ndx0 = pfx->usedElements;
   if (fe==fDo) {
     (void) AddAddressingElement (pfx, rGoto, NULL_ADDRESS); /* address will be ndx1+1 */
   }
   while (nArgs > 0) {
     int FndOne = 0;
     if (TranslateStatementList (pfx, strLimit, &chLimit)) {
       FndOne = 1;
     } else {
       /* Maybe don't break because other expressions may be not empty. */
       if (!chLimit) break;
       if (fe == fP || fe == fS|| fe == fIf) {
         (void) AddElement (pfx, (fxFltType) 0, oNull);
         FndOne = 1;
       } 
     }
 
     if (strchr (strLimit, chLimit)==NULL) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "For function", "'%s' expected one of '%s' after expression but found '%c' at '%s'",
         funStr, strLimit, chLimit ? chLimit : ' ', SetShortExp(pfx));
       return MagickFalse;
     }
     if (FndOne) {
       FndArgs++;
       nArgs--;
     }
     switch (FndArgs) {
       case 1:
         if (ndx1 != NULL_ADDRESS) {
           (void) ThrowMagickException (
             pfx->exception, GetMagickModule(), OptionError,
             "For function", "'%s' required argument is missing at '%s'",
             funStr, SetShortExp(pfx));
           return MagickFalse;
         }
         ndx1 = pfx->usedElements;
         if (fe==fWhile || fe==fIf) {
           (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2+1 */
         } else if (fe==fDo) {
           (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2+1 */
         } else if (fe==fFor) {
           pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
         }
         break;
       case 2:
         if (ndx2 != NULL_ADDRESS) {
           (void) ThrowMagickException (
             pfx->exception, GetMagickModule(), OptionError,
             "For function", "'%s' required argument is missing at '%s'",
             funStr, SetShortExp(pfx));
           return MagickFalse;
         }
         ndx2 = pfx->usedElements;
         if (fe==fWhile) {
           pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
-          (void) AddAddressingElement (pfx, rGoto, ndx0);
+          (void) AddAddressingElement (pfx, rGotoChk, ndx0);
         } else if (fe==fDo) {
           pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
-          (void) AddAddressingElement (pfx, rGoto, ndx0 + 1);
+          (void) AddAddressingElement (pfx, rGotoChk, ndx0 + 1);
         } else if (fe==fFor) {
           (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx3 */
           pfx->Elements[pfx->usedElements-1].DoPush = MagickTrue; /* we may need return from for() */
           (void) AddAddressingElement (pfx, rZerStk, NULL_ADDRESS);
         } else if (fe==fIf) {
           (void) AddAddressingElement (pfx, rGoto, NULL_ADDRESS); /* address will be ndx3 */
         }
         break;
       case 3:
         if (ndx3 != NULL_ADDRESS) {
           (void) ThrowMagickException (
             pfx->exception, GetMagickModule(), OptionError,
             "For function", "'%s' required argument is missing at '%s'",
             funStr, SetShortExp(pfx));
           return MagickFalse;
         }
         if (fe==fFor) {
           pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
-          (void) AddAddressingElement (pfx, rGoto, ndx1);
+          (void) AddAddressingElement (pfx, rGotoChk, ndx1);
         }
         ndx3 = pfx->usedElements;
         break;
       default:
         break;
     }
     if (chLimit == expChLimit) {
       lenExp = pfx->pex - pExpStart - 1;
       break;
     }
   } /* end while args of a function */
   if (chLimit && chLimit != expChLimit && chLimit != ',' ) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "For function", "'%s' expected '%c', found '%c' at '%s'",
       funStr, expChLimit, chLimit ? chLimit : ' ', SetShortExp(pfx));
     return MagickFalse;
   }
 
   if (fe == fP || fe == fS || fe == fU || fe == fChannel) {
     while (FndArgs < Functions[fe-(int) FirstFunc].nArgs) {
       (void) AddElement (pfx, (fxFltType) 0, oNull);
       FndArgs++;
     }
   }
 
   if (FndArgs > Functions[fe-(int) FirstFunc].nArgs)
   {
     if (fe==fChannel) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "For function", "'%s' expected up to %i arguments, found '%i' at '%s'",
         funStr, Functions[fe-(int) FirstFunc].nArgs, FndArgs, SetShortExp(pfx));
     } else {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "For function", "'%s' expected %i arguments, found '%i' at '%s'",
         funStr, Functions[fe-(int) FirstFunc].nArgs, FndArgs, SetShortExp(pfx));
     }
     return MagickFalse;
   }
   if (FndArgs < Functions[fe-(int) FirstFunc].nArgs) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "For function", "'%s' expected %i arguments, found too few (%i) at '%s'",
       funStr, Functions[fe-(int) FirstFunc].nArgs, FndArgs, SetShortExp(pfx));
     return MagickFalse;
   }
   if (fe != fS && fe != fV && FndArgs == 0 && Functions[fe-(int) FirstFunc].nArgs == 0) {
     /* This is for "rand()" and similar. */
     chLimit = expChLimit;
     if (!ExpectChar (pfx, ')')) return MagickFalse;
   }
 
   if (chLimit != expChLimit) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "For function", "'%s', arguments don't end with '%c' at '%s'",
       funStr, expChLimit, SetShortExp(pfx));
     return MagickFalse;
   }
   if (!PopOprOpenParen (pfx, pushOp)) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "Bug: For function", "'%s' tos not '%s' at '%s'",
       funStr, Operators[pushOp].str, SetShortExp(pfx));
     return MagickFalse;
   }
 
   if (IsQualifier (pfx)) {
 
     if (fe == fU || fe == fV || fe == fS) {
 
       coordQual = (GetCoordQualifier (pfx, (int) fe) == 1) ? MagickTrue : MagickFalse;
 
       if (coordQual) {
 
         /* Remove last element, which should be fP */
         ElementT * pel = &pfx->Elements[pfx->usedElements-1];
         if (pel->oprNum != fP) {
           (void) ThrowMagickException (
             pfx->exception, GetMagickModule(), OptionError,
             "Bug: For function", "'%s' last element not 'p' at '%s'",
             funStr, SetShortExp(pfx));
           return MagickFalse;
         }
         chQual = pel->ChannelQual;
         expChLimit = (pel->IsRelative) ? ']' : '}';
         pfx->usedElements--;
         if (fe == fU) fe = fUP;
         else if (fe == fV) fe = fVP;
         else if (fe == fS) fe = fSP;
         funStr = Functions[fe-(int) FirstFunc].str;
       }
     }
 
     if ( chQual == NO_CHAN_QUAL &&
          (fe == fP || fe == fS || fe == fSP || fe == fU || fe == fUP || fe == fV || fe == fVP)
        )
     {
       chQual = GetChannelQualifier (pfx, (int) fe);
     }
 
     if (chQual == NO_CHAN_QUAL && (fe == fU || fe == fV || fe == fS)) {
       /* Note: we don't allow "p.mean" etc. */
       iaQual = GetImgAttrQualifier (pfx, (int) fe);
     }
     if (IsQualifier (pfx) && chQual == NO_CHAN_QUAL && iaQual != aNull) {
       chQual = GetChannelQualifier (pfx, (int) fe);
     }
     if (coordQual && iaQual != aNull) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "For function", "'%s', can't have qualifiers 'p' and image attribute '%s' at '%s'",
         funStr, pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
     if (!coordQual && chQual == NO_CHAN_QUAL && iaQual == aNull) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "For function", "'%s', bad qualifier '%s' at '%s'",
         funStr, pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
     if (!coordQual && chQual == CompositePixelChannel && iaQual == aNull) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "For function", "'%s', bad composite qualifier '%s' at '%s'",
         funStr, pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
 
     if (chQual == HUE_CHANNEL || chQual == SAT_CHANNEL || chQual == LIGHT_CHANNEL) {
       pfx->NeedHsl = MagickTrue;
 
       if (iaQual >= FirstImgAttr && iaQual < aNull) {
         (void) ThrowMagickException (
           pfx->exception, GetMagickModule(), OptionError,
           "Can't have image attribute with HLS qualifier at", "'%s'",
           SetShortExp(pfx));
         return MagickFalse;
       }
     }
   }
 
   if (iaQual != aNull && chQual != NO_CHAN_QUAL) {
     if (ImgAttrs[iaQual-(int) FirstImgAttr].NeedStats==0) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "Can't have image attribute ", "'%s' with channel qualifier '%s' at '%s'",
         ImgAttrs[iaQual-(int) FirstImgAttr].str,
         pfx->token, SetShortExp(pfx));
       return MagickFalse;
     } else {
       if (ChanIsVirtual (chQual)) {
         (void) ThrowMagickException (
           pfx->exception, GetMagickModule(), OptionError,
           "Can't have statistical image attribute ", "'%s' with virtual channel qualifier '%s' at '%s'",
           ImgAttrs[iaQual-(int) FirstImgAttr].str,
           pfx->token, SetShortExp(pfx));
         return MagickFalse;
       }
     }
   }
 
   if (fe==fWhile) {
     pfx->Elements[ndx1].EleNdx = ndx2+1;
   } else if (fe==fDo) {
     pfx->Elements[ndx0].EleNdx = ndx1+1;
     pfx->Elements[ndx1].EleNdx = ndx2+1;
   } else if (fe==fFor) {
     pfx->Elements[ndx2].EleNdx = ndx3;
   } else if (fe==fIf) {
     pfx->Elements[ndx1].EleNdx = ndx2 + 1;
     pfx->Elements[ndx2].EleNdx = ndx3;
   } else {
     if (fe == fU && iaQual == aNull) {
       ElementT * pel = &pfx->Elements[pfx->usedElements-1];
       if (pel->type == etConstant && pel->val == 0.0) {
         pfx->usedElements--;
         fe = fU0;
       }
     }
     (void) AddElement (pfx, (fxFltType) 0, (int) fe);
     if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
         fe == fV || fe == fVP || fe == fS || fe == fSP)
     {
       ElementT * pel = &pfx->Elements[pfx->usedElements-1];
       pel->IsRelative = (expChLimit == ']' ? MagickTrue : MagickFalse);
       if (chQual >= 0) pel->ChannelQual = chQual;
       if (iaQual != aNull && (fe == fU || fe == fV || fe == fS)) {
         /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
         pel->ImgAttrQual = iaQual;
       }
     }
   }
 
   if (pExpStart && lenExp) {
     ElementT * pel = &pfx->Elements[pfx->usedElements-1];
     pel->pExpStart = pExpStart;
     pel->lenExp = lenExp;
   }
 
   if (fe == fDebug)
     pfx->ContainsDebug = MagickTrue;
 
   return MagickTrue;
 }
@@ -3131,851 +3140,865 @@ static inline fxFltType GetIntensity (FxInfo * pfx, ssize_t ImgNum, const fxFltT
 static MagickBooleanType ExecuteRPN (FxInfo * pfx, fxRtT * pfxrt, fxFltType *result,
   const PixelChannel channel, const ssize_t imgx, const ssize_t imgy)
 {
   const Quantum * p = pfxrt->thisPixel;
   fxFltType regA=0, regB=0, regC=0, regD=0, regE=0;
   Image * img = pfx->image;
   ChannelStatistics * cs = NULL;
   MagickBooleanType NeedRelinq = MagickFalse;
   double hue=0, saturation=0, lightness=0;
   int i;
 
   /* For -fx, this sets p to ImgNum 0.
      for %[fx:...], this sets p to the current image.
      Similarly img.
   */
   if (!p) p = GetCacheViewVirtualPixels (
     pfx->Imgs[pfx->ImgNum].View, imgx, imgy, 1, 1, pfx->exception);
 
   if (p == (const Quantum *) NULL)
     {
       (void) ThrowMagickException (pfx->exception,GetMagickModule(),
         OptionError,"GetHslInt failure","%lu %li,%li",(unsigned long)
         pfx->ImgNum,(long) imgx,(long) imgy);
       return(MagickFalse);
     }
 
   if (pfx->GotStats) {
     cs = pfx->statistics[pfx->ImgNum];
   } else if (pfx->NeedStats) {
     cs = CollectOneImgStats (pfx, pfx->Images[pfx->ImgNum]);
     NeedRelinq = MagickTrue;
   }
 
   /*  Following is only for expressions like "saturation", with no image specifier.
   */
   if (pfx->NeedHsl) {
     ConvertRGBToHSL (
       GetPixelRed (img, p), GetPixelGreen (img, p), GetPixelBlue (img, p),
       &hue, &saturation, &lightness);
   }
 
   for (i=0; i < pfx->usedElements; i++) {
+    if (i < 0) {
+      (void) ThrowMagickException (
+        pfx->exception, GetMagickModule(), OptionError,
+        "Bad run-time address", "%i", i);
+    }
     ElementT *pel = &pfx->Elements[i];
-      switch (pel->nArgs) {
+    switch (pel->nArgs) {
         case 0:
           break;
         case 1:
           regA = PopVal (pfx, pfxrt, i);
           break;
         case 2:
           regB = PopVal (pfx, pfxrt, i);
           regA = PopVal (pfx, pfxrt, i);
           break;
         case 3:
           regC = PopVal (pfx, pfxrt, i);
           regB = PopVal (pfx, pfxrt, i);
           regA = PopVal (pfx, pfxrt, i);
           break;
         case 4:
           regD = PopVal (pfx, pfxrt, i);
           regC = PopVal (pfx, pfxrt, i);
           regB = PopVal (pfx, pfxrt, i);
           regA = PopVal (pfx, pfxrt, i);
           break;
         case 5:
           regE = PopVal (pfx, pfxrt, i);
           regD = PopVal (pfx, pfxrt, i);
           regC = PopVal (pfx, pfxrt, i);
           regB = PopVal (pfx, pfxrt, i);
           regA = PopVal (pfx, pfxrt, i);
           break;
         default:
           (void) ThrowMagickException (
             pfx->exception, GetMagickModule(), OptionError,
             "Too many args:", "%i", pel->nArgs);
           break;
       }
 
       switch (pel->oprNum) {
         case oAddEq:
           regA = (pfxrt->UserSymVals[pel->EleNdx] += regA);
           break;
         case oSubtractEq:
           regA = (pfxrt->UserSymVals[pel->EleNdx] -= regA);
           break;
         case oMultiplyEq:
           regA = (pfxrt->UserSymVals[pel->EleNdx] *= regA);
           break;
         case oDivideEq:
           regA = (pfxrt->UserSymVals[pel->EleNdx] *= PerceptibleReciprocal((double)regA));
           break;
         case oPlusPlus:
           regA = pfxrt->UserSymVals[pel->EleNdx]++;
           break;
         case oSubSub:
           regA = pfxrt->UserSymVals[pel->EleNdx]--;
           break;
         case oAdd:
           regA += regB;
           break;
         case oSubtract:
           regA -= regB;
           break;
         case oMultiply:
           regA *= regB;
           break;
         case oDivide:
           regA *= PerceptibleReciprocal((double)regB);
           break;
         case oModulus:
           regA = fmod ((double) regA, fabs(floor((double) regB+0.5)));
           break;
         case oUnaryPlus:
           /* Do nothing. */
           break;
         case oUnaryMinus:
           regA = -regA;
           break;
         case oLshift:
           if ((size_t) (regB+0.5) >= (8*sizeof(size_t)))
             {
               (void) ThrowMagickException ( pfx->exception, GetMagickModule(),
                 OptionError, "undefined shift", "%g", (double) regB);
               regA = (fxFltType) 0.0;
               break;
             }
           regA = (fxFltType) ((size_t)(regA+0.5) << (size_t)(regB+0.5));
           break;
         case oRshift:
           if ((size_t) (regB+0.5) >= (8*sizeof(size_t)))
             {
               (void) ThrowMagickException ( pfx->exception, GetMagickModule(),
                 OptionError, "undefined shift", "%g", (double) regB);
               regA = (fxFltType) 0.0;
               break;
             }
           regA = (fxFltType) ((size_t)(regA+0.5) >> (size_t)(regB+0.5));
           break;
         case oEq:
           regA = fabs((double) (regA-regB)) < MagickEpsilon ? 1.0 : 0.0;
           break;
         case oNotEq:
           regA = fabs((double) (regA-regB)) >= MagickEpsilon ? 1.0 : 0.0;
           break;
         case oLtEq:
           regA = (regA <= regB) ? 1.0 : 0.0;
           break;
         case oGtEq:
           regA = (regA >= regB) ? 1.0 : 0.0;
           break;
         case oLt:
           regA = (regA < regB) ? 1.0 : 0.0;
           break;
         case oGt:
           regA = (regA > regB) ? 1.0 : 0.0;
           break;
         case oLogAnd:
           regA = (regA<=0) ? 0.0 : (regB > 0) ? 1.0 : 0.0;
           break;
         case oLogOr:
           regA = (regA>0) ? 1.0 : (regB > 0.0) ? 1.0 : 0.0;
           break;
         case oLogNot:
           regA = (regA==0) ? 1.0 : 0.0;
           break;
         case oBitAnd:
           regA = (fxFltType) ((size_t)(regA+0.5) & (size_t)(regB+0.5));
           break;
         case oBitOr:
           regA = (fxFltType) ((size_t)(regA+0.5) | (size_t)(regB+0.5));
           break;
         case oBitNot:
           /* Old fx doesn't add 0.5. */
           regA = (fxFltType) (~(size_t)(regA+0.5));
           break;
         case oPow:
           regA = pow ((double) regA, (double) regB);
           break;
         case oQuery:
         case oColon:
           break;
         case oOpenParen:
         case oCloseParen:
         case oOpenBracket:
         case oCloseBracket:
         case oOpenBrace:
         case oCloseBrace:
           break;
         case oAssign:
           pel->val = regA;
           break;
         case oNull: {
           if (pel->type == etColourConstant) {
             switch (channel) { default:
               case (PixelChannel) 0:
                 regA = pel->val;
                 break;
               case (PixelChannel) 1:
                 regA = pel->val1;
                 break;
               case (PixelChannel) 2:
                 regA = pel->val2;
                 break;
             }
           } else {
             regA = pel->val;
           }
           break;
         }
         case fAbs:
           regA = fabs ((double) regA);
           break;
 #if defined(MAGICKCORE_HAVE_ACOSH)
         case fAcosh:
           regA = acosh ((double) regA);
           break;
 #endif
         case fAcos:
           regA = acos ((double) regA);
           break;
 #if defined(MAGICKCORE_HAVE_J1)
         case fAiry:
           if (regA==0) regA = 1.0;
           else {
             fxFltType gamma = 2.0 * j1 ((MagickPI*regA)) / (MagickPI*regA);
             regA = gamma * gamma;
           }
           break;
 #endif
         case fAlt:
           regA = (fxFltType) (((ssize_t) regA) & 0x01 ? -1.0 : 1.0);
           break;
 #if defined(MAGICKCORE_HAVE_ASINH)
         case fAsinh:
           regA = asinh ((double) regA);
           break;
 #endif
         case fAsin:
           regA = asin ((double) regA);
           break;
 #if defined(MAGICKCORE_HAVE_ATANH)
         case fAtanh:
           regA = atanh ((double) regA);
           break;
 #endif
         case fAtan2:
           regA = atan2 ((double) regA, (double) regB);
           break;
         case fAtan:
           regA = atan ((double) regA);
           break;
         case fCeil:
           regA = ceil ((double) regA);
           break;
         case fChannel:
           switch (channel) {
             case (PixelChannel) 0: break;
             case (PixelChannel) 1: regA = regB; break;
             case (PixelChannel) 2: regA = regC; break;
             case (PixelChannel) 3: regA = regD; break;
             case (PixelChannel) 4: regA = regE; break;
             default: regA = 0.0;
           }
           break;
         case fClamp:
           if (regA < 0) regA = 0.0;
           else if (regA > 1.0) regA = 1.0;
           break;
         case fCosh:
           regA = cosh ((double) regA);
           break;
         case fCos:
           regA = cos ((double) regA);
           break;
         case fDebug:
           /* FIXME: debug() should give channel name. */
 
           (void) fprintf (stderr, "%s[%g,%g].[%i]: %s=%.*g\n",
                    img->filename, (double) imgx, (double) imgy,
                    channel, SetPtrShortExp (pfx, pel->pExpStart, (size_t) (pel->lenExp+1)),
                    pfx->precision, (double) regA);
           break;
         case fDrc:
           regA = regA / (regB*(regA-1.0) + 1.0);
           break;
 #if defined(MAGICKCORE_HAVE_ERF)
         case fErf:
           regA = erf ((double) regA);
           break;
 #endif
         case fExp:
           regA = exp ((double) regA);
           break;
         case fFloor:
           regA = floor ((double) regA);
           break;
         case fGauss:
           regA = exp((double) (-regA*regA/2.0))/sqrt(2.0*MagickPI);
           break;
         case fGcd:
           if (!IsNaN(regA)) 
             regA = FxGcd (regA, regB, 0);
           break;
         case fHypot:
           regA = hypot ((double) regA, (double) regB);
           break;
         case fInt:
           regA = floor ((double) regA);
           break;
         case fIsnan:
           regA = (fxFltType) (!!IsNaN (regA));
           break;
 #if defined(MAGICKCORE_HAVE_J0)
         case fJ0:
           regA = j0 ((double) regA);
           break;
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
         case fJ1:
           regA = j1 ((double) regA);
           break;
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
         case fJinc:
           if (regA==0) regA = 1.0;
           else regA = 2.0 * j1 ((MagickPI*regA))/(MagickPI*regA);
           break;
 #endif
         case fLn:
           regA = log ((double) regA);
           break;
         case fLogtwo:
           regA = MagickLog10((double) regA) / log10(2.0);
           break;
         case fLog:
           regA = MagickLog10 ((double) regA);
           break;
         case fMax:
           regA = (regA > regB) ? regA : regB;
           break;
         case fMin:
           regA = (regA < regB) ? regA : regB;
           break;
         case fMod:
           regA = regA - floor((double) (regA*PerceptibleReciprocal((double) regB)))*regB;
           break;
         case fNot:
           regA = (fxFltType) (regA < MagickEpsilon);
           break;
         case fPow:
           regA = pow ((double) regA, (double) regB);
           break;
         case fRand: {
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
           #pragma omp critical (MagickCore_ExecuteRPN)
 #endif
           regA = GetPseudoRandomValue (pfxrt->random_info);
           break;
         }
         case fRound:
           regA = floor ((double) regA + 0.5);
           break;
         case fSign:
           regA = (regA < 0) ? -1.0 : 1.0;
           break;
         case fSinc:
           regA = sin ((double) (MagickPI*regA)) / (MagickPI*regA);
           break;
         case fSinh:
           regA = sinh ((double) regA);
           break;
         case fSin:
           regA = sin ((double) regA);
           break;
         case fSqrt:
           regA = sqrt ((double) regA);
           break;
         case fSquish:
           regA = 1.0 / (1.0 + exp ((double) -regA));
           break;
         case fTanh:
           regA = tanh ((double) regA);
           break;
         case fTan:
           regA = tan ((double) regA);
           break;
         case fTrunc:
           if (regA >= 0) regA = floor ((double) regA);
           else regA = ceil ((double) regA);
           break;
 
         case fDo:
         case fFor:
         case fIf:
         case fWhile:
           break;
         case fU: {
           /* Note: 1 value is available, index into image list.
              May have ImgAttr qualifier or channel qualifier or both.
           */
           ssize_t ImgNum = ChkImgNum (pfx, regA);
           if (ImgNum < 0) break;
           regA = (fxFltType) 0;
           if (ImgNum == 0) {
             Image * pimg = pfx->Images[0];
             if (pel->ImgAttrQual == aNull) {
               if ((int) pel->ChannelQual < 0) {
                 if (pel->ChannelQual == NO_CHAN_QUAL || pel->ChannelQual == THIS_CHANNEL) {
                   if (pfx->ImgNum==0) {
                     regA = QuantumScale * (double) p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                   } else {
                     const Quantum * pv = GetCacheViewVirtualPixels (
                                    pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
                     if (!pv) {
                       (void) ThrowMagickException (
                         pfx->exception, GetMagickModule(), OptionError,
                         "fU can't get cache", "%lu", (unsigned long) ImgNum);
                       break;
                     }
                     regA = QuantumScale * (double) pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                   }
                 } else if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                     pel->ChannelQual == LIGHT_CHANNEL) {
                   regA = GetHslInt (pfx, ImgNum, imgx, imgy, pel->ChannelQual);
                   break;
                 } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
                   regA = GetIntensity (pfx, 0, (double) imgx, (double) imgy);
                   break;
                 }
               } else {
                 if (pfx->ImgNum==0) {
                   regA = QuantumScale * (double) p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                 } else {
                   const Quantum * pv = GetCacheViewVirtualPixels (
                                  pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
                   if (!pv) {
                     (void) ThrowMagickException (
                       pfx->exception, GetMagickModule(), OptionError,
                       "fU can't get cache", "%lu", (unsigned long) ImgNum);
                     break;
                   }
                   regA = QuantumScale * (double) pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                 }
               }
             } else {
               /* we have an image attribute */
               regA = ImageStat (pfx, 0, WHICH_ATTR_CHAN, pel->ImgAttrQual);
             }
           } else {
             /* We have non-zero ImgNum. */
             if (pel->ImgAttrQual == aNull) {
               const Quantum * pv;
               if ((int) pel->ChannelQual < 0) {
                 if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                     pel->ChannelQual == LIGHT_CHANNEL)
                 {
                   regA = GetHslInt (pfx, ImgNum, imgx, imgy, pel->ChannelQual);
                   break;
                 } else if (pel->ChannelQual == INTENSITY_CHANNEL)
                 {
                   regA = GetIntensity (pfx, ImgNum, (fxFltType) imgx, (fxFltType) imgy);
                   break;
                 }
               }
 
               pv = GetCacheViewVirtualPixels (
                      pfx->Imgs[ImgNum].View, imgx, imgy, 1,1, pfx->exception);
               if (!pv) {
                 (void) ThrowMagickException (
                   pfx->exception, GetMagickModule(), OptionError,
                   "fU can't get cache", "%lu", (unsigned long) ImgNum);
                 break;
               }
               regA = QuantumScale * (double)
                 pv[pfx->Images[ImgNum]->channel_map[WHICH_NON_ATTR_CHAN].offset];
             } else {
               regA = ImageStat (pfx, ImgNum, WHICH_ATTR_CHAN, pel->ImgAttrQual);
             }
           }
           break;
         }
         case fU0: {
           /* No args. No image attribute. We may have a ChannelQual.
              If called from %[fx:...], ChannelQual will be CompositePixelChannel.
           */
           Image * pimg = pfx->Images[0];
           if ((int) pel->ChannelQual < 0) {
             if (pel->ChannelQual == NO_CHAN_QUAL || pel->ChannelQual == THIS_CHANNEL) {
 
               if (pfx->ImgNum==0) {
                 regA = QuantumScale * (double) p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
               } else {
                 const Quantum * pv = GetCacheViewVirtualPixels (
                                pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
                 if (!pv) {
                   (void) ThrowMagickException (
                     pfx->exception, GetMagickModule(), OptionError,
                     "fU0 can't get cache", "%i", 0);
                   break;
                 }
                 regA = QuantumScale * (double) pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
               }
 
             } else if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                        pel->ChannelQual == LIGHT_CHANNEL) {
               regA = GetHslInt (pfx, 0, imgx, imgy, pel->ChannelQual);
               break;
             } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
               regA = GetIntensity (pfx, 0, (fxFltType) imgx, (fxFltType) imgy);
             }
           } else {
             if (pfx->ImgNum==0) {
               regA = QuantumScale * (double) p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
             } else {
               const Quantum * pv = GetCacheViewVirtualPixels (
                                    pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
               if (!pv) {
                 (void) ThrowMagickException (
                   pfx->exception, GetMagickModule(), OptionError,
                   "fU0 can't get cache", "%i", 0);
                 break;
               }
               regA = QuantumScale * (double) pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
             }
           }
           break;
         }
         case fUP: {
           /* 3 args are: ImgNum, x, y */
           ssize_t ImgNum = ChkImgNum (pfx, regA);
           fxFltType fx, fy;
 
           if (ImgNum < 0) break;
 
           if (pel->IsRelative) {
             fx = imgx + regB;
             fy = imgy + regC;
           } else {
             fx = regB;
             fy = regC;
           }
 
           if ((int) pel->ChannelQual < 0) {
             if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL
              || pel->ChannelQual == LIGHT_CHANNEL) {
               regA = GetHslFlt (pfx, ImgNum, fx, fy, pel->ChannelQual);
               break;
             } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
               regA = GetIntensity (pfx, ImgNum, fx, fy);
               break;
             }
           }
 
           {
             double v;
             Image * imUP = pfx->Images[ImgNum];
             if (! InterpolatePixelChannel (imUP, pfx->Imgs[ImgNum].View, WHICH_NON_ATTR_CHAN,
                     imUP->interpolate, (double) fx, (double) fy, &v, pfx->exception))
             {
               (void) ThrowMagickException (
                 pfx->exception, GetMagickModule(), OptionError,
                 "fUP can't get interpolate", "%lu", (unsigned long) ImgNum);
               break;
             }
             regA = v * QuantumScale;
           }
 
           break;
         }
         case fS:
         case fV: {
           /* No args. */
           ssize_t ImgNum = 1;
           if (pel->oprNum == fS) ImgNum = pfx->ImgNum;
 
           if (pel->ImgAttrQual == aNull) {
             const Quantum * pv = GetCacheViewVirtualPixels (
                                    pfx->Imgs[ImgNum].View, imgx, imgy, 1,1, pfx->exception);
             if (!pv) {
               (void) ThrowMagickException (
                 pfx->exception, GetMagickModule(), OptionError,
                 "fV can't get cache", "%lu", (unsigned long) ImgNum);
               break;
             }
 
             if ((int) pel->ChannelQual < 0) {
               if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                   pel->ChannelQual == LIGHT_CHANNEL) {
                 regA = GetHslInt (pfx, ImgNum, imgx, imgy, pel->ChannelQual);
                 break;
               } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
                 regA = GetIntensity (pfx, ImgNum, (double) imgx, (double) imgy);
                 break;
               }
             }
 
             regA = QuantumScale * (double)
               pv[pfx->Images[ImgNum]->channel_map[WHICH_NON_ATTR_CHAN].offset];
           } else {
             regA = ImageStat (pfx, ImgNum, WHICH_ATTR_CHAN, pel->ImgAttrQual);
           }
 
           break;
         }
         case fP:
         case fSP:
         case fVP: {
           /* 2 args are: x, y */
           fxFltType fx, fy;
           ssize_t ImgNum = pfx->ImgNum;
           if (pel->oprNum == fVP) ImgNum = 1;
           if (pel->IsRelative) {
             fx = imgx + regA;
             fy = imgy + regB;
           } else {
             fx = regA;
             fy = regB;
           }
           if ((int) pel->ChannelQual < 0) {
             if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                 pel->ChannelQual == LIGHT_CHANNEL) {
               regA = GetHslFlt (pfx, ImgNum, fx, fy, pel->ChannelQual);
               break;
             } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
               regA = GetIntensity (pfx, ImgNum, fx, fy);
               break;
             }
           }
 
           {
             double v;
 
             if (! InterpolatePixelChannel (pfx->Images[ImgNum], pfx->Imgs[ImgNum].View,
                                            WHICH_NON_ATTR_CHAN, pfx->Images[ImgNum]->interpolate,
                                            (double) fx, (double) fy, &v, pfx->exception)
                                           )
             {
               (void) ThrowMagickException (
                 pfx->exception, GetMagickModule(), OptionError,
                 "fSP or fVP can't get interp", "%lu", (unsigned long) ImgNum);
               break;
             }
             regA = v * (fxFltType)QuantumScale;
           }
 
           break;
         }
         case fNull:
           break;
         case aDepth:
           regA = (fxFltType) GetImageDepth (img, pfx->exception);
           break;
         case aExtent:
           regA = (fxFltType) img->extent;
           break;
         case aKurtosis:
           if ((cs != (ChannelStatistics *) NULL) && (channel > 0))
             regA = cs[WHICH_ATTR_CHAN].kurtosis;
           break;
         case aMaxima:
           if ((cs != (ChannelStatistics *) NULL) && (channel > 0))
             regA = cs[WHICH_ATTR_CHAN].maxima;
           break;
         case aMean:
           if ((cs != (ChannelStatistics *) NULL) && (channel > 0))
             regA = cs[WHICH_ATTR_CHAN].mean;
           break;
         case aMedian:
           if ((cs != (ChannelStatistics *) NULL) && (channel > 0))
             regA = cs[WHICH_ATTR_CHAN].median;
           break;
         case aMinima:
           if ((cs != (ChannelStatistics *) NULL) && (channel > 0))
             regA = cs[WHICH_ATTR_CHAN].minima;
           break;
         case aPage:
           break;
         case aPageX:
           regA = (fxFltType) img->page.x;
           break;
         case aPageY:
           regA = (fxFltType) img->page.y;
           break;
         case aPageWid:
           regA = (fxFltType) img->page.width;
           break;
         case aPageHt:
           regA = (fxFltType) img->page.height;
           break;
         case aPrintsize:
           break;
         case aPrintsizeX:
           regA = (fxFltType) PerceptibleReciprocal (img->resolution.x) * img->columns;
           break;
         case aPrintsizeY:
           regA = (fxFltType) PerceptibleReciprocal (img->resolution.y) * img->rows;
           break;
         case aQuality:
           regA = (fxFltType) img->quality;
           break;
         case aRes:
           break;
         case aResX:
           regA = (fxFltType) img->resolution.x;
           break;
         case aResY:
           regA = (fxFltType) img->resolution.y;
           break;
         case aSkewness:
           if ((cs != (ChannelStatistics *) NULL) && (channel > 0))
             regA = cs[WHICH_ATTR_CHAN].skewness;
           break;
         case aStdDev:
           if ((cs != (ChannelStatistics *) NULL) && (channel > 0))
             regA = cs[WHICH_ATTR_CHAN].standard_deviation;
           break;
         case aH: /* image->rows */
           regA = (fxFltType) img->rows;
           break;
         case aN: /* image list length */
           regA = (fxFltType) pfx->ImgListLen;
           break;
         case aT: /* image index in list */
           regA = (fxFltType) pfx->ImgNum;
           break;
         case aW: /* image->columns */
           regA = (fxFltType) img->columns;
           break;
         case aZ: /* image depth */
           regA = (fxFltType) GetImageDepth (img, pfx->exception);
           break;
         case aNull:
           break;
         case sHue: /* of conversion to HSL */
           regA = hue;
           break;
         case sIntensity:
           regA = GetIntensity (pfx, pfx->ImgNum, (double) imgx, (double) imgy);
           break;
         case sLightness: /* of conversion to HSL */
           regA = lightness;
           break;
         case sLuma: /* calculation */
         case sLuminance: /* as Luma */
           regA = QuantumScale * (0.212656 * (double) GetPixelRed (img,p) +
                                  0.715158 * (double) GetPixelGreen (img,p) +
                                  0.072186 * (double) GetPixelBlue (img,p));
           break;
         case sSaturation: /* from conversion to HSL */
           regA = saturation;
           break;
         case sA: /* alpha */
           regA = QuantumScale * (double) GetPixelAlpha (img, p);
           break;
         case sB: /* blue */
           regA = QuantumScale * (double) GetPixelBlue (img, p);
           break;
         case sC: /* red (ie cyan) */
           regA = QuantumScale * (double) GetPixelCyan (img, p);
           break;
         case sG: /* green */
           regA = QuantumScale * (double) GetPixelGreen (img, p);
           break;
         case sI: /* current x-coordinate */
           regA = (fxFltType) imgx;
           break;
         case sJ: /* current y-coordinate */
           regA = (fxFltType) imgy;
           break;
         case sK: /* black of CMYK */
           regA = QuantumScale * (double) GetPixelBlack (img, p);
           break;
         case sM: /* green (ie magenta) */
           regA = QuantumScale * (double) GetPixelGreen (img, p);
           break;
         case sO: /* alpha */
           regA = QuantumScale * (double) GetPixelAlpha (img, p);
           break;
         case sR:
           regA = QuantumScale * (double) GetPixelRed (img, p);
           break;
         case sY:
           regA = QuantumScale * (double) GetPixelYellow (img, p);
           break;
         case sNull:
           break;
 
         case rGoto:
           assert (pel->EleNdx >= 0);
           i = pel->EleNdx-1; /* -1 because 'for' loop will increment. */
           break;
+        case rGotoChk:
+          assert (pel->EleNdx >= 0);
+          i = pel->EleNdx-1; /* -1 because 'for' loop will increment. */
+          if ((pfxrt->loopCount++ % 4096) == 0) {
+            if (GetMagickTTL() <= 0) {
+              i = pfx->usedElements-1; /* Do no more opcodes. */
+              (void) ThrowMagickException (pfx->exception, GetMagickModule(),
+                ResourceLimitFatalError, "TimeLimitExceeded", "`%s'", img->filename);
+            }
+            if (pfxrt->cpu_throttle != 0) {
+              MagickDelay (pfxrt->cpu_throttle);
+            }
+          }
+          break;
         case rIfZeroGoto:
           assert (pel->EleNdx >= 0);
           if (fabs((double) regA) < MagickEpsilon) i = pel->EleNdx-1;
           break;
         case rIfNotZeroGoto:
           assert (pel->EleNdx >= 0);
           if (fabs((double) regA) > MagickEpsilon) i = pel->EleNdx-1;
           break;
         case rCopyFrom:
           assert (pel->EleNdx >= 0);
           regA = pfxrt->UserSymVals[pel->EleNdx];
           break;
         case rCopyTo:
           assert (pel->EleNdx >= 0);
           pfxrt->UserSymVals[pel->EleNdx] = regA;
           break;
         case rZerStk:
           pfxrt->usedValStack = 0;
           break;
         case rNull:
           break;
 
         default:
           (void) ThrowMagickException (
             pfx->exception, GetMagickModule(), OptionError,
             "pel->oprNum", "%i '%s' not yet implemented",
             (int)pel->oprNum, OprStr(pel->oprNum));
           break;
     }
-    if (i < 0) {
-      (void) ThrowMagickException (
-        pfx->exception, GetMagickModule(), OptionError,
-        "Bad run-time address", "%i", i);
-    }
     if (pel->DoPush) 
       if (!PushVal (pfx, pfxrt, regA, i)) break;
   }
 
   if (pfxrt->usedValStack > 0) regA = PopVal (pfx, pfxrt, 9999);
 
   *result = regA;
 
   if (NeedRelinq) cs = (ChannelStatistics *)RelinquishMagickMemory (cs);
 
   if (pfx->exception->severity != UndefinedException) {
     return MagickFalse;
   }
 
   if (pfxrt->usedValStack != 0) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "ValStack not empty", "(%i)", pfxrt->usedValStack);
     return MagickFalse;
   }
 
   return MagickTrue;
 }
 
 /* Following is substitute for FxEvaluateChannelExpression().
 */
