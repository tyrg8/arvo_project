commit 344e1661e18234c9a3c56d7108aad06987b82b5a
Author: Daniel Pouzzner <douzzer@wolfssl.com>
Date:   Wed Sep 6 14:53:19 2023 -0500

    wolfcrypt/src/{hmac.c,sha256.c,sha512.c,kdf.c}: ForceZero() smallstack buffers before freeing them, and ForceZero() the Hmac, wc_Sha512, wc_Sha384, wc_Sha256, and wc_Sha224 structures at the end of their respective freeing routines.  also, remove superseded ForceZero() calls in wc_HKDF_Expand(), wc_SSH_KDF(), and wc_HKDF_Extract().

diff --git a/wolfcrypt/src/hmac.c b/wolfcrypt/src/hmac.c
index 4f1b68c7d..83e693b25 100644
--- a/wolfcrypt/src/hmac.c
+++ b/wolfcrypt/src/hmac.c
@@ -1088,287 +1088,287 @@ int wc_HmacInit_Label(Hmac* hmac, const char* label, void* heap, int devId)
 /* Free Hmac from use with async device */
 void wc_HmacFree(Hmac* hmac)
 {
     if (hmac == NULL)
         return;
 
 #ifdef WOLF_CRYPTO_CB
     /* handle cleanup case where final is not called */
     if (hmac->devId != INVALID_DEVID && hmac->devCtx != NULL) {
         int  ret;
         byte finalHash[WC_HMAC_BLOCK_SIZE];
         ret = wc_CryptoCb_Hmac(hmac, hmac->macType, NULL, 0, finalHash);
         (void)ret; /* must ignore return code here */
         (void)finalHash;
     }
 #endif
 
 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_HMAC)
     wolfAsync_DevCtxFree(&hmac->asyncDev, WOLFSSL_ASYNC_MARKER_HMAC);
 #endif /* WOLFSSL_ASYNC_CRYPT */
 
     switch (hmac->macType) {
     #ifndef NO_MD5
         case WC_MD5:
             wc_Md5Free(&hmac->hash.md5);
             break;
     #endif /* !NO_MD5 */
 
     #ifndef NO_SHA
         case WC_SHA:
             wc_ShaFree(&hmac->hash.sha);
             break;
     #endif /* !NO_SHA */
 
     #ifdef WOLFSSL_SHA224
         case WC_SHA224:
             wc_Sha224Free(&hmac->hash.sha224);
             break;
     #endif /* WOLFSSL_SHA224 */
     #ifndef NO_SHA256
         case WC_SHA256:
             wc_Sha256Free(&hmac->hash.sha256);
             break;
     #endif /* !NO_SHA256 */
 
     #ifdef WOLFSSL_SHA384
         case WC_SHA384:
             wc_Sha384Free(&hmac->hash.sha384);
             break;
     #endif /* WOLFSSL_SHA384 */
     #ifdef WOLFSSL_SHA512
         case WC_SHA512:
             wc_Sha512Free(&hmac->hash.sha512);
             break;
     #endif /* WOLFSSL_SHA512 */
 
     #ifdef WOLFSSL_SHA3
     #ifndef WOLFSSL_NOSHA3_224
         case WC_SHA3_224:
             wc_Sha3_224_Free(&hmac->hash.sha3);
             break;
     #endif
     #ifndef WOLFSSL_NOSHA3_256
         case WC_SHA3_256:
             wc_Sha3_256_Free(&hmac->hash.sha3);
             break;
     #endif
     #ifndef WOLFSSL_NOSHA3_384
         case WC_SHA3_384:
             wc_Sha3_384_Free(&hmac->hash.sha3);
             break;
     #endif
     #ifndef WOLFSSL_NOSHA3_512
         case WC_SHA3_512:
             wc_Sha3_512_Free(&hmac->hash.sha3);
             break;
     #endif
     #endif /* WOLFSSL_SHA3 */
 
     #ifdef WOLFSSL_SM3
         case WC_SM3:
             wc_Sm3Free(&hmac->hash.sm3);
             break;
     #endif
 
         default:
             break;
     }
+
+    ForceZero(hmac, sizeof(*hmac));
 }
 #endif /* WOLFSSL_KCAPI_HMAC */
 
 int wolfSSL_GetHmacMaxSize(void)
 {
     return WC_MAX_DIGEST_SIZE;
 }
 
 #ifdef HAVE_HKDF
     /* HMAC-KDF-Extract.
      * RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF).
      *
      * type     The hash algorithm type.
      * salt     The optional salt value.
      * saltSz   The size of the salt.
      * inKey    The input keying material.
      * inKeySz  The size of the input keying material.
      * out      The pseudorandom key with the length that of the hash.
      * returns 0 on success, otherwise failure.
      */
     int wc_HKDF_Extract(int type, const byte* salt, word32 saltSz,
                         const byte* inKey, word32 inKeySz, byte* out)
     {
         byte   tmp[WC_MAX_DIGEST_SIZE]; /* localSalt helper */
     #ifdef WOLFSSL_SMALL_STACK
         Hmac*  myHmac;
     #else
         Hmac   myHmac[1];
     #endif
         int    ret;
         const  byte* localSalt;  /* either points to user input or tmp */
         word32 hashSz;
 
         ret = wc_HmacSizeByType(type);
         if (ret < 0) {
             return ret;
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         myHmac = (Hmac*)XMALLOC(sizeof(Hmac), NULL, DYNAMIC_TYPE_HMAC);
         if (myHmac == NULL) {
             return MEMORY_E;
         }
     #endif
 
         hashSz = (word32)ret;
         localSalt = salt;
         if (localSalt == NULL) {
             XMEMSET(tmp, 0, hashSz);
             localSalt = tmp;
             saltSz    = hashSz;
         }
 
         ret = wc_HmacInit(myHmac, NULL, INVALID_DEVID);
         if (ret == 0) {
             ret = wc_HmacSetKey(myHmac, type, localSalt, saltSz);
             if (ret == 0)
                 ret = wc_HmacUpdate(myHmac, inKey, inKeySz);
             if (ret == 0)
                 ret = wc_HmacFinal(myHmac,  out);
-            ForceZero(myHmac, sizeof(Hmac));
             wc_HmacFree(myHmac);
         }
     #ifdef WOLFSSL_SMALL_STACK
         XFREE(myHmac, NULL, DYNAMIC_TYPE_HMAC);
     #endif
 
         return ret;
     }
 
     /* HMAC-KDF-Expand.
      * RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF).
      *
      * type     The hash algorithm type.
      * inKey    The input key.
      * inKeySz  The size of the input key.
      * info     The application specific information.
      * infoSz   The size of the application specific information.
      * out      The output keying material.
      * returns 0 on success, otherwise failure.
      */
     int wc_HKDF_Expand(int type, const byte* inKey, word32 inKeySz,
                        const byte* info, word32 infoSz, byte* out, word32 outSz)
     {
         byte   tmp[WC_MAX_DIGEST_SIZE];
     #ifdef WOLFSSL_SMALL_STACK
         Hmac*  myHmac;
     #else
         Hmac   myHmac[1];
     #endif
         int    ret = 0;
         word32 outIdx = 0;
         word32 hashSz;
         byte   n = 0x1;
 
         ret = wc_HmacSizeByType(type);
         if (ret < 0) {
             return ret;
         }
         hashSz = (word32)ret;
 
         /* RFC 5869 states that the length of output keying material in
          * octets must be L <= 255*HashLen or N = ceil(L/HashLen) */
 
         if (out == NULL || ((outSz/hashSz) + ((outSz % hashSz) != 0)) > 255) {
             return BAD_FUNC_ARG;
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         myHmac = (Hmac*)XMALLOC(sizeof(Hmac), NULL, DYNAMIC_TYPE_HMAC);
         if (myHmac == NULL) {
             return MEMORY_E;
         }
     #endif
 
         ret = wc_HmacInit(myHmac, NULL, INVALID_DEVID);
         if (ret != 0) {
     #ifdef WOLFSSL_SMALL_STACK
         XFREE(myHmac, NULL, DYNAMIC_TYPE_HMAC);
     #endif
             return ret;
         }
 
         XMEMSET(tmp, 0, WC_MAX_DIGEST_SIZE);
 
         while (outIdx < outSz) {
             word32 tmpSz = (n == 1) ? 0 : hashSz;
             word32 left = outSz - outIdx;
 
             ret = wc_HmacSetKey(myHmac, type, inKey, inKeySz);
             if (ret != 0)
                 break;
             ret = wc_HmacUpdate(myHmac, tmp, tmpSz);
             if (ret != 0)
                 break;
             ret = wc_HmacUpdate(myHmac, info, infoSz);
             if (ret != 0)
                 break;
             ret = wc_HmacUpdate(myHmac, &n, 1);
             if (ret != 0)
                 break;
             ret = wc_HmacFinal(myHmac, tmp);
             if (ret != 0)
                 break;
 
             left = min(left, hashSz);
             XMEMCPY(out+outIdx, tmp, left);
 
             outIdx += hashSz;
             n++;
         }
 
-        ForceZero(myHmac, sizeof(Hmac));
         wc_HmacFree(myHmac);
     #ifdef WOLFSSL_SMALL_STACK
         XFREE(myHmac, NULL, DYNAMIC_TYPE_HMAC);
     #endif
 
         return ret;
     }
 
     /* HMAC-KDF.
      * RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF).
      *
      * type     The hash algorithm type.
      * inKey    The input keying material.
      * inKeySz  The size of the input keying material.
      * salt     The optional salt value.
      * saltSz   The size of the salt.
      * info     The application specific information.
      * infoSz   The size of the application specific information.
      * out      The output keying material.
      * returns 0 on success, otherwise failure.
      */
     int wc_HKDF(int type, const byte* inKey, word32 inKeySz,
                        const byte* salt,  word32 saltSz,
                        const byte* info,  word32 infoSz,
                        byte* out,         word32 outSz)
     {
         byte   prk[WC_MAX_DIGEST_SIZE];
         word32 hashSz;
         int    ret;
 
         ret = wc_HmacSizeByType(type);
         if (ret < 0) {
             return ret;
         }
         hashSz = (word32)ret;
 
         ret = wc_HKDF_Extract(type, salt, saltSz, inKey, inKeySz, prk);
         if (ret != 0)
             return ret;
 
         return wc_HKDF_Expand(type, prk, hashSz, info, infoSz, out, outSz);
     }
 
 #endif /* HAVE_HKDF */
 
 #endif /* NO_HMAC */
diff --git a/wolfcrypt/src/kdf.c b/wolfcrypt/src/kdf.c
index 0223817b2..2568c444c 100644
--- a/wolfcrypt/src/kdf.c
+++ b/wolfcrypt/src/kdf.c
@@ -763,112 +763,111 @@ void _HashFree(byte hashId, _hash* hash)
 int wc_SSH_KDF(byte hashId, byte keyId, byte* key, word32 keySz,
         const byte* k, word32 kSz, const byte* h, word32 hSz,
         const byte* sessionId, word32 sessionIdSz)
 {
     word32 blocks, remainder;
     _hash hash;
     enum wc_HashType enmhashId = (enum wc_HashType)hashId;
     byte kPad = 0;
     byte pad = 0;
     byte kSzFlat[LENGTH_SZ];
     word32 digestSz;
     int ret;
 
     if (key == NULL || keySz == 0 ||
         k == NULL || kSz == 0 ||
         h == NULL || hSz == 0 ||
         sessionId == NULL || sessionIdSz == 0) {
 
         return BAD_FUNC_ARG;
     }
 
     ret = wc_HmacSizeByType(enmhashId);
     if (ret <= 0) {
         return BAD_FUNC_ARG;
     }
     digestSz = (word32)ret;
 
     if (k[0] & 0x80) kPad = 1;
     c32toa(kSz + kPad, kSzFlat);
 
     blocks = keySz / digestSz;
     remainder = keySz % digestSz;
 
     ret = _HashInit(enmhashId, &hash);
     if (ret == 0)
         ret = _HashUpdate(enmhashId, &hash, kSzFlat, LENGTH_SZ);
     if (ret == 0 && kPad)
         ret = _HashUpdate(enmhashId, &hash, &pad, 1);
     if (ret == 0)
         ret = _HashUpdate(enmhashId, &hash, k, kSz);
     if (ret == 0)
         ret = _HashUpdate(enmhashId, &hash, h, hSz);
     if (ret == 0)
         ret = _HashUpdate(enmhashId, &hash, &keyId, sizeof(keyId));
     if (ret == 0)
         ret = _HashUpdate(enmhashId, &hash, sessionId, sessionIdSz);
 
     if (ret == 0) {
         if (blocks == 0) {
             if (remainder > 0) {
                 byte lastBlock[WC_MAX_DIGEST_SIZE];
                 ret = _HashFinal(enmhashId, &hash, lastBlock);
                 if (ret == 0)
                     XMEMCPY(key, lastBlock, remainder);
             }
         }
         else {
             word32 runningKeySz, curBlock;
 
             runningKeySz = digestSz;
             ret = _HashFinal(enmhashId, &hash, key);
 
             for (curBlock = 1; curBlock < blocks; curBlock++) {
                 ret = _HashInit(enmhashId, &hash);
                 if (ret != 0) break;
                 ret = _HashUpdate(enmhashId, &hash, kSzFlat, LENGTH_SZ);
                 if (ret != 0) break;
                 if (kPad)
                     ret = _HashUpdate(enmhashId, &hash, &pad, 1);
                 if (ret != 0) break;
                 ret = _HashUpdate(enmhashId, &hash, k, kSz);
                 if (ret != 0) break;
                 ret = _HashUpdate(enmhashId, &hash, h, hSz);
                 if (ret != 0) break;
                 ret = _HashUpdate(enmhashId, &hash, key, runningKeySz);
                 if (ret != 0) break;
                 ret = _HashFinal(enmhashId, &hash, key + runningKeySz);
                 if (ret != 0) break;
                 runningKeySz += digestSz;
             }
 
             if (remainder > 0) {
                 byte lastBlock[WC_MAX_DIGEST_SIZE];
                 if (ret == 0)
                     ret = _HashInit(enmhashId, &hash);
                 if (ret == 0)
                     ret = _HashUpdate(enmhashId, &hash, kSzFlat, LENGTH_SZ);
                 if (ret == 0 && kPad)
                     ret = _HashUpdate(enmhashId, &hash, &pad, 1);
                 if (ret == 0)
                     ret = _HashUpdate(enmhashId, &hash, k, kSz);
                 if (ret == 0)
                     ret = _HashUpdate(enmhashId, &hash, h, hSz);
                 if (ret == 0)
                     ret = _HashUpdate(enmhashId, &hash, key, runningKeySz);
                 if (ret == 0)
                     ret = _HashFinal(enmhashId, &hash, lastBlock);
                 if (ret == 0)
                     XMEMCPY(key + runningKeySz, lastBlock, remainder);
             }
         }
     }
 
-    ForceZero(&hash, sizeof(hash));
     _HashFree(enmhashId, &hash);
 
     return ret;
 }
 
 #endif /* WOLFSSL_WOLFSSH */
 
 #endif /* NO_KDF */
diff --git a/wolfcrypt/src/sha256.c b/wolfcrypt/src/sha256.c
index e17ba65ac..747d3dd46 100644
--- a/wolfcrypt/src/sha256.c
+++ b/wolfcrypt/src/sha256.c
@@ -186,1532 +186,1536 @@ on the specific device platform.
 static int InitSha256(wc_Sha256* sha256)
 {
     int ret = 0;
 
     if (sha256 == NULL)
         return BAD_FUNC_ARG;
 
     XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
     sha256->digest[0] = 0x6A09E667L;
     sha256->digest[1] = 0xBB67AE85L;
     sha256->digest[2] = 0x3C6EF372L;
     sha256->digest[3] = 0xA54FF53AL;
     sha256->digest[4] = 0x510E527FL;
     sha256->digest[5] = 0x9B05688CL;
     sha256->digest[6] = 0x1F83D9ABL;
     sha256->digest[7] = 0x5BE0CD19L;
 
     sha256->buffLen = 0;
     sha256->loLen   = 0;
     sha256->hiLen   = 0;
 #ifdef WOLFSSL_HASH_FLAGS
     sha256->flags = 0;
 #endif
 #ifdef WOLFSSL_HASH_KEEP
     sha256->msg  = NULL;
     sha256->len  = 0;
     sha256->used = 0;
 #endif
 
 #ifdef WOLF_CRYPTO_CB
     sha256->devId = wc_CryptoCb_DefaultDevID();
 #endif
 
 #ifdef WOLFSSL_MAXQ10XX_CRYPTO
     XMEMSET(&sha256->maxq_ctx, 0, sizeof(sha256->maxq_ctx));
 #endif
 
 #ifdef HAVE_ARIA
     sha256->hSession = NULL;
 #endif
 
     return ret;
 }
 #endif
 
 
 /* Hardware Acceleration */
 #if defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
 
     /* in case intel instructions aren't available, plus we need the K[] global */
     #define NEED_SOFT_SHA256
 
     /*****
     Intel AVX1/AVX2 Macro Control Structure
 
     #define HAVE_INTEL_AVX1
     #define HAVE_INTEL_AVX2
 
     #define HAVE_INTEL_RORX
 
 
     int InitSha256(wc_Sha256* sha256) {
          Save/Recover XMM, YMM
          ...
     }
 
     #if defined(HAVE_INTEL_AVX1)|| defined(HAVE_INTEL_AVX2)
       Transform_Sha256(); Function prototype
     #else
       Transform_Sha256() {   }
       int Sha256Final() {
          Save/Recover XMM, YMM
          ...
       }
     #endif
 
     #if defined(HAVE_INTEL_AVX1)|| defined(HAVE_INTEL_AVX2)
         #if defined(HAVE_INTEL_RORX
              #define RND with rorx instruction
         #else
             #define RND
         #endif
     #endif
 
     #if defined(HAVE_INTEL_AVX1)
 
        #define XMM Instructions/inline asm
 
        int Transform_Sha256() {
            Stitched Message Sched/Round
         }
 
     #elif defined(HAVE_INTEL_AVX2)
 
       #define YMM Instructions/inline asm
 
       int Transform_Sha256() {
           More granular Stitched Message Sched/Round
       }
 
     #endif
 
     */
 
     /* Each platform needs to query info type 1 from cpuid to see if aesni is
      * supported. Also, let's setup a macro for proper linkage w/o ABI conflicts
      */
 
     /* #if defined(HAVE_INTEL_AVX1/2) at the tail of sha256 */
     static int Transform_Sha256(wc_Sha256* sha256, const byte* data);
 
 #ifdef __cplusplus
     extern "C" {
 #endif
 
     #if defined(HAVE_INTEL_AVX1)
         extern int Transform_Sha256_AVX1(wc_Sha256 *sha256, const byte* data);
         extern int Transform_Sha256_AVX1_Len(wc_Sha256* sha256,
                                              const byte* data, word32 len);
     #endif
     #if defined(HAVE_INTEL_AVX2)
         extern int Transform_Sha256_AVX2(wc_Sha256 *sha256, const byte* data);
         extern int Transform_Sha256_AVX2_Len(wc_Sha256* sha256,
                                              const byte* data, word32 len);
         #ifdef HAVE_INTEL_RORX
         extern int Transform_Sha256_AVX1_RORX(wc_Sha256 *sha256, const byte* data);
         extern int Transform_Sha256_AVX1_RORX_Len(wc_Sha256* sha256,
                                                   const byte* data, word32 len);
         extern int Transform_Sha256_AVX2_RORX(wc_Sha256 *sha256, const byte* data);
         extern int Transform_Sha256_AVX2_RORX_Len(wc_Sha256* sha256,
                                                   const byte* data, word32 len);
         #endif /* HAVE_INTEL_RORX */
     #endif /* HAVE_INTEL_AVX2 */
 
 #ifdef __cplusplus
     }  /* extern "C" */
 #endif
 
     static int (*Transform_Sha256_p)(wc_Sha256* sha256, const byte* data);
                                                        /* = _Transform_Sha256 */
     static int (*Transform_Sha256_Len_p)(wc_Sha256* sha256, const byte* data,
                                          word32 len);
                                                                     /* = NULL */
     static int transform_check = 0;
     static word32 intel_flags;
     static int Transform_Sha256_is_vectorized = 0;
 
     static WC_INLINE int inline_XTRANSFORM(wc_Sha256* S, const byte* D) {
         int ret;
         ret = (*Transform_Sha256_p)(S, D);
         return ret;
     }
 #define XTRANSFORM(...) inline_XTRANSFORM(__VA_ARGS__)
 
     static WC_INLINE int inline_XTRANSFORM_LEN(wc_Sha256* S, const byte* D, word32 L) {
         int ret;
         ret = (*Transform_Sha256_Len_p)(S, D, L);
         return ret;
     }
 #define XTRANSFORM_LEN(...) inline_XTRANSFORM_LEN(__VA_ARGS__)
 
     static void Sha256_SetTransform(void)
     {
 
         if (transform_check)
             return;
 
         intel_flags = cpuid_get_flags();
 
     #ifdef HAVE_INTEL_AVX2
         if (1 && IS_INTEL_AVX2(intel_flags)) {
         #ifdef HAVE_INTEL_RORX
             if (IS_INTEL_BMI2(intel_flags)) {
                 Transform_Sha256_p = Transform_Sha256_AVX2_RORX;
                 Transform_Sha256_Len_p = Transform_Sha256_AVX2_RORX_Len;
                 Transform_Sha256_is_vectorized = 1;
             }
             else
         #endif
             if (1)
             {
                 Transform_Sha256_p = Transform_Sha256_AVX2;
                 Transform_Sha256_Len_p = Transform_Sha256_AVX2_Len;
                 Transform_Sha256_is_vectorized = 1;
             }
         #ifdef HAVE_INTEL_RORX
             else {
                 Transform_Sha256_p = Transform_Sha256_AVX1_RORX;
                 Transform_Sha256_Len_p = Transform_Sha256_AVX1_RORX_Len;
                 Transform_Sha256_is_vectorized = 1;
             }
         #endif
         }
         else
     #endif
     #ifdef HAVE_INTEL_AVX1
         if (IS_INTEL_AVX1(intel_flags)) {
             Transform_Sha256_p = Transform_Sha256_AVX1;
             Transform_Sha256_Len_p = Transform_Sha256_AVX1_Len;
             Transform_Sha256_is_vectorized = 1;
         }
         else
     #endif
         {
             Transform_Sha256_p = Transform_Sha256;
             Transform_Sha256_Len_p = NULL;
             Transform_Sha256_is_vectorized = 0;
         }
 
         transform_check = 1;
     }
 
 #if !defined(WOLFSSL_KCAPI_HASH)
     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
     {
         int ret = 0;
         if (sha256 == NULL)
             return BAD_FUNC_ARG;
 
         sha256->heap = heap;
     #ifdef WOLF_CRYPTO_CB
         sha256->devId = devId;
         sha256->devCtx = NULL;
     #endif
     #ifdef WOLFSSL_SMALL_STACK_CACHE
         sha256->W = NULL;
     #endif
 
         ret = InitSha256(sha256);
         if (ret != 0)
             return ret;
 
         /* choose best Transform function under this runtime environment */
         Sha256_SetTransform();
 
     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
         ret = wolfAsync_DevCtxInit(&sha256->asyncDev,
                             WOLFSSL_ASYNC_MARKER_SHA256, sha256->heap, devId);
     #else
         (void)devId;
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
         return ret;
     }
 #endif /* !WOLFSSL_KCAPI_HASH */
 
 #elif defined(FREESCALE_LTC_SHA)
     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
     {
         (void)heap;
         (void)devId;
 
         LTC_HASH_Init(LTC_BASE, &sha256->ctx, kLTC_Sha256, NULL, 0);
 
         return 0;
     }
 
 #elif defined(FREESCALE_MMCAU_SHA)
 
     #ifdef FREESCALE_MMCAU_CLASSIC_SHA
         #include "cau_api.h"
     #else
         #include "fsl_mmcau.h"
     #endif
 
     #define XTRANSFORM(S, D)         Transform_Sha256((S),(D))
     #define XTRANSFORM_LEN(S, D, L)  Transform_Sha256_Len((S),(D),(L))
 
     #ifndef WC_HASH_DATA_ALIGNMENT
         /* these hardware API's require 4 byte (word32) alignment */
         #define WC_HASH_DATA_ALIGNMENT 4
     #endif
 
     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
     {
         int ret = 0;
 
         (void)heap;
         (void)devId;
 
         ret = wolfSSL_CryptHwMutexLock();
         if (ret != 0) {
             return ret;
         }
 
     #ifdef FREESCALE_MMCAU_CLASSIC_SHA
         cau_sha256_initialize_output(sha256->digest);
     #else
         MMCAU_SHA256_InitializeOutput((uint32_t*)sha256->digest);
     #endif
         wolfSSL_CryptHwMutexUnLock();
 
         sha256->buffLen = 0;
         sha256->loLen   = 0;
         sha256->hiLen   = 0;
     #ifdef WOLFSSL_SMALL_STACK_CACHE
         sha256->W = NULL;
     #endif
 
         return ret;
     }
 
     static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
     {
         int ret = wolfSSL_CryptHwMutexLock();
         if (ret == 0) {
     #ifdef FREESCALE_MMCAU_CLASSIC_SHA
             cau_sha256_hash_n((byte*)data, 1, sha256->digest);
     #else
             MMCAU_SHA256_HashN((byte*)data, 1, (uint32_t*)sha256->digest);
     #endif
             wolfSSL_CryptHwMutexUnLock();
         }
         return ret;
     }
 
     static int Transform_Sha256_Len(wc_Sha256* sha256, const byte* data,
         word32 len)
     {
         int ret = wolfSSL_CryptHwMutexLock();
         if (ret == 0) {
         #if defined(WC_HASH_DATA_ALIGNMENT) && WC_HASH_DATA_ALIGNMENT > 0
             if ((wc_ptr_t)data % WC_HASH_DATA_ALIGNMENT) {
                 /* data pointer is NOT aligned,
                  * so copy and perform one block at a time */
                 byte* local = (byte*)sha256->buffer;
                 while (len >= WC_SHA256_BLOCK_SIZE) {
                     XMEMCPY(local, data, WC_SHA256_BLOCK_SIZE);
                 #ifdef FREESCALE_MMCAU_CLASSIC_SHA
                     cau_sha256_hash_n(local, 1, sha256->digest);
                 #else
                     MMCAU_SHA256_HashN(local, 1, (uint32_t*)sha256->digest);
                 #endif
                     data += WC_SHA256_BLOCK_SIZE;
                     len  -= WC_SHA256_BLOCK_SIZE;
                 }
             }
             else
         #endif
             {
     #ifdef FREESCALE_MMCAU_CLASSIC_SHA
             cau_sha256_hash_n((byte*)data, len/WC_SHA256_BLOCK_SIZE,
                 sha256->digest);
     #else
             MMCAU_SHA256_HashN((byte*)data, len/WC_SHA256_BLOCK_SIZE,
                 (uint32_t*)sha256->digest);
     #endif
             }
             wolfSSL_CryptHwMutexUnLock();
         }
         return ret;
     }
 
 #elif defined(WOLFSSL_PIC32MZ_HASH)
     #include <wolfssl/wolfcrypt/port/pic32/pic32mz-crypt.h>
 
 #elif defined(STM32_HASH_SHA2)
 
     /* Supports CubeMX HAL or Standard Peripheral Library */
 
     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
     {
         if (sha256 == NULL)
             return BAD_FUNC_ARG;
 
         (void)devId;
         (void)heap;
 
         XMEMSET(sha256, 0, sizeof(wc_Sha256));
         wc_Stm32_Hash_Init(&sha256->stmCtx);
         return 0;
     }
 
     int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
     {
         int ret = 0;
 
         if (sha256 == NULL || (data == NULL && len > 0)) {
             return BAD_FUNC_ARG;
         }
 
         ret = wolfSSL_CryptHwMutexLock();
         if (ret == 0) {
             ret = wc_Stm32_Hash_Update(&sha256->stmCtx,
                 HASH_AlgoSelection_SHA256, data, len, WC_SHA256_BLOCK_SIZE);
             wolfSSL_CryptHwMutexUnLock();
         }
         return ret;
     }
 
     int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
     {
         int ret = 0;
 
         if (sha256 == NULL || hash == NULL) {
             return BAD_FUNC_ARG;
         }
 
         ret = wolfSSL_CryptHwMutexLock();
         if (ret == 0) {
             ret = wc_Stm32_Hash_Final(&sha256->stmCtx,
                 HASH_AlgoSelection_SHA256, hash, WC_SHA256_DIGEST_SIZE);
             wolfSSL_CryptHwMutexUnLock();
         }
 
         (void)wc_InitSha256(sha256); /* reset state */
 
         return ret;
     }
 
 #elif defined(WOLFSSL_IMX6_CAAM) && !defined(NO_IMX6_CAAM_HASH) && \
     !defined(WOLFSSL_QNX_CAAM)
     /* functions defined in wolfcrypt/src/port/caam/caam_sha256.c */
 
 #elif defined(WOLFSSL_SE050) && defined(WOLFSSL_SE050_HASH)
 
     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
     {
         if (sha256 == NULL) {
             return BAD_FUNC_ARG;
         }
         (void)devId;
 
         return se050_hash_init(&sha256->se050Ctx, heap);
     }
 
     int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
     {
         return se050_hash_update(&sha256->se050Ctx, data, len);
     }
 
     int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
     {
         int ret = 0;
         ret = se050_hash_final(&sha256->se050Ctx, hash, WC_SHA256_DIGEST_SIZE,
                                kAlgorithm_SSS_SHA256);
         return ret;
     }
     int wc_Sha256FinalRaw(wc_Sha256* sha256, byte* hash)
     {
         int ret = 0;
         ret = se050_hash_final(&sha256->se050Ctx, hash, WC_SHA256_DIGEST_SIZE,
                                kAlgorithm_SSS_SHA256);
         return ret;
     }
 
 #elif defined(WOLFSSL_AFALG_HASH)
     /* implemented in wolfcrypt/src/port/af_alg/afalg_hash.c */
 
 #elif defined(WOLFSSL_DEVCRYPTO_HASH)
     /* implemented in wolfcrypt/src/port/devcrypto/devcrypt_hash.c */
 
 #elif defined(WOLFSSL_SCE) && !defined(WOLFSSL_SCE_NO_HASH)
     #include "hal_data.h"
 
     #ifndef WOLFSSL_SCE_SHA256_HANDLE
         #define WOLFSSL_SCE_SHA256_HANDLE g_sce_hash_0
     #endif
 
     #define WC_SHA256_DIGEST_WORD_SIZE 16
     #define XTRANSFORM(S, D) wc_Sha256SCE_XTRANSFORM((S), (D))
     static int wc_Sha256SCE_XTRANSFORM(wc_Sha256* sha256, const byte* data)
     {
         if (WOLFSSL_SCE_GSCE_HANDLE.p_cfg->endian_flag ==
                 CRYPTO_WORD_ENDIAN_LITTLE)
         {
             ByteReverseWords((word32*)data, (word32*)data,
                     WC_SHA256_BLOCK_SIZE);
             ByteReverseWords(sha256->digest, sha256->digest,
                     WC_SHA256_DIGEST_SIZE);
         }
 
         if (WOLFSSL_SCE_SHA256_HANDLE.p_api->hashUpdate(
                     WOLFSSL_SCE_SHA256_HANDLE.p_ctrl, (word32*)data,
                     WC_SHA256_DIGEST_WORD_SIZE, sha256->digest) != SSP_SUCCESS){
             WOLFSSL_MSG("Unexpected hardware return value");
             return WC_HW_E;
         }
 
         if (WOLFSSL_SCE_GSCE_HANDLE.p_cfg->endian_flag ==
                 CRYPTO_WORD_ENDIAN_LITTLE)
         {
             ByteReverseWords((word32*)data, (word32*)data,
                     WC_SHA256_BLOCK_SIZE);
             ByteReverseWords(sha256->digest, sha256->digest,
                     WC_SHA256_DIGEST_SIZE);
         }
 
         return 0;
     }
 
 
     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
     {
         int ret = 0;
         if (sha256 == NULL)
             return BAD_FUNC_ARG;
 
         sha256->heap = heap;
 
         ret = InitSha256(sha256);
         if (ret != 0)
             return ret;
 
         (void)devId;
 
         return ret;
     }
 
 #elif defined(WOLFSSL_USE_ESP32_CRYPT_HASH_HW)
 
     /* HW may fail since there's only one, so we still need SW */
     #define NEED_SOFT_SHA256
 
     /*
     ** soft SHA needs initialization digest, but HW does not.
     */
     static int InitSha256(wc_Sha256* sha256)
     {
         int ret = 0; /* zero = success */
 
         if (sha256 == NULL) {
             return BAD_FUNC_ARG;
         }
 
         sha256->digest[0] = 0x6A09E667L;
         sha256->digest[1] = 0xBB67AE85L;
         sha256->digest[2] = 0x3C6EF372L;
         sha256->digest[3] = 0xA54FF53AL;
         sha256->digest[4] = 0x510E527FL;
         sha256->digest[5] = 0x9B05688CL;
         sha256->digest[6] = 0x1F83D9ABL;
         sha256->digest[7] = 0x5BE0CD19L;
 
         sha256->buffLen = 0;
         sha256->loLen   = 0;
         sha256->hiLen   = 0;
 
         ret = esp_sha_init(&(sha256->ctx), WC_HASH_TYPE_SHA256);
 
         return ret;
     }
 
     /*
     ** wolfCrypt InitSha256 external wrapper.
     **
     ** we'll assume this is ALWAYS for a new, uninitialized sha256
     */
     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
     {
         (void)devId;
         if (sha256 == NULL) {
             return BAD_FUNC_ARG;
         }
 
     #ifdef WOLFSSL_USE_ESP32_CRYPT_HASH_HW
         /* We know this is a fresh, uninitialized item, so set to INIT */
         if (sha256->ctx.mode != ESP32_SHA_INIT) {
             ESP_LOGV(TAG, "Set ctx mode from prior value: "
                                "%d", sha256->ctx.mode);
         }
         sha256->ctx.mode = ESP32_SHA_INIT;
     #endif
 
         return InitSha256(sha256);
     }
 
 #elif (defined(WOLFSSL_RENESAS_TSIP_TLS) || \
        defined(WOLFSSL_RENESAS_TSIP_CRYPTONLY)) && \
     !defined(NO_WOLFSSL_RENESAS_TSIP_CRYPT_HASH)
 
     /* implemented in wolfcrypt/src/port/Renesas/renesas_tsip_sha.c */
 
 #elif defined(WOLFSSL_RENESAS_SCEPROTECT) && \
      !defined(NO_WOLFSSL_RENESAS_FSPSM_HASH)
 
     /* implemented in wolfcrypt/src/port/Renesas/renesas_fspsm_sha.c */
 
 #elif defined(WOLFSSL_PSOC6_CRYPTO)
 
     /* implemented in wolfcrypt/src/port/cypress/psoc6_crypto.c */
 
 #elif defined(WOLFSSL_IMXRT_DCP)
     #include <wolfssl/wolfcrypt/port/nxp/dcp_port.h>
     /* implemented in wolfcrypt/src/port/nxp/dcp_port.c */
 
 #elif defined(WOLFSSL_SILABS_SE_ACCEL)
     /* implemented in wolfcrypt/src/port/silabs/silabs_hash.c */
 
 #elif defined(WOLFSSL_KCAPI_HASH)
     /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */
 
 #elif defined(WOLFSSL_HAVE_PSA) && !defined(WOLFSSL_PSA_NO_HASH)
     /* implemented in wolfcrypt/src/port/psa/psa_hash.c */
 
 #elif defined(WOLFSSL_RENESAS_RX64_HASH)
 
     /* implemented in wolfcrypt/src/port/Renesas/renesas_rx64_hw_sha.c */
 
 #else
     #define NEED_SOFT_SHA256
 
     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
     {
         int ret = 0;
         if (sha256 == NULL)
             return BAD_FUNC_ARG;
         ret = InitSha256(sha256);
         if (ret != 0)
             return ret;
 
         sha256->heap = heap;
     #ifdef WOLF_CRYPTO_CB
         sha256->devId = devId;
         sha256->devCtx = NULL;
     #endif
     #ifdef WOLFSSL_SMALL_STACK_CACHE
         sha256->W = NULL;
     #endif
 
     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
         ret = wolfAsync_DevCtxInit(&sha256->asyncDev,
                             WOLFSSL_ASYNC_MARKER_SHA256, sha256->heap, devId);
     #else
         (void)devId;
     #endif /* WOLFSSL_ASYNC_CRYPT */
     #ifdef WOLFSSL_IMXRT1170_CAAM
          ret = wc_CAAM_HashInit(&sha256->hndl, &sha256->ctx, WC_HASH_TYPE_SHA256);
     #endif
 
         return ret;
     }
 #endif /* End Hardware Acceleration */
 
 #ifdef NEED_SOFT_SHA256
 
     static const FLASH_QUALIFIER ALIGN32 word32 K[64] = {
         0x428A2F98L, 0x71374491L, 0xB5C0FBCFL, 0xE9B5DBA5L, 0x3956C25BL,
         0x59F111F1L, 0x923F82A4L, 0xAB1C5ED5L, 0xD807AA98L, 0x12835B01L,
         0x243185BEL, 0x550C7DC3L, 0x72BE5D74L, 0x80DEB1FEL, 0x9BDC06A7L,
         0xC19BF174L, 0xE49B69C1L, 0xEFBE4786L, 0x0FC19DC6L, 0x240CA1CCL,
         0x2DE92C6FL, 0x4A7484AAL, 0x5CB0A9DCL, 0x76F988DAL, 0x983E5152L,
         0xA831C66DL, 0xB00327C8L, 0xBF597FC7L, 0xC6E00BF3L, 0xD5A79147L,
         0x06CA6351L, 0x14292967L, 0x27B70A85L, 0x2E1B2138L, 0x4D2C6DFCL,
         0x53380D13L, 0x650A7354L, 0x766A0ABBL, 0x81C2C92EL, 0x92722C85L,
         0xA2BFE8A1L, 0xA81A664BL, 0xC24B8B70L, 0xC76C51A3L, 0xD192E819L,
         0xD6990624L, 0xF40E3585L, 0x106AA070L, 0x19A4C116L, 0x1E376C08L,
         0x2748774CL, 0x34B0BCB5L, 0x391C0CB3L, 0x4ED8AA4AL, 0x5B9CCA4FL,
         0x682E6FF3L, 0x748F82EEL, 0x78A5636FL, 0x84C87814L, 0x8CC70208L,
         0x90BEFFFAL, 0xA4506CEBL, 0xBEF9A3F7L, 0xC67178F2L
     };
 
 /* Both versions of Ch and Maj are logically the same, but with the second set
     the compilers can recognize them better for optimization */
 #ifdef WOLFSSL_SHA256_BY_SPEC
     /* SHA256 math based on specification */
     #define Ch(x,y,z)       ((z) ^ ((x) & ((y) ^ (z))))
     #define Maj(x,y,z)      ((((x) | (y)) & (z)) | ((x) & (y)))
 #else
     /* SHA256 math reworked for easier compiler optimization */
     #define Ch(x,y,z)       ((((y) ^ (z)) & (x)) ^ (z))
     #define Maj(x,y,z)      ((((x) ^ (y)) & ((y) ^ (z))) ^ (y))
 #endif
     #define R(x, n)         (((x) & 0xFFFFFFFFU) >> (n))
 
     #define S(x, n)         rotrFixed(x, n)
     #define Sigma0(x)       (S(x, 2)  ^ S(x, 13) ^ S(x, 22))
     #define Sigma1(x)       (S(x, 6)  ^ S(x, 11) ^ S(x, 25))
     #define Gamma0(x)       (S(x, 7)  ^ S(x, 18) ^ R(x, 3))
     #define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
 
     #define a(i) S[(0-(i)) & 7]
     #define b(i) S[(1-(i)) & 7]
     #define c(i) S[(2-(i)) & 7]
     #define d(i) S[(3-(i)) & 7]
     #define e(i) S[(4-(i)) & 7]
     #define f(i) S[(5-(i)) & 7]
     #define g(i) S[(6-(i)) & 7]
     #define h(i) S[(7-(i)) & 7]
 
     #ifndef XTRANSFORM
          #define XTRANSFORM(S, D)         Transform_Sha256((S),(D))
     #endif
 
 #ifndef SHA256_MANY_REGISTERS
     #define RND(j) \
          t0 = h(j) + Sigma1(e(j)) + Ch(e(j), f(j), g(j)) + K[i+(j)] + W[i+(j)]; \
          t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
          d(j) += t0; \
          h(j)  = t0 + t1
 
     static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
     {
         word32 S[8], t0, t1;
         int i;
 
     #ifdef WOLFSSL_SMALL_STACK_CACHE
         word32* W = sha256->W;
         if (W == NULL) {
             W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
                                                            DYNAMIC_TYPE_DIGEST);
             if (W == NULL)
                 return MEMORY_E;
             sha256->W = W;
         }
     #elif defined(WOLFSSL_SMALL_STACK)
         word32* W;
         W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
                                                        DYNAMIC_TYPE_TMP_BUFFER);
         if (W == NULL)
             return MEMORY_E;
     #else
         word32 W[WC_SHA256_BLOCK_SIZE];
     #endif
 
         /* Copy context->state[] to working vars */
         for (i = 0; i < 8; i++)
             S[i] = sha256->digest[i];
 
         for (i = 0; i < 16; i++)
             W[i] = *((const word32*)&data[i*(int)sizeof(word32)]);
 
         for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
             W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
 
     #ifdef USE_SLOW_SHA256
         /* not unrolled - ~2k smaller and ~25% slower */
         for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
             int j;
             for (j = 0; j < 8; j++) { /* braces needed here for macros {} */
                 RND(j);
             }
         }
     #else
         /* partially loop unrolled */
         for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
             RND(0); RND(1); RND(2); RND(3);
             RND(4); RND(5); RND(6); RND(7);
         }
     #endif /* USE_SLOW_SHA256 */
 
         /* Add the working vars back into digest state[] */
         for (i = 0; i < 8; i++) {
             sha256->digest[i] += S[i];
         }
 
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
+        ForceZero(W, sizeof(word32) * WC_SHA256_BLOCK_SIZE);
         XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
     #endif
         return 0;
     }
 #else
     /* SHA256 version that keeps all data in registers */
     #define SCHED1(j) (W[j] = *((word32*)&data[j*sizeof(word32)]))
     #define SCHED(j) (               \
                    W[ j     & 15] += \
             Gamma1(W[(j-2)  & 15])+  \
                    W[(j-7)  & 15] +  \
             Gamma0(W[(j-15) & 15])   \
         )
 
     #define RND1(j) \
          t0 = h(j) + Sigma1(e(j)) + Ch(e(j), f(j), g(j)) + K[i+j] + SCHED1(j); \
          t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
          d(j) += t0; \
          h(j)  = t0 + t1
     #define RNDN(j) \
          t0 = h(j) + Sigma1(e(j)) + Ch(e(j), f(j), g(j)) + K[i+j] + SCHED(j); \
          t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
          d(j) += t0; \
          h(j)  = t0 + t1
 
     static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
     {
         word32 S[8], t0, t1;
         int i;
         word32 W[WC_SHA256_BLOCK_SIZE/sizeof(word32)];
 
         /* Copy digest to working vars */
         S[0] = sha256->digest[0];
         S[1] = sha256->digest[1];
         S[2] = sha256->digest[2];
         S[3] = sha256->digest[3];
         S[4] = sha256->digest[4];
         S[5] = sha256->digest[5];
         S[6] = sha256->digest[6];
         S[7] = sha256->digest[7];
 
         i = 0;
         RND1( 0); RND1( 1); RND1( 2); RND1( 3);
         RND1( 4); RND1( 5); RND1( 6); RND1( 7);
         RND1( 8); RND1( 9); RND1(10); RND1(11);
         RND1(12); RND1(13); RND1(14); RND1(15);
         /* 64 operations, partially loop unrolled */
         for (i = 16; i < 64; i += 16) {
             RNDN( 0); RNDN( 1); RNDN( 2); RNDN( 3);
             RNDN( 4); RNDN( 5); RNDN( 6); RNDN( 7);
             RNDN( 8); RNDN( 9); RNDN(10); RNDN(11);
             RNDN(12); RNDN(13); RNDN(14); RNDN(15);
         }
 
         /* Add the working vars back into digest */
         sha256->digest[0] += S[0];
         sha256->digest[1] += S[1];
         sha256->digest[2] += S[2];
         sha256->digest[3] += S[3];
         sha256->digest[4] += S[4];
         sha256->digest[5] += S[5];
         sha256->digest[6] += S[6];
         sha256->digest[7] += S[7];
 
         return 0;
     }
 #endif /* SHA256_MANY_REGISTERS */
 #endif
 /* End wc_ software implementation */
 
 
 #ifdef XTRANSFORM
 
     static WC_INLINE void AddLength(wc_Sha256* sha256, word32 len)
     {
         word32 tmp = sha256->loLen;
         if ((sha256->loLen += len) < tmp) {
             sha256->hiLen++;                       /* carry low to high */
         }
     }
 
     /* do block size increments/updates */
     static WC_INLINE int Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
     {
         int ret = 0;
         word32 blocksLen;
         byte* local;
 
         if (sha256 == NULL || (data == NULL && len > 0)) {
             return BAD_FUNC_ARG;
         }
 
         if (data == NULL && len == 0) {
             /* valid, but do nothing */
             return 0;
         }
 
         /* check that internal buffLen is valid */
         if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
             return BUFFER_E;
         }
 
         /* add length for final */
         AddLength(sha256, len);
 
         local = (byte*)sha256->buffer;
 
         /* process any remainder from previous operation */
         if (sha256->buffLen > 0) {
             blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
             XMEMCPY(&local[sha256->buffLen], data, blocksLen);
 
             sha256->buffLen += blocksLen;
             data            += blocksLen;
             len             -= blocksLen;
 
             if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
             #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
                 #if defined(WOLFSSL_X86_64_BUILD) && \
                           defined(USE_INTEL_SPEEDUP) && \
                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
                 if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
                 #endif
                 {
                     ByteReverseWords(sha256->buffer, sha256->buffer,
                         WC_SHA256_BLOCK_SIZE);
                 }
             #endif
 
             #if defined(WOLFSSL_USE_ESP32_CRYPT_HASH_HW)
                 if (sha256->ctx.mode == ESP32_SHA_INIT) {
                     ESP_LOGV(TAG, "Sha256Update try hardware");
                     esp_sha_try_hw_lock(&sha256->ctx);
                 }
 
                 if (sha256->ctx.mode == ESP32_SHA_SW) {
                     ESP_LOGV(TAG, "Sha256Update process software");
                     ret = XTRANSFORM(sha256, (const byte*)local);
                 }
                 else {
                     ESP_LOGV(TAG, "Sha256Update process hardware");
                     esp_sha256_process(sha256, (const byte*)local);
                 }
             #else
                 ret = XTRANSFORM(sha256, (const byte*)local);
             #endif
 
                 if (ret == 0)
                     sha256->buffLen = 0;
                 else
                     len = 0; /* error */
             }
         }
 
         /* process blocks */
     #ifdef XTRANSFORM_LEN
         #if defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
         if (Transform_Sha256_Len_p != NULL)
         #endif
         {
             /* get number of blocks */
             /* 64-1 = 0x3F (~ Inverted = 0xFFFFFFC0) */
             /* len (masked by 0xFFFFFFC0) returns block aligned length */
             blocksLen = len & ~((word32)WC_SHA256_BLOCK_SIZE-1);
             if (blocksLen > 0) {
                 /* Byte reversal and alignment handled in function if required */
                 XTRANSFORM_LEN(sha256, data, blocksLen);
                 data += blocksLen;
                 len  -= blocksLen;
             }
         }
         #if defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
         else
         #endif
     #endif /* XTRANSFORM_LEN */
     #if !defined(XTRANSFORM_LEN) || \
         (defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
         {
             while (len >= WC_SHA256_BLOCK_SIZE) {
                 word32* local32 = sha256->buffer;
                 /* optimization to avoid memcpy if data pointer is properly aligned */
                 /* Intel transform function requires use of sha256->buffer */
                 /* Little Endian requires byte swap, so can't use data directly */
             #if defined(WC_HASH_DATA_ALIGNMENT) && !defined(LITTLE_ENDIAN_ORDER) && \
                 !(defined(WOLFSSL_X86_64_BUILD) && \
                          defined(USE_INTEL_SPEEDUP) && \
                          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
                 if (((wc_ptr_t)data % WC_HASH_DATA_ALIGNMENT) == 0) {
                     local32 = (word32*)data;
                 }
                 else
             #endif
                 {
                     XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
                 }
 
                 data += WC_SHA256_BLOCK_SIZE;
                 len  -= WC_SHA256_BLOCK_SIZE;
 
             #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
                 #if defined(WOLFSSL_X86_64_BUILD) && \
                           defined(USE_INTEL_SPEEDUP) && \
                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
                 if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
                 #endif
                 {
                     ByteReverseWords(local32, local32, WC_SHA256_BLOCK_SIZE);
                 }
             #endif
 
             #if defined(WOLFSSL_USE_ESP32_CRYPT_HASH_HW)
                 if (sha256->ctx.mode == ESP32_SHA_INIT){
                     ESP_LOGV(TAG, "Sha256Update try hardware loop");
                     esp_sha_try_hw_lock(&sha256->ctx);
                 }
                 if (sha256->ctx.mode == ESP32_SHA_SW) {
                     ESP_LOGV(TAG, "Sha256Update process software loop");
                     ret = XTRANSFORM(sha256, (const byte*)local32);
                 }
                 else {
                     ESP_LOGV(TAG, "Sha256Update process hardware");
                     esp_sha256_process(sha256, (const byte*)local32);
                 }
             #else
                 ret = XTRANSFORM(sha256, (const byte*)local32);
             #endif
 
                 if (ret != 0)
                     break;
             }
         }
     #endif
 
         /* save remainder */
         if (ret == 0 && len > 0) {
             XMEMCPY(local, data, len);
             sha256->buffLen = len;
         }
 
         return ret;
     }
 
 #if defined(WOLFSSL_KCAPI_HASH)
     /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */
 
 #else
     int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
     {
         if (sha256 == NULL || (data == NULL && len > 0)) {
             return BAD_FUNC_ARG;
         }
 
         if (data == NULL && len == 0) {
             /* valid, but do nothing */
             return 0;
         }
 
     #ifdef WOLF_CRYPTO_CB
         #ifndef WOLF_CRYPTO_CB_FIND
         if (sha256->devId != INVALID_DEVID)
         #endif
         {
             int ret = wc_CryptoCb_Sha256Hash(sha256, data, len, NULL);
             if (ret != CRYPTOCB_UNAVAILABLE)
                 return ret;
             /* fall-through when unavailable */
         }
     #endif
     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
         if (sha256->asyncDev.marker == WOLFSSL_ASYNC_MARKER_SHA256) {
         #if defined(HAVE_INTEL_QA)
             return IntelQaSymSha256(&sha256->asyncDev, NULL, data, len);
         #endif
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
         return Sha256Update(sha256, data, len);
     }
 #endif
 
     static WC_INLINE int Sha256Final(wc_Sha256* sha256)
     {
 
         int ret;
         byte* local;
 
         if (sha256 == NULL) {
             return BAD_FUNC_ARG;
         }
 
         /* we'll add a 0x80 byte at the end,
         ** so make sure we have appropriate buffer length. */
         if (sha256->buffLen > WC_SHA256_BLOCK_SIZE - 1) {
             /* exit with error code if there's a bad buffer size in buffLen */
             return BAD_STATE_E;
         } /* buffLen check */
 
         local = (byte*)sha256->buffer;
         local[sha256->buffLen++] = 0x80; /* add 1 */
 
         /* pad with zeros */
         if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
             XMEMSET(&local[sha256->buffLen], 0,
                 WC_SHA256_BLOCK_SIZE - sha256->buffLen);
             sha256->buffLen += WC_SHA256_BLOCK_SIZE - sha256->buffLen;
 
         #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
             #if defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
             if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
             #endif
             {
                 ByteReverseWords(sha256->buffer, sha256->buffer,
                                                       WC_SHA256_BLOCK_SIZE);
             }
         #endif
 
         #if defined(WOLFSSL_USE_ESP32_CRYPT_HASH_HW)
             if (sha256->ctx.mode == ESP32_SHA_INIT) {
                 esp_sha_try_hw_lock(&sha256->ctx);
             }
             if (sha256->ctx.mode == ESP32_SHA_SW) {
                 ret = XTRANSFORM(sha256, (const byte*)local);
             }
             else {
                 ret = esp_sha256_process(sha256, (const byte*)local);
             }
         #else
             ret = XTRANSFORM(sha256, (const byte*)local);
         #endif
             if (ret != 0)
                 return ret;
 
             sha256->buffLen = 0;
         }
         XMEMSET(&local[sha256->buffLen], 0,
             WC_SHA256_PAD_SIZE - sha256->buffLen);
 
         /* put lengths in bits */
         sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
                                                          (sha256->hiLen << 3);
         sha256->loLen = sha256->loLen << 3;
 
         /* store lengths */
     #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
         #if defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
         if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
         #endif
         {
             ByteReverseWords(sha256->buffer, sha256->buffer,
                 WC_SHA256_BLOCK_SIZE);
         }
     #endif
         /* ! length ordering dependent on digest endian type ! */
         XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
         XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
                 sizeof(word32));
 
     #if defined(FREESCALE_MMCAU_SHA) || \
         (defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
                          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
         /* Kinetis requires only these bytes reversed */
         #if defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
         if (IS_INTEL_AVX1(intel_flags) || IS_INTEL_AVX2(intel_flags))
         #endif
         {
             ByteReverseWords(
                 &sha256->buffer[WC_SHA256_PAD_SIZE / sizeof(word32)],
                 &sha256->buffer[WC_SHA256_PAD_SIZE / sizeof(word32)],
                 2 * sizeof(word32));
         }
     #endif
 
     #if defined(WOLFSSL_USE_ESP32_CRYPT_HASH_HW)
         if (sha256->ctx.mode == ESP32_SHA_INIT) {
             esp_sha_try_hw_lock(&sha256->ctx);
         }
         if (sha256->ctx.mode == ESP32_SHA_SW) {
             ret = XTRANSFORM(sha256, (const byte*)local);
         }
         else {
             ret = esp_sha256_digest_process(sha256, 1);
         }
     #else
         ret = XTRANSFORM(sha256, (const byte*)local);
     #endif
 
         return ret;
     }
 
 #if !defined(WOLFSSL_KCAPI_HASH)
 
     int wc_Sha256FinalRaw(wc_Sha256* sha256, byte* hash)
     {
     #ifdef LITTLE_ENDIAN_ORDER
         word32 digest[WC_SHA256_DIGEST_SIZE / sizeof(word32)];
     #endif
 
         if (sha256 == NULL || hash == NULL) {
             return BAD_FUNC_ARG;
         }
 
     #ifdef LITTLE_ENDIAN_ORDER
         ByteReverseWords((word32*)digest, (word32*)sha256->digest,
                                                          WC_SHA256_DIGEST_SIZE);
         XMEMCPY(hash, digest, WC_SHA256_DIGEST_SIZE);
     #else
         XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
     #endif
 
         return 0;
     }
 
     int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
     {
         int ret;
 
         if (sha256 == NULL || hash == NULL) {
             return BAD_FUNC_ARG;
         }
 
     #ifdef WOLF_CRYPTO_CB
         #ifndef WOLF_CRYPTO_CB_FIND
         if (sha256->devId != INVALID_DEVID)
         #endif
         {
             ret = wc_CryptoCb_Sha256Hash(sha256, NULL, 0, hash);
             if (ret != CRYPTOCB_UNAVAILABLE)
                 return ret;
             /* fall-through when unavailable */
         }
     #endif
 
     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
         if (sha256->asyncDev.marker == WOLFSSL_ASYNC_MARKER_SHA256) {
         #if defined(HAVE_INTEL_QA)
             return IntelQaSymSha256(&sha256->asyncDev, hash, NULL,
                                             WC_SHA256_DIGEST_SIZE);
         #endif
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
         ret = Sha256Final(sha256);
         if (ret != 0) {
             return ret;
         }
 
     #if defined(LITTLE_ENDIAN_ORDER)
         ByteReverseWords(sha256->digest, sha256->digest, WC_SHA256_DIGEST_SIZE);
     #endif
         XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
 
         return InitSha256(sha256);  /* reset state */
     }
 
 #if defined(OPENSSL_EXTRA) || defined(HAVE_CURL)
 /* Apply SHA256 transformation to the data                */
 /* @param sha  a pointer to wc_Sha256 structure           */
 /* @param data data to be applied SHA256 transformation   */
 /* @return 0 on successful, otherwise non-zero on failure */
     int wc_Sha256Transform(wc_Sha256* sha, const unsigned char* data)
     {
         if (sha == NULL || data == NULL) {
             return BAD_FUNC_ARG;
         }
         return (Transform_Sha256(sha, data));
     }
     #endif
 #endif /* OPENSSL_EXTRA */
 
 #endif /* !WOLFSSL_KCAPI_HASH */
 
 
 #ifdef WOLFSSL_SHA224
 
 #ifdef STM32_HASH_SHA2
 
     /* Supports CubeMX HAL or Standard Peripheral Library */
 
     int wc_InitSha224_ex(wc_Sha224* sha224, void* heap, int devId)
     {
         if (sha224 == NULL)
             return BAD_FUNC_ARG;
         (void)devId;
         (void)heap;
 
         XMEMSET(sha224, 0, sizeof(wc_Sha224));
         wc_Stm32_Hash_Init(&sha224->stmCtx);
         return 0;
     }
 
     int wc_Sha224Update(wc_Sha224* sha224, const byte* data, word32 len)
     {
         int ret = 0;
 
         if (sha224 == NULL || (data == NULL && len > 0)) {
             return BAD_FUNC_ARG;
         }
 
         ret = wolfSSL_CryptHwMutexLock();
         if (ret == 0) {
             ret = wc_Stm32_Hash_Update(&sha224->stmCtx,
                 HASH_AlgoSelection_SHA224, data, len, WC_SHA224_BLOCK_SIZE);
             wolfSSL_CryptHwMutexUnLock();
         }
         return ret;
     }
 
     int wc_Sha224Final(wc_Sha224* sha224, byte* hash)
     {
         int ret = 0;
 
         if (sha224 == NULL || hash == NULL) {
             return BAD_FUNC_ARG;
         }
 
         ret = wolfSSL_CryptHwMutexLock();
         if (ret == 0) {
             ret = wc_Stm32_Hash_Final(&sha224->stmCtx,
                 HASH_AlgoSelection_SHA224, hash, WC_SHA224_DIGEST_SIZE);
             wolfSSL_CryptHwMutexUnLock();
         }
 
         (void)wc_InitSha224(sha224); /* reset state */
 
         return ret;
     }
 #elif defined(WOLFSSL_SE050) && defined(WOLFSSL_SE050_HASH)
 
     int wc_InitSha224_ex(wc_Sha224* sha224, void* heap, int devId)
     {
         if (sha224 == NULL) {
             return BAD_FUNC_ARG;
         }
         (void)devId;
 
         return se050_hash_init(&sha224->se050Ctx, heap);
     }
 
     int wc_Sha224Update(wc_Sha224* sha224, const byte* data, word32 len)
     {
         return se050_hash_update(&sha224->se050Ctx, data, len);
     }
 
     int wc_Sha224Final(wc_Sha224* sha224, byte* hash)
     {
         int ret = 0;
         ret = se050_hash_final(&sha224->se050Ctx, hash, WC_SHA224_DIGEST_SIZE,
                                kAlgorithm_SSS_SHA224);
         (void)wc_InitSha224(sha224);
         return ret;
     }
 
 #elif defined(WOLFSSL_IMX6_CAAM) && !defined(NO_IMX6_CAAM_HASH) && \
     !defined(WOLFSSL_QNX_CAAM)
     /* functions defined in wolfcrypt/src/port/caam/caam_sha256.c */
 
 #elif defined(WOLFSSL_AFALG_HASH)
     #error SHA224 currently not supported with AF_ALG enabled
 
 #elif defined(WOLFSSL_DEVCRYPTO_HASH)
     /* implemented in wolfcrypt/src/port/devcrypto/devcrypt_hash.c */
 
 #elif defined(WOLFSSL_SILABS_SE_ACCEL)
     /* implemented in wolfcrypt/src/port/silabs/silabs_hash.c */
 
 #elif defined(WOLFSSL_KCAPI_HASH) && !defined(WOLFSSL_NO_KCAPI_SHA224)
     /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */
 
 #elif defined(WOLFSSL_HAVE_PSA) && !defined(WOLFSSL_PSA_NO_HASH)
     /* implemented in wolfcrypt/src/port/psa/psa_hash.c */
 
 #elif defined(WOLFSSL_RENESAS_RX64_HASH)
 
 /* implemented in wolfcrypt/src/port/Renesas/renesas_rx64_hw_sha.c */
 
 #else
 
     #define NEED_SOFT_SHA224
 
 
     static int InitSha224(wc_Sha224* sha224)
     {
         int ret = 0;
 
         if (sha224 == NULL) {
             return BAD_FUNC_ARG;
         }
 
         sha224->digest[0] = 0xc1059ed8;
         sha224->digest[1] = 0x367cd507;
         sha224->digest[2] = 0x3070dd17;
         sha224->digest[3] = 0xf70e5939;
         sha224->digest[4] = 0xffc00b31;
         sha224->digest[5] = 0x68581511;
         sha224->digest[6] = 0x64f98fa7;
         sha224->digest[7] = 0xbefa4fa4;
 
         sha224->buffLen = 0;
         sha224->loLen   = 0;
         sha224->hiLen   = 0;
 
     #if defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
         /* choose best Transform function under this runtime environment */
         Sha256_SetTransform();
     #endif
     #ifdef WOLFSSL_HASH_FLAGS
         sha224->flags = 0;
     #endif
     #ifdef WOLFSSL_HASH_KEEP
         sha224->msg  = NULL;
         sha224->len  = 0;
         sha224->used = 0;
     #endif
 
     #if defined(WOLFSSL_USE_ESP32_CRYPT_HASH_HW)
         /* not to be confused with HAS512_224 */
         sha224->ctx.mode = ESP32_SHA_SW; /* no SHA224 HW, so always SW */
     #endif
 
         return ret;
     }
 
 #endif
 
 #ifdef NEED_SOFT_SHA224
     int wc_InitSha224_ex(wc_Sha224* sha224, void* heap, int devId)
     {
         int ret = 0;
 
         if (sha224 == NULL)
             return BAD_FUNC_ARG;
 
         sha224->heap = heap;
     #ifdef WOLFSSL_SMALL_STACK_CACHE
         sha224->W = NULL;
     #endif
 
     #ifdef WOLFSSL_USE_ESP32_CRYPT_HASH_HW
         /* We know this is a fresh, uninitialized item, so set to INIT */
         if (sha224->ctx.mode != ESP32_SHA_SW) {
             ESP_LOGV(TAG, "Set sha224 ctx mode init to ESP32_SHA_SW. "
                           "Prior value: %d", sha224->ctx.mode);
         }
         /* no sha224 HW support is available, set to SW */
         sha224->ctx.mode = ESP32_SHA_SW;
     #endif
 
         ret = InitSha224(sha224);
         if (ret != 0) {
             return ret;
         }
 
     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA224)
         ret = wolfAsync_DevCtxInit(&sha224->asyncDev,
                             WOLFSSL_ASYNC_MARKER_SHA224, sha224->heap, devId);
     #else
         (void)devId;
     #endif /* WOLFSSL_ASYNC_CRYPT */
 #ifdef WOLFSSL_IMXRT1170_CAAM
      ret = wc_CAAM_HashInit(&sha224->hndl, &sha224->ctx, WC_HASH_TYPE_SHA224);
 #endif
 
     #ifdef WOLFSSL_USE_ESP32_CRYPT_HASH_HW
         if (sha224->ctx.mode != ESP32_SHA_INIT) {
             ESP_LOGV("SHA224", "Set ctx mode from prior value: "
                                "%d", sha224->ctx.mode);
         }
         /* We know this is a fresh, uninitialized item, so set to INIT */
         sha224->ctx.mode = ESP32_SHA_INIT;
     #endif
 
         return ret;
     }
 
     int wc_Sha224Update(wc_Sha224* sha224, const byte* data, word32 len)
     {
         int ret;
 
         if (sha224 == NULL || (data == NULL && len > 0)) {
             return BAD_FUNC_ARG;
         }
 
     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA224)
         if (sha224->asyncDev.marker == WOLFSSL_ASYNC_MARKER_SHA224) {
         #if defined(HAVE_INTEL_QA)
             return IntelQaSymSha224(&sha224->asyncDev, NULL, data, len);
         #endif
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
     #if defined(WOLFSSL_USE_ESP32_CRYPT_HASH_HW)
         sha224->ctx.mode = ESP32_SHA_SW; /* no SHA224 HW, so always SW */
     #endif
 
         ret = Sha256Update((wc_Sha256*)sha224, data, len);
 
         return ret;
     }
 
     int wc_Sha224Final(wc_Sha224* sha224, byte* hash)
     {
         int ret;
 
         if (sha224 == NULL || hash == NULL) {
             return BAD_FUNC_ARG;
         }
 
     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA224)
         if (sha224->asyncDev.marker == WOLFSSL_ASYNC_MARKER_SHA224) {
         #if defined(HAVE_INTEL_QA)
             return IntelQaSymSha224(&sha224->asyncDev, hash, NULL,
                                             WC_SHA224_DIGEST_SIZE);
         #endif
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
     #if defined(WOLFSSL_USE_ESP32_CRYPT_HASH_HW)
         sha224->ctx.mode = ESP32_SHA_SW; /* no SHA224 HW, so always SW */
     #endif
 
         ret = Sha256Final((wc_Sha256*)sha224);
         if (ret != 0)
             return ret;
 
     #if defined(LITTLE_ENDIAN_ORDER)
         ByteReverseWords(sha224->digest, sha224->digest, WC_SHA224_DIGEST_SIZE);
     #endif
         XMEMCPY(hash, sha224->digest, WC_SHA224_DIGEST_SIZE);
 
         return InitSha224(sha224);  /* reset state */
     }
 #endif /* end of SHA224 software implementation */
 
     int wc_InitSha224(wc_Sha224* sha224)
     {
         int devId = INVALID_DEVID;
 
     #ifdef WOLF_CRYPTO_CB
         devId = wc_CryptoCb_DefaultDevID();
     #endif
         return wc_InitSha224_ex(sha224, NULL, devId);
     }
 
 #if !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)
     /* implemented in wolfcrypt/src/port/psa/psa_hash.c */
 
     void wc_Sha224Free(wc_Sha224* sha224)
     {
         if (sha224 == NULL)
             return;
 
 #ifdef WOLFSSL_SMALL_STACK_CACHE
-    if (sha224->W != NULL) {
-        XFREE(sha224->W, NULL, DYNAMIC_TYPE_DIGEST);
-        sha224->W = NULL;
-    }
+        if (sha224->W != NULL) {
+            ForceZero(sha224->W, sizeof(word32) * WC_SHA224_BLOCK_SIZE);
+            XFREE(sha224->W, NULL, DYNAMIC_TYPE_DIGEST);
+            sha224->W = NULL;
+        }
 #endif
 
     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA224)
         wolfAsync_DevCtxFree(&sha224->asyncDev, WOLFSSL_ASYNC_MARKER_SHA224);
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
     #ifdef WOLFSSL_PIC32MZ_HASH
         wc_Sha256Pic32Free(sha224);
     #endif
     #if defined(WOLFSSL_KCAPI_HASH)
         KcapiHashFree(&sha224->kcapi);
     #endif
     #if defined(WOLFSSL_RENESAS_RX64_HASH)
-    if (sha224->msg != NULL) {
-        XFREE(sha224->msg, sha224->heap, DYNAMIC_TYPE_TMP_BUFFER);
-        sha224->msg = NULL;
-    }
+        if (sha224->msg != NULL) {
+            ForceZero(sha224->msg, sha224->len);
+            XFREE(sha224->msg, sha224->heap, DYNAMIC_TYPE_TMP_BUFFER);
+            sha224->msg = NULL;
+        }
     #endif
+        ForceZero(sha224, sizeof(*sha224));
     }
 #endif /* WOLFSSL_SHA224 */
 #endif /* !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH) */
@@ -1733,92 +1737,95 @@ int wc_InitSha256(wc_Sha256* sha256)
 void wc_Sha256Free(wc_Sha256* sha256)
 {
     if (sha256 == NULL)
         return;
 
 #ifdef WOLFSSL_SMALL_STACK_CACHE
     if (sha256->W != NULL) {
+        ForceZero(sha256->W, sizeof(word32) * WC_SHA256_BLOCK_SIZE);
         XFREE(sha256->W, NULL, DYNAMIC_TYPE_DIGEST);
         sha256->W = NULL;
     }
 #endif
 
 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
     wolfAsync_DevCtxFree(&sha256->asyncDev, WOLFSSL_ASYNC_MARKER_SHA256);
 #endif /* WOLFSSL_ASYNC_CRYPT */
 #ifdef WOLFSSL_PIC32MZ_HASH
     wc_Sha256Pic32Free(sha256);
 #endif
 #if defined(WOLFSSL_AFALG_HASH)
     if (sha256->alFd > 0) {
         close(sha256->alFd);
         sha256->alFd = -1; /* avoid possible double close on socket */
     }
     if (sha256->rdFd > 0) {
         close(sha256->rdFd);
         sha256->rdFd = -1; /* avoid possible double close on socket */
     }
 #endif /* WOLFSSL_AFALG_HASH */
 #ifdef WOLFSSL_DEVCRYPTO_HASH
     wc_DevCryptoFree(&sha256->ctx);
 #endif /* WOLFSSL_DEVCRYPTO */
 #if (defined(WOLFSSL_AFALG_HASH) && defined(WOLFSSL_AFALG_HASH_KEEP)) || \
     (defined(WOLFSSL_DEVCRYPTO_HASH) && defined(WOLFSSL_DEVCRYPTO_HASH_KEEP)) || \
     ((defined(WOLFSSL_RENESAS_TSIP_TLS) || \
       defined(WOLFSSL_RENESAS_TSIP_CRYPTONLY)) && \
     !defined(NO_WOLFSSL_RENESAS_TSIP_CRYPT_HASH)) || \
     (defined(WOLFSSL_RENESAS_SCEPROTECT) && \
     !defined(NO_WOLFSSL_RENESAS_FSPSM_HASH)) || \
     defined(WOLFSSL_RENESAS_RX64_HASH) || \
     defined(WOLFSSL_HASH_KEEP)
 
     if (sha256->msg != NULL) {
+        ForceZero(sha256->msg, sha256->len);
         XFREE(sha256->msg, sha256->heap, DYNAMIC_TYPE_TMP_BUFFER);
         sha256->msg = NULL;
     }
 #endif
 #if defined(WOLFSSL_SE050) && defined(WOLFSSL_SE050_HASH)
     se050_hash_free(&sha256->se050Ctx);
 #endif
 #if defined(WOLFSSL_KCAPI_HASH)
     KcapiHashFree(&sha256->kcapi);
 #endif
 #ifdef WOLFSSL_IMXRT_DCP
     DCPSha256Free(sha256);
 #endif
 #ifdef WOLFSSL_MAXQ10XX_CRYPTO
     wc_MAXQ10XX_Sha256Free(sha256);
 #endif
 
 #ifdef HAVE_ARIA
     if (sha256->hSession != NULL) {
         MC_CloseSession(sha256->hSession);
         sha256->hSession = NULL;
     }
 #endif
 
 /* Espressif embedded hardware acceleration specific: */
 #if defined(WOLFSSL_USE_ESP32_CRYPT_HASH_HW)
     if (sha256->ctx.lockDepth > 0) {
         /* probably due to unclean shutdown, error, or other problem.
          *
          * if you find yourself here, code needs to be cleaned up to
          * properly release hardware. this init is only for handling
          * the unexpected. by the time free is called, the hardware
          * should have already been released (lockDepth = 0)
          */
         (void)InitSha256(sha256); /* unlock mutex, set mode to ESP32_SHA_INIT */
         ESP_LOGV(TAG, "Alert: hardware unlock needed in wc_Sha256Free.");
     }
     else {
         ESP_LOGV(TAG, "Hardware unlock not needed in wc_Sha256Free.");
     }
 #endif
+    ForceZero(sha256, sizeof(*sha256));
 }
 
 #endif /* !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH) */
 #ifdef WOLFSSL_HASH_KEEP
 /* Some hardware have issues with update, this function stores the data to be
  * hashed into an array. Once ready, the Final operation is called on all of the
  * data to be hashed at once.
  * returns 0 on success
  */
diff --git a/wolfcrypt/src/sha512.c b/wolfcrypt/src/sha512.c
index 0c2750a90..83af39c4b 100644
--- a/wolfcrypt/src/sha512.c
+++ b/wolfcrypt/src/sha512.c
@@ -1122,131 +1122,136 @@ int wc_InitSha512(wc_Sha512* sha512)
 void wc_Sha512Free(wc_Sha512* sha512)
 {
     if (sha512 == NULL)
         return;
 
 #ifdef WOLFSSL_SMALL_STACK_CACHE
     if (sha512->W != NULL) {
+        ForceZero(sha512->W, sizeof(word64) * 16);
         XFREE(sha512->W, sha512->heap, DYNAMIC_TYPE_TMP_BUFFER);
         sha512->W = NULL;
     }
 #endif
 
 #if defined(WOLFSSL_KCAPI_HASH)
     KcapiHashFree(&sha512->kcapi);
 #endif
 
 #if defined(WOLFSSL_HASH_KEEP)
     if (sha512->msg != NULL) {
+        ForceZero(sha512->msg, sha512->len);
         XFREE(sha512->msg, sha512->heap, DYNAMIC_TYPE_TMP_BUFFER);
         sha512->msg = NULL;
     }
 #endif
 
 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA512)
     wolfAsync_DevCtxFree(&sha512->asyncDev, WOLFSSL_ASYNC_MARKER_SHA512);
 #endif /* WOLFSSL_ASYNC_CRYPT */
+
+    ForceZero(sha512, sizeof(*sha512));
 }
 #if (defined(OPENSSL_EXTRA) || defined(HAVE_CURL)) \
     && !defined(WOLFSSL_KCAPI_HASH)
 /* Apply SHA512 transformation to the data                */
 /* @param sha  a pointer to wc_Sha512 structure           */
 /* @param data data to be applied SHA512 transformation   */
 /* @return 0 on successful, otherwise non-zero on failure */
 int wc_Sha512Transform(wc_Sha512* sha, const unsigned char* data)
 {
     int ret;
     /* back up buffer */
 #ifdef WOLFSSL_SMALL_STACK
     word64 *buffer;
 #else
     word64  buffer[WC_SHA512_BLOCK_SIZE  / sizeof(word64)];
 #endif
 
     /* sanity check */
     if (sha == NULL || data == NULL) {
         return BAD_FUNC_ARG;
     }
 
 #ifdef WOLFSSL_SMALL_STACK
     buffer = (word64*)XMALLOC(WC_SHA512_BLOCK_SIZE, sha->heap,
         DYNAMIC_TYPE_TMP_BUFFER);
     if (buffer == NULL)
         return MEMORY_E;
 #endif
 
 #if defined(USE_INTEL_SPEEDUP) && \
     (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
     Sha512_SetTransform();
 #endif
 
 #if defined(LITTLE_ENDIAN_ORDER)
 #if defined(USE_INTEL_SPEEDUP) && \
     (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
     if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
 #endif
     {
         ByteReverseWords64((word64*)data, (word64*)data,
                                                 WC_SHA512_BLOCK_SIZE);
     }
 #endif /* LITTLE_ENDIAN_ORDER */
 
     XMEMCPY(buffer, sha->buffer, WC_SHA512_BLOCK_SIZE);
     XMEMCPY(sha->buffer, data, WC_SHA512_BLOCK_SIZE);
 
     ret = Transform_Sha512(sha);
 
     XMEMCPY(sha->buffer, buffer, WC_SHA512_BLOCK_SIZE);
 #ifdef WOLFSSL_SMALL_STACK
+    ForceZero(buffer, WC_SHA512_BLOCK_SIZE);
     XFREE(buffer, sha->heap, DYNAMIC_TYPE_TMP_BUFFER);
 #endif
     return ret;
 }
 #endif /* OPENSSL_EXTRA */
 #endif /* WOLFSSL_SHA512 */
 #endif /* !WOLFSSL_SE050 || !WOLFSSL_SE050_HASH */
 
 
 /* -------------------------------------------------------------------------- */
 /* SHA384 */
 /* -------------------------------------------------------------------------- */
 #ifdef WOLFSSL_SHA384
 
 #if defined(WOLFSSL_IMX6_CAAM) && !defined(NO_IMX6_CAAM_HASH) && \
     !defined(WOLFSSL_QNX_CAAM)
     /* functions defined in wolfcrypt/src/port/caam/caam_sha.c */
 #elif defined(WOLFSSL_SE050) && defined(WOLFSSL_SE050_HASH)
     int wc_InitSha384_ex(wc_Sha384* sha384, void* heap, int devId)
     {
         if (sha384 == NULL) {
             return BAD_FUNC_ARG;
         }
         (void)devId;
         return se050_hash_init(&sha384->se050Ctx, heap);
     }
     int wc_Sha384Update(wc_Sha384* sha384, const byte* data, word32 len)
     {
         return se050_hash_update(&sha384->se050Ctx, data, len);
 
     }
     int wc_Sha384Final(wc_Sha384* sha384, byte* hash)
     {
         int ret = 0;
         ret = se050_hash_final(&sha384->se050Ctx, hash, WC_SHA384_DIGEST_SIZE,
                                kAlgorithm_SSS_SHA384);
         return ret;
     }
     int wc_Sha384FinalRaw(wc_Sha384* sha384, byte* hash)
     {
         int ret = 0;
         ret = se050_hash_final(&sha384->se050Ctx, hash, WC_SHA384_DIGEST_SIZE,
                                kAlgorithm_SSS_SHA384);
         return ret;
     }
 
 #elif defined(WOLFSSL_SILABS_SHA512)
     /* functions defined in wolfcrypt/src/port/silabs/silabs_hash.c */
 
 #elif defined(WOLFSSL_KCAPI_HASH)
     /* functions defined in wolfcrypt/src/port/kcapi/kcapi_hash.c */
 
 #else
@@ -1442,47 +1447,51 @@ int wc_InitSha384(wc_Sha384* sha384)
 void wc_Sha384Free(wc_Sha384* sha384)
 {
     if (sha384 == NULL)
         return;
 
 #ifdef WOLFSSL_SMALL_STACK_CACHE
     if (sha384->W != NULL) {
+        ForceZero(sha384->W, sizeof(word64) * 16);
         XFREE(sha384->W, sha384->heap, DYNAMIC_TYPE_TMP_BUFFER);
         sha384->W = NULL;
     }
 #endif
 
 #if defined(WOLFSSL_KCAPI_HASH)
     KcapiHashFree(&sha384->kcapi);
 #endif
 
 #if defined(WOLFSSL_HASH_KEEP)
     if (sha384->msg != NULL) {
+        ForceZero(sha384->msg, sha384->len);
         XFREE(sha384->msg, sha384->heap, DYNAMIC_TYPE_TMP_BUFFER);
         sha384->msg = NULL;
     }
 #endif
 
 #if defined(WOLFSSL_SE050) && defined(WOLFSSL_SE050_HASH)
     se050_hash_free(&sha384->se050Ctx);
 #endif
 
 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA384)
     wolfAsync_DevCtxFree(&sha384->asyncDev, WOLFSSL_ASYNC_MARKER_SHA384);
 #endif /* WOLFSSL_ASYNC_CRYPT */
 
 #ifdef HAVE_ARIA
     if (sha384->hSession != NULL) {
         MC_CloseSession(sha384->hSession);
         sha384->hSession = NULL;
     }
 #endif
+
+    ForceZero(sha384, sizeof(*sha384));
 }
 
 #endif /* WOLFSSL_SHA384 */
 
 #ifdef WOLFSSL_SHA512
 
 #if defined(WOLFSSL_KCAPI_HASH)
     /* functions defined in wolfcrypt/src/port/kcapi/kcapi_hash.c */
 
 #else
