commit 9f050fa0a65f3403c1f8296faf5f9d88d4900a8d
Author: Ivan Nardi <12729895+IvanNardi@users.noreply.github.com>
Date:   Tue Jan 18 21:52:37 2022 +0100

    TLS, H323, examples: fix some memory errors (#1414)
    
    Detected by oss-fuzz:
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26880
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26906
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=43782
    https://oss-fuzz.com/testcase-detail/6334089358082048

diff --git a/example/reader_util.c b/example/reader_util.c
index 7ca60214..136bef91 100644
--- a/example/reader_util.c
+++ b/example/reader_util.c
@@ -991,39 +991,41 @@ static struct ndpi_flow_info *get_ndpi_flow_info(struct ndpi_workflow * workflow
 static struct ndpi_flow_info *get_ndpi_flow_info6(struct ndpi_workflow * workflow,
 						  u_int16_t vlan_id,
 						  ndpi_packet_tunnel tunnel_type,
 						  const struct ndpi_ipv6hdr *iph6,
 						  u_int16_t ip_offset,
 						  u_int16_t ipsize,
 						  struct ndpi_tcphdr **tcph,
 						  struct ndpi_udphdr **udph,
 						  u_int16_t *sport, u_int16_t *dport,
 						  struct ndpi_id_struct **src,
 						  struct ndpi_id_struct **dst,
 						  u_int8_t *proto,
 						  u_int8_t **payload,
 						  u_int16_t *payload_len,
 						  u_int8_t *src_to_dst_direction,
                                                   pkt_timeval when) {
   struct ndpi_iphdr iph;
 
+  if(ipsize < 40)
+    return(NULL);
   memset(&iph, 0, sizeof(iph));
   iph.version = IPVERSION;
   iph.saddr = iph6->ip6_src.u6_addr.u6_addr32[2] + iph6->ip6_src.u6_addr.u6_addr32[3];
   iph.daddr = iph6->ip6_dst.u6_addr.u6_addr32[2] + iph6->ip6_dst.u6_addr.u6_addr32[3];
   u_int8_t l4proto = iph6->ip6_hdr.ip6_un1_nxt;
   u_int16_t ip_len = ntohs(iph6->ip6_hdr.ip6_un1_plen);
   const u_int8_t *l4ptr = (((const u_int8_t *) iph6) + sizeof(struct ndpi_ipv6hdr));
   if(ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr), &l4ptr, &ip_len, &l4proto) != 0) {
     return(NULL);
   }
   iph.protocol = l4proto;
 
   return(get_ndpi_flow_info(workflow, 6, vlan_id, tunnel_type,
 			    &iph, iph6, ip_offset, ipsize,
 			    ip_len, l4ptr - (const u_int8_t *)iph6,
 			    tcph, udph, sport, dport,
 			    src, dst, proto, payload,
 			    payload_len, src_to_dst_direction, when));
 }
 
 /* ****************************************************** */
@@ -1636,488 +1638,490 @@ int ndpi_is_datalink_supported(int datalink_type) {
 struct ndpi_proto ndpi_workflow_process_packet(struct ndpi_workflow * workflow,
 					       const struct pcap_pkthdr *header,
 					       const u_char *packet,
 					       ndpi_risk *flow_risk,
 					       FILE * csv_fp) {
   /*
    * Declare pointers to packet headers
    */
   /* --- Ethernet header --- */
   const struct ndpi_ethhdr *ethernet;
   /* --- LLC header --- */
   const struct ndpi_llc_header_snap *llc;
 
   /* --- Cisco HDLC header --- */
   const struct ndpi_chdlc *chdlc;
 
   /* --- Radio Tap header --- */
   const struct ndpi_radiotap_header *radiotap;
   /* --- Wifi header --- */
   const struct ndpi_wifi_header *wifi;
 
   /* --- MPLS header --- */
   union mpls {
     uint32_t u32;
     struct ndpi_mpls_header mpls;
   } mpls;
 
   /** --- IP header --- **/
   struct ndpi_iphdr *iph;
   /** --- IPv6 header --- **/
   struct ndpi_ipv6hdr *iph6;
 
   struct ndpi_proto nproto = NDPI_PROTOCOL_NULL;
   ndpi_packet_tunnel tunnel_type = ndpi_no_tunnel;
 
   /* lengths and offsets */
   u_int32_t eth_offset = 0;
   u_int16_t radio_len;
   u_int16_t fc;
   u_int16_t type = 0;
   int wifi_len = 0;
   int pyld_eth_len = 0;
   int check;
   u_int64_t time_ms;
   u_int16_t ip_offset = 0, ip_len;
   u_int16_t frag_off = 0, vlan_id = 0;
   u_int8_t proto = 0, recheck_type;
   /*u_int32_t label;*/
 
   /* counters */
   u_int8_t vlan_packet = 0;
 
   *flow_risk = 0 /* NDPI_NO_RISK */;
 
   /* Increment raw packet counter */
   workflow->stats.raw_packet_count++;
 
   /* setting time */
   time_ms = ((uint64_t) header->ts.tv_sec) * TICK_RESOLUTION + header->ts.tv_usec / (1000000 / TICK_RESOLUTION);
 
   /* safety check */
   if(workflow->last_time > time_ms) {
     /* printf("\nWARNING: timestamp bug in the pcap file (ts delta: %llu, repairing)\n", ndpi_thread_info[thread_id].last_time - time); */
     time_ms = workflow->last_time;
   }
   /* update last time value */
   workflow->last_time = time_ms;
 
   /*** check Data Link type ***/
   int datalink_type;
 
 #ifdef USE_DPDK
   datalink_type = DLT_EN10MB;
 #else
   datalink_type = (int)pcap_datalink(workflow->pcap_handle);
 #endif
 
  datalink_check:
   // 20 for min iph and 8 for min UDP
   if(header->caplen < eth_offset + 28)
     return(nproto); /* Too short */
 
   /* Keep in sync with ndpi_is_datalink_supported() */
   switch(datalink_type) {
   case DLT_NULL:
     if(ntohl(*((u_int32_t*)&packet[eth_offset])) == 2)
       type = ETH_P_IP;
     else
       type = ETH_P_IPV6;
 
     ip_offset = 4 + eth_offset;
     break;
 
     /* Cisco PPP in HDLC-like framing - 50 */
   case DLT_PPP_SERIAL:
     chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
-    ip_offset = sizeof(struct ndpi_chdlc); /* CHDLC_OFF = 4 */
+    ip_offset = eth_offset + sizeof(struct ndpi_chdlc); /* CHDLC_OFF = 4 */
     type = ntohs(chdlc->proto_code);
     break;
 
     /* Cisco PPP - 9 or 104 */
   case DLT_C_HDLC:
   case DLT_PPP:
     if(packet[0] == 0x0f || packet[0] == 0x8f) {
       chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
-      ip_offset = sizeof(struct ndpi_chdlc); /* CHDLC_OFF = 4 */
+      ip_offset = eth_offset + sizeof(struct ndpi_chdlc); /* CHDLC_OFF = 4 */
       type = ntohs(chdlc->proto_code);
     } else {
-      ip_offset = 2;
+      ip_offset = eth_offset + 2;
       type = ntohs(*((u_int16_t*)&packet[eth_offset]));
     }
     break;
 
 #ifdef DLT_IPV4
   case DLT_IPV4:
     type = ETH_P_IP;
     ip_offset = 0;
     break;
 #endif
 
 #ifdef DLT_IPV6
   case DLT_IPV6:
     type = ETH_P_IPV6;
     ip_offset = 0;
     break;
 #endif
 
     /* IEEE 802.3 Ethernet - 1 */
   case DLT_EN10MB:
     ethernet = (struct ndpi_ethhdr *) &packet[eth_offset];
     ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;
     check = ntohs(ethernet->h_proto);
 
     if(check <= 1500)
       pyld_eth_len = check;
     else if(check >= 1536)
       type = check;
 
     if(pyld_eth_len != 0) {
       llc = (struct ndpi_llc_header_snap *)(&packet[ip_offset]);
       /* check for LLC layer with SNAP extension */
       if(llc->dsap == SNAP || llc->ssap == SNAP) {
 	type = llc->snap.proto_ID;
 	ip_offset += + 8;
       }
       /* No SNAP extension - Spanning Tree pkt must be discarted */
       else if(llc->dsap == BSTP || llc->ssap == BSTP) {
 	goto v4_warning;
       }
     }
     break;
 
     /* Linux Cooked Capture - 113 */
   case DLT_LINUX_SLL:
     type = (packet[eth_offset+14] << 8) + packet[eth_offset+15];
     ip_offset = 16 + eth_offset;
     break;
 
     /* Radiotap link-layer - 127 */
   case DLT_IEEE802_11_RADIO:
     radiotap = (struct ndpi_radiotap_header *) &packet[eth_offset];
     radio_len = radiotap->len;
 
     /* Check Bad FCS presence */
     if((radiotap->flags & BAD_FCS) == BAD_FCS) {
       workflow->stats.total_discarded_bytes +=  header->len;
       return(nproto);
     }
 
     if(header->caplen < (eth_offset + radio_len + sizeof(struct ndpi_wifi_header)))
       return(nproto);
 
     /* Calculate 802.11 header length (variable) */
     wifi = (struct ndpi_wifi_header*)( packet + eth_offset + radio_len);
     fc = wifi->fc;
 
     /* check wifi data presence */
     if(FCF_TYPE(fc) == WIFI_DATA) {
       if((FCF_TO_DS(fc) && FCF_FROM_DS(fc) == 0x0) ||
 	 (FCF_TO_DS(fc) == 0x0 && FCF_FROM_DS(fc)))
 	wifi_len = 26; /* + 4 byte fcs */
     } else   /* no data frames */
       break;
 
     /* Check ether_type from LLC */
     if(header->caplen < (eth_offset + wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap)))
       return(nproto);
     llc = (struct ndpi_llc_header_snap*)(packet + eth_offset + wifi_len + radio_len);
     if(llc->dsap == SNAP)
       type = ntohs(llc->snap.proto_ID);
 
     /* Set IP header offset */
     ip_offset = wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap) + eth_offset;
     break;
 
   case DLT_RAW:
     ip_offset = eth_offset = 0;
     break;
 
   default:
     /*
      * We shoudn't be here, because we already checked that this datalink is supported.
      * Should ndpi_is_datalink_supported() be updated?
      */
     printf("Unknown datalink %d\n", datalink_type);
     return(nproto);
   }
 
  ether_type_check:
   recheck_type = 0;
 
   /* check ether type */
   switch(type) {
   case ETH_P_VLAN:
+    if(ip_offset+4 >= (int)header->caplen)
+      return(nproto);
     vlan_id = ((packet[ip_offset] << 8) + packet[ip_offset+1]) & 0xFFF;
     type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];
     ip_offset += 4;
     vlan_packet = 1;
 
     // double tagging for 802.1Q
-    while((type == 0x8100) && (((bpf_u_int32)ip_offset) < header->caplen)) {
+    while((type == 0x8100) && (((bpf_u_int32)ip_offset+4) < header->caplen)) {
       vlan_id = ((packet[ip_offset] << 8) + packet[ip_offset+1]) & 0xFFF;
       type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];
       ip_offset += 4;
     }
     recheck_type = 1;
     break;
 
   case ETH_P_MPLS_UNI:
   case ETH_P_MPLS_MULTI:
     mpls.u32 = *((uint32_t *) &packet[ip_offset]);
     mpls.u32 = ntohl(mpls.u32);
     workflow->stats.mpls_count++;
     type = ETH_P_IP, ip_offset += 4;
 
     while(!mpls.mpls.s && (((bpf_u_int32)ip_offset) + 4 < header->caplen)) {
       mpls.u32 = *((uint32_t *) &packet[ip_offset]);
       mpls.u32 = ntohl(mpls.u32);
       ip_offset += 4;
     }
     recheck_type = 1;
     break;
 
   case ETH_P_PPPoE:
     workflow->stats.pppoe_count++;
     type = ETH_P_IP;
     ip_offset += 8;
     recheck_type = 1;
     break;
 
   default:
     break;
   }
 
   if(recheck_type)
     goto ether_type_check;
 
   workflow->stats.vlan_count += vlan_packet;
 
  iph_check:
   /* Check and set IP header size and total packet length */
   if(header->caplen < ip_offset + sizeof(struct ndpi_iphdr))
     return(nproto); /* Too short for next IP header*/
 
   iph = (struct ndpi_iphdr *) &packet[ip_offset];
 
   /* just work on Ethernet packets that contain IP */
   if(type == ETH_P_IP && header->caplen >= ip_offset) {
     frag_off = ntohs(iph->frag_off);
 
     proto = iph->protocol;
     if(header->caplen < header->len) {
       static u_int8_t cap_warning_used = 0;
 
       if(cap_warning_used == 0) {
 	if(!workflow->prefs.quiet_mode)
 	  LOG(NDPI_LOG_DEBUG,
 		   "\n\nWARNING: packet capture size is smaller than packet size, DETECTION MIGHT NOT WORK CORRECTLY\n\n");
 	cap_warning_used = 1;
       }
     }
   }
 
   if(iph->version == IPVERSION) {
     ip_len = ((u_int16_t)iph->ihl * 4);
     iph6 = NULL;
 
     if(iph->protocol == IPPROTO_IPV6
 #ifdef IPPROTO_IPIP
        || iph->protocol == IPPROTO_IPIP
 #endif
        ) {
       ip_offset += ip_len;
       if(ip_len > 0)
         goto iph_check;
     }
 
     if((frag_off & 0x1FFF) != 0) {
       static u_int8_t ipv4_frags_warning_used = 0;
       workflow->stats.fragmented_count++;
 
       if(ipv4_frags_warning_used == 0) {
 	if(!workflow->prefs.quiet_mode)
 	  LOG(NDPI_LOG_DEBUG, "\n\nWARNING: IPv4 fragments are not handled by this demo (nDPI supports them)\n");
 	ipv4_frags_warning_used = 1;
       }
 
       workflow->stats.total_discarded_bytes +=  header->len;
       return(nproto);
     }
   } else if(iph->version == 6) {
     if(header->caplen < ip_offset + sizeof(struct ndpi_ipv6hdr))
       return(nproto); /* Too short for IPv6 header*/
 
     iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
     proto = iph6->ip6_hdr.ip6_un1_nxt;
     ip_len = ntohs(iph6->ip6_hdr.ip6_un1_plen);
 
     if(header->caplen < (ip_offset + sizeof(struct ndpi_ipv6hdr) + ntohs(iph6->ip6_hdr.ip6_un1_plen)))
       return(nproto); /* Too short for IPv6 payload*/
 
     const u_int8_t *l4ptr = (((const u_int8_t *) iph6) + sizeof(struct ndpi_ipv6hdr));
     u_int16_t ipsize = header->caplen - ip_offset;
 
     if(ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr), &l4ptr, &ip_len, &proto) != 0) {
       return(nproto);
     }
 
     if(proto == IPPROTO_IPV6
 #ifdef IPPROTO_IPIP
        || proto == IPPROTO_IPIP
 #endif
        ) {
       if(l4ptr > packet) { /* Better safe than sorry */
         ip_offset = (l4ptr - packet);
         goto iph_check;
       }
     }
 
     iph = NULL;
   } else {
     static u_int8_t ipv4_warning_used = 0;
 
   v4_warning:
     if(ipv4_warning_used == 0) {
       if(!workflow->prefs.quiet_mode)
         LOG(NDPI_LOG_DEBUG,
 		 "\n\nWARNING: only IPv4/IPv6 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\n\n");
       ipv4_warning_used = 1;
     }
 
     workflow->stats.total_discarded_bytes +=  header->len;
     return(nproto);
   }
 
   if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
     if(header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr))
       return(nproto); /* Too short for UDP header*/
     else {
       struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];
       u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);
 
       if(((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) &&
          (ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 8 /* Minimum GTPv1 header len */ < header->caplen)) {
 	/* Check if it's GTPv1 */
 	u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
 	u_int8_t flags = packet[offset];
 	u_int8_t message_type = packet[offset+1];
 	u_int8_t exts_parsing_error = 0;
 
 	if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) &&
 	   (message_type == 0xFF /* T-PDU */)) {
 
 	  offset += 8; /* GTPv1 header len */
 	  if(flags & 0x07)
 	    offset += 4; /* sequence_number + pdu_number + next_ext_header fields */
 	  /* Extensions parsing */
 	  if(flags & 0x04) {
 	    unsigned int ext_length = 0;
 
 	    while(offset < header->caplen) {
 	      ext_length = packet[offset] << 2;
 	      offset += ext_length;
 	      if(offset >= header->caplen || ext_length == 0) {
 	        exts_parsing_error = 1;
 	        break;
 	      }
 	      if(packet[offset - 1] == 0)
 	        break;
 	    }
 	  }
 
 	  if(offset < header->caplen && !exts_parsing_error) {
 	    /* Ok, valid GTP-U */
 	    tunnel_type = ndpi_gtp_tunnel;
 	    ip_offset = offset;
 	    iph = (struct ndpi_iphdr *)&packet[ip_offset];
 	    if(iph->version == 6) {
 	      iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
 	      iph = NULL;
 	    } else if(iph->version != IPVERSION) {
 	      // printf("WARNING: not good (packet_id=%u)!\n", (unsigned int)workflow->stats.raw_packet_count);
 	      goto v4_warning;
 	    }
 	  }
 	}
       } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
 	/* https://en.wikipedia.org/wiki/TZSP */
 	if(header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4)
 	  return(nproto); /* Too short for TZSP*/
 
 	u_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
 	u_int8_t version       = packet[offset];
 	u_int8_t ts_type       = packet[offset+1];
 	u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));
 
 	tunnel_type = ndpi_tzsp_tunnel;
 
 	if((version == 1) && (ts_type == 0) && (encapsulates == 1)) {
 	  u_int8_t stop = 0;
 
 	  offset += 4;
 
 	  while((!stop) && (offset < header->caplen)) {
 	    u_int8_t tag_type = packet[offset];
 	    u_int8_t tag_len;
 
 	    switch(tag_type) {
 	    case 0: /* PADDING Tag */
 	      tag_len = 1;
 	      break;
 	    case 1: /* END Tag */
 	      tag_len = 1, stop = 1;
 	      break;
 	    default:
 	      tag_len = packet[offset+1];
 	      break;
 	    }
 
 	    offset += tag_len;
 
 	    if(offset >= header->caplen)
 	      return(nproto); /* Invalid packet */
 	    else {
 	      eth_offset = offset;
 	      goto datalink_check;
 	    }
 	  }
 	}
       } else if((sport == NDPI_CAPWAP_DATA_PORT) || (dport == NDPI_CAPWAP_DATA_PORT)) {
 	/* We dissect ONLY CAPWAP traffic */
 	u_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
 
 	if((offset+1) < header->caplen) {
 	  uint8_t preamble = packet[offset];
 
 	  if((preamble & 0x0F) == 0) { /* CAPWAP header */
 	    u_int16_t msg_len = (packet[offset+1] & 0xF8) >> 1;
 
 	    offset += msg_len;
 
 	    if((offset + 32 < header->caplen)) {
 	      /* IEEE 802.11 Data */
 	      offset += 24;
 	      /* LLC header is 8 bytes */
 	      type = ntohs((u_int16_t)*((u_int16_t*)&packet[offset+6]));
 
 	      ip_offset = offset + 8;
 
 	      tunnel_type = ndpi_capwap_tunnel;
 	      goto iph_check;
 	    }
 	  }
 	}
       }
     }
   }
 
   /* process the packet */
   return(packet_processing(workflow, time_ms, vlan_id, tunnel_type, iph, iph6,
 			   ip_offset, header->caplen - ip_offset,
 			   header->caplen, header, packet, header->ts,
 			   flow_risk, csv_fp));
 }
 
 /* ********************************************************** */
 /*       http://home.thep.lu.se/~bjorn/crc/crc32_fast.c       */
 /* ********************************************************** */
diff --git a/src/lib/protocols/h323.c b/src/lib/protocols/h323.c
index 7774b9d0..c52ddb0f 100644
--- a/src/lib/protocols/h323.c
+++ b/src/lib/protocols/h323.c
@@ -34,85 +34,85 @@ struct tpkt {
 void ndpi_search_h323(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
 {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   u_int16_t dport = 0, sport = 0;
 
   NDPI_LOG_DBG(ndpi_struct, "search H323\n");
 
   /*
     The TPKT protocol is used by ISO 8072 (on port 102)
     and H.323. So this check below is to avoid ambiguities
   */
   if((packet->tcp != NULL) && (packet->tcp->dest != ntohs(102))) {
     NDPI_LOG_DBG2(ndpi_struct, "calculated dport over tcp\n");
 
     /* H323  */
-    if(packet->payload_packet_len > 4
+    if(packet->payload_packet_len > 5
        && (packet->payload[0] == 0x03)
        && (packet->payload[1] == 0x00)) {
       struct tpkt *t = (struct tpkt*)packet->payload;
       u_int16_t len = ntohs(t->len);
 
       if(packet->payload_packet_len == len) {
 	/*
 	  We need to check if this packet is in reality
 	  a RDP (Remote Desktop) packet encapsulated on TPTK
 	*/
 
 	if(packet->payload[4] == (packet->payload_packet_len - sizeof(struct tpkt) - 1)) {
 	  /* ISO 8073/X.224 */
 	  if((packet->payload[5] == 0xE0 /* CC Connect Request */)
 	     || (packet->payload[5] == 0xD0 /* CC Connect Confirm */)) {
 	    NDPI_LOG_INFO(ndpi_struct, "found RDP\n");
 	    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_RDP, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI);
 	    return;
 	  }
 	}
 
 	flow->l4.tcp.h323_valid_packets++;
 
 	if(flow->l4.tcp.h323_valid_packets >= 2) {
 	  NDPI_LOG_INFO(ndpi_struct, "found H323 broadcast\n");
 	  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI);
 	}
       } else {
 	/* This is not H.323 */
 	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
 	return;
       }
     }
   } else if(packet->udp != NULL) {
     sport = ntohs(packet->udp->source), dport = ntohs(packet->udp->dest);
     NDPI_LOG_DBG2(ndpi_struct, "calculated dport over udp\n");
 
     if(packet->payload_packet_len >= 6 && packet->payload[0] == 0x80 && packet->payload[1] == 0x08 &&
        (packet->payload[2] == 0xe7 || packet->payload[2] == 0x26) &&
        packet->payload[4] == 0x00 && packet->payload[5] == 0x00)
       {
 	NDPI_LOG_INFO(ndpi_struct, "found H323 broadcast\n");
 	ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI);
 	return;
       }
     /* H323  */
     if(sport == 1719 || dport == 1719) {
       if((packet->payload_packet_len > 5)
 	 && (packet->payload[0] == 0x16)
 	 && (packet->payload[1] == 0x80)
 	 && (packet->payload[4] == 0x06)
 	 && (packet->payload[5] == 0x00)) {
 	NDPI_LOG_INFO(ndpi_struct, "found H323 broadcast\n");
 	ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI);
 	return;
       } else if(packet->payload_packet_len >= 20 && packet->payload_packet_len <= 117) {
 	NDPI_LOG_INFO(ndpi_struct, "found H323 broadcast\n");
 	ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI);
 	return;
       } else {
 	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
 	return;
       }
     }
   }
   
   if(flow->packet_counter > 5)
     NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
 }
diff --git a/src/lib/protocols/tls.c b/src/lib/protocols/tls.c
index fe28b825..600346b8 100644
--- a/src/lib/protocols/tls.c
+++ b/src/lib/protocols/tls.c
@@ -1271,1074 +1271,1074 @@ static void checkExtensions(struct ndpi_detection_module_struct *ndpi_struct,
 int processClientServerHello(struct ndpi_detection_module_struct *ndpi_struct,
 			     struct ndpi_flow_struct *flow, uint32_t quic_version) {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   union ja3_info ja3;
   u_int8_t invalid_ja3 = 0;
   u_int16_t tls_version, ja3_str_len;
   char ja3_str[JA3_STR_LEN];
   ndpi_MD5_CTX ctx;
   u_char md5_hash[16];
   u_int32_t i, j;
   u_int16_t total_len;
   u_int8_t handshake_type;
   int is_quic = (quic_version != 0);
   int is_dtls = packet->udp && (!is_quic);
 
 #ifdef DEBUG_TLS
   printf("TLS %s() called\n", __FUNCTION__);
 #endif
 
 
   handshake_type = packet->payload[0];
   total_len = (packet->payload[1] << 16) +  (packet->payload[2] << 8) + packet->payload[3];
 
   if((total_len > packet->payload_packet_len) || (packet->payload[1] != 0x0))
     return(0); /* Not found */
 
   total_len = packet->payload_packet_len;
 
   /* At least "magic" 3 bytes, null for string end, otherwise no need to waste cpu cycles */
   if(total_len > 4) {
     u_int16_t base_offset    = (!is_dtls) ? 38 : 46;
     u_int16_t version_offset = (!is_dtls) ? 4 : 12;
     u_int16_t offset = (!is_dtls) ? 38 : 46;
     u_int32_t tot_extension_len;
     u_int8_t  session_id_len =  0;
 
     if((base_offset >= total_len) ||
        (version_offset + 1) >= total_len)
       return 0; /* Not found */
 
     session_id_len = packet->payload[base_offset];
 
 #ifdef DEBUG_TLS
     printf("TLS [len: %u][handshake_type: %02X]\n", packet->payload_packet_len, handshake_type);
 #endif
 
     tls_version = ntohs(*((u_int16_t*)&packet->payload[version_offset]));
 
     if(handshake_type == 0x02 /* Server Hello */) {
       int rc;
 
       ja3.server.num_cipher = 0;
       ja3.server.num_tls_extension = 0;
       ja3.server.num_elliptic_curve_point_format = 0;
       ja3.server.alpn[0] = '\0';
 
       ja3.server.tls_handshake_version = tls_version;
 
 #ifdef DEBUG_TLS
       printf("TLS Server Hello [version: 0x%04X]\n", tls_version);
 #endif
 
       /*
 	The server hello decides about the TLS version of this flow
 	https://networkengineering.stackexchange.com/questions/55752/why-does-wireshark-show-version-tls-1-2-here-instead-of-tls-1-3
       */
       if(packet->udp)
 	offset += session_id_len + 1;
       else {
 	if(tls_version < 0x7F15 /* TLS 1.3 lacks of session id */)
 	  offset += session_id_len+1;
       }
 
       if((offset+3) > packet->payload_packet_len)
 	return(0); /* Not found */
 
       ja3.server.num_cipher = 1, ja3.server.cipher[0] = ntohs(*((u_int16_t*)&packet->payload[offset]));
       if((flow->protos.tls_quic.server_unsafe_cipher = ndpi_is_safe_ssl_cipher(ja3.server.cipher[0])) == 1)
 	ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_WEAK_CIPHER);
 
       flow->protos.tls_quic.server_cipher = ja3.server.cipher[0];
 
 #ifdef DEBUG_TLS
       printf("TLS [server][session_id_len: %u][cipher: %04X]\n", session_id_len, ja3.server.cipher[0]);
 #endif
 
       offset += 2 + 1;
 
       if((offset + 1) < packet->payload_packet_len) /* +1 because we are goint to read 2 bytes */
 	tot_extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
       else
 	tot_extension_len = 0;
 
 #ifdef DEBUG_TLS
       printf("TLS [server][tot_extension_len: %u]\n", tot_extension_len);
 #endif
       offset += 2;
 
       for(i=0; i<tot_extension_len; ) {
         u_int16_t extension_id;
         u_int32_t extension_len;
 
 	if((offset+4) > packet->payload_packet_len) break;
 
 	extension_id  = ntohs(*((u_int16_t*)&packet->payload[offset]));
 	extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+2]));
 	if(offset+4+extension_len > packet->payload_packet_len) {
 	  break;
 	}
 
 	if(ja3.server.num_tls_extension < MAX_NUM_JA3)
 	  ja3.server.tls_extension[ja3.server.num_tls_extension++] = extension_id;
 
 #ifdef DEBUG_TLS
 	printf("TLS [server][extension_id: %u/0x%04X][len: %u]\n",
 	       extension_id, extension_id, extension_len);
 #endif
 	checkExtensions(ndpi_struct, flow, is_dtls, extension_id, extension_len, offset + 4);
 
 	if(extension_id == 43 /* supported versions */) {
 	  if(extension_len >= 2) {
 	    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset+4]));
 
 #ifdef DEBUG_TLS
 	    printf("TLS [server] [TLS version: 0x%04X]\n", tls_version);
 #endif
 
 	    flow->protos.tls_quic.ssl_version = ja3.server.tls_supported_version = tls_version;
 	  }
 	} else if(extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */ &&
 	          offset + 6 < packet->payload_packet_len) {
 	  u_int16_t s_offset = offset+4;
 	  u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 	  char alpn_str[256];
 	  u_int8_t alpn_str_len = 0, i;
 
 #ifdef DEBUG_TLS
 	  printf("Server TLS [ALPN: block_len=%u/len=%u]\n", extension_len, tot_alpn_len);
 #endif
 	  s_offset += 2;
 	  tot_alpn_len += s_offset;
 
 	  if(tot_alpn_len > packet->payload_packet_len)
 	    return 0;
 
 	  while(s_offset < tot_alpn_len && s_offset < total_len) {
 	    u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];
 
 	    if((s_offset + alpn_len) <= tot_alpn_len) {
 #ifdef DEBUG_TLS
 	      printf("Server TLS [ALPN: %u]\n", alpn_len);
 #endif
 
 	      if(((uint32_t)alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {
 	        if(alpn_str_len > 0) {
 	          alpn_str[alpn_str_len] = ',';
 	          alpn_str_len++;
 	        }
 
 	        for(alpn_i=0; alpn_i<alpn_len; alpn_i++)
 	        {
 	          alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];
 	        }
 
 	        s_offset += alpn_len, alpn_str_len += alpn_len;;
 	      } else {
 	        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN);
 	        break;
 	      }
 	    } else {
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN);
 	      break;
 	    }
 	  } /* while */
 
 	  alpn_str[alpn_str_len] = '\0';
 
 #ifdef DEBUG_TLS
 	  printf("Server TLS [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
 #endif
 	  if(ndpi_is_printable_string(alpn_str, alpn_str_len) == 0)
 	    ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);
 
 	  if(flow->protos.tls_quic.alpn == NULL)
 	    flow->protos.tls_quic.alpn = ndpi_strdup(alpn_str);
 
 	  if(flow->protos.tls_quic.alpn != NULL)
 	    tlsCheckUncommonALPN(ndpi_struct, flow);
 
 	  snprintf(ja3.server.alpn, sizeof(ja3.server.alpn), "%s", alpn_str);
 
 	  /* Replace , with - as in JA3 */
 	  for(i=0; ja3.server.alpn[i] != '\0'; i++)
 	    if(ja3.server.alpn[i] == ',') ja3.server.alpn[i] = '-';
 	} else if(extension_id == 11 /* ec_point_formats groups */) {
 	  u_int16_t s_offset = offset+4 + 1;
 
 #ifdef DEBUG_TLS
 	  printf("Server TLS [EllipticCurveFormat: len=%u]\n", extension_len);
 #endif
 	  if((s_offset+extension_len-1) <= total_len) {
 	    for(i=0; i<extension_len-1 && s_offset+i<packet->payload_packet_len; i++) {
 	      u_int8_t s_group = packet->payload[s_offset+i];
 
 #ifdef DEBUG_TLS
 	      printf("Server TLS [EllipticCurveFormat: %u]\n", s_group);
 #endif
 
 	      if(ja3.server.num_elliptic_curve_point_format < MAX_NUM_JA3)
 		ja3.server.elliptic_curve_point_format[ja3.server.num_elliptic_curve_point_format++] = s_group;
 	      else {
 		invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		printf("Server TLS Invalid num elliptic %u\n", ja3.server.num_elliptic_curve_point_format);
 #endif
 	      }
 	    }
 	  } else {
 	    invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 	    printf("Server TLS Invalid len %u vs %u\n", s_offset+extension_len, total_len);
 #endif
 	  }
 	}
 
 	i += 4 + extension_len, offset += 4 + extension_len;
       } /* for */
 
       ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.server.tls_handshake_version);
 
       for(i=0; (i<ja3.server.num_cipher) && (JA3_STR_LEN > ja3_str_len); i++) {
 	rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u", (i > 0) ? "-" : "", ja3.server.cipher[i]);
 
 	if(rc <= 0) break; else ja3_str_len += rc;
       }
 
       if(JA3_STR_LEN > ja3_str_len) {
 	rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",");
 	if(rc > 0 && ja3_str_len + rc < JA3_STR_LEN) ja3_str_len += rc;
       }
 
       /* ********** */
 
       for(i=0; (i<ja3.server.num_tls_extension) && (JA3_STR_LEN > ja3_str_len); i++) {
 	int rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u", (i > 0) ? "-" : "", ja3.server.tls_extension[i]);
 
 	if(rc <= 0) break; else ja3_str_len += rc;
       }
 
       if(ndpi_struct->enable_ja3_plus) {
 	for(i=0; (i<ja3.server.num_elliptic_curve_point_format) && (JA3_STR_LEN > ja3_str_len); i++) {
 	  rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			(i > 0) ? "-" : "", ja3.server.elliptic_curve_point_format[i]);
 	  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	}
 
 	if((ja3.server.alpn[0] != '\0') && (JA3_STR_LEN > ja3_str_len)) {
 	  rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",%s", ja3.server.alpn);
 	  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 	}
 
 #ifdef DEBUG_TLS
 	printf("[JA3+] Server: %s \n", ja3_str);
 #endif
       } else {
 #ifdef DEBUG_TLS
 	printf("[JA3] Server: %s \n", ja3_str);
 #endif
       }
 
       ndpi_MD5Init(&ctx);
       ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));
       ndpi_MD5Final(md5_hash, &ctx);
 
       for(i=0, j=0; i<16; i++) {
 	int rc = snprintf(&flow->protos.tls_quic.ja3_server[j],
 			  sizeof(flow->protos.tls_quic.ja3_server)-j, "%02x", md5_hash[i]);
 	if(rc <= 0) break; else j += rc;
       }
 
 #ifdef DEBUG_TLS
       printf("[JA3] Server: %s \n", flow->protos.tls_quic.ja3_server);
 #endif
     } else if(handshake_type == 0x01 /* Client Hello */) {
       u_int16_t cipher_len, cipher_offset;
       u_int8_t cookie_len = 0;
 
       ja3.client.num_cipher = 0;
       ja3.client.num_tls_extension = 0;
       ja3.client.num_elliptic_curve = 0;
       ja3.client.num_elliptic_curve_point_format = 0;
       ja3.client.signature_algorithms[0] = '\0';
       ja3.client.supported_versions[0] = '\0';
       ja3.client.alpn[0] = '\0';
 
       flow->protos.tls_quic.ssl_version = ja3.client.tls_handshake_version = tls_version;
       if(flow->protos.tls_quic.ssl_version < 0x0303) /* < TLSv1.2 */
 	ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_OBSOLETE_VERSION);
 
       if((session_id_len+base_offset+3) > packet->payload_packet_len)
 	return(0); /* Not found */
 
       if(!is_dtls) {
 	cipher_len = packet->payload[session_id_len+base_offset+2] + (packet->payload[session_id_len+base_offset+1] << 8);
 	cipher_offset = base_offset + session_id_len + 3;
       } else {
 	cookie_len = packet->payload[base_offset+session_id_len+1];
 #ifdef DEBUG_TLS
 	printf("[JA3] Client: DTLS cookie len %d\n", cookie_len);
 #endif
 	if((session_id_len+base_offset+cookie_len+4) > packet->payload_packet_len)
 	  return(0); /* Not found */
 	cipher_len = ntohs(*((u_int16_t*)&packet->payload[base_offset+session_id_len+cookie_len+2]));
 	cipher_offset = base_offset + session_id_len + cookie_len + 4;
       }
 
 #ifdef DEBUG_TLS
       printf("Client TLS [client cipher_len: %u][tls_version: 0x%04X]\n", cipher_len, tls_version);
 #endif
 
       if((cipher_offset+cipher_len) <= total_len - 1) { /* -1 because variable "id" is a u_int16_t */
 	u_int8_t safari_ciphers = 0, chrome_ciphers = 0, this_is_not_safari = 0, looks_like_safari_on_big_sur = 0;
 
 	for(i=0; i<cipher_len;) {
 	  u_int16_t *id = (u_int16_t*)&packet->payload[cipher_offset+i];
 	  u_int16_t cipher_id = ntohs(*id);
 
 	  if(cipher_offset+i+1 < packet->payload_packet_len &&
 	     packet->payload[cipher_offset+i] != packet->payload[cipher_offset+i+1] /* Skip Grease */) {
 	    /*
 	      Skip GREASE [https://tools.ietf.org/id/draft-ietf-tls-grease-01.html]
 	      https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967
 	    */
 
 #if defined(DEBUG_TLS) || defined(DEBUG_HEURISTIC)
 	    printf("Client TLS [non-GREASE cipher suite: %u/0x%04X] [%d/%u]\n", cipher_id, cipher_id, i, cipher_len);
 #endif
 
 	    if(ja3.client.num_cipher < MAX_NUM_JA3)
 	      ja3.client.cipher[ja3.client.num_cipher++] = cipher_id;
 	    else {
 	      invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 	      printf("Client TLS Invalid cipher %u\n", ja3.client.num_cipher);
 #endif
 	    }
 
 #if defined(DEBUG_TLS) || defined(DEBUG_HEURISTIC)
 	    printf("Client TLS [cipher suite: %u/0x%04X] [%d/%u]\n", cipher_id, cipher_id, i, cipher_len);
 #endif
 
 	    switch(cipher_id) {
 	    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
 	    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:
 	      safari_ciphers++;
 	      break;
 
 	    case TLS_AES_128_GCM_SHA256:
 	    case TLS_AES_256_GCM_SHA384:
 	    case TLS_CHACHA20_POLY1305_SHA256:
 	      chrome_ciphers++;
 	      break;
 
 	    case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:
 	    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
 	    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
 	    case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
 	    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
 	    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
 	    case TLS_RSA_WITH_AES_128_CBC_SHA:
 	    case TLS_RSA_WITH_AES_256_CBC_SHA:
 	    case TLS_RSA_WITH_AES_128_GCM_SHA256:
 	    case TLS_RSA_WITH_AES_256_GCM_SHA384:
 	      safari_ciphers++, chrome_ciphers++;
 	      break;
 
 	    case TLS_RSA_WITH_3DES_EDE_CBC_SHA:
 	      looks_like_safari_on_big_sur = 1;
 	      break;
 	    }
 	  } else {
 #if defined(DEBUG_TLS) || defined(DEBUG_HEURISTIC)
 	    printf("Client TLS [GREASE cipher suite: %u/0x%04X] [%d/%u]\n", cipher_id, cipher_id, i, cipher_len);
 #endif
 
 	    this_is_not_safari = 1; /* NOTE: BugSur and up have grease support */
 	  }
 
 	  i += 2;
 	} /* for */
 
 	/* NOTE:
 	   we do not check for duplicates as with signatures because
 	   this is time consuming and we want to avoid overhead whem possible
 	*/
 	if(this_is_not_safari)
 	  flow->protos.tls_quic.browser_heuristics.is_safari_tls = 0;
 	else if((safari_ciphers == 12) || (this_is_not_safari && looks_like_safari_on_big_sur))
 	  flow->protos.tls_quic.browser_heuristics.is_safari_tls = 1;
 
 	if(chrome_ciphers == 13)
 	  flow->protos.tls_quic.browser_heuristics.is_chrome_tls = 1;
 
 	/* Note that both Safari and Chrome can overlap */
 #ifdef DEBUG_HEURISTIC
 	printf("[CIPHERS] [is_chrome_tls: %u (%u)][is_safari_tls: %u (%u)][this_is_not_safari: %u]\n",
 	       flow->protos.tls_quic.browser_heuristics.is_chrome_tls,
 	       chrome_ciphers,
 	       flow->protos.tls_quic.browser_heuristics.is_safari_tls,
 	       safari_ciphers,
 	       this_is_not_safari);
 #endif
       } else {
 	invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 	printf("Client TLS Invalid len %u vs %u\n", (cipher_offset+cipher_len), total_len);
 #endif
       }
 
       offset = base_offset + session_id_len + cookie_len + cipher_len + 2;
       offset += (!is_dtls) ? 1 : 2;
 
       if(offset < total_len) {
 	u_int16_t compression_len;
 	u_int16_t extensions_len;
 
 	compression_len = packet->payload[offset];
 	offset++;
 
 #ifdef DEBUG_TLS
 	printf("Client TLS [compression_len: %u]\n", compression_len);
 #endif
 
 	// offset += compression_len + 3;
 	offset += compression_len;
 
 	if(offset+1 < total_len) {
 	  extensions_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
 	  offset += 2;
 
 #ifdef DEBUG_TLS
 	  printf("Client TLS [extensions_len: %u]\n", extensions_len);
 #endif
 
 	  if((extensions_len+offset) <= total_len) {
 	    /* Move to the first extension
 	       Type is u_int to avoid possible overflow on extension_len addition */
 	    u_int extension_offset = 0;
 
 	    while(extension_offset < extensions_len &&
 		  offset+extension_offset+4 <= total_len) {
 	      u_int16_t extension_id, extension_len, extn_off = offset+extension_offset;
 
 
 	      extension_id = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));
 	      extension_offset += 2;
 
 	      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));
 	      extension_offset += 2;
 
 #ifdef DEBUG_TLS
 	      printf("Client TLS [extension_id: %u][extension_len: %u]\n", extension_id, extension_len);
 #endif
 	      checkExtensions(ndpi_struct, flow, is_dtls,
 			      extension_id, extension_len, offset + extension_offset);
 
 	      if(offset + 4 + extension_len > total_len) {
 #ifdef DEBUG_TLS
 	        printf("[TLS] extension length %u too long (%u, offset %u)\n",
 	               extension_len, total_len, offset);
 #endif
 	        break;
 	      }
 
 	      if((extension_id == 0) || (packet->payload[extn_off] != packet->payload[extn_off+1])) {
 		/* Skip GREASE */
 
 		if(ja3.client.num_tls_extension < MAX_NUM_JA3)
 		  ja3.client.tls_extension[ja3.client.num_tls_extension++] = extension_id;
 		else {
 		  invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		  printf("Client TLS Invalid extensions %u\n", ja3.client.num_tls_extension);
 #endif
 		}
 	      }
 
 	      if(extension_id == 0 /* server name */) {
 		u_int16_t len;
 
 #ifdef DEBUG_TLS
 		printf("[TLS] Extensions: found server name\n");
 #endif
 		if((offset+extension_offset+4) < packet->payload_packet_len) {
 
 		  len = (packet->payload[offset+extension_offset+3] << 8) + packet->payload[offset+extension_offset+4];
 
 		  if((offset+extension_offset+5+len) <= packet->payload_packet_len) {
 
 		    char *sni = ndpi_hostname_sni_set(flow, &packet->payload[offset+extension_offset+5], len);
 		    int sni_len = strlen(sni);
 #ifdef DEBUG_TLS
 		    printf("[TLS] SNI: [%s]\n", sni);
 #endif
 		    if(ndpi_is_printable_string(sni, sni_len) == 0)
 		    {
 		       ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);
 		    }
 
 		    if(!is_quic) {
 		      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, sni, sni_len))
 		        flow->protos.tls_quic.subprotocol_detected = 1;
 		    } else {
 		      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, sni, sni_len))
 		        flow->protos.tls_quic.subprotocol_detected = 1;
 		    }
 
 		    if(ndpi_check_dga_name(ndpi_struct, flow,
 					   sni, 1)) {
 #ifdef DEBUG_TLS
 		      printf("[TLS] SNI: (DGA) [%s]\n", sni);
 #endif
 
 		      if((sni_len >= 4)
 		         /* Check if it ends in .com or .net */
 		         && ((strcmp(&sni[sni_len-4], ".com") == 0) || (strcmp(&sni[sni_len-4], ".net") == 0))
 		         && (strncmp(sni, "www.", 4) == 0)) /* Not starting with www.... */
 		        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TOR, NDPI_PROTOCOL_TLS, NDPI_CONFIDENCE_DPI);
 		    } else {
 #ifdef DEBUG_TLS
 		      printf("[TLS] SNI: (NO DGA) [%s]\n", sni);
 #endif
 		    }
 		  } else {
 #ifdef DEBUG_TLS
 		    printf("[TLS] Extensions server len too short: %u vs %u\n",
 			   offset+extension_offset+5+len,
 			   packet->payload_packet_len);
 #endif
 		  }
 		}
 	      } else if(extension_id == 10 /* supported groups */) {
 		u_int16_t s_offset = offset+extension_offset + 2;
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [EllipticCurveGroups: len=%u]\n", extension_len);
 #endif
 
 		if((s_offset+extension_len-2) <= total_len) {
 		  for(i=0; i<(u_int32_t)extension_len-2 && s_offset + i + 1 < total_len; i += 2) {
 		    u_int16_t s_group = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));
 
 #ifdef DEBUG_TLS
 		    printf("Client TLS [EllipticCurve: %u/0x%04X]\n", s_group, s_group);
 #endif
 		    if((s_group == 0) || (packet->payload[s_offset+i] != packet->payload[s_offset+i+1])) {
 		      /* Skip GREASE */
 		      if(ja3.client.num_elliptic_curve < MAX_NUM_JA3)
 			ja3.client.elliptic_curve[ja3.client.num_elliptic_curve++] = s_group;
 		      else {
 			invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 			printf("Client TLS Invalid num elliptic %u\n", ja3.client.num_elliptic_curve);
 #endif
 		      }
 		    }
 		  }
 		} else {
 		  invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		  printf("Client TLS Invalid len %u vs %u\n", (s_offset+extension_len-1), total_len);
 #endif
 		}
 	      } else if(extension_id == 11 /* ec_point_formats groups */) {
 		u_int16_t s_offset = offset+extension_offset + 1;
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [EllipticCurveFormat: len=%u]\n", extension_len);
 #endif
 		if((s_offset+extension_len-1) <= total_len) {
 		  for(i=0; i<(u_int32_t)extension_len-1 && s_offset+i < total_len; i++) {
 		    u_int8_t s_group = packet->payload[s_offset+i];
 
 #ifdef DEBUG_TLS
 		    printf("Client TLS [EllipticCurveFormat: %u]\n", s_group);
 #endif
 
 		    if(ja3.client.num_elliptic_curve_point_format < MAX_NUM_JA3)
 		      ja3.client.elliptic_curve_point_format[ja3.client.num_elliptic_curve_point_format++] = s_group;
 		    else {
 		      invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		      printf("Client TLS Invalid num elliptic %u\n", ja3.client.num_elliptic_curve_point_format);
 #endif
 		    }
 		  }
 		} else {
 		  invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		  printf("Client TLS Invalid len %u vs %u\n", s_offset+extension_len, total_len);
 #endif
 		}
 	      } else if(extension_id == 13 /* signature algorithms */ &&
 	                offset+extension_offset+1 < total_len) {
 		int s_offset = offset+extension_offset, safari_signature_algorithms = 0, chrome_signature_algorithms = 0,
 		  duplicate_found = 0, last_signature = 0;
 		u_int16_t tot_signature_algorithms_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [SIGNATURE_ALGORITHMS: block_len=%u/len=%u]\n", extension_len, tot_signature_algorithms_len);
 #endif
 
 		s_offset += 2;
 		tot_signature_algorithms_len = ndpi_min((sizeof(ja3.client.signature_algorithms) / 2) - 1, tot_signature_algorithms_len);
 
 #ifdef TLS_HANDLE_SIGNATURE_ALGORITMS
 		flow->protos.tls_quic.num_tls_signature_algorithms = ndpi_min(tot_signature_algorithms_len / 2, MAX_NUM_TLS_SIGNATURE_ALGORITHMS);
 
 		memcpy(flow->protos.tls_quic.client_signature_algorithms,
 		       &packet->payload[s_offset], 2 /* 16 bit */*flow->protos.tls_quic.num_tls_signature_algorithms);
 #endif
 
 		for(i=0; i<tot_signature_algorithms_len && s_offset+i<total_len; i++) {
 		  int rc = snprintf(&ja3.client.signature_algorithms[i*2], sizeof(ja3.client.signature_algorithms)-i*2, "%02X", packet->payload[s_offset+i]);
 
 		  if(rc < 0) break;
 		}
 
 		for(i=0; i<tot_signature_algorithms_len && s_offset + (int)i + 2 < packet->payload_packet_len; i+=2) {
 		  u_int16_t signature_algo = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));
 
 		  if(last_signature == signature_algo) {
 		    /* Consecutive duplication */
 		    duplicate_found = 1;
 		    continue;
 		  } else {
 		    /* Check for other duplications */
 		    u_int all_ok = 1;
 
 		    for(j=0; j<tot_signature_algorithms_len; j+=2) {
 		      if(j != i && s_offset + (int)j + 2 < packet->payload_packet_len) {
 			u_int16_t j_signature_algo = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+j]));
 
 			if((signature_algo == j_signature_algo)
 			   && (i < j) /* Don't skip both of them */) {
 #ifdef DEBUG_HEURISTIC
 			  printf("[SIGNATURE] [TLS Signature Algorithm] Skipping duplicate 0x%04X\n", signature_algo);
 #endif
 
 			  duplicate_found = 1, all_ok = 0;
 			  break;
 			}
 		      }
 		    }
 
 		    if(!all_ok)
 		      continue;
 		  }
 
 		  last_signature = signature_algo;
 
 #ifdef DEBUG_HEURISTIC
 		  printf("[SIGNATURE] [TLS Signature Algorithm] 0x%04X\n", signature_algo);
 #endif
 		  switch(signature_algo) {
 		  case ECDSA_SECP521R1_SHA512:
 		    flow->protos.tls_quic.browser_heuristics.is_firefox_tls = 1;
 		    break;
 
 		  case ECDSA_SECP256R1_SHA256:
 		  case ECDSA_SECP384R1_SHA384:
 		  case RSA_PKCS1_SHA256:
 		  case RSA_PKCS1_SHA384:
 		  case RSA_PKCS1_SHA512:
 		  case RSA_PSS_RSAE_SHA256:
 		  case RSA_PSS_RSAE_SHA384:
 		  case RSA_PSS_RSAE_SHA512:
 		    chrome_signature_algorithms++, safari_signature_algorithms++;
 #ifdef DEBUG_HEURISTIC
 		    printf("[SIGNATURE] [Chrome/Safari] Found 0x%04X [chrome: %u][safari: %u]\n",
 			   signature_algo, chrome_signature_algorithms, safari_signature_algorithms);
 #endif
 
 		    break;
 		  }
 		}
 
 #ifdef DEBUG_HEURISTIC
 		printf("[SIGNATURE] [safari_signature_algorithms: %u][chrome_signature_algorithms: %u]\n",
 		       safari_signature_algorithms, chrome_signature_algorithms);
 #endif
 
 		if(flow->protos.tls_quic.browser_heuristics.is_firefox_tls)
 		  flow->protos.tls_quic.browser_heuristics.is_safari_tls = 0,
 		    flow->protos.tls_quic.browser_heuristics.is_chrome_tls = 0;
 
 		if(safari_signature_algorithms != 8)
 		   flow->protos.tls_quic.browser_heuristics.is_safari_tls = 0;
 
 		if((chrome_signature_algorithms != 8) || duplicate_found)
 		   flow->protos.tls_quic.browser_heuristics.is_chrome_tls = 0;
 
 		/* Avoid Chrome and Safari overlaps, thing that cannot happen with Firefox */
 		if(flow->protos.tls_quic.browser_heuristics.is_safari_tls)
 		  flow->protos.tls_quic.browser_heuristics.is_chrome_tls = 0;
 
 		if((flow->protos.tls_quic.browser_heuristics.is_chrome_tls == 0)
 		   && duplicate_found)
 		  flow->protos.tls_quic.browser_heuristics.is_safari_tls = 1; /* Safari */
 
 #ifdef DEBUG_HEURISTIC
 		printf("[SIGNATURE] [is_firefox_tls: %u][is_chrome_tls: %u][is_safari_tls: %u][duplicate_found: %u]\n",
 		       flow->protos.tls_quic.browser_heuristics.is_firefox_tls,
 		       flow->protos.tls_quic.browser_heuristics.is_chrome_tls,
 		       flow->protos.tls_quic.browser_heuristics.is_safari_tls,
 		       duplicate_found);
 #endif
 
 		if(i > 0 && i >= tot_signature_algorithms_len) {
 		  ja3.client.signature_algorithms[i*2 - 1] = '\0';
 		} else {
 		  ja3.client.signature_algorithms[i*2] = '\0';
 		}
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [SIGNATURE_ALGORITHMS: %s]\n", ja3.client.signature_algorithms);
 #endif
 	      } else if(extension_id == 16 /* application_layer_protocol_negotiation */ &&
 	                offset+extension_offset+1 < total_len) {
 		u_int16_t s_offset = offset+extension_offset;
 		u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 		char alpn_str[256];
 		u_int8_t alpn_str_len = 0, i;
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [ALPN: block_len=%u/len=%u]\n", extension_len, tot_alpn_len);
 #endif
 		s_offset += 2;
 		tot_alpn_len += s_offset;
 
 		while(s_offset < tot_alpn_len && s_offset < total_len) {
 		  u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];
 
 		  if((s_offset + alpn_len) <= tot_alpn_len &&
 		     (s_offset + alpn_len) <= total_len) {
 #ifdef DEBUG_TLS
 		    printf("Client TLS [ALPN: %u]\n", alpn_len);
 #endif
 
 		    if(((uint32_t)alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {
 		      if(alpn_str_len > 0) {
 			alpn_str[alpn_str_len] = ',';
 			alpn_str_len++;
 		      }
 
 		      for(alpn_i=0; alpn_i<alpn_len; alpn_i++)
 			alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];
 
 		      s_offset += alpn_len, alpn_str_len += alpn_len;;
 		    } else
 		      break;
 		  } else
 		    break;
 		} /* while */
 
 		alpn_str[alpn_str_len] = '\0';
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
 #endif
 		if(flow->protos.tls_quic.alpn == NULL)
 		  flow->protos.tls_quic.alpn = ndpi_strdup(alpn_str);
 
 		snprintf(ja3.client.alpn, sizeof(ja3.client.alpn), "%s", alpn_str);
 
 		/* Replace , with - as in JA3 */
 		for(i=0; ja3.client.alpn[i] != '\0'; i++)
 		  if(ja3.client.alpn[i] == ',') ja3.client.alpn[i] = '-';
 
 	      } else if(extension_id == 43 /* supported versions */) {
 		u_int16_t s_offset = offset+extension_offset;
 		u_int8_t version_len = packet->payload[s_offset];
 		char version_str[256];
 		char buf_ver_tmp[16];
 		size_t version_str_len = 0;
 		version_str[0] = 0;
 #ifdef DEBUG_TLS
 		printf("Client TLS [TLS version len: %u]\n", version_len);
 #endif
 
 		if(version_len == (extension_len-1)) {
 		  u_int8_t j;
 		  u_int16_t supported_versions_offset = 0;
 
 		  s_offset++;
 
 		  // careful not to overflow and loop forever with u_int8_t
 		  for(j=0; j+1<version_len && s_offset + j + 1 < packet->payload_packet_len; j += 2) {
 		    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+j]));
 		    u_int8_t unknown_tls_version;
 
 #ifdef DEBUG_TLS
 		    printf("Client TLS [TLS version: %s/0x%04X]\n",
 			   ndpi_ssl_version2str(buf_ver_tmp, sizeof(buf_ver_tmp), tls_version, &unknown_tls_version), tls_version);
 #endif
 
 		    if((version_str_len+8) < sizeof(version_str)) {
 		      int rc = snprintf(&version_str[version_str_len],
 					sizeof(version_str) - version_str_len, "%s%s",
 					(version_str_len > 0) ? "," : "",
 					ndpi_ssl_version2str(buf_ver_tmp, sizeof(buf_ver_tmp), tls_version, &unknown_tls_version));
 		      if(rc <= 0)
 			break;
 		      else
 			version_str_len += rc;
 
 		      rc = snprintf(&ja3.client.supported_versions[supported_versions_offset],
 				    sizeof(ja3.client.supported_versions)-supported_versions_offset,
 				    "%s%04X", (j > 0) ? "-" : "", tls_version);
 
 		      if(rc > 0)
 			supported_versions_offset += rc;
 		    }
 		  }
 
 #ifdef DEBUG_TLS
 		  printf("Client TLS [SUPPORTED_VERSIONS: %s]\n", ja3.client.supported_versions);
 #endif
 
 		  if(flow->protos.tls_quic.tls_supported_versions == NULL)
 		    flow->protos.tls_quic.tls_supported_versions = ndpi_strdup(version_str);
 		}
 	      } else if(extension_id == 65486 /* encrypted server name */ &&
 	                offset+extension_offset+1 < total_len) {
 		/*
 		   - https://tools.ietf.org/html/draft-ietf-tls-esni-06
 		   - https://blog.cloudflare.com/encrypted-sni/
 		*/
 		int e_offset = offset+extension_offset;
 		int e_sni_len;
 		int initial_offset = e_offset;
 		u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[e_offset]));
 
 		flow->protos.tls_quic.encrypted_sni.cipher_suite = cipher_suite;
 
 		e_offset += 2; /* Cipher suite len */
 
 		/* Key Share Entry */
 		e_offset += 2; /* Group */
 		if(e_offset + 2 < packet->payload_packet_len) {
 		e_offset += ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */
 
 		if((e_offset+4) < packet->payload_packet_len) {
 		  /* Record Digest */
 		  e_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */
 
 		  if((e_offset+4) < packet->payload_packet_len) {
 		    e_sni_len = ntohs(*((u_int16_t*)&packet->payload[e_offset]));
 		    e_offset += 2;
 
 		    if((e_offset+e_sni_len-(int)extension_len-initial_offset) >= 0 &&
 		        e_offset+e_sni_len < packet->payload_packet_len) {
 #ifdef DEBUG_ENCRYPTED_SNI
 		      printf("Client TLS [Encrypted Server Name len: %u]\n", e_sni_len);
 #endif
 
 		      if(flow->protos.tls_quic.encrypted_sni.esni == NULL) {
 			flow->protos.tls_quic.encrypted_sni.esni = (char*)ndpi_malloc(e_sni_len*2+1);
 
 			if(flow->protos.tls_quic.encrypted_sni.esni) {
 			  u_int16_t off;
 			  int i;
 
 			  for(i=e_offset, off=0; i<(e_offset+e_sni_len); i++) {
 			    int rc = sprintf(&flow->protos.tls_quic.encrypted_sni.esni[off], "%02X", packet->payload[i] & 0XFF);
 
 			    if(rc <= 0) {
-			      flow->protos.tls_quic.encrypted_sni.esni[off] = '\0';
 			      break;
 			    } else
 			      off += rc;
 			  }
+			  flow->protos.tls_quic.encrypted_sni.esni[off] = '\0';
 			}
 		      }
 		    }
 		  }
 		}
 		}
 	      } else if(extension_id == 65445 || /* QUIC transport parameters (drafts version) */
 		        extension_id == 57) { /* QUIC transport parameters (final version) */
 		u_int16_t s_offset = offset+extension_offset;
 		uint16_t final_offset;
 		int using_var_int = is_version_with_var_int_transport_params(quic_version);
 
 		if(!using_var_int) {
 		  if(s_offset+1 >= total_len) {
 		    final_offset = 0; /* Force skipping extension */
 		  } else {
 		    u_int16_t seq_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 		    s_offset += 2;
 	            final_offset = MIN(total_len, s_offset + seq_len);
 		  }
 		} else {
 	          final_offset = MIN(total_len, s_offset + extension_len);
 		}
 
 		while(s_offset < final_offset) {
 		  u_int64_t param_type, param_len;
 
                   if(!using_var_int) {
 		    if(s_offset+3 >= final_offset)
 		      break;
 		    param_type = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 		    param_len = ntohs(*((u_int16_t*)&packet->payload[s_offset + 2]));
 		    s_offset += 4;
 		  } else {
 		    if(s_offset >= final_offset ||
 		       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)
 		      break;
 		    s_offset += quic_len(&packet->payload[s_offset], &param_type);
 
 		    if(s_offset >= final_offset ||
 		       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)
 		      break;
 		    s_offset += quic_len(&packet->payload[s_offset], &param_len);
 		  }
 
 #ifdef DEBUG_TLS
 		  printf("Client TLS [QUIC TP: Param 0x%x Len %d]\n", (int)param_type, (int)param_len);
 #endif
 		  if(s_offset+param_len > final_offset)
 		    break;
 
 		  if(param_type==0x3129) {
 #ifdef DEBUG_TLS
 		      printf("UA [%.*s]\n", (int)param_len, &packet->payload[s_offset]);
 #endif
 		      http_process_user_agent(ndpi_struct, flow,
 					      &packet->payload[s_offset], param_len);
 		      break;
 		  }
 		  s_offset += param_len;
 		}
 	      }
 
 	      extension_offset += extension_len; /* Move to the next extension */
 
 #ifdef DEBUG_TLS
 	      printf("Client TLS [extension_offset/len: %u/%u]\n", extension_offset, extension_len);
 #endif
 	    } /* while */
 
 	    if(!invalid_ja3) {
 	      int rc;
 
 	    compute_ja3c:
 	      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.client.tls_handshake_version);
 
 	      for(i=0; i<ja3.client.num_cipher; i++) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			      (i > 0) ? "-" : "", ja3.client.cipher[i]);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	      }
 
 	      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",");
 	      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 
 	      /* ********** */
 
 	      for(i=0; i<ja3.client.num_tls_extension; i++) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			      (i > 0) ? "-" : "", ja3.client.tls_extension[i]);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	      }
 
 	      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",");
 	      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 
 	      /* ********** */
 
 	      for(i=0; i<ja3.client.num_elliptic_curve; i++) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			      (i > 0) ? "-" : "", ja3.client.elliptic_curve[i]);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	      }
 
 	      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",");
 	      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 
 	      for(i=0; i<ja3.client.num_elliptic_curve_point_format; i++) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			      (i > 0) ? "-" : "", ja3.client.elliptic_curve_point_format[i]);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	      }
 
 	      if(ndpi_struct->enable_ja3_plus) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len,
 			      ",%s,%s,%s", ja3.client.signature_algorithms, ja3.client.supported_versions, ja3.client.alpn);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 	      }
 
 #ifdef DEBUG_JA3C
 	      printf("[JA3+] Client: %s \n", ja3_str);
 #endif
 
 	      ndpi_MD5Init(&ctx);
 	      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));
 	      ndpi_MD5Final(md5_hash, &ctx);
 
 	      for(i=0, j=0; i<16; i++) {
 		rc = snprintf(&flow->protos.tls_quic.ja3_client[j],
 			      sizeof(flow->protos.tls_quic.ja3_client)-j, "%02x",
 			      md5_hash[i]);
 		if(rc > 0) j += rc; else break;
 	      }
 
 #ifdef DEBUG_JA3C
 	      printf("[JA3] Client: %s \n", flow->protos.tls_quic.ja3_client);
 #endif
 
 	      if(ndpi_struct->malicious_ja3_automa.ac_automa != NULL) {
 		u_int16_t rc1 = ndpi_match_string(ndpi_struct->malicious_ja3_automa.ac_automa,
 						  flow->protos.tls_quic.ja3_client);
 
 		if(rc1 > 0)
 		  ndpi_set_risk(ndpi_struct, flow, NDPI_MALICIOUS_JA3);
 	      }
 	    }
 
 	    /* Before returning to the caller we need to make a final check */
 	    if((flow->protos.tls_quic.ssl_version >= 0x0303) /* >= TLSv1.2 */
 	       && (flow->protos.tls_quic.alpn == NULL) /* No ALPN */) {
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_NOT_CARRYING_HTTPS);
 	    }
 
 	    /* Suspicious Domain Fronting:
 	       https://github.com/SixGenInc/Noctilucent/blob/master/docs/ */
 	    if(flow->protos.tls_quic.encrypted_sni.esni &&
 	       flow->host_server_name[0] != '\0') {
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_ESNI_USAGE);
 	    }
 
 	    /* Add check for missing SNI */
 	    if(flow->host_server_name[0] == '\0'
 	       && (flow->protos.tls_quic.ssl_version >= 0x0302) /* TLSv1.1 */
 	       && (flow->protos.tls_quic.encrypted_sni.esni == NULL) /* No ESNI */
 	       ) {
 	      /* This is a bit suspicious */
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_MISSING_SNI);
 	    }
 
 	    return(2 /* Client Certificate */);
 	  } else {
 #ifdef DEBUG_TLS
 	    printf("[TLS] Client: too short [%u vs %u]\n",
 		   (extensions_len+offset), total_len);
 #endif
 	  }
 	} else if(offset == total_len) {
 	  /* TLS does not have extensions etc */
 	  goto compute_ja3c;
 	}
       } else {
 #ifdef DEBUG_TLS
 	printf("[JA3] Client: invalid length detected\n");
 #endif
       }
     }
   }
 
   return(0); /* Not found */
 }
 
 /* **************************************** */
