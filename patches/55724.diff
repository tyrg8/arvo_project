commit b899fda3d88dc92f50e73544fb7524a1c3c70354
Author: Edward Thomson <ethomson@edwardthomson.com>
Date:   Mon Apr 10 10:34:20 2023 +0100

    commit graph: support sha256

diff --git a/include/git2/sys/commit_graph.h b/include/git2/sys/commit_graph.h
index 823c7ed57..06e045fcd 100644
--- a/include/git2/sys/commit_graph.h
+++ b/include/git2/sys/commit_graph.h
@@ -22,19 +22,25 @@ GIT_BEGIN_DECL
 /**
  * Opens a `git_commit_graph` from a path to an objects directory.
  *
  * This finds, opens, and validates the `commit-graph` file.
  *
  * @param cgraph_out the `git_commit_graph` struct to initialize.
  * @param objects_dir the path to a git objects directory.
  * @return Zero on success; -1 on failure.
  */
-GIT_EXTERN(int) git_commit_graph_open(git_commit_graph **cgraph_out, const char *objects_dir);
+GIT_EXTERN(int) git_commit_graph_open(
+	git_commit_graph **cgraph_out,
+	const char *objects_dir
+#ifdef GIT_EXPERIMENTAL_SHA256
+	, git_oid_t oid_type
+#endif
+	);
 
 /**
  * Frees commit-graph data. This should only be called when memory allocated
  * using `git_commit_graph_open` is not returned to libgit2 because it was not
  * associated with the ODB through a successful call to
  * `git_odb_set_commit_graph`.
  *
  * @param cgraph the commit-graph object to free. If NULL, no action is taken.
  */
@@ -43,17 +49,21 @@ GIT_EXTERN(void) git_commit_graph_free(git_commit_graph *cgraph);
 /**
  * Create a new writer for `commit-graph` files.
  *
  * @param out Location to store the writer pointer.
  * @param objects_info_dir The `objects/info` directory.
  * The `commit-graph` file will be written in this directory.
  * @return 0 or an error code
  */
 GIT_EXTERN(int) git_commit_graph_writer_new(
 		git_commit_graph_writer **out,
-		const char *objects_info_dir);
+		const char *objects_info_dir
+#ifdef GIT_EXPERIMENTAL_SHA256
+	, git_oid_t oid_type
+#endif
+		);
 
 /**
  * Free the commit-graph writer and its resources.
  *
  * @param w The writer to free. If NULL no action is taken.
  */
diff --git a/src/libgit2/commit_graph.c b/src/libgit2/commit_graph.c
index bf557f7ad..4edd71106 100644
--- a/src/libgit2/commit_graph.c
+++ b/src/libgit2/commit_graph.c
@@ -135,25 +135,28 @@ static int commit_graph_parse_oid_fanout(
 static int commit_graph_parse_oid_lookup(
 		git_commit_graph_file *file,
 		const unsigned char *data,
 		struct git_commit_graph_chunk *chunk_oid_lookup)
 {
 	uint32_t i;
-	unsigned char *oid, *prev_oid, zero_oid[GIT_OID_SHA1_SIZE] = {0};
+	unsigned char *oid, *prev_oid, zero_oid[GIT_OID_MAX_SIZE] = {0};
+	size_t oid_size;
+
+	oid_size = git_oid_size(file->oid_type);
 
 	if (chunk_oid_lookup->offset == 0)
 		return commit_graph_error("missing OID Lookup chunk");
 	if (chunk_oid_lookup->length == 0)
 		return commit_graph_error("empty OID Lookup chunk");
-	if (chunk_oid_lookup->length != file->num_commits * GIT_OID_SHA1_SIZE)
+	if (chunk_oid_lookup->length != file->num_commits * oid_size)
 		return commit_graph_error("OID Lookup chunk has wrong length");
 
 	file->oid_lookup = oid = (unsigned char *)(data + chunk_oid_lookup->offset);
 	prev_oid = zero_oid;
-	for (i = 0; i < file->num_commits; ++i, oid += GIT_OID_SHA1_SIZE) {
-		if (git_oid_raw_cmp(prev_oid, oid, GIT_OID_SHA1_SIZE) >= 0)
+	for (i = 0; i < file->num_commits; ++i, oid += oid_size) {
+		if (git_oid_raw_cmp(prev_oid, oid, oid_size) >= 0)
 			return commit_graph_error("OID Lookup index is non-monotonic");
 		prev_oid = oid;
 	}
 
 	return 0;
 }
@@ -161,16 +164,18 @@ static int commit_graph_parse_oid_lookup(
 static int commit_graph_parse_commit_data(
 		git_commit_graph_file *file,
 		const unsigned char *data,
 		struct git_commit_graph_chunk *chunk_commit_data)
 {
+	size_t oid_size = git_oid_size(file->oid_type);
+
 	if (chunk_commit_data->offset == 0)
 		return commit_graph_error("missing Commit Data chunk");
 	if (chunk_commit_data->length == 0)
 		return commit_graph_error("empty Commit Data chunk");
-	if (chunk_commit_data->length != file->num_commits * (GIT_OID_SHA1_SIZE + 16))
+	if (chunk_commit_data->length != file->num_commits * (oid_size + 16))
 		return commit_graph_error("Commit Data chunk has wrong length");
 
 	file->commit_data = data + chunk_commit_data->offset;
 
 	return 0;
 }
@@ -194,128 +199,139 @@ static int commit_graph_parse_extra_edge_list(
 int git_commit_graph_file_parse(
 		git_commit_graph_file *file,
 		const unsigned char *data,
 		size_t size)
 {
 	struct git_commit_graph_header *hdr;
 	const unsigned char *chunk_hdr;
 	struct git_commit_graph_chunk *last_chunk;
 	uint32_t i;
 	uint64_t last_chunk_offset, chunk_offset, trailer_offset;
 	size_t checksum_size;
 	int error;
 	struct git_commit_graph_chunk chunk_oid_fanout = {0}, chunk_oid_lookup = {0},
 				      chunk_commit_data = {0}, chunk_extra_edge_list = {0},
 				      chunk_unsupported = {0};
 
 	GIT_ASSERT_ARG(file);
 
-	if (size < sizeof(struct git_commit_graph_header) + GIT_OID_SHA1_SIZE)
+	checksum_size = git_oid_size(file->oid_type);
+
+	if (size < sizeof(struct git_commit_graph_header) + checksum_size)
 		return commit_graph_error("commit-graph is too short");
 
 	hdr = ((struct git_commit_graph_header *)data);
 
 	if (hdr->signature != htonl(COMMIT_GRAPH_SIGNATURE) || hdr->version != COMMIT_GRAPH_VERSION
 	    || hdr->object_id_version != COMMIT_GRAPH_OBJECT_ID_VERSION) {
 		return commit_graph_error("unsupported commit-graph version");
 	}
 	if (hdr->chunks == 0)
 		return commit_graph_error("no chunks in commit-graph");
 
 	/*
 	 * The very first chunk's offset should be after the header, all the chunk
 	 * headers, and a special zero chunk.
 	 */
 	last_chunk_offset = sizeof(struct git_commit_graph_header) + (1 + hdr->chunks) * 12;
-	trailer_offset = size - GIT_OID_SHA1_SIZE;
-	checksum_size = GIT_HASH_SHA1_SIZE;
+	trailer_offset = size - checksum_size;
 
 	if (trailer_offset < last_chunk_offset)
 		return commit_graph_error("wrong commit-graph size");
 	memcpy(file->checksum, (data + trailer_offset), checksum_size);
 
 	chunk_hdr = data + sizeof(struct git_commit_graph_header);
 	last_chunk = NULL;
 	for (i = 0; i < hdr->chunks; ++i, chunk_hdr += 12) {
 		chunk_offset = ((uint64_t)ntohl(*((uint32_t *)(chunk_hdr + 4)))) << 32
 				| ((uint64_t)ntohl(*((uint32_t *)(chunk_hdr + 8))));
 		if (chunk_offset < last_chunk_offset)
 			return commit_graph_error("chunks are non-monotonic");
 		if (chunk_offset >= trailer_offset)
 			return commit_graph_error("chunks extend beyond the trailer");
 		if (last_chunk != NULL)
 			last_chunk->length = (size_t)(chunk_offset - last_chunk_offset);
 		last_chunk_offset = chunk_offset;
 
 		switch (ntohl(*((uint32_t *)(chunk_hdr + 0)))) {
 		case COMMIT_GRAPH_OID_FANOUT_ID:
 			chunk_oid_fanout.offset = last_chunk_offset;
 			last_chunk = &chunk_oid_fanout;
 			break;
 
 		case COMMIT_GRAPH_OID_LOOKUP_ID:
 			chunk_oid_lookup.offset = last_chunk_offset;
 			last_chunk = &chunk_oid_lookup;
 			break;
 
 		case COMMIT_GRAPH_COMMIT_DATA_ID:
 			chunk_commit_data.offset = last_chunk_offset;
 			last_chunk = &chunk_commit_data;
 			break;
 
 		case COMMIT_GRAPH_EXTRA_EDGE_LIST_ID:
 			chunk_extra_edge_list.offset = last_chunk_offset;
 			last_chunk = &chunk_extra_edge_list;
 			break;
 
 		case COMMIT_GRAPH_BLOOM_FILTER_INDEX_ID:
 		case COMMIT_GRAPH_BLOOM_FILTER_DATA_ID:
 			chunk_unsupported.offset = last_chunk_offset;
 			last_chunk = &chunk_unsupported;
 			break;
 
 		default:
 			return commit_graph_error("unrecognized chunk ID");
 		}
 	}
 	last_chunk->length = (size_t)(trailer_offset - last_chunk_offset);
 
 	error = commit_graph_parse_oid_fanout(file, data, &chunk_oid_fanout);
 	if (error < 0)
 		return error;
 	error = commit_graph_parse_oid_lookup(file, data, &chunk_oid_lookup);
 	if (error < 0)
 		return error;
 	error = commit_graph_parse_commit_data(file, data, &chunk_commit_data);
 	if (error < 0)
 		return error;
 	error = commit_graph_parse_extra_edge_list(file, data, &chunk_extra_edge_list);
 	if (error < 0)
 		return error;
 
 	return 0;
 }
 
-int git_commit_graph_new(git_commit_graph **cgraph_out, const char *objects_dir, bool open_file)
+int git_commit_graph_new(
+	git_commit_graph **cgraph_out,
+	const char *objects_dir,
+	bool open_file,
+	git_oid_t oid_type)
 {
 	git_commit_graph *cgraph = NULL;
 	int error = 0;
 
 	GIT_ASSERT_ARG(cgraph_out);
 	GIT_ASSERT_ARG(objects_dir);
+	GIT_ASSERT_ARG(oid_type);
 
 	cgraph = git__calloc(1, sizeof(git_commit_graph));
 	GIT_ERROR_CHECK_ALLOC(cgraph);
 
+	cgraph->oid_type = oid_type;
+
 	error = git_str_joinpath(&cgraph->filename, objects_dir, "info/commit-graph");
 	if (error < 0)
 		goto error;
 
 	if (open_file) {
-		error = git_commit_graph_file_open(&cgraph->file, git_str_cstr(&cgraph->filename));
+		error = git_commit_graph_file_open(&cgraph->file,
+				git_str_cstr(&cgraph->filename), oid_type);
+
 		if (error < 0)
 			goto error;
+
 		cgraph->checked = 1;
 	}
 
 	*cgraph_out = cgraph;
 	return 0;
@@ -326,95 +342,120 @@ error:
 }
 
 int git_commit_graph_validate(git_commit_graph *cgraph) {
-	unsigned char checksum[GIT_HASH_SHA1_SIZE];
-	size_t checksum_size = GIT_HASH_SHA1_SIZE;
-	size_t trailer_offset = cgraph->file->graph_map.len - checksum_size;
+	unsigned char checksum[GIT_HASH_MAX_SIZE];
+	git_hash_algorithm_t checksum_type;
+	size_t checksum_size, trailer_offset;
+
+	checksum_type = git_oid_algorithm(cgraph->oid_type);
+	checksum_size = git_hash_size(checksum_type);
+	trailer_offset = cgraph->file->graph_map.len - checksum_size;
 
 	if (cgraph->file->graph_map.len < checksum_size)
 		return commit_graph_error("map length too small");
 
-	if (git_hash_buf(checksum, cgraph->file->graph_map.data, trailer_offset, GIT_HASH_ALGORITHM_SHA1) < 0)
+	if (git_hash_buf(checksum, cgraph->file->graph_map.data, trailer_offset, checksum_type) < 0)
 		return commit_graph_error("could not calculate signature");
 	if (memcmp(checksum, cgraph->file->checksum, checksum_size) != 0)
 		return commit_graph_error("index signature mismatch");
 
 	return 0;
 }
 
-int git_commit_graph_open(git_commit_graph **cgraph_out, const char *objects_dir)
+int git_commit_graph_open(
+	git_commit_graph **cgraph_out,
+	const char *objects_dir
+#ifdef GIT_EXPERIMENTAL_SHA256
+	, git_oid_t oid_type
+#endif
+	)
 {
-	int error = git_commit_graph_new(cgraph_out, objects_dir, true);
-	if (!error) {
+#ifndef GIT_EXPERIMENTAL_SHA256
+	git_oid_t oid_type = GIT_OID_SHA1;
+#endif
+	int error;
+
+	error = git_commit_graph_new(cgraph_out, objects_dir, true,
+			oid_type);
+
+	if (!error)
 		return git_commit_graph_validate(*cgraph_out);
-	}
+
 	return error;
 }
 
-int git_commit_graph_file_open(git_commit_graph_file **file_out, const char *path)
+int git_commit_graph_file_open(
+	git_commit_graph_file **file_out,
+	const char *path,
+	git_oid_t oid_type)
 {
 	git_commit_graph_file *file;
 	git_file fd = -1;
 	size_t cgraph_size;
 	struct stat st;
 	int error;
 
 	/* TODO: properly open the file without access time using O_NOATIME */
 	fd = git_futils_open_ro(path);
 	if (fd < 0)
 		return fd;
 
 	if (p_fstat(fd, &st) < 0) {
 		p_close(fd);
 		git_error_set(GIT_ERROR_ODB, "commit-graph file not found - '%s'", path);
 		return GIT_ENOTFOUND;
 	}
 
 	if (!S_ISREG(st.st_mode) || !git__is_sizet(st.st_size)) {
 		p_close(fd);
 		git_error_set(GIT_ERROR_ODB, "invalid pack index '%s'", path);
 		return GIT_ENOTFOUND;
 	}
 	cgraph_size = (size_t)st.st_size;
 
 	file = git__calloc(1, sizeof(git_commit_graph_file));
 	GIT_ERROR_CHECK_ALLOC(file);
 
+	file->oid_type = oid_type;
+
 	error = git_futils_mmap_ro(&file->graph_map, fd, 0, cgraph_size);
 	p_close(fd);
 	if (error < 0) {
 		git_commit_graph_file_free(file);
 		return error;
 	}
 
 	if ((error = git_commit_graph_file_parse(file, file->graph_map.data, cgraph_size)) < 0) {
 		git_commit_graph_file_free(file);
 		return error;
 	}
 
 	*file_out = file;
 	return 0;
 }
 
-int git_commit_graph_get_file(git_commit_graph_file **file_out, git_commit_graph *cgraph)
+int git_commit_graph_get_file(
+	git_commit_graph_file **file_out,
+	git_commit_graph *cgraph)
 {
 	if (!cgraph->checked) {
 		int error = 0;
 		git_commit_graph_file *result = NULL;
 
 		/* We only check once, no matter the result. */
 		cgraph->checked = 1;
 
 		/* Best effort */
-		error = git_commit_graph_file_open(&result, git_str_cstr(&cgraph->filename));
+		error = git_commit_graph_file_open(&result,
+			git_str_cstr(&cgraph->filename), cgraph->oid_type);
 
 		if (error < 0)
 			return error;
 
 		cgraph->file = result;
 	}
 	if (!cgraph->file)
 		return GIT_ENOTFOUND;
 
 	*file_out = cgraph->file;
 	return 0;
 }
@@ -438,85 +479,86 @@ void git_commit_graph_refresh(git_commit_graph *cgraph)
 static int git_commit_graph_entry_get_byindex(
 		git_commit_graph_entry *e,
 		const git_commit_graph_file *file,
 		size_t pos)
 {
 	const unsigned char *commit_data;
+	size_t oid_size = git_oid_size(file->oid_type);
 
 	GIT_ASSERT_ARG(e);
 	GIT_ASSERT_ARG(file);
 
 	if (pos >= file->num_commits) {
 		git_error_set(GIT_ERROR_INVALID, "commit index %zu does not exist", pos);
 		return GIT_ENOTFOUND;
 	}
 
-	commit_data = file->commit_data + pos * (GIT_OID_SHA1_SIZE + 4 * sizeof(uint32_t));
-	git_oid__fromraw(&e->tree_oid, commit_data, GIT_OID_SHA1);
-	e->parent_indices[0] = ntohl(*((uint32_t *)(commit_data + GIT_OID_SHA1_SIZE)));
+	commit_data = file->commit_data + pos * (oid_size + 4 * sizeof(uint32_t));
+	git_oid__fromraw(&e->tree_oid, commit_data, file->oid_type);
+	e->parent_indices[0] = ntohl(*((uint32_t *)(commit_data + oid_size)));
 	e->parent_indices[1] = ntohl(
-			*((uint32_t *)(commit_data + GIT_OID_SHA1_SIZE + sizeof(uint32_t))));
+			*((uint32_t *)(commit_data + oid_size + sizeof(uint32_t))));
 	e->parent_count = (e->parent_indices[0] != GIT_COMMIT_GRAPH_MISSING_PARENT)
 			+ (e->parent_indices[1] != GIT_COMMIT_GRAPH_MISSING_PARENT);
-	e->generation = ntohl(*((uint32_t *)(commit_data + GIT_OID_SHA1_SIZE + 2 * sizeof(uint32_t))));
-	e->commit_time = ntohl(*((uint32_t *)(commit_data + GIT_OID_SHA1_SIZE + 3 * sizeof(uint32_t))));
+	e->generation = ntohl(*((uint32_t *)(commit_data + oid_size + 2 * sizeof(uint32_t))));
+	e->commit_time = ntohl(*((uint32_t *)(commit_data + oid_size + 3 * sizeof(uint32_t))));
 
 	e->commit_time |= (e->generation & UINT64_C(0x3)) << UINT64_C(32);
 	e->generation >>= 2u;
 	if (e->parent_indices[1] & 0x80000000u) {
 		uint32_t extra_edge_list_pos = e->parent_indices[1] & 0x7fffffff;
 
 		/* Make sure we're not being sent out of bounds */
 		if (extra_edge_list_pos >= file->num_extra_edge_list) {
 			git_error_set(GIT_ERROR_INVALID,
 				      "commit %u does not exist",
 				      extra_edge_list_pos);
 			return GIT_ENOTFOUND;
 		}
 
 		e->extra_parents_index = extra_edge_list_pos;
 		while (extra_edge_list_pos < file->num_extra_edge_list
 		       && (ntohl(*(
 					   (uint32_t *)(file->extra_edge_list
 							+ extra_edge_list_pos * sizeof(uint32_t))))
 			   & 0x80000000u)
 				       == 0) {
 			extra_edge_list_pos++;
 			e->parent_count++;
 		}
 	}
 
-	git_oid__fromraw(&e->sha1, &file->oid_lookup[pos * GIT_OID_SHA1_SIZE], GIT_OID_SHA1);
+	git_oid__fromraw(&e->sha1, &file->oid_lookup[pos * oid_size], file->oid_type);
 	return 0;
 }
 
 bool git_commit_graph_file_needs_refresh(const git_commit_graph_file *file, const char *path)
 {
 	git_file fd = -1;
 	struct stat st;
 	ssize_t bytes_read;
-	unsigned char checksum[GIT_HASH_SHA1_SIZE];
-	size_t checksum_size = GIT_HASH_SHA1_SIZE;
+	unsigned char checksum[GIT_HASH_MAX_SIZE];
+	size_t checksum_size = git_oid_size(file->oid_type);
 
 	/* TODO: properly open the file without access time using O_NOATIME */
 	fd = git_futils_open_ro(path);
 	if (fd < 0)
 		return true;
 
 	if (p_fstat(fd, &st) < 0) {
 		p_close(fd);
 		return true;
 	}
 
 	if (!S_ISREG(st.st_mode) || !git__is_sizet(st.st_size)
 	    || (size_t)st.st_size != file->graph_map.len) {
 		p_close(fd);
 		return true;
 	}
 
 	bytes_read = p_pread(fd, checksum, checksum_size, st.st_size - checksum_size);
 	p_close(fd);
 	if (bytes_read != (ssize_t)checksum_size)
 		return true;
 
 	return (memcmp(checksum, file->checksum, checksum_size) != 0);
 }
@@ -524,52 +566,57 @@ bool git_commit_graph_file_needs_refresh(const git_commit_graph_file *file, cons
 int git_commit_graph_entry_find(
 		git_commit_graph_entry *e,
 		const git_commit_graph_file *file,
 		const git_oid *short_oid,
 		size_t len)
 {
 	int pos, found = 0;
 	uint32_t hi, lo;
 	const unsigned char *current = NULL;
+	size_t oid_size, oid_hexsize;
 
 	GIT_ASSERT_ARG(e);
 	GIT_ASSERT_ARG(file);
 	GIT_ASSERT_ARG(short_oid);
 
+	oid_size = git_oid_size(file->oid_type);
+	oid_hexsize = git_oid_hexsize(file->oid_type);
+
 	hi = ntohl(file->oid_fanout[(int)short_oid->id[0]]);
 	lo = ((short_oid->id[0] == 0x0) ? 0 : ntohl(file->oid_fanout[(int)short_oid->id[0] - 1]));
 
-	pos = git_pack__lookup_id(file->oid_lookup, GIT_OID_SHA1_SIZE, lo, hi, short_oid->id, GIT_OID_SHA1);
+	pos = git_pack__lookup_id(file->oid_lookup, oid_size, lo, hi,
+		short_oid->id, file->oid_type);
 
 	if (pos >= 0) {
 		/* An object matching exactly the oid was found */
 		found = 1;
-		current = file->oid_lookup + (pos * GIT_OID_SHA1_SIZE);
+		current = file->oid_lookup + (pos * oid_size);
 	} else {
 		/* No object was found */
 		/* pos refers to the object with the "closest" oid to short_oid */
 		pos = -1 - pos;
 		if (pos < (int)file->num_commits) {
-			current = file->oid_lookup + (pos * GIT_OID_SHA1_SIZE);
+			current = file->oid_lookup + (pos * oid_size);
 
 			if (!git_oid_raw_ncmp(short_oid->id, current, len))
 				found = 1;
 		}
 	}
 
-	if (found && len != GIT_OID_SHA1_HEXSIZE && pos + 1 < (int)file->num_commits) {
+	if (found && len != oid_hexsize && pos + 1 < (int)file->num_commits) {
 		/* Check for ambiguousity */
-		const unsigned char *next = current + GIT_OID_SHA1_SIZE;
+		const unsigned char *next = current + oid_size;
 
 		if (!git_oid_raw_ncmp(short_oid->id, next, len))
 			found = 2;
 	}
 
 	if (!found)
 		return git_odb__error_notfound(
 				"failed to find offset for commit-graph index entry", short_oid, len);
 	if (found > 1)
 		return git_odb__error_ambiguous(
 				"found multiple offsets for commit-graph index entry");
 
 	return git_commit_graph_entry_get_byindex(e, file, pos);
 }
@@ -637,22 +684,38 @@ static int packed_commit__cmp(const void *a_, const void *b_)
 	return git_oid_cmp(&a->sha1, &b->sha1);
 }
 
-int git_commit_graph_writer_new(git_commit_graph_writer **out, const char *objects_info_dir)
+int git_commit_graph_writer_new(
+	git_commit_graph_writer **out,
+	const char *objects_info_dir
+#ifdef GIT_EXPERIMENTAL_SHA256
+	, git_oid_t oid_type
+#endif
+	)
 {
-	git_commit_graph_writer *w = git__calloc(1, sizeof(git_commit_graph_writer));
+	git_commit_graph_writer *w;
+
+#ifndef GIT_EXPERIMENTAL_SHA256
+	git_oid_t oid_type = GIT_OID_SHA1;
+#endif
+
+	GIT_ASSERT_ARG(out && objects_info_dir && oid_type);
+
+	w = git__calloc(1, sizeof(git_commit_graph_writer));
 	GIT_ERROR_CHECK_ALLOC(w);
 
+	w->oid_type = oid_type;
+
 	if (git_str_sets(&w->objects_info_dir, objects_info_dir) < 0) {
 		git__free(w);
 		return -1;
 	}
 
 	if (git_vector_init(&w->commits, 0, packed_commit__cmp) < 0) {
 		git_str_dispose(&w->objects_info_dir);
 		git__free(w);
 		return -1;
 	}
 
 	*out = w;
 	return 0;
 }
@@ -981,185 +1044,189 @@ static void packed_commit_free_dup(void *packed_commit)
 static int commit_graph_write(
 		git_commit_graph_writer *w,
 		commit_graph_write_cb write_cb,
 		void *cb_data)
 {
 	int error = 0;
 	size_t i;
 	struct packed_commit *packed_commit;
 	struct git_commit_graph_header hdr = {0};
 	uint32_t oid_fanout_count;
 	uint32_t extra_edge_list_count;
 	uint32_t oid_fanout[256];
 	off64_t offset;
 	git_str oid_lookup = GIT_STR_INIT, commit_data = GIT_STR_INIT,
 		extra_edge_list = GIT_STR_INIT;
-	unsigned char checksum[GIT_HASH_SHA1_SIZE];
-	size_t checksum_size;
+	unsigned char checksum[GIT_HASH_MAX_SIZE];
+	git_hash_algorithm_t checksum_type;
+	size_t checksum_size, oid_size;
 	git_hash_ctx ctx;
 	struct commit_graph_write_hash_context hash_cb_data = {0};
 
 	hdr.signature = htonl(COMMIT_GRAPH_SIGNATURE);
 	hdr.version = COMMIT_GRAPH_VERSION;
 	hdr.object_id_version = COMMIT_GRAPH_OBJECT_ID_VERSION;
 	hdr.chunks = 0;
 	hdr.base_graph_files = 0;
 	hash_cb_data.write_cb = write_cb;
 	hash_cb_data.cb_data = cb_data;
 	hash_cb_data.ctx = &ctx;
 
-	checksum_size = GIT_HASH_SHA1_SIZE;
-	error = git_hash_ctx_init(&ctx, GIT_HASH_ALGORITHM_SHA1);
+	oid_size = git_oid_size(w->oid_type);
+	checksum_type = git_oid_algorithm(w->oid_type);
+	checksum_size = git_hash_size(checksum_type);
+
+	error = git_hash_ctx_init(&ctx, checksum_type);
 	if (error < 0)
 		return error;
 	cb_data = &hash_cb_data;
 	write_cb = commit_graph_write_hash;
 
 	/* Sort the commits. */
 	git_vector_sort(&w->commits);
 	git_vector_uniq(&w->commits, packed_commit_free_dup);
 	error = compute_generation_numbers(&w->commits);
 	if (error < 0)
 		goto cleanup;
 
 	/* Fill the OID Fanout table. */
 	oid_fanout_count = 0;
 	for (i = 0; i < 256; i++) {
 		while (oid_fanout_count < git_vector_length(&w->commits) &&
 		       (packed_commit = (struct packed_commit *)git_vector_get(&w->commits, oid_fanout_count)) &&
 		       packed_commit->sha1.id[0] <= i)
 			++oid_fanout_count;
 		oid_fanout[i] = htonl(oid_fanout_count);
 	}
 
 	/* Fill the OID Lookup table. */
 	git_vector_foreach (&w->commits, i, packed_commit) {
 		error = git_str_put(&oid_lookup,
 			(const char *)&packed_commit->sha1.id,
-			GIT_OID_SHA1_SIZE);
+			oid_size);
 
 		if (error < 0)
 			goto cleanup;
 	}
 
 	/* Fill the Commit Data and Extra Edge List tables. */
 	extra_edge_list_count = 0;
 	git_vector_foreach (&w->commits, i, packed_commit) {
 		uint64_t commit_time;
 		uint32_t generation;
 		uint32_t word;
 		size_t *packed_index;
 		unsigned int parentcount = (unsigned int)git_array_size(packed_commit->parents);
 
 		error = git_str_put(&commit_data,
 			(const char *)&packed_commit->tree_oid.id,
-			GIT_OID_SHA1_SIZE);
+			oid_size);
 
 		if (error < 0)
 			goto cleanup;
 
 		if (parentcount == 0) {
 			word = htonl(GIT_COMMIT_GRAPH_MISSING_PARENT);
 		} else {
 			packed_index = git_array_get(packed_commit->parent_indices, 0);
 			word = htonl((uint32_t)*packed_index);
 		}
 		error = git_str_put(&commit_data, (const char *)&word, sizeof(word));
 		if (error < 0)
 			goto cleanup;
 
 		if (parentcount < 2) {
 			word = htonl(GIT_COMMIT_GRAPH_MISSING_PARENT);
 		} else if (parentcount == 2) {
 			packed_index = git_array_get(packed_commit->parent_indices, 1);
 			word = htonl((uint32_t)*packed_index);
 		} else {
 			word = htonl(0x80000000u | extra_edge_list_count);
 		}
 		error = git_str_put(&commit_data, (const char *)&word, sizeof(word));
 		if (error < 0)
 			goto cleanup;
 
 		if (parentcount > 2) {
 			unsigned int parent_i;
 			for (parent_i = 1; parent_i < parentcount; ++parent_i) {
 				packed_index = git_array_get(
 					packed_commit->parent_indices, parent_i);
 				word = htonl((uint32_t)(*packed_index | (parent_i + 1 == parentcount ? 0x80000000u : 0)));
 
 				error = git_str_put(&extra_edge_list,
 						(const char *)&word,
 						sizeof(word));
 				if (error < 0)
 					goto cleanup;
 			}
 			extra_edge_list_count += parentcount - 1;
 		}
 
 		generation = packed_commit->generation;
 		commit_time = (uint64_t)packed_commit->commit_time;
 		if (generation > GIT_COMMIT_GRAPH_GENERATION_NUMBER_MAX)
 			generation = GIT_COMMIT_GRAPH_GENERATION_NUMBER_MAX;
 		word = ntohl((uint32_t)((generation << 2) | (((uint32_t)(commit_time >> 32)) & 0x3) ));
 		error = git_str_put(&commit_data, (const char *)&word, sizeof(word));
 		if (error < 0)
 			goto cleanup;
 		word = ntohl((uint32_t)(commit_time & 0xfffffffful));
 		error = git_str_put(&commit_data, (const char *)&word, sizeof(word));
 		if (error < 0)
 			goto cleanup;
 	}
 
 	/* Write the header. */
 	hdr.chunks = 3;
 	if (git_str_len(&extra_edge_list) > 0)
 		hdr.chunks++;
 	error = write_cb((const char *)&hdr, sizeof(hdr), cb_data);
 	if (error < 0)
 		goto cleanup;
 
 	/* Write the chunk headers. */
 	offset = sizeof(hdr) + (hdr.chunks + 1) * 12;
 	error = write_chunk_header(COMMIT_GRAPH_OID_FANOUT_ID, offset, write_cb, cb_data);
 	if (error < 0)
 		goto cleanup;
 	offset += sizeof(oid_fanout);
 	error = write_chunk_header(COMMIT_GRAPH_OID_LOOKUP_ID, offset, write_cb, cb_data);
 	if (error < 0)
 		goto cleanup;
 	offset += git_str_len(&oid_lookup);
 	error = write_chunk_header(COMMIT_GRAPH_COMMIT_DATA_ID, offset, write_cb, cb_data);
 	if (error < 0)
 		goto cleanup;
 	offset += git_str_len(&commit_data);
 	if (git_str_len(&extra_edge_list) > 0) {
 		error = write_chunk_header(
 				COMMIT_GRAPH_EXTRA_EDGE_LIST_ID, offset, write_cb, cb_data);
 		if (error < 0)
 			goto cleanup;
 		offset += git_str_len(&extra_edge_list);
 	}
 	error = write_chunk_header(0, offset, write_cb, cb_data);
 	if (error < 0)
 		goto cleanup;
 
 	/* Write all the chunks. */
 	error = write_cb((const char *)oid_fanout, sizeof(oid_fanout), cb_data);
 	if (error < 0)
 		goto cleanup;
 	error = write_cb(git_str_cstr(&oid_lookup), git_str_len(&oid_lookup), cb_data);
 	if (error < 0)
 		goto cleanup;
 	error = write_cb(git_str_cstr(&commit_data), git_str_len(&commit_data), cb_data);
 	if (error < 0)
 		goto cleanup;
 	error = write_cb(git_str_cstr(&extra_edge_list), git_str_len(&extra_edge_list), cb_data);
 	if (error < 0)
 		goto cleanup;
 
 	/* Finalize the checksum and write the trailer. */
 	error = git_hash_final(checksum, &ctx);
 	if (error < 0)
 		goto cleanup;
 	error = write_cb((char *)checksum, checksum_size, cb_data);
 	if (error < 0)
 		goto cleanup;
diff --git a/src/libgit2/commit_graph.h b/src/libgit2/commit_graph.h
index 517abb239..ecf4379bd 100644
--- a/src/libgit2/commit_graph.h
+++ b/src/libgit2/commit_graph.h
@@ -21,101 +21,114 @@
 /**
  * A commit-graph file.
  *
  * This file contains metadata about commits, particularly the generation
  * number for each one. This can help speed up graph operations without
  * requiring a full graph traversal.
  *
  * Support for this feature was added in git 2.19.
  */
 typedef struct git_commit_graph_file {
 	git_map graph_map;
 
+	/* The type of object IDs in the commit graph file. */
+	git_oid_t oid_type;
+
 	/* The OID Fanout table. */
 	const uint32_t *oid_fanout;
 	/* The total number of commits in the graph. */
 	uint32_t num_commits;
 
 	/* The OID Lookup table. */
 	unsigned char *oid_lookup;
 
 	/*
 	 * The Commit Data table. Each entry contains the OID of the commit followed
 	 * by two 8-byte fields in network byte order:
 	 * - The indices of the first two parents (32 bits each).
 	 * - The generation number (first 30 bits) and commit time in seconds since
 	 *   UNIX epoch (34 bits).
 	 */
 	const unsigned char *commit_data;
 
 	/*
 	 * The Extra Edge List table. Each 4-byte entry is a network byte order index
 	 * of one of the i-th (i > 0) parents of commits in the `commit_data` table,
 	 * when the commit has more than 2 parents.
 	 */
 	const unsigned char *extra_edge_list;
 	/* The number of entries in the Extra Edge List table. Each entry is 4 bytes wide. */
 	size_t num_extra_edge_list;
 
 	/* The trailer of the file. Contains the SHA1-checksum of the whole file. */
 	unsigned char checksum[GIT_HASH_SHA1_SIZE];
 } git_commit_graph_file;
 
 /**
  * An entry in the commit-graph file. Provides a subset of the information that
  * can be obtained from the commit header.
  */
 typedef struct git_commit_graph_entry {
 	/* The generation number of the commit within the graph */
 	size_t generation;
 
 	/* Time in seconds from UNIX epoch. */
 	git_time_t commit_time;
 
 	/* The number of parents of the commit. */
 	size_t parent_count;
 
 	/*
 	 * The indices of the parent commits within the Commit Data table. The value
 	 * of `GIT_COMMIT_GRAPH_MISSING_PARENT` indicates that no parent is in that
 	 * position.
 	 */
 	size_t parent_indices[2];
 
 	/* The index within the Extra Edge List of any parent after the first two. */
 	size_t extra_parents_index;
 
-	/* The SHA-1 hash of the root tree of the commit. */
+	/* The object ID of the root tree of the commit. */
 	git_oid tree_oid;
 
-	/* The SHA-1 hash of the requested commit. */
+	/* The object ID hash of the requested commit. */
 	git_oid sha1;
 } git_commit_graph_entry;
 
 /* A wrapper for git_commit_graph_file to enable lazy loading in the ODB. */
 struct git_commit_graph {
 	/* The path to the commit-graph file. Something like ".git/objects/info/commit-graph". */
 	git_str filename;
 
 	/* The underlying commit-graph file. */
 	git_commit_graph_file *file;
 
+	/* The object ID types in the commit graph. */
+	git_oid_t oid_type;
+
 	/* Whether the commit-graph file was already checked for validity. */
 	bool checked;
 };
 
 /** Create a new commit-graph, optionally opening the underlying file. */
-int git_commit_graph_new(git_commit_graph **cgraph_out, const char *objects_dir, bool open_file);
+int git_commit_graph_new(
+	git_commit_graph **cgraph_out,
+	const char *objects_dir,
+	bool open_file,
+	git_oid_t oid_type);
 
 /** Validate the checksum of a commit graph */
 int git_commit_graph_validate(git_commit_graph *cgraph);
 
 /** Open and validate a commit-graph file. */
-int git_commit_graph_file_open(git_commit_graph_file **file_out, const char *path);
+int git_commit_graph_file_open(
+	git_commit_graph_file **file_out,
+	const char *path,
+	git_oid_t oid_type);
 
 /*
  * Attempt to get the git_commit_graph's commit-graph file. This object is
  * still owned by the git_commit_graph. If the repository does not contain a commit graph,
  * it will return GIT_ENOTFOUND.
  *
  * This function is not thread-safe.
  */
@@ -127,13 +140,16 @@ void git_commit_graph_refresh(git_commit_graph *cgraph);
 /*
  * A writer for `commit-graph` files.
  */
 struct git_commit_graph_writer {
 	/*
 	 * The path of the `objects/info` directory where the `commit-graph` will be
 	 * stored.
 	 */
 	git_str objects_info_dir;
 
+	/* The object ID type of the commit graph. */
+	git_oid_t oid_type;
+
 	/* The list of packed commits. */
 	git_vector commits;
 };
diff --git a/src/libgit2/odb.c b/src/libgit2/odb.c
index 0fc48035a..68872e1a1 100644
--- a/src/libgit2/odb.c
+++ b/src/libgit2/odb.c
@@ -678,81 +678,82 @@ int git_odb_get_backend(git_odb_backend **out, git_odb *odb, size_t pos)
 int git_odb__add_default_backends(
 	git_odb *db, const char *objects_dir,
 	bool as_alternates, int alternate_depth)
 {
 	size_t i = 0;
 	struct stat st;
 	ino_t inode;
 	git_odb_backend *loose, *packed;
 	git_odb_backend_loose_options loose_opts = GIT_ODB_BACKEND_LOOSE_OPTIONS_INIT;
 	git_odb_backend_pack_options pack_opts = GIT_ODB_BACKEND_PACK_OPTIONS_INIT;
 
 	/* TODO: inodes are not really relevant on Win32, so we need to find
 	 * a cross-platform workaround for this */
 #ifdef GIT_WIN32
 	GIT_UNUSED(i);
 	GIT_UNUSED(&st);
 
 	inode = 0;
 #else
 	if (p_stat(objects_dir, &st) < 0) {
 		if (as_alternates)
 			/* this should warn */
 			return 0;
 
 		git_error_set(GIT_ERROR_ODB, "failed to load object database in '%s'", objects_dir);
 		return -1;
 	}
 
 	inode = st.st_ino;
 
 	if (git_mutex_lock(&db->lock) < 0) {
 		git_error_set(GIT_ERROR_ODB, "failed to acquire the odb lock");
 		return -1;
 	}
 	for (i = 0; i < db->backends.length; ++i) {
 		backend_internal *backend = git_vector_get(&db->backends, i);
 		if (backend->disk_inode == inode) {
 			git_mutex_unlock(&db->lock);
 			return 0;
 		}
 	}
 	git_mutex_unlock(&db->lock);
 #endif
 
 	if (db->do_fsync)
 		loose_opts.flags |= GIT_ODB_BACKEND_LOOSE_FSYNC;
 
 	loose_opts.oid_type = db->options.oid_type;
 	pack_opts.oid_type = db->options.oid_type;
 
 	/* add the loose object backend */
 	if (git_odb__backend_loose(&loose, objects_dir, &loose_opts) < 0 ||
 		add_backend_internal(db, loose, git_odb__loose_priority, as_alternates, inode) < 0)
 		return -1;
 
 	/* add the packed file backend */
 #ifdef GIT_EXPERIMENTAL_SHA256
 	if (git_odb_backend_pack(&packed, objects_dir, &pack_opts) < 0)
 		return -1;
 #else
 	GIT_UNUSED(pack_opts);
 
 	if (git_odb_backend_pack(&packed, objects_dir) < 0)
 		return -1;
 #endif
 
 	if (add_backend_internal(db, packed, git_odb__packed_priority, as_alternates, inode) < 0)
 		return -1;
 
 	if (git_mutex_lock(&db->lock) < 0) {
 		git_error_set(GIT_ERROR_ODB, "failed to acquire the odb lock");
 		return -1;
 	}
-	if (!db->cgraph && git_commit_graph_new(&db->cgraph, objects_dir, false) < 0) {
+	if (!db->cgraph &&
+	    git_commit_graph_new(&db->cgraph, objects_dir, false, db->options.oid_type) < 0) {
 		git_mutex_unlock(&db->lock);
 		return -1;
 	}
 	git_mutex_unlock(&db->lock);
 
 	return load_alternates(db, objects_dir, alternate_depth);
 }
diff --git a/tests/libgit2/graph/commitgraph.c b/tests/libgit2/graph/commitgraph.c
index 82f7f936f..53869d61d 100644
--- a/tests/libgit2/graph/commitgraph.c
+++ b/tests/libgit2/graph/commitgraph.c
@@ -9,43 +9,43 @@
 void test_graph_commitgraph__parse(void)
 {
 	git_repository *repo;
 	struct git_commit_graph_file *file;
 	struct git_commit_graph_entry e, parent;
 	git_oid id;
 	git_str commit_graph_path = GIT_STR_INIT;
 
 	cl_git_pass(git_repository_open(&repo, cl_fixture("testrepo.git")));
 	cl_git_pass(git_str_joinpath(&commit_graph_path, git_repository_path(repo), "objects/info/commit-graph"));
-	cl_git_pass(git_commit_graph_file_open(&file, git_str_cstr(&commit_graph_path)));
+	cl_git_pass(git_commit_graph_file_open(&file, git_str_cstr(&commit_graph_path), GIT_OID_SHA1));
 	cl_assert_equal_i(git_commit_graph_file_needs_refresh(file, git_str_cstr(&commit_graph_path)), 0);
 
 	cl_git_pass(git_oid__fromstr(&id, "5001298e0c09ad9c34e4249bc5801c75e9754fa5", GIT_OID_SHA1));
 	cl_git_pass(git_commit_graph_entry_find(&e, file, &id, GIT_OID_SHA1_HEXSIZE));
 	cl_assert_equal_oid(&e.sha1, &id);
 	cl_git_pass(git_oid__fromstr(&id, "418382dff1ffb8bdfba833f4d8bbcde58b1e7f47", GIT_OID_SHA1));
 	cl_assert_equal_oid(&e.tree_oid, &id);
 	cl_assert_equal_i(e.generation, 1);
 	cl_assert_equal_i(e.commit_time, UINT64_C(1273610423));
 	cl_assert_equal_i(e.parent_count, 0);
 
 	cl_git_pass(git_oid__fromstr(&id, "be3563ae3f795b2b4353bcce3a527ad0a4f7f644", GIT_OID_SHA1));
 	cl_git_pass(git_commit_graph_entry_find(&e, file, &id, GIT_OID_SHA1_HEXSIZE));
 	cl_assert_equal_oid(&e.sha1, &id);
 	cl_assert_equal_i(e.generation, 5);
 	cl_assert_equal_i(e.commit_time, UINT64_C(1274813907));
 	cl_assert_equal_i(e.parent_count, 2);
 
 	cl_git_pass(git_oid__fromstr(&id, "9fd738e8f7967c078dceed8190330fc8648ee56a", GIT_OID_SHA1));
 	cl_git_pass(git_commit_graph_entry_parent(&parent, file, &e, 0));
 	cl_assert_equal_oid(&parent.sha1, &id);
 	cl_assert_equal_i(parent.generation, 4);
 
 	cl_git_pass(git_oid__fromstr(&id, "c47800c7266a2be04c571c04d5a6614691ea99bd", GIT_OID_SHA1));
 	cl_git_pass(git_commit_graph_entry_parent(&parent, file, &e, 1));
 	cl_assert_equal_oid(&parent.sha1, &id);
 	cl_assert_equal_i(parent.generation, 3);
 
 	git_commit_graph_file_free(file);
 	git_repository_free(repo);
 	git_str_dispose(&commit_graph_path);
 }
@@ -53,40 +53,40 @@ void test_graph_commitgraph__parse(void)
 void test_graph_commitgraph__parse_octopus_merge(void)
 {
 	git_repository *repo;
 	struct git_commit_graph_file *file;
 	struct git_commit_graph_entry e, parent;
 	git_oid id;
 	git_str commit_graph_path = GIT_STR_INIT;
 
 	cl_git_pass(git_repository_open(&repo, cl_fixture("merge-recursive/.gitted")));
 	cl_git_pass(git_str_joinpath(&commit_graph_path, git_repository_path(repo), "objects/info/commit-graph"));
-	cl_git_pass(git_commit_graph_file_open(&file, git_str_cstr(&commit_graph_path)));
+	cl_git_pass(git_commit_graph_file_open(&file, git_str_cstr(&commit_graph_path), GIT_OID_SHA1));
 
 	cl_git_pass(git_oid__fromstr(&id, "d71c24b3b113fd1d1909998c5bfe33b86a65ee03", GIT_OID_SHA1));
 	cl_git_pass(git_commit_graph_entry_find(&e, file, &id, GIT_OID_SHA1_HEXSIZE));
 	cl_assert_equal_oid(&e.sha1, &id);
 	cl_git_pass(git_oid__fromstr(&id, "348f16ffaeb73f319a75cec5b16a0a47d2d5e27c", GIT_OID_SHA1));
 	cl_assert_equal_oid(&e.tree_oid, &id);
 	cl_assert_equal_i(e.generation, 7);
 	cl_assert_equal_i(e.commit_time, UINT64_C(1447083009));
 	cl_assert_equal_i(e.parent_count, 3);
 
 	cl_git_pass(git_oid__fromstr(&id, "ad2ace9e15f66b3d1138922e6ffdc3ea3f967fa6", GIT_OID_SHA1));
 	cl_git_pass(git_commit_graph_entry_parent(&parent, file, &e, 0));
 	cl_assert_equal_oid(&parent.sha1, &id);
 	cl_assert_equal_i(parent.generation, 6);
 
 	cl_git_pass(git_oid__fromstr(&id, "483065df53c0f4a02cdc6b2910b05d388fc17ffb", GIT_OID_SHA1));
 	cl_git_pass(git_commit_graph_entry_parent(&parent, file, &e, 1));
 	cl_assert_equal_oid(&parent.sha1, &id);
 	cl_assert_equal_i(parent.generation, 2);
 
 	cl_git_pass(git_oid__fromstr(&id, "815b5a1c80ca749d705c7aa0cb294a00cbedd340", GIT_OID_SHA1));
 	cl_git_pass(git_commit_graph_entry_parent(&parent, file, &e, 2));
 	cl_assert_equal_oid(&parent.sha1, &id);
 	cl_assert_equal_i(parent.generation, 6);
 
 	git_commit_graph_file_free(file);
 	git_repository_free(repo);
 	git_str_dispose(&commit_graph_path);
 }
@@ -94,33 +94,38 @@ void test_graph_commitgraph__parse_octopus_merge(void)
 void test_graph_commitgraph__writer(void)
 {
 	git_repository *repo;
 	git_commit_graph_writer *w = NULL;
 	git_revwalk *walk;
 	git_commit_graph_writer_options opts = GIT_COMMIT_GRAPH_WRITER_OPTIONS_INIT;
 	git_buf cgraph = GIT_BUF_INIT;
 	git_str expected_cgraph = GIT_STR_INIT, path = GIT_STR_INIT;
 
 	cl_git_pass(git_repository_open(&repo, cl_fixture("testrepo.git")));
 
 	cl_git_pass(git_str_joinpath(&path, git_repository_path(repo), "objects/info"));
+
+#ifdef GIT_EXPERIMENTAL_SHA256
+	cl_git_pass(git_commit_graph_writer_new(&w, git_str_cstr(&path), GIT_OID_SHA1));
+#else
 	cl_git_pass(git_commit_graph_writer_new(&w, git_str_cstr(&path)));
+#endif
 
 	/* This is equivalent to `git commit-graph write --reachable`. */
 	cl_git_pass(git_revwalk_new(&walk, repo));
 	cl_git_pass(git_revwalk_push_glob(walk, "refs/*"));
 	cl_git_pass(git_commit_graph_writer_add_revwalk(w, walk));
 	git_revwalk_free(walk);
 
 	cl_git_pass(git_commit_graph_writer_dump(&cgraph, w, &opts));
 	cl_git_pass(git_str_joinpath(&path, git_repository_path(repo), "objects/info/commit-graph"));
 	cl_git_pass(git_futils_readbuffer(&expected_cgraph, git_str_cstr(&path)));
 
 	cl_assert_equal_i(cgraph.size, git_str_len(&expected_cgraph));
 	cl_assert_equal_i(memcmp(cgraph.ptr, git_str_cstr(&expected_cgraph), cgraph.size), 0);
 
 	git_buf_dispose(&cgraph);
 	git_str_dispose(&expected_cgraph);
 	git_str_dispose(&path);
 	git_commit_graph_writer_free(w);
 	git_repository_free(repo);
 }
@@ -128,16 +133,20 @@ void test_graph_commitgraph__writer(void)
 void test_graph_commitgraph__validate(void)
 {
 	git_repository *repo;
 	struct git_commit_graph *cgraph;
 	git_str objects_dir = GIT_STR_INIT;
 
 	cl_git_pass(git_repository_open(&repo, cl_fixture("testrepo.git")));
 	cl_git_pass(git_str_joinpath(&objects_dir, git_repository_path(repo), "objects"));
 
 	/* git_commit_graph_open() calls git_commit_graph_validate() */
+#ifdef GIT_EXPERIMENTAL_SHA256
+	cl_git_pass(git_commit_graph_open(&cgraph, git_str_cstr(&objects_dir), GIT_OID_SHA1));
+#else
 	cl_git_pass(git_commit_graph_open(&cgraph, git_str_cstr(&objects_dir)));
+#endif
 
 	git_commit_graph_free(cgraph);
 	git_str_dispose(&objects_dir);
 	git_repository_free(repo);
 }
@@ -145,23 +154,27 @@ void test_graph_commitgraph__validate(void)
 void test_graph_commitgraph__validate_corrupt(void)
 {
 	git_repository *repo;
 	struct git_commit_graph *cgraph;
 	int fd = -1;
 
 	cl_fixture_sandbox("testrepo.git");
 	cl_git_pass(git_repository_open(&repo, cl_git_sandbox_path(1, "testrepo.git", NULL)));
 
 	/* corrupt commit graph checksum at the end of the file */
 	cl_assert((fd = p_open(cl_git_sandbox_path(0, "testrepo.git", "objects", "info", "commit-graph", NULL), O_WRONLY)) > 0);
 	cl_assert(p_lseek(fd, -5, SEEK_END) > 0);
 	cl_must_pass(p_write(fd, "\0\0", 2));
 	cl_must_pass(p_close(fd));
 
 	/* git_commit_graph_open() calls git_commit_graph_validate() */
+#ifdef GIT_EXPERIMENTAL_SHA256
+	cl_git_fail(git_commit_graph_open(&cgraph, cl_git_sandbox_path(1, "testrepo.git", "objects", NULL), GIT_OID_SHA1));
+#else
 	cl_git_fail(git_commit_graph_open(&cgraph, cl_git_sandbox_path(1, "testrepo.git", "objects", NULL)));
+#endif
 
 	git_commit_graph_free(cgraph);
 	git_repository_free(repo);
 
 	cl_fixture_cleanup("testrepo.git");
 }
